diff --git a/src/internal.h b/src/internal.h
index 28d3554..f8f1018 100644
--- a/src/internal.h
+++ b/src/internal.h
@@ -21,6 +21,55 @@
  */
 #pragma once
 
+#ifdef __MINGW32__
+
+#define EMIT(a) ".byte " #a "; "
+
+#define X64_Start_with_CS(_cs) \
+    EMIT(0x6A) EMIT(_cs)                         /*  push   _cs             */ \
+    EMIT(0xE8) EMIT(0) EMIT(0) EMIT(0) EMIT(0)   /*  call   $+5             */ \
+    EMIT(0x83) EMIT(4) EMIT(0x24) EMIT(5)        /*  add    dword [esp], 5  */ \
+    EMIT(0xCB)                                   /*  retf                   */
+
+#define X64_End_with_CS(_cs) \
+    EMIT(0xE8) EMIT(0) EMIT(0) EMIT(0) EMIT(0)                                 /*  call   $+5                   */ \
+    EMIT(0xC7) EMIT(0x44) EMIT(0x24) EMIT(4) EMIT(_cs) EMIT(0) EMIT(0) EMIT(0) /*  mov    dword [rsp + 4], _cs  */ \
+    EMIT(0x83) EMIT(4) EMIT(0x24) EMIT(0xD)                                    /*  add    dword [rsp], 0xD      */ \
+    EMIT(0xCB)                                                                 /*  retf                         */
+
+#define X64_Start() X64_Start_with_CS(0x33)
+#define X64_End() X64_End_with_CS(0x23)
+
+#define _RAX  0
+#define _RCX  1
+#define _RDX  2
+#define _RBX  3
+#define _RSP  4
+#define _RBP  5
+#define _RSI  6
+#define _RDI  7
+#define _R8   8
+#define _R9   9
+#define _R10 10
+#define _R11 11
+#define _R12 12
+#define _R13 13
+#define _R14 14
+#define _R15 15
+
+#define X64_Push(r) EMIT(0x48 | ((r) >> 3)) EMIT(0x50 | ((r) & 7))
+#define X64_Pop(r) EMIT(0x48 | ((r) >> 3)) EMIT(0x58 | ((r) & 7))
+
+#define REX_W EMIT(0x48)
+
+union reg64
+{
+    DWORD64 v;
+    DWORD dw[2];
+};
+
+#else
+
 #define EMIT(a) __asm __emit (a)
 
 #define X64_Start_with_CS(_cs) \
@@ -71,3 +120,4 @@ union reg64
     DWORD64 v;
     DWORD dw[2];
 };
+#endif
diff --git a/src/wow64ext.cpp b/src/wow64ext.cpp
index fbba809..e66a820 100644
--- a/src/wow64ext.cpp
+++ b/src/wow64ext.cpp
@@ -85,13 +85,77 @@ extern "C" __declspec(dllexport) DWORD64 __cdecl X64Call(DWORD64 func, int argC,
     reg64 _r9 = { (argC > 0) ? argC--, va_arg(args, DWORD64) : 0 };
     reg64 _rax = { 0 };
 
-    reg64 restArgs = { (DWORD64)&va_arg(args, DWORD64) };
+    reg64 restArgs = { (DWORD64)args };
     
     // conversion to QWORD for easier use in inline assembly
     reg64 _argC = { (DWORD64)argC };
     DWORD back_esp = 0;
 	WORD back_fs = 0;
 
+#ifdef __MINGW32__
+    DWORD64* p_rax = &_rax.v;
+    DWORD64* p_rcx = &_rcx.v;
+    DWORD64* p_rdx = &_rdx.v;
+    DWORD64* p_r8 = &_r8.v;
+    DWORD64* p_r9 = &_r9.v;
+    DWORD64* p_argC = &_argC.v;
+    DWORD64* p_restArgs = &restArgs.v;
+    DWORD64* p_func = &func;
+    WORD* p_back_fs = &back_fs;
+    DWORD* p_back_esp = &back_esp;
+
+    asm volatile (
+        ".intel_syntax noprefix;"
+        "mov word ptr [%P[p_back_fs]], fs;"
+        "mov eax, 0x2B;"
+        "mov fs, ax;"
+        "mov dword ptr [%P[p_back_esp]], esp;"
+        "and esp, 0xFFFFFFF0;"
+        X64_Start()
+        REX_W "mov ecx, dword ptr [%P[p_rcx]];"
+        REX_W "mov edx, dword ptr [%P[p_rdx]];"
+        "push dword ptr [%P[p_r8]];"
+        X64_Pop(_R8)
+        "push dword ptr [%P[p_r9]];"
+        X64_Pop(_R9)
+        REX_W "mov eax, dword ptr [%P[p_argC]];"
+        "test al, 1;"
+        "jnz _no_adjust%=;"
+        "sub esp, 8;"
+        "_no_adjust%=:;"
+        "push edi;"
+        REX_W "mov edi, dword ptr [%P[p_restArgs]];"
+        REX_W "test eax, eax;"
+        "jz _ls_e%=;"
+        REX_W "lea edi, [edi + 8*eax - 8];"
+        "_ls%=:;"
+        REX_W "test eax, eax;"
+        "jz _ls_e%=;"
+        "push dword ptr [edi];"
+        REX_W "sub edi, 8;"
+        REX_W "sub eax, 1;"
+        "jmp _ls%=;"
+        "_ls_e%=:;"
+        REX_W "sub esp, 0x20;"
+        "call dword ptr [%P[p_func]];"
+        REX_W "mov ecx, dword ptr [%P[p_argC]];"
+        REX_W "lea esp, [esp + 8*ecx + 0x20];"
+        "pop edi;"
+        REX_W "mov dword ptr [%P[p_rax]], eax;"
+        X64_End()
+        "mov ax, ds;"
+        "mov ss, ax;"
+        "mov esp, dword ptr [%P[p_back_esp]];"
+        "mov ax, word ptr [%P[p_back_fs]];"
+        "mov fs, ax;"
+        ".att_syntax prefix;"
+        : 
+        : [p_rax] "r" (p_rax), [p_back_fs] "r" (p_back_fs), [p_back_esp] "r" (p_back_esp),
+          [p_rcx] "r" (p_rcx), [p_rdx] "r" (p_rdx), [p_r8] "r" (p_r8), [p_r9] "r" (p_r9),
+          [p_argC] "r" (p_argC), [p_restArgs] "r" (p_restArgs), [p_func] "r" (p_func)
+        : "eax", "ecx", "edx", "edi", "memory"
+    );
+#else
     __asm
     {
         ;// reset FS segment, to properly handle RFG
@@ -172,6 +236,7 @@ _ls_e:                                                  ;//
         mov    ax, back_fs
         mov    fs, ax
     }
+#endif
     return _rax.v;
 }
 #pragma warning(pop)
@@ -183,6 +248,36 @@ void getMem64(void* dstMem, DWORD64 srcMem, size_t sz)
 
     reg64 _src = { srcMem };
 
+#ifdef __MINGW32__
+    DWORD64* p_src = &_src.v;
+
+    asm volatile (
+        ".intel_syntax noprefix;"
+        X64_Start()
+        "mov edi, %P[dstMem];"
+        REX_W "mov esi, dword ptr [%P[p_src]];"
+        "mov ecx, %P[sz];"
+        "mov eax, ecx;"
+        "and eax, 3;"
+        "shr ecx, 2;"
+        "rep movsd;"
+        "test eax, eax;"
+        "je _move_0%=;"
+        "cmp eax, 1;"
+        "je _move_1%=;"
+        "movsw;"
+        "cmp eax, 2;"
+        "je _move_0%=;"
+        "_move_1%=:;"
+        "movsb;"
+        "_move_0%=:;"
+        X64_End()
+        ".att_syntax prefix;"
+        : 
+        : [dstMem] "r" (dstMem), [p_src] "r" (p_src), [sz] "r" (sz)
+        : "eax", "ecx", "edi", "esi", "memory", "cc"
+    );
+#else
     __asm
     {
         X64_Start();
@@ -222,15 +317,52 @@ _move_0:                            ;//
 
         X64_End();
     }
+#endif
 }
 
-bool cmpMem64(void* dstMem, DWORD64 srcMem, size_t sz)
+bool cmpMem64(const void* dstMem, DWORD64 srcMem, size_t sz)
 {
     if ((nullptr == dstMem) || (0 == srcMem) || (0 == sz))
         return false;
 
     bool result = false;
     reg64 _src = { srcMem };
+#ifdef __MINGW32__
+    DWORD64* p_src = &_src.v;
+    bool* p_result = &result;
+
+    asm volatile (
+        ".intel_syntax noprefix;"
+        X64_Start()
+        "mov edi, %P[dstMem];"
+        REX_W "mov esi, dword ptr [%P[p_src]];"
+        "mov ecx, %P[sz];"
+        "mov eax, ecx;"
+        "and eax, 3;"
+        "shr ecx, 2;"
+        "repe cmpsd;"
+        "jnz _ret_false%=;"
+        "test eax, eax;"
+        "je _move_0%=;"
+        "cmp eax, 1;"
+        "je _move_1%=;"
+        "cmpsw;"
+        "jnz _ret_false%=;"
+        "cmp eax, 2;"
+        "je _move_0%=;"
+        "_move_1%=:;"
+        "cmpsb;"
+        "jnz _ret_false%=;"
+        "_move_0%=:;"
+        "mov byte ptr [%P[p_result]], 1;"
+        "_ret_false%=:;"
+        X64_End()
+        ".att_syntax prefix;"
+        : 
+        : [p_result] "r" (p_result), [dstMem] "r" (dstMem), [p_src] "r" (p_src), [sz] "r" (sz)
+        : "eax", "ecx", "edi", "esi", "cc", "memory"
+    );
+#else
     __asm
     {
         X64_Start();
@@ -276,6 +408,7 @@ _ret_false:                         ;//
 
         X64_End();
     }
+#endif
 
     return result;
 }
@@ -285,12 +418,27 @@ DWORD64 getTEB64()
     reg64 reg;
     reg.v = 0;
     
+#ifdef __MINGW32__
+    DWORD64* p_reg = &reg.v;
+    asm volatile (
+        ".intel_syntax noprefix;"
+        X64_Start()
+        X64_Push(_R12)
+        "pop dword ptr [%P[p_reg]];"
+        X64_End()
+        ".att_syntax prefix;"
+        : 
+        : [p_reg] "r" (p_reg)
+        : "memory"
+    );
+#else
     X64_Start();
     // R12 register should always contain pointer to TEB64 in WoW64 processes
     X64_Push(_R12);
     // below pop will pop QWORD from stack, as we're in x64 mode now
     __asm pop reg.dw[0]
     X64_End();
+#endif
 
     return reg.v;
 }
