From 0a3c2cc4006157241665c6ccefc8b9676c1c752e Mon Sep 17 00:00:00 2001
From: Michele Caini <michele.caini@gmail.com>
Date: Wed, 23 Oct 2024 16:06:27 +0200
Subject: [PATCH] update single include file

---
 single_include/entt/entt.hpp | 26880 ++++++++++++++++++---------------
 1 file changed, 14970 insertions(+), 11910 deletions(-)

diff --git a/single_include/entt/entt.hpp b/single_include/entt/entt.hpp
index b3a763a203..8a12c48dce 100644
--- a/single_include/entt/entt.hpp
+++ b/single_include/entt/entt.hpp
@@ -11,23 +11,33 @@
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -67,7 +77,7 @@
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -85,6 +95,12 @@
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -107,15 +123,21 @@
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "config/macro.h"
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "config/version.h"
@@ -125,14 +147,18 @@
 // #include "macro.h"
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "container/dense_map.hpp"
@@ -161,23 +187,33 @@
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -217,7 +253,7 @@
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -235,6 +271,12 @@
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -257,25 +299,17 @@
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+#endif
 
-#include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -288,23 +322,33 @@
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -344,7 +388,7 @@
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -362,6 +406,12 @@
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -384,8 +434,81 @@
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
 #endif
 
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -396,6 +519,7 @@
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -405,10 +529,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -975,7 +1127,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -983,12 +1135,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -1173,14 +1322,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -1194,6 +1340,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -1274,9 +1421,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -1292,8 +1439,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -1332,9 +1482,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -1353,7 +1503,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -1362,7 +1512,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -1417,7 +1567,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -1425,13 +1575,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -1441,7 +1591,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -1453,23 +1603,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -1501,7 +1654,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -1514,7 +1667,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -1525,7 +1678,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -1557,8 +1710,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -1581,7 +1732,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -1735,7 +1885,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -1744,7 +1894,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -1789,7 +1939,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -1799,44 +1948,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -2063,7 +2174,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -2649,7 +2760,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -2657,12 +2768,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -2847,14 +2955,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -2868,6 +2973,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -2948,9 +3054,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -2966,8 +3072,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -3002,6 +3111,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -3009,17 +3119,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -3129,7 +3249,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -3274,6 +3394,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -3332,7 +3453,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -3348,6 +3469,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -3360,8 +3483,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -3411,8 +3532,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -3430,7 +3550,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -3442,6 +3562,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -3452,7 +3575,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -3684,7 +3807,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -3700,7 +3823,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -4029,7 +4152,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -4062,9 +4185,9 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #include <vector>
 // #include "../config/config.h"
 
-// #include "../core/compressed_pair.hpp"
+// #include "../core/bit.hpp"
 
-// #include "../core/memory.hpp"
+// #include "../core/compressed_pair.hpp"
 
 // #include "../core/type_traits.hpp"
 
@@ -4139,11 +4262,11 @@ class dense_set_iterator final {
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return std::addressof(it->second);
+        return std::addressof(operator[](0));
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -4325,7 +4448,7 @@ class dense_set {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + value_to_bucket(packed.first().back().second);
+            size_type *curr = &sparse.first()[value_to_bucket(packed.first().back().second)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].first) {}
             *curr = pos;
@@ -4341,6 +4464,8 @@ class dense_set {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Type;
     /*! @brief Value type of the container. */
@@ -4351,8 +4476,6 @@ class dense_set {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the elements for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Random access iterator type. */
     using iterator = internal::dense_set_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant random access iterator type. */
@@ -4406,8 +4529,7 @@ class dense_set {
      */
     explicit dense_set(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -4425,7 +4547,7 @@ class dense_set {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_set(dense_set &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set(dense_set &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -4437,6 +4559,9 @@ class dense_set {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_set() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -4447,7 +4572,7 @@ class dense_set {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_set &operator=(dense_set &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set &operator=(dense_set &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -4663,7 +4788,7 @@ class dense_set {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const value_type &value) {
-        for(size_type *curr = sparse.first().data() + value_to_bucket(value); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
+        for(size_type *curr = &sparse.first()[value_to_bucket(value)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
             if(packed.second()(packed.first()[*curr].second, value)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].first;
@@ -4679,7 +4804,7 @@ class dense_set {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_set &other) {
+    void swap(dense_set &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -4971,11 +5096,476 @@ class dense_set {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
+};
+
+} // namespace entt
+
+#endif
+
+// #include "container/table.hpp"
+#ifndef ENTT_CONTAINER_TABLE_HPP
+#define ENTT_CONTAINER_TABLE_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "../core/iterator.hpp"
+
+// #include "fwd.hpp"
+
+
+namespace entt {
+
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+template<typename... It>
+class table_iterator {
+    template<typename...>
+    friend class table_iterator;
+
+public:
+    using value_type = decltype(std::forward_as_tuple(*std::declval<It>()...));
+    using pointer = input_iterator_pointer<value_type>;
+    using reference = value_type;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::input_iterator_tag;
+    using iterator_concept = std::random_access_iterator_tag;
+
+    constexpr table_iterator() noexcept
+        : it{} {}
+
+    constexpr table_iterator(It... from) noexcept
+        : it{from...} {}
+
+    template<typename... Other, typename = std::enable_if_t<(std::is_constructible_v<It, Other> && ...)>>
+    constexpr table_iterator(const table_iterator<Other...> &other) noexcept
+        : table_iterator{std::get<Other>(other.it)...} {}
+
+    constexpr table_iterator &operator++() noexcept {
+        return (++std::get<It>(it), ...), *this;
+    }
+
+    constexpr table_iterator operator++(int) noexcept {
+        table_iterator orig = *this;
+        return ++(*this), orig;
+    }
+
+    constexpr table_iterator &operator--() noexcept {
+        return (--std::get<It>(it), ...), *this;
+    }
+
+    constexpr table_iterator operator--(int) noexcept {
+        table_iterator orig = *this;
+        return operator--(), orig;
+    }
+
+    constexpr table_iterator &operator+=(const difference_type value) noexcept {
+        return ((std::get<It>(it) += value), ...), *this;
+    }
+
+    constexpr table_iterator operator+(const difference_type value) const noexcept {
+        table_iterator copy = *this;
+        return (copy += value);
+    }
+
+    constexpr table_iterator &operator-=(const difference_type value) noexcept {
+        return (*this += -value);
+    }
+
+    constexpr table_iterator operator-(const difference_type value) const noexcept {
+        return (*this + -value);
+    }
+
+    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
+        return std::forward_as_tuple(std::get<It>(it)[value]...);
+    }
+
+    [[nodiscard]] constexpr pointer operator->() const noexcept {
+        return {operator[](0)};
+    }
+
+    [[nodiscard]] constexpr reference operator*() const noexcept {
+        return operator[](0);
+    }
+
+    template<typename... Lhs, typename... Rhs>
+    friend constexpr std::ptrdiff_t operator-(const table_iterator<Lhs...> &, const table_iterator<Rhs...> &) noexcept;
+
+    template<typename... Lhs, typename... Rhs>
+    friend constexpr bool operator==(const table_iterator<Lhs...> &, const table_iterator<Rhs...> &) noexcept;
+
+    template<typename... Lhs, typename... Rhs>
+    friend constexpr bool operator<(const table_iterator<Lhs...> &, const table_iterator<Rhs...> &) noexcept;
+
+private:
+    std::tuple<It...> it;
+};
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr std::ptrdiff_t operator-(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return std::get<0>(lhs.it) - std::get<0>(rhs.it);
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator==(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return std::get<0>(lhs.it) == std::get<0>(rhs.it);
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator!=(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return !(lhs == rhs);
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator<(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return std::get<0>(lhs.it) < std::get<0>(rhs.it);
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator>(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return rhs < lhs;
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator<=(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return !(lhs > rhs);
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator>=(const table_iterator<Lhs...> &lhs, const table_iterator<Rhs...> &rhs) noexcept {
+    return !(lhs < rhs);
+}
+
+} // namespace internal
+/*! @endcond */
+
+/**
+ * @brief Basic table implementation.
+ *
+ * Internal data structures arrange elements to maximize performance. There are
+ * no guarantees that objects are returned in the insertion order when iterate
+ * a table. Do not make assumption on the order in any case.
+ *
+ * @tparam Container Sequence container row types.
+ */
+template<typename... Container>
+class basic_table {
+    using container_type = std::tuple<Container...>;
+
+public:
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Input iterator type. */
+    using iterator = internal::table_iterator<typename Container::iterator...>;
+    /*! @brief Constant input iterator type. */
+    using const_iterator = internal::table_iterator<typename Container::const_iterator...>;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = internal::table_iterator<typename Container::reverse_iterator...>;
+    /*! @brief Constant reverse iterator type. */
+    using const_reverse_iterator = internal::table_iterator<typename Container::const_reverse_iterator...>;
+
+    /*! @brief Default constructor. */
+    basic_table()
+        : payload{} {
+    }
+
+    /**
+     * @brief Copy constructs the underlying containers.
+     * @param container The containers to copy from.
+     */
+    explicit basic_table(const Container &...container) noexcept
+        : payload{container...} {
+        ENTT_ASSERT((((std::get<Container>(payload).size() * sizeof...(Container)) == (std::get<Container>(payload).size() + ...)) && ...), "Unexpected container size");
+    }
+
+    /**
+     * @brief Move constructs the underlying containers.
+     * @param container The containers to move from.
+     */
+    explicit basic_table(Container &&...container) noexcept
+        : payload{std::move(container)...} {
+        ENTT_ASSERT((((std::get<Container>(payload).size() * sizeof...(Container)) == (std::get<Container>(payload).size() + ...)) && ...), "Unexpected container size");
+    }
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_table(const basic_table &) = delete;
+
+    /**
+     * @brief Move constructor.
+     * @param other The instance to move from.
+     */
+    basic_table(basic_table &&other) noexcept
+        : payload{std::move(other.payload)} {}
+
+    /**
+     * @brief Constructs the underlying containers using a given allocator.
+     * @tparam Allocator Type of allocator.
+     * @param allocator A valid allocator.
+     */
+    template<typename Allocator>
+    explicit basic_table(const Allocator &allocator)
+        : payload{Container{allocator}...} {}
+
+    /**
+     * @brief Copy constructs the underlying containers using a given allocator.
+     * @tparam Allocator Type of allocator.
+     * @param container The containers to copy from.
+     * @param allocator A valid allocator.
+     */
+    template<class Allocator>
+    basic_table(const Container &...container, const Allocator &allocator) noexcept
+        : payload{Container{container, allocator}...} {
+        ENTT_ASSERT((((std::get<Container>(payload).size() * sizeof...(Container)) == (std::get<Container>(payload).size() + ...)) && ...), "Unexpected container size");
+    }
+
+    /**
+     * @brief Move constructs the underlying containers using a given allocator.
+     * @tparam Allocator Type of allocator.
+     * @param container The containers to move from.
+     * @param allocator A valid allocator.
+     */
+    template<class Allocator>
+    basic_table(Container &&...container, const Allocator &allocator) noexcept
+        : payload{Container{std::move(container), allocator}...} {
+        ENTT_ASSERT((((std::get<Container>(payload).size() * sizeof...(Container)) == (std::get<Container>(payload).size() + ...)) && ...), "Unexpected container size");
+    }
+
+    /**
+     * @brief Allocator-extended move constructor.
+     * @tparam Allocator Type of allocator.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
+     */
+    template<class Allocator>
+    basic_table(basic_table &&other, const Allocator &allocator)
+        : payload{Container{std::move(std::get<Container>(other.payload)), allocator}...} {}
+
+    /*! @brief Default destructor. */
+    ~basic_table() = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This container.
+     */
+    basic_table &operator=(const basic_table &) = delete;
+
+    /**
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This container.
+     */
+    basic_table &operator=(basic_table &&other) noexcept {
+        swap(other);
+        return *this;
+    }
+
+    /**
+     * @brief Exchanges the contents with those of a given table.
+     * @param other Table to exchange the content with.
+     */
+    void swap(basic_table &other) noexcept {
+        using std::swap;
+        swap(payload, other.payload);
+    }
+
+    /**
+     * @brief Increases the capacity of a table.
+     *
+     * If the new capacity is greater than the current capacity, new storage is
+     * allocated, otherwise the method does nothing.
+     *
+     * @param cap Desired capacity.
+     */
+    void reserve(const size_type cap) {
+        (std::get<Container>(payload).reserve(cap), ...);
+    }
+
+    /**
+     * @brief Returns the number of rows that a table has currently allocated
+     * space for.
+     * @return Capacity of the table.
+     */
+    [[nodiscard]] size_type capacity() const noexcept {
+        return std::get<0>(payload).capacity();
+    }
+
+    /*! @brief Requests the removal of unused capacity. */
+    void shrink_to_fit() {
+        (std::get<Container>(payload).shrink_to_fit(), ...);
+    }
+
+    /**
+     * @brief Returns the number of rows in a table.
+     * @return Number of rows.
+     */
+    [[nodiscard]] size_type size() const noexcept {
+        return std::get<0>(payload).size();
+    }
+
+    /**
+     * @brief Checks whether a table is empty.
+     * @return True if the table is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        return std::get<0>(payload).empty();
+    }
+
+    /**
+     * @brief Returns an iterator to the beginning.
+     *
+     * If the table is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first row of the table.
+     */
+    [[nodiscard]] const_iterator cbegin() const noexcept {
+        return {std::get<Container>(payload).cbegin()...};
+    }
+
+    /*! @copydoc cbegin */
+    [[nodiscard]] const_iterator begin() const noexcept {
+        return cbegin();
+    }
+
+    /*! @copydoc begin */
+    [[nodiscard]] iterator begin() noexcept {
+        return {std::get<Container>(payload).begin()...};
+    }
+
+    /**
+     * @brief Returns an iterator to the end.
+     * @return An iterator to the element following the last row of the table.
+     */
+    [[nodiscard]] const_iterator cend() const noexcept {
+        return {std::get<Container>(payload).cend()...};
+    }
+
+    /*! @copydoc cend */
+    [[nodiscard]] const_iterator end() const noexcept {
+        return cend();
+    }
+
+    /*! @copydoc end */
+    [[nodiscard]] iterator end() noexcept {
+        return {std::get<Container>(payload).end()...};
+    }
+
+    /**
+     * @brief Returns a reverse iterator to the beginning.
+     *
+     * If the table is empty, the returned iterator will be equal to `rend()`.
+     *
+     * @return An iterator to the first row of the reversed table.
+     */
+    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
+        return {std::get<Container>(payload).crbegin()...};
+    }
+
+    /*! @copydoc crbegin */
+    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
+        return crbegin();
+    }
+
+    /*! @copydoc rbegin */
+    [[nodiscard]] reverse_iterator rbegin() noexcept {
+        return {std::get<Container>(payload).rbegin()...};
+    }
+
+    /**
+     * @brief Returns a reverse iterator to the end.
+     * @return An iterator to the element following the last row of the reversed
+     * table.
+     */
+    [[nodiscard]] const_reverse_iterator crend() const noexcept {
+        return {std::get<Container>(payload).crend()...};
+    }
+
+    /*! @copydoc crend */
+    [[nodiscard]] const_reverse_iterator rend() const noexcept {
+        return crend();
+    }
+
+    /*! @copydoc rend */
+    [[nodiscard]] reverse_iterator rend() noexcept {
+        return {std::get<Container>(payload).rend()...};
+    }
+
+    /**
+     * @brief Appends a row to the end of a table.
+     * @tparam Args Types of arguments to use to construct the row data.
+     * @param args Parameters to use to construct the row data.
+     * @return A reference to the newly created row data.
+     */
+    template<typename... Args>
+    std::tuple<typename Container::value_type &...> emplace(Args &&...args) {
+        if constexpr(sizeof...(Args) == 0u) {
+            return std::forward_as_tuple(std::get<Container>(payload).emplace_back()...);
+        } else {
+            return std::forward_as_tuple(std::get<Container>(payload).emplace_back(std::forward<Args>(args))...);
+        }
+    }
+
+    /**
+     * @brief Removes a row from a table.
+     * @param pos An iterator to the row to remove.
+     * @return An iterator following the removed row.
+     */
+    iterator erase(const_iterator pos) {
+        const auto diff = pos - begin();
+        return {std::get<Container>(payload).erase(std::get<Container>(payload).begin() + diff)...};
+    }
+
+    /**
+     * @brief Removes a row from a table.
+     * @param pos Index of the row to remove.
+     */
+    void erase(const size_type pos) {
+        ENTT_ASSERT(pos < size(), "Index out of bounds");
+        erase(begin() + static_cast<typename const_iterator::difference_type>(pos));
+    }
+
+    /**
+     * @brief Returns the row data at specified location.
+     * @param pos The row for which to return the data.
+     * @return The row data at specified location.
+     */
+    [[nodiscard]] std::tuple<const typename Container::value_type &...> operator[](const size_type pos) const {
+        ENTT_ASSERT(pos < size(), "Index out of bounds");
+        return std::forward_as_tuple(std::get<Container>(payload)[pos]...);
+    }
+
+    /*! @copydoc operator[] */
+    [[nodiscard]] std::tuple<typename Container::value_type &...> operator[](const size_type pos) {
+        ENTT_ASSERT(pos < size(), "Index out of bounds");
+        return std::forward_as_tuple(std::get<Container>(payload)[pos]...);
+    }
+
+    /*! @brief Clears a table. */
+    void clear() {
+        (std::get<Container>(payload).clear(), ...);
+    }
+
+private:
+    container_type payload;
 };
 
 } // namespace entt
 
+/*! @cond TURN_OFF_DOXYGEN */
+namespace std {
+
+template<typename... Container, typename Allocator>
+struct uses_allocator<entt::basic_table<Container...>, Allocator>
+    : std::bool_constant<(std::uses_allocator_v<Container, Allocator> && ...)> {};
+
+} // namespace std
+/*! @endcond */
+
 #endif
 
 // #include "core/algorithm.hpp"
@@ -5141,9 +5731,11 @@ struct insertion_sort {
                 auto value = std::move(*it);
                 auto pre = it;
 
+                // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic)
                 for(; pre > first && compare(value, *(pre - 1)); --pre) {
                     *pre = std::move(*(pre - 1));
                 }
+                // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
                 *pre = std::move(value);
             }
@@ -5187,13 +5779,16 @@ struct radix_sort {
                 constexpr auto mask = (1 << Bit) - 1;
                 constexpr auto buckets = 1 << Bit;
 
-                std::size_t index[buckets]{};
+                // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
                 std::size_t count[buckets]{};
 
                 for(auto it = from; it != to; ++it) {
                     ++count[(getter(*it) >> start) & mask];
                 }
 
+                // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+                std::size_t index[buckets]{};
+
                 for(std::size_t pos{}, end = buckets - 1u; pos < end; ++pos) {
                     index[pos + 1u] = index[pos] + count[pos];
                 }
@@ -5240,23 +5835,33 @@ struct radix_sort {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -5296,7 +5901,7 @@ struct radix_sort {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -5314,6 +5919,12 @@ struct radix_sort {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -5336,6 +5947,8 @@ struct radix_sort {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/utility.hpp"
@@ -5451,6 +6064,7 @@ struct y_combinator {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -5460,6 +6074,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -5513,6 +6142,7 @@ using any = basic_any<>;
 
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 // #include "fwd.hpp"
 
 
@@ -5521,21 +6151,19 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename>
-struct fnv1a_traits;
+template<typename = id_type>
+struct fnv_1a_params;
 
 template<>
-struct fnv1a_traits<std::uint32_t> {
-    using type = std::uint32_t;
-    static constexpr std::uint32_t offset = 2166136261;
-    static constexpr std::uint32_t prime = 16777619;
+struct fnv_1a_params<std::uint32_t> {
+    static constexpr auto offset = 2166136261;
+    static constexpr auto prime = 16777619;
 };
 
 template<>
-struct fnv1a_traits<std::uint64_t> {
-    using type = std::uint64_t;
-    static constexpr std::uint64_t offset = 14695981039346656037ull;
-    static constexpr std::uint64_t prime = 1099511628211ull;
+struct fnv_1a_params<std::uint64_t> {
+    static constexpr auto offset = 14695981039346656037ull;
+    static constexpr auto prime = 1099511628211ull;
 };
 
 template<typename Char>
@@ -5570,7 +6198,7 @@ struct basic_hashed_string {
 template<typename Char>
 class basic_hashed_string: internal::basic_hashed_string<Char> {
     using base_type = internal::basic_hashed_string<Char>;
-    using traits_type = internal::fnv1a_traits<id_type>;
+    using params = internal::fnv_1a_params<>;
 
     struct const_wrapper {
         // non-explicit constructor on purpose
@@ -5581,22 +6209,11 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
     };
 
     // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
-        base_type base{str, 0u, traits_type::offset};
-
-        for(; str[base.length]; ++base.length) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
-        }
-
-        return base;
-    }
-
-    // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
-        base_type base{str, len, traits_type::offset};
+    [[nodiscard]] static constexpr auto helper(const std::basic_string_view<Char> view) noexcept {
+        base_type base{view.data(), view.size(), params::offset};
 
-        for(size_type pos{}; pos < len; ++pos) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
+        for(auto &&curr: view) {
+            base.hash = (base.hash ^ static_cast<id_type>(curr)) * params::prime;
         }
 
         return base;
@@ -5627,6 +6244,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @return The numeric representation of the string.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
         return basic_hashed_string{str};
     }
@@ -5642,7 +6260,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
 
     /*! @brief Constructs an empty hashed string. */
     constexpr basic_hashed_string() noexcept
-        : base_type{} {}
+        : basic_hashed_string{nullptr, 0u} {}
 
     /**
      * @brief Constructs a hashed string from a string view.
@@ -5650,7 +6268,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param len Length of the string to hash.
      */
     constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
-        : base_type{helper(str, len)} {}
+        : base_type{helper({str, len})} {}
 
     /**
      * @brief Constructs a hashed string from an array of const characters.
@@ -5658,8 +6276,9 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param str Human-readable identifier.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
-        : base_type{helper(str)} {}
+        : base_type{helper({static_cast<const value_type *>(str)})} {}
 
     /**
      * @brief Explicit constructor on purpose to avoid constructing a hashed
@@ -5671,14 +6290,14 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param wrapper Helps achieving the purpose by relying on overloading.
      */
     explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
-        : base_type{helper(wrapper.repr)} {}
+        : base_type{helper({wrapper.repr})} {}
 
     /**
      * @brief Returns the size a hashed string.
      * @return The size of the hashed string.
      */
     [[nodiscard]] constexpr size_type size() const noexcept {
-        return base_type::length; // NOLINT
+        return base_type::length;
     }
 
     /**
@@ -5718,7 +6337,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
  * @param len Length of the string to hash.
  */
 template<typename Char>
-basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;
+basic_hashed_string(const Char *str, std::size_t len) -> basic_hashed_string<Char>;
 
 /**
  * @brief Deduction guide.
@@ -5727,6 +6346,7 @@ basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_stri
  * @param str Human-readable identifier.
  */
 template<typename Char, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;
 
 /**
@@ -5804,12 +6424,6 @@ template<typename Char>
     return !(lhs < rhs);
 }
 
-/*! @brief Aliases for common character types. */
-using hashed_string = basic_hashed_string<char>;
-
-/*! @brief Aliases for common character types. */
-using hashed_wstring = basic_hashed_string<wchar_t>;
-
 inline namespace literals {
 
 /**
@@ -5852,7 +6466,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -5964,10 +6578,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -6025,7 +6641,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -6036,7 +6652,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -6047,7 +6663,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -6058,7 +6674,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -6672,7 +7288,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -6680,12 +7296,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -6870,14 +7483,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -6891,6 +7501,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -6971,9 +7582,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -6989,8 +7600,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -7058,66 +7672,67 @@ class basic_any {
     using vtable_type = const void *(const operation, const basic_any &, const void *);
 
     struct storage_type {
-        alignas(Align) std::byte data[Len + !Len];
+        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+        alignas(Align) std::byte data[Len + static_cast<std::size_t>(Len == 0u)];
     };
 
     template<typename Type>
-    static constexpr bool in_situ = Len && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
+    static constexpr bool in_situ = (Len != 0u) && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
 
     template<typename Type>
     static const void *basic_vtable(const operation op, const basic_any &value, const void *other) {
         static_assert(!std::is_void_v<Type> && std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");
-        const Type *element = nullptr;
+        const Type *elem = nullptr;
 
         if constexpr(in_situ<Type>) {
-            element = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
+            elem = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
         } else {
-            element = static_cast<const Type *>(value.instance);
+            elem = static_cast<const Type *>(value.instance);
         }
 
         switch(op) {
         case operation::copy:
             if constexpr(std::is_copy_constructible_v<Type>) {
-                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*element);
+                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*elem);
             }
             break;
         case operation::move:
             if constexpr(in_situ<Type>) {
                 if(value.mode == any_policy::owner) {
-                    return new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(element))};
+                    return ::new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(elem))};
                 }
             }
 
             return (static_cast<basic_any *>(const_cast<void *>(other))->instance = std::exchange(const_cast<basic_any &>(value).instance, nullptr));
         case operation::transfer:
             if constexpr(std::is_move_assignable_v<Type>) {
-                *const_cast<Type *>(element) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
+                *const_cast<Type *>(elem) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
                 return other;
             }
             [[fallthrough]];
         case operation::assign:
             if constexpr(std::is_copy_assignable_v<Type>) {
-                *const_cast<Type *>(element) = *static_cast<const Type *>(other);
+                *const_cast<Type *>(elem) = *static_cast<const Type *>(other);
                 return other;
             }
             break;
         case operation::destroy:
             if constexpr(in_situ<Type>) {
-                element->~Type();
+                elem->~Type();
             } else if constexpr(std::is_array_v<Type>) {
-                delete[] element;
+                delete[] elem;
             } else {
-                delete element;
+                delete elem;
             }
             break;
         case operation::compare:
             if constexpr(!std::is_function_v<Type> && !std::is_array_v<Type> && is_equality_comparable_v<Type>) {
-                return *element == *static_cast<const Type *>(other) ? other : nullptr;
+                return *elem == *static_cast<const Type *>(other) ? other : nullptr;
             } else {
-                return (element == other) ? other : nullptr;
+                return (elem == other) ? other : nullptr;
             }
         case operation::get:
-            return element;
+            return elem;
         }
 
         return nullptr;
@@ -7125,26 +7740,31 @@ class basic_any {
 
     template<typename Type, typename... Args>
     void initialize([[maybe_unused]] Args &&...args) {
-        info = &type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
+        using plain_type = std::remove_cv_t<std::remove_reference_t<Type>>;
+        info = &type_id<plain_type>();
 
         if constexpr(!std::is_void_v<Type>) {
-            vtable = basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>;
+            vtable = basic_vtable<plain_type>;
 
             if constexpr(std::is_lvalue_reference_v<Type>) {
                 static_assert((std::is_lvalue_reference_v<Args> && ...) && (sizeof...(Args) == 1u), "Invalid arguments");
                 mode = std::is_const_v<std::remove_reference_t<Type>> ? any_policy::cref : any_policy::ref;
                 instance = (std::addressof(args), ...);
-            } else if constexpr(in_situ<std::remove_cv_t<std::remove_reference_t<Type>>>) {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
+            } else if constexpr(in_situ<plain_type>) {
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    ::new(&storage) plain_type{std::forward<Args>(args)...};
                 } else {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
+                    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
+                    ::new(&storage) plain_type(std::forward<Args>(args)...);
                 }
             } else {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    instance = new plain_type{std::forward<Args>(args)...};
+                } else if constexpr(std::is_array_v<plain_type>) {
+                    static_assert(sizeof...(Args) == 0u, "Invalid arguments");
+                    instance = new plain_type[std::extent_v<plain_type>]();
                 } else {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
+                    instance = new plain_type(std::forward<Args>(args)...);
                 }
             }
         }
@@ -7228,10 +7848,12 @@ class basic_any {
      * @return This any object.
      */
     basic_any &operator=(const basic_any &other) {
-        reset();
+        if(this != &other) {
+            reset();
 
-        if(other.vtable) {
-            other.vtable(operation::copy, other, this);
+            if(other.vtable) {
+                other.vtable(operation::copy, other, this);
+            }
         }
 
         return *this;
@@ -7243,6 +7865,8 @@ class basic_any {
      * @return This any object.
      */
     basic_any &operator=(basic_any &&other) noexcept {
+        ENTT_ASSERT(this != &other, "Self move assignment");
+
         reset();
 
         if(other.vtable) {
@@ -7261,9 +7885,8 @@ class basic_any {
      * @param value An instance of an object to use to initialize the wrapper.
      * @return This any object.
      */
-    template<typename Type>
-    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>, basic_any &>
-    operator=(Type &&value) {
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
+    basic_any &operator=(Type &&value) {
         emplace<std::decay_t<Type>>(std::forward<Type>(value));
         return *this;
     }
@@ -7340,9 +7963,9 @@ class basic_any {
         if(vtable && mode != any_policy::cref && *info == *other.info) {
             if(auto *val = other.data(); val) {
                 return (vtable(operation::transfer, *this, val) != nullptr);
-            } else {
-                return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
             }
+
+            return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
         }
 
         return false;
@@ -7404,14 +8027,6 @@ class basic_any {
         return basic_any{*this, any_policy::cref};
     }
 
-    /**
-     * @brief Returns true if a wrapper owns its object, false otherwise.
-     * @return True if the wrapper owns its object, false otherwise.
-     */
-    [[deprecated("use policy() and any_policy instead")]] [[nodiscard]] bool owner() const noexcept {
-        return (mode == any_policy::owner);
-    }
-
     /**
      * @brief Returns the current mode of an any object.
      * @return The current mode of the any object.
@@ -7439,7 +8054,7 @@ class basic_any {
  * @return The element converted to the requested type.
  */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(const basic_any<Len, Align> &data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(const basic_any<Len, Align> &data) noexcept {
     const auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
     ENTT_ASSERT(instance, "Invalid instance");
     return static_cast<Type>(*instance);
@@ -7447,7 +8062,7 @@ template<typename Type, std::size_t Len, std::size_t Align>
 
 /*! @copydoc any_cast */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &data) noexcept {
     // forces const on non-reference types to make them work also with wrappers for const references
     auto *const instance = any_cast<std::remove_reference_t<const Type>>(&data);
     ENTT_ASSERT(instance, "Invalid instance");
@@ -7456,13 +8071,13 @@ template<typename Type, std::size_t Len, std::size_t Align>
 
 /*! @copydoc any_cast */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &&data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &&data) noexcept {
     if constexpr(std::is_copy_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>) {
         if(auto *const instance = any_cast<std::remove_reference_t<Type>>(&data); instance) {
             return static_cast<Type>(std::move(*instance));
-        } else {
-            return any_cast<Type>(data);
         }
+
+        return any_cast<Type>(data);
     } else {
         auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
         ENTT_ASSERT(instance, "Invalid instance");
@@ -7552,6 +8167,78 @@ template<std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Le
 
 #endif
 
+// #include "core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
+
+#include <cstddef>
+#include <limits>
+#include <type_traits>
+// #include "../config/config.h"
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
+#endif
+
 // #include "core/compressed_pair.hpp"
 #ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
 #define ENTT_CORE_COMPRESSED_PAIR_HPP
@@ -7560,6 +8247,8 @@ template<std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Le
 #include <tuple>
 #include <type_traits>
 #include <utility>
+// #include "fwd.hpp"
+
 // #include "type_traits.hpp"
 
 
@@ -7573,9 +8262,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -7594,7 +8283,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -7603,7 +8292,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -7658,7 +8347,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -7666,13 +8355,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -7682,7 +8371,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -7694,23 +8383,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -7742,7 +8434,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -7755,7 +8447,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -7766,7 +8458,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -7798,8 +8490,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -7822,7 +8512,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -7945,6 +8634,7 @@ namespace entt {
  */
 template<typename...>
 class family {
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
     inline static ENTT_MAYBE_ATOMIC(id_type) identifier{};
 
 public:
@@ -7967,6 +8657,7 @@ class family {
 
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 // #include "fwd.hpp"
 
 
@@ -7975,21 +8666,19 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename>
-struct fnv1a_traits;
+template<typename = id_type>
+struct fnv_1a_params;
 
 template<>
-struct fnv1a_traits<std::uint32_t> {
-    using type = std::uint32_t;
-    static constexpr std::uint32_t offset = 2166136261;
-    static constexpr std::uint32_t prime = 16777619;
+struct fnv_1a_params<std::uint32_t> {
+    static constexpr auto offset = 2166136261;
+    static constexpr auto prime = 16777619;
 };
 
 template<>
-struct fnv1a_traits<std::uint64_t> {
-    using type = std::uint64_t;
-    static constexpr std::uint64_t offset = 14695981039346656037ull;
-    static constexpr std::uint64_t prime = 1099511628211ull;
+struct fnv_1a_params<std::uint64_t> {
+    static constexpr auto offset = 14695981039346656037ull;
+    static constexpr auto prime = 1099511628211ull;
 };
 
 template<typename Char>
@@ -8024,7 +8713,7 @@ struct basic_hashed_string {
 template<typename Char>
 class basic_hashed_string: internal::basic_hashed_string<Char> {
     using base_type = internal::basic_hashed_string<Char>;
-    using traits_type = internal::fnv1a_traits<id_type>;
+    using params = internal::fnv_1a_params<>;
 
     struct const_wrapper {
         // non-explicit constructor on purpose
@@ -8035,22 +8724,11 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
     };
 
     // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
-        base_type base{str, 0u, traits_type::offset};
-
-        for(; str[base.length]; ++base.length) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
-        }
-
-        return base;
-    }
-
-    // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
-        base_type base{str, len, traits_type::offset};
+    [[nodiscard]] static constexpr auto helper(const std::basic_string_view<Char> view) noexcept {
+        base_type base{view.data(), view.size(), params::offset};
 
-        for(size_type pos{}; pos < len; ++pos) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
+        for(auto &&curr: view) {
+            base.hash = (base.hash ^ static_cast<id_type>(curr)) * params::prime;
         }
 
         return base;
@@ -8081,6 +8759,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @return The numeric representation of the string.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
         return basic_hashed_string{str};
     }
@@ -8096,7 +8775,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
 
     /*! @brief Constructs an empty hashed string. */
     constexpr basic_hashed_string() noexcept
-        : base_type{} {}
+        : basic_hashed_string{nullptr, 0u} {}
 
     /**
      * @brief Constructs a hashed string from a string view.
@@ -8104,7 +8783,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param len Length of the string to hash.
      */
     constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
-        : base_type{helper(str, len)} {}
+        : base_type{helper({str, len})} {}
 
     /**
      * @brief Constructs a hashed string from an array of const characters.
@@ -8112,8 +8791,9 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param str Human-readable identifier.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
-        : base_type{helper(str)} {}
+        : base_type{helper({static_cast<const value_type *>(str)})} {}
 
     /**
      * @brief Explicit constructor on purpose to avoid constructing a hashed
@@ -8125,14 +8805,14 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param wrapper Helps achieving the purpose by relying on overloading.
      */
     explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
-        : base_type{helper(wrapper.repr)} {}
+        : base_type{helper({wrapper.repr})} {}
 
     /**
      * @brief Returns the size a hashed string.
      * @return The size of the hashed string.
      */
     [[nodiscard]] constexpr size_type size() const noexcept {
-        return base_type::length; // NOLINT
+        return base_type::length;
     }
 
     /**
@@ -8172,7 +8852,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
  * @param len Length of the string to hash.
  */
 template<typename Char>
-basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;
+basic_hashed_string(const Char *str, std::size_t len) -> basic_hashed_string<Char>;
 
 /**
  * @brief Deduction guide.
@@ -8181,6 +8861,7 @@ basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_stri
  * @param str Human-readable identifier.
  */
 template<typename Char, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;
 
 /**
@@ -8258,12 +8939,6 @@ template<typename Char>
     return !(lhs < rhs);
 }
 
-/*! @brief Aliases for common character types. */
-using hashed_string = basic_hashed_string<char>;
-
-/*! @brief Aliases for common character types. */
-using hashed_wstring = basic_hashed_string<wchar_t>;
-
 inline namespace literals {
 
 /**
@@ -8479,7 +9154,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -8488,7 +9163,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -8533,7 +9208,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -8543,44 +9217,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -8807,7 +9443,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -8842,10 +9478,12 @@ struct monostate {
      * @brief Assigns a value of a specific type to a given key.
      * @tparam Type Type of the value to assign.
      * @param val User data to assign to the given key.
+     * @return This monostate object.
      */
     template<typename Type>
-    void operator=(Type val) const noexcept {
+    monostate &operator=(Type val) noexcept {
         value<Type> = val;
+        return *this;
     }
 
     /**
@@ -8860,6 +9498,7 @@ struct monostate {
 
 private:
     template<typename Type>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
     inline static ENTT_MAYBE_ATOMIC(Type) value{};
 };
 
@@ -8868,12 +9507,232 @@ struct monostate {
  * @tparam Value Value used to differentiate between different variables.
  */
 template<id_type Value>
-inline monostate<Value> monostate_v = {};
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+inline monostate<Value> monostate_v{};
+
+} // namespace entt
+
+#endif
+
+// #include "core/ranges.hpp"
+#ifndef ENTT_CORE_RANGES_HPP
+#define ENTT_CORE_RANGES_HPP
+
+#if __has_include(<version>)
+#    include <version>
+#
+#    if defined(__cpp_lib_ranges)
+#        include <ranges>
+// #        include "iterator.hpp"
+#ifndef ENTT_CORE_ITERATOR_HPP
+#define ENTT_CORE_ITERATOR_HPP
+
+#include <iterator>
+#include <memory>
+#include <type_traits>
+#include <utility>
+
+namespace entt {
+
+/**
+ * @brief Helper type to use as pointer with input iterators.
+ * @tparam Type of wrapped value.
+ */
+template<typename Type>
+struct input_iterator_pointer final {
+    /*! @brief Value type. */
+    using value_type = Type;
+    /*! @brief Pointer type. */
+    using pointer = Type *;
+    /*! @brief Reference type. */
+    using reference = Type &;
+
+    /**
+     * @brief Constructs a proxy object by move.
+     * @param val Value to use to initialize the proxy object.
+     */
+    constexpr input_iterator_pointer(value_type &&val) noexcept(std::is_nothrow_move_constructible_v<value_type>)
+        : value{std::move(val)} {}
+
+    /**
+     * @brief Access operator for accessing wrapped values.
+     * @return A pointer to the wrapped value.
+     */
+    [[nodiscard]] constexpr pointer operator->() noexcept {
+        return std::addressof(value);
+    }
+
+    /**
+     * @brief Dereference operator for accessing wrapped values.
+     * @return A reference to the wrapped value.
+     */
+    [[nodiscard]] constexpr reference operator*() noexcept {
+        return value;
+    }
+
+private:
+    Type value;
+};
+
+/**
+ * @brief Plain iota iterator (waiting for C++20).
+ * @tparam Type Value type.
+ */
+template<typename Type>
+class iota_iterator final {
+    static_assert(std::is_integral_v<Type>, "Not an integral type");
+
+public:
+    /*! @brief Value type, likely an integral one. */
+    using value_type = Type;
+    /*! @brief Invalid pointer type. */
+    using pointer = void;
+    /*! @brief Non-reference type, same as value type. */
+    using reference = value_type;
+    /*! @brief Difference type. */
+    using difference_type = std::ptrdiff_t;
+    /*! @brief Iterator category. */
+    using iterator_category = std::input_iterator_tag;
+
+    /*! @brief Default constructor. */
+    constexpr iota_iterator() noexcept
+        : current{} {}
+
+    /**
+     * @brief Constructs an iota iterator from a given value.
+     * @param init The initial value assigned to the iota iterator.
+     */
+    constexpr iota_iterator(const value_type init) noexcept
+        : current{init} {}
+
+    /**
+     * @brief Pre-increment operator.
+     * @return This iota iterator.
+     */
+    constexpr iota_iterator &operator++() noexcept {
+        return ++current, *this;
+    }
+
+    /**
+     * @brief Post-increment operator.
+     * @return This iota iterator.
+     */
+    constexpr iota_iterator operator++(int) noexcept {
+        iota_iterator orig = *this;
+        return ++(*this), orig;
+    }
+
+    /**
+     * @brief Dereference operator.
+     * @return The underlying value.
+     */
+    [[nodiscard]] constexpr reference operator*() const noexcept {
+        return current;
+    }
+
+private:
+    value_type current;
+};
+
+/**
+ * @brief Comparison operator.
+ * @tparam Type Value type of the iota iterator.
+ * @param lhs A properly initialized iota iterator.
+ * @param rhs A properly initialized iota iterator.
+ * @return True if the two iterators are identical, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr bool operator==(const iota_iterator<Type> &lhs, const iota_iterator<Type> &rhs) noexcept {
+    return *lhs == *rhs;
+}
+
+/**
+ * @brief Comparison operator.
+ * @tparam Type Value type of the iota iterator.
+ * @param lhs A properly initialized iota iterator.
+ * @param rhs A properly initialized iota iterator.
+ * @return True if the two iterators differ, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr bool operator!=(const iota_iterator<Type> &lhs, const iota_iterator<Type> &rhs) noexcept {
+    return !(lhs == rhs);
+}
+
+/**
+ * @brief Utility class to create an iterable object from a pair of iterators.
+ * @tparam It Type of iterator.
+ * @tparam Sentinel Type of sentinel.
+ */
+template<typename It, typename Sentinel = It>
+struct iterable_adaptor final {
+    /*! @brief Value type. */
+    using value_type = typename std::iterator_traits<It>::value_type;
+    /*! @brief Iterator type. */
+    using iterator = It;
+    /*! @brief Sentinel type. */
+    using sentinel = Sentinel;
+
+    /*! @brief Default constructor. */
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
+        : first{},
+          last{} {}
+
+    /**
+     * @brief Creates an iterable object from a pair of iterators.
+     * @param from Begin iterator.
+     * @param to End iterator.
+     */
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
+        : first{std::move(from)},
+          last{std::move(to)} {}
+
+    /**
+     * @brief Returns an iterator to the beginning.
+     * @return An iterator to the first element of the range.
+     */
+    [[nodiscard]] constexpr iterator begin() const noexcept {
+        return first;
+    }
+
+    /**
+     * @brief Returns an iterator to the end.
+     * @return An iterator to the element following the last element of the
+     * range.
+     */
+    [[nodiscard]] constexpr sentinel end() const noexcept {
+        return last;
+    }
+
+    /*! @copydoc begin */
+    [[nodiscard]] constexpr iterator cbegin() const noexcept {
+        return begin();
+    }
+
+    /*! @copydoc end */
+    [[nodiscard]] constexpr sentinel cend() const noexcept {
+        return end();
+    }
+
+private:
+    It first;
+    Sentinel last;
+};
 
 } // namespace entt
 
 #endif
 
+
+template<class... Args>
+inline constexpr bool std::ranges::enable_borrowed_range<entt::iterable_adaptor<Args...>>{true};
+
+template<class... Args>
+inline constexpr bool std::ranges::enable_view<entt::iterable_adaptor<Args...>>{true};
+
+#    endif
+#endif
+
+#endif
 // #include "core/tuple.hpp"
 #ifndef ENTT_CORE_TUPLE_HPP
 #define ENTT_CORE_TUPLE_HPP
@@ -9002,7 +9861,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -9114,10 +9973,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -9175,7 +10036,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -9186,7 +10047,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -9197,7 +10058,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -9208,7 +10069,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -9822,7 +10683,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -9830,12 +10691,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -10020,14 +10878,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -10041,6 +10896,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -10121,9 +10977,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -10139,8 +10995,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -10289,23 +11148,33 @@ struct y_combinator {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -10345,7 +11214,7 @@ struct y_combinator {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -10363,6 +11232,12 @@ struct y_combinator {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -10385,6 +11260,8 @@ struct y_combinator {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "fwd.hpp"
@@ -10394,6 +11271,8 @@ struct y_combinator {
 #include <cstdint>
 #include <memory>
 #include <type_traits>
+// #include "../config/config.h"
+
 // #include "../core/fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -10411,23 +11290,33 @@ struct y_combinator {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -10467,7 +11356,7 @@ struct y_combinator {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -10485,6 +11374,12 @@ struct y_combinator {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -10507,11 +11402,14 @@ struct y_combinator {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -10521,6 +11419,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -10546,6 +11459,7 @@ using any = basic_any<>;
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -10555,6 +11469,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -11125,7 +12054,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -11133,12 +12062,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -11323,14 +12249,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -11344,6 +12267,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -11424,9 +12348,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -11442,8 +12366,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -11496,6 +12423,9 @@ class basic_storage;
 template<typename, typename>
 class basic_sigh_mixin;
 
+template<typename, typename>
+class basic_reactive_mixin;
+
 template<typename Entity = entity, typename = std::allocator<Entity>>
 class basic_registry;
 
@@ -11508,14 +12438,14 @@ class basic_runtime_view;
 template<typename, typename, typename>
 class basic_group;
 
-template<typename, typename Mask = std::uint32_t, typename = std::allocator<Mask>>
+template<typename, typename = std::allocator<void>>
 class basic_observer;
 
 template<typename>
 class basic_organizer;
 
 template<typename, typename...>
-struct basic_handle;
+class basic_handle;
 
 template<typename>
 class basic_snapshot;
@@ -11531,7 +12461,7 @@ using sparse_set = basic_sparse_set<>;
 
 /**
  * @brief Alias declaration for the most common use case.
- * @tparam Type Type of objects assigned to the entities.
+ * @tparam Type Element type.
  */
 template<typename Type>
 using storage = basic_storage<Type>;
@@ -11543,6 +12473,13 @@ using storage = basic_storage<Type>;
 template<typename Type>
 using sigh_mixin = basic_sigh_mixin<Type, basic_registry<typename Type::entity_type, typename Type::base_type::allocator_type>>;
 
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Underlying storage type.
+ */
+template<typename Type>
+using reactive_mixin = basic_reactive_mixin<Type, basic_registry<typename Type::entity_type, typename Type::base_type::allocator_type>>;
+
 /*! @brief Alias declaration for the most common use case. */
 using registry = basic_registry<>;
 
@@ -11594,7 +12531,7 @@ using const_runtime_view = basic_runtime_view<const sparse_set>;
 template<typename... Type>
 struct exclude_t final: type_list<Type...> {
     /*! @brief Default constructor. */
-    explicit constexpr exclude_t() {}
+    explicit constexpr exclude_t() = default;
 };
 
 /**
@@ -11605,34 +12542,34 @@ template<typename... Type>
 inline constexpr exclude_t<Type...> exclude{};
 
 /**
- * @brief Alias for lists of observed components.
+ * @brief Alias for lists of observed elements.
  * @tparam Type List of types.
  */
 template<typename... Type>
 struct get_t final: type_list<Type...> {
     /*! @brief Default constructor. */
-    explicit constexpr get_t() {}
+    explicit constexpr get_t() = default;
 };
 
 /**
- * @brief Variable template for lists of observed components.
+ * @brief Variable template for lists of observed elements.
  * @tparam Type List of types.
  */
 template<typename... Type>
 inline constexpr get_t<Type...> get{};
 
 /**
- * @brief Alias for lists of owned components.
+ * @brief Alias for lists of owned elements.
  * @tparam Type List of types.
  */
 template<typename... Type>
 struct owned_t final: type_list<Type...> {
     /*! @brief Default constructor. */
-    explicit constexpr owned_t() {}
+    explicit constexpr owned_t() = default;
 };
 
 /**
- * @brief Variable template for lists of owned components.
+ * @brief Variable template for lists of owned elements.
  * @tparam Type List of types.
  */
 template<typename... Type>
@@ -11680,7 +12617,21 @@ struct type_list_transform<owned_t<Type...>, Op> {
 template<typename Type, typename Entity = entity, typename Allocator = std::allocator<Type>, typename = void>
 struct storage_type {
     /*! @brief Type-to-storage conversion result. */
-    using type = sigh_mixin<basic_storage<Type, Entity, Allocator>>;
+    using type = ENTT_STORAGE(sigh_mixin, basic_storage<Type, Entity, Allocator>);
+};
+
+/*! @brief Empty value type for reactive storage types. */
+struct reactive final {};
+
+/**
+ * @ brief Partial specialization for reactive storage types.
+ * @tparam Entity A valid entity type.
+ * @tparam Allocator Type of allocator used to manage memory and elements.
+ */
+template<typename Entity, typename Allocator>
+struct storage_type<reactive, Entity, Allocator> {
+    /*! @brief Type-to-storage conversion result. */
+    using type = ENTT_STORAGE(reactive_mixin, basic_storage<reactive, Entity, Allocator>);
 };
 
 /**
@@ -11789,20 +12740,86 @@ struct component_traits {
 #include <type_traits>
 // #include "../config/config.h"
 
-// #include "fwd.hpp"
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
+
+#include <cstddef>
+#include <limits>
+#include <type_traits>
+// #include "../config/config.h"
 
 
 namespace entt {
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
 
-// waiting for C++20 and std::popcount
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
 template<typename Type>
-constexpr int popcount(Type value) noexcept {
-    return value ? (int(value & 1) + popcount(value >> 1)) : 0;
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
 }
 
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
+#endif
+
+// #include "fwd.hpp"
+
+
+namespace entt {
+
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
 template<typename, typename = void>
 struct entt_traits;
 
@@ -11849,10 +12866,10 @@ struct entt_traits<std::uint64_t> {
  */
 template<typename Traits>
 class basic_entt_traits {
-    static constexpr auto length = internal::popcount(Traits::entity_mask);
+    static constexpr auto length = popcount(Traits::entity_mask);
 
-    static_assert(Traits::entity_mask && ((typename Traits::entity_type{1} << length) == (Traits::entity_mask + 1)), "Invalid entity mask");
-    static_assert((typename Traits::entity_type{1} << internal::popcount(Traits::version_mask)) == (Traits::version_mask + 1), "Invalid version mask");
+    static_assert(Traits::entity_mask && ((Traits::entity_mask & (Traits::entity_mask + 1)) == 0), "Invalid entity mask");
+    static_assert((Traits::version_mask & (Traits::version_mask + 1)) == 0, "Invalid version mask");
 
 public:
     /*! @brief Value type. */
@@ -11891,7 +12908,11 @@ class basic_entt_traits {
      * @return The integral representation of the version part.
      */
     [[nodiscard]] static constexpr version_type to_version(const value_type value) noexcept {
-        return (static_cast<version_type>(to_integral(value) >> length) & version_mask);
+        if constexpr(Traits::version_mask == 0u) {
+            return version_type{};
+        } else {
+            return (static_cast<version_type>(to_integral(value) >> length) & version_mask);
+        }
     }
 
     /**
@@ -11915,7 +12936,11 @@ class basic_entt_traits {
      * @return A properly constructed identifier.
      */
     [[nodiscard]] static constexpr value_type construct(const entity_type entity, const version_type version) noexcept {
-        return value_type{(entity & entity_mask) | (static_cast<entity_type>(version & version_mask) << length)};
+        if constexpr(Traits::version_mask == 0u) {
+            return value_type{entity & entity_mask};
+        } else {
+            return value_type{(entity & entity_mask) | (static_cast<entity_type>(version & version_mask) << length)};
+        }
     }
 
     /**
@@ -11929,7 +12954,11 @@ class basic_entt_traits {
      * @return A properly constructed identifier.
      */
     [[nodiscard]] static constexpr value_type combine(const entity_type lhs, const entity_type rhs) noexcept {
-        return value_type{(lhs & entity_mask) | (rhs & (version_mask << length))};
+        if constexpr(Traits::version_mask == 0u) {
+            return value_type{lhs & entity_mask};
+        } else {
+            return value_type{(lhs & entity_mask) | (rhs & (version_mask << length))};
+        }
     }
 };
 
@@ -12037,25 +13066,25 @@ struct null_t {
 /**
  * @brief Compares a null object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A null object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A null object yet to be converted.
  * @return False if the two elements differ, true otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator==(const Entity entity, const null_t other) noexcept {
-    return other.operator==(entity);
+[[nodiscard]] constexpr bool operator==(const Entity lhs, const null_t rhs) noexcept {
+    return rhs.operator==(lhs);
 }
 
 /**
  * @brief Compares a null object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A null object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A null object yet to be converted.
  * @return True if the two elements differ, false otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator!=(const Entity entity, const null_t other) noexcept {
-    return !(other == entity);
+[[nodiscard]] constexpr bool operator!=(const Entity lhs, const null_t rhs) noexcept {
+    return !(rhs == lhs);
 }
 
 /*! @brief Tombstone object for all identifiers.  */
@@ -12099,7 +13128,12 @@ struct tombstone_t {
     template<typename Entity>
     [[nodiscard]] constexpr bool operator==(const Entity entity) const noexcept {
         using traits_type = entt_traits<Entity>;
-        return traits_type::to_version(entity) == traits_type::to_version(*this);
+
+        if constexpr(traits_type::version_mask == 0u) {
+            return false;
+        } else {
+            return (traits_type::to_version(entity) == traits_type::to_version(*this));
+        }
     }
 
     /**
@@ -12117,25 +13151,25 @@ struct tombstone_t {
 /**
  * @brief Compares a tombstone object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A tombstone object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A tombstone object yet to be converted.
  * @return False if the two elements differ, true otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator==(const Entity entity, const tombstone_t other) noexcept {
-    return other.operator==(entity);
+[[nodiscard]] constexpr bool operator==(const Entity lhs, const tombstone_t rhs) noexcept {
+    return rhs.operator==(lhs);
 }
 
 /**
  * @brief Compares a tombstone object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A tombstone object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A tombstone object yet to be converted.
  * @return True if the two elements differ, false otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator!=(const Entity entity, const tombstone_t other) noexcept {
-    return !(other == entity);
+[[nodiscard]] constexpr bool operator!=(const Entity lhs, const tombstone_t rhs) noexcept {
+    return !(rhs == lhs);
 }
 
 /**
@@ -12164,11 +13198,261 @@ inline constexpr tombstone_t tombstone{};
 #ifndef ENTT_ENTITY_GROUP_HPP
 #define ENTT_ENTITY_GROUP_HPP
 
+#include <array>
+#include <cstddef>
+#include <iterator>
 #include <tuple>
 #include <type_traits>
 #include <utility>
 // #include "../config/config.h"
 
+// #include "../core/algorithm.hpp"
+#ifndef ENTT_CORE_ALGORITHM_HPP
+#define ENTT_CORE_ALGORITHM_HPP
+
+#include <algorithm>
+#include <functional>
+#include <iterator>
+#include <utility>
+#include <vector>
+// #include "utility.hpp"
+#ifndef ENTT_CORE_UTILITY_HPP
+#define ENTT_CORE_UTILITY_HPP
+
+#include <type_traits>
+#include <utility>
+
+namespace entt {
+
+/*! @brief Identity function object (waiting for C++20). */
+struct identity {
+    /*! @brief Indicates that this is a transparent function object. */
+    using is_transparent = void;
+
+    /**
+     * @brief Returns its argument unchanged.
+     * @tparam Type Type of the argument.
+     * @param value The actual argument.
+     * @return The submitted value as-is.
+     */
+    template<typename Type>
+    [[nodiscard]] constexpr Type &&operator()(Type &&value) const noexcept {
+        return std::forward<Type>(value);
+    }
+};
+
+/**
+ * @brief Constant utility to disambiguate overloaded members of a class.
+ * @tparam Type Type of the desired overload.
+ * @tparam Class Type of class to which the member belongs.
+ * @param member A valid pointer to a member.
+ * @return Pointer to the member.
+ */
+template<typename Type, typename Class>
+[[nodiscard]] constexpr auto overload(Type Class::*member) noexcept {
+    return member;
+}
+
+/**
+ * @brief Constant utility to disambiguate overloaded functions.
+ * @tparam Func Function type of the desired overload.
+ * @param func A valid pointer to a function.
+ * @return Pointer to the function.
+ */
+template<typename Func>
+[[nodiscard]] constexpr auto overload(Func *func) noexcept {
+    return func;
+}
+
+/**
+ * @brief Helper type for visitors.
+ * @tparam Func Types of function objects.
+ */
+template<typename... Func>
+struct overloaded: Func... {
+    using Func::operator()...;
+};
+
+/**
+ * @brief Deduction guide.
+ * @tparam Func Types of function objects.
+ */
+template<typename... Func>
+overloaded(Func...) -> overloaded<Func...>;
+
+/**
+ * @brief Basic implementation of a y-combinator.
+ * @tparam Func Type of a potentially recursive function.
+ */
+template<typename Func>
+struct y_combinator {
+    /**
+     * @brief Constructs a y-combinator from a given function.
+     * @param recursive A potentially recursive function.
+     */
+    constexpr y_combinator(Func recursive) noexcept(std::is_nothrow_move_constructible_v<Func>)
+        : func{std::move(recursive)} {}
+
+    /**
+     * @brief Invokes a y-combinator and therefore its underlying function.
+     * @tparam Args Types of arguments to use to invoke the underlying function.
+     * @param args Parameters to use to invoke the underlying function.
+     * @return Return value of the underlying function, if any.
+     */
+    template<typename... Args>
+    constexpr decltype(auto) operator()(Args &&...args) const noexcept(std::is_nothrow_invocable_v<Func, const y_combinator &, Args...>) {
+        return func(*this, std::forward<Args>(args)...);
+    }
+
+    /*! @copydoc operator()() */
+    template<typename... Args>
+    constexpr decltype(auto) operator()(Args &&...args) noexcept(std::is_nothrow_invocable_v<Func, y_combinator &, Args...>) {
+        return func(*this, std::forward<Args>(args)...);
+    }
+
+private:
+    Func func;
+};
+
+} // namespace entt
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Function object to wrap `std::sort` in a class type.
+ *
+ * Unfortunately, `std::sort` cannot be passed as template argument to a class
+ * template or a function template.<br/>
+ * This class fills the gap by wrapping some flavors of `std::sort` in a
+ * function object.
+ */
+struct std_sort {
+    /**
+     * @brief Sorts the elements in a range.
+     *
+     * Sorts the elements in a range using the given binary comparison function.
+     *
+     * @tparam It Type of random access iterator.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Args Types of arguments to forward to the sort function.
+     * @param first An iterator to the first element of the range to sort.
+     * @param last An iterator past the last element of the range to sort.
+     * @param compare A valid comparison function object.
+     * @param args Arguments to forward to the sort function, if any.
+     */
+    template<typename It, typename Compare = std::less<>, typename... Args>
+    void operator()(It first, It last, Compare compare = Compare{}, Args &&...args) const {
+        std::sort(std::forward<Args>(args)..., std::move(first), std::move(last), std::move(compare));
+    }
+};
+
+/*! @brief Function object for performing insertion sort. */
+struct insertion_sort {
+    /**
+     * @brief Sorts the elements in a range.
+     *
+     * Sorts the elements in a range using the given binary comparison function.
+     *
+     * @tparam It Type of random access iterator.
+     * @tparam Compare Type of comparison function object.
+     * @param first An iterator to the first element of the range to sort.
+     * @param last An iterator past the last element of the range to sort.
+     * @param compare A valid comparison function object.
+     */
+    template<typename It, typename Compare = std::less<>>
+    void operator()(It first, It last, Compare compare = Compare{}) const {
+        if(first < last) {
+            for(auto it = first + 1; it < last; ++it) {
+                auto value = std::move(*it);
+                auto pre = it;
+
+                // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic)
+                for(; pre > first && compare(value, *(pre - 1)); --pre) {
+                    *pre = std::move(*(pre - 1));
+                }
+                // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
+
+                *pre = std::move(value);
+            }
+        }
+    }
+};
+
+/**
+ * @brief Function object for performing LSD radix sort.
+ * @tparam Bit Number of bits processed per pass.
+ * @tparam N Maximum number of bits to sort.
+ */
+template<std::size_t Bit, std::size_t N>
+struct radix_sort {
+    static_assert((N % Bit) == 0, "The maximum number of bits to sort must be a multiple of the number of bits processed per pass");
+
+    /**
+     * @brief Sorts the elements in a range.
+     *
+     * Sorts the elements in a range using the given _getter_ to access the
+     * actual data to be sorted.
+     *
+     * This implementation is inspired by the online book
+     * [Physically Based Rendering](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#RadixSort).
+     *
+     * @tparam It Type of random access iterator.
+     * @tparam Getter Type of _getter_ function object.
+     * @param first An iterator to the first element of the range to sort.
+     * @param last An iterator past the last element of the range to sort.
+     * @param getter A valid _getter_ function object.
+     */
+    template<typename It, typename Getter = identity>
+    void operator()(It first, It last, Getter getter = Getter{}) const {
+        if(first < last) {
+            constexpr auto passes = N / Bit;
+
+            using value_type = typename std::iterator_traits<It>::value_type;
+            std::vector<value_type> aux(std::distance(first, last));
+
+            auto part = [getter = std::move(getter)](auto from, auto to, auto out, auto start) {
+                constexpr auto mask = (1 << Bit) - 1;
+                constexpr auto buckets = 1 << Bit;
+
+                // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+                std::size_t count[buckets]{};
+
+                for(auto it = from; it != to; ++it) {
+                    ++count[(getter(*it) >> start) & mask];
+                }
+
+                // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+                std::size_t index[buckets]{};
+
+                for(std::size_t pos{}, end = buckets - 1u; pos < end; ++pos) {
+                    index[pos + 1u] = index[pos] + count[pos];
+                }
+
+                for(auto it = from; it != to; ++it) {
+                    out[index[(getter(*it) >> start) & mask]++] = std::move(*it);
+                }
+            };
+
+            for(std::size_t pass = 0; pass < (passes & ~1); pass += 2) {
+                part(first, last, aux.begin(), pass * Bit);
+                part(aux.begin(), aux.end(), first, (pass + 1) * Bit);
+            }
+
+            if constexpr(passes & 1) {
+                part(first, last, aux.begin(), (passes - 1) * Bit);
+                std::move(aux.begin(), aux.end(), first);
+            }
+        }
+    }
+};
+
+} // namespace entt
+
+#endif
+
 // #include "../core/fwd.hpp"
 
 // #include "../core/iterator.hpp"
@@ -12321,7 +13605,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -12330,7 +13614,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -12419,6 +13703,7 @@ struct iterable_adaptor final {
 
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 // #include "fwd.hpp"
 
 
@@ -12427,21 +13712,19 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename>
-struct fnv1a_traits;
+template<typename = id_type>
+struct fnv_1a_params;
 
 template<>
-struct fnv1a_traits<std::uint32_t> {
-    using type = std::uint32_t;
-    static constexpr std::uint32_t offset = 2166136261;
-    static constexpr std::uint32_t prime = 16777619;
+struct fnv_1a_params<std::uint32_t> {
+    static constexpr auto offset = 2166136261;
+    static constexpr auto prime = 16777619;
 };
 
 template<>
-struct fnv1a_traits<std::uint64_t> {
-    using type = std::uint64_t;
-    static constexpr std::uint64_t offset = 14695981039346656037ull;
-    static constexpr std::uint64_t prime = 1099511628211ull;
+struct fnv_1a_params<std::uint64_t> {
+    static constexpr auto offset = 14695981039346656037ull;
+    static constexpr auto prime = 1099511628211ull;
 };
 
 template<typename Char>
@@ -12476,7 +13759,7 @@ struct basic_hashed_string {
 template<typename Char>
 class basic_hashed_string: internal::basic_hashed_string<Char> {
     using base_type = internal::basic_hashed_string<Char>;
-    using traits_type = internal::fnv1a_traits<id_type>;
+    using params = internal::fnv_1a_params<>;
 
     struct const_wrapper {
         // non-explicit constructor on purpose
@@ -12487,22 +13770,11 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
     };
 
     // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
-        base_type base{str, 0u, traits_type::offset};
-
-        for(; str[base.length]; ++base.length) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
-        }
-
-        return base;
-    }
-
-    // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
-        base_type base{str, len, traits_type::offset};
+    [[nodiscard]] static constexpr auto helper(const std::basic_string_view<Char> view) noexcept {
+        base_type base{view.data(), view.size(), params::offset};
 
-        for(size_type pos{}; pos < len; ++pos) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
+        for(auto &&curr: view) {
+            base.hash = (base.hash ^ static_cast<id_type>(curr)) * params::prime;
         }
 
         return base;
@@ -12533,6 +13805,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @return The numeric representation of the string.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
         return basic_hashed_string{str};
     }
@@ -12548,7 +13821,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
 
     /*! @brief Constructs an empty hashed string. */
     constexpr basic_hashed_string() noexcept
-        : base_type{} {}
+        : basic_hashed_string{nullptr, 0u} {}
 
     /**
      * @brief Constructs a hashed string from a string view.
@@ -12556,7 +13829,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param len Length of the string to hash.
      */
     constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
-        : base_type{helper(str, len)} {}
+        : base_type{helper({str, len})} {}
 
     /**
      * @brief Constructs a hashed string from an array of const characters.
@@ -12564,8 +13837,9 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param str Human-readable identifier.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
-        : base_type{helper(str)} {}
+        : base_type{helper({static_cast<const value_type *>(str)})} {}
 
     /**
      * @brief Explicit constructor on purpose to avoid constructing a hashed
@@ -12577,14 +13851,14 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param wrapper Helps achieving the purpose by relying on overloading.
      */
     explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
-        : base_type{helper(wrapper.repr)} {}
+        : base_type{helper({wrapper.repr})} {}
 
     /**
      * @brief Returns the size a hashed string.
      * @return The size of the hashed string.
      */
     [[nodiscard]] constexpr size_type size() const noexcept {
-        return base_type::length; // NOLINT
+        return base_type::length;
     }
 
     /**
@@ -12624,7 +13898,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
  * @param len Length of the string to hash.
  */
 template<typename Char>
-basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;
+basic_hashed_string(const Char *str, std::size_t len) -> basic_hashed_string<Char>;
 
 /**
  * @brief Deduction guide.
@@ -12633,6 +13907,7 @@ basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_stri
  * @param str Human-readable identifier.
  */
 template<typename Char, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;
 
 /**
@@ -12710,12 +13985,6 @@ template<typename Char>
     return !(lhs < rhs);
 }
 
-/*! @brief Aliases for common character types. */
-using hashed_string = basic_hashed_string<char>;
-
-/*! @brief Aliases for common character types. */
-using hashed_wstring = basic_hashed_string<wchar_t>;
-
 inline namespace literals {
 
 /**
@@ -12758,7 +14027,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -12870,10 +14139,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -12931,7 +14202,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -12942,7 +14213,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -12953,7 +14224,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -12964,7 +14235,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -13010,6 +14281,8 @@ template<typename Type>
 #include <type_traits>
 // #include "../config/config.h"
 
+// #include "../core/bit.hpp"
+
 // #include "fwd.hpp"
 
 
@@ -13018,12 +14291,6 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-// waiting for C++20 and std::popcount
-template<typename Type>
-constexpr int popcount(Type value) noexcept {
-    return value ? (int(value & 1) + popcount(value >> 1)) : 0;
-}
-
 template<typename, typename = void>
 struct entt_traits;
 
@@ -13070,10 +14337,10 @@ struct entt_traits<std::uint64_t> {
  */
 template<typename Traits>
 class basic_entt_traits {
-    static constexpr auto length = internal::popcount(Traits::entity_mask);
+    static constexpr auto length = popcount(Traits::entity_mask);
 
-    static_assert(Traits::entity_mask && ((typename Traits::entity_type{1} << length) == (Traits::entity_mask + 1)), "Invalid entity mask");
-    static_assert((typename Traits::entity_type{1} << internal::popcount(Traits::version_mask)) == (Traits::version_mask + 1), "Invalid version mask");
+    static_assert(Traits::entity_mask && ((Traits::entity_mask & (Traits::entity_mask + 1)) == 0), "Invalid entity mask");
+    static_assert((Traits::version_mask & (Traits::version_mask + 1)) == 0, "Invalid version mask");
 
 public:
     /*! @brief Value type. */
@@ -13112,7 +14379,11 @@ class basic_entt_traits {
      * @return The integral representation of the version part.
      */
     [[nodiscard]] static constexpr version_type to_version(const value_type value) noexcept {
-        return (static_cast<version_type>(to_integral(value) >> length) & version_mask);
+        if constexpr(Traits::version_mask == 0u) {
+            return version_type{};
+        } else {
+            return (static_cast<version_type>(to_integral(value) >> length) & version_mask);
+        }
     }
 
     /**
@@ -13136,7 +14407,11 @@ class basic_entt_traits {
      * @return A properly constructed identifier.
      */
     [[nodiscard]] static constexpr value_type construct(const entity_type entity, const version_type version) noexcept {
-        return value_type{(entity & entity_mask) | (static_cast<entity_type>(version & version_mask) << length)};
+        if constexpr(Traits::version_mask == 0u) {
+            return value_type{entity & entity_mask};
+        } else {
+            return value_type{(entity & entity_mask) | (static_cast<entity_type>(version & version_mask) << length)};
+        }
     }
 
     /**
@@ -13150,7 +14425,11 @@ class basic_entt_traits {
      * @return A properly constructed identifier.
      */
     [[nodiscard]] static constexpr value_type combine(const entity_type lhs, const entity_type rhs) noexcept {
-        return value_type{(lhs & entity_mask) | (rhs & (version_mask << length))};
+        if constexpr(Traits::version_mask == 0u) {
+            return value_type{lhs & entity_mask};
+        } else {
+            return value_type{(lhs & entity_mask) | (rhs & (version_mask << length))};
+        }
     }
 };
 
@@ -13258,25 +14537,25 @@ struct null_t {
 /**
  * @brief Compares a null object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A null object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A null object yet to be converted.
  * @return False if the two elements differ, true otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator==(const Entity entity, const null_t other) noexcept {
-    return other.operator==(entity);
+[[nodiscard]] constexpr bool operator==(const Entity lhs, const null_t rhs) noexcept {
+    return rhs.operator==(lhs);
 }
 
 /**
  * @brief Compares a null object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A null object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A null object yet to be converted.
  * @return True if the two elements differ, false otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator!=(const Entity entity, const null_t other) noexcept {
-    return !(other == entity);
+[[nodiscard]] constexpr bool operator!=(const Entity lhs, const null_t rhs) noexcept {
+    return !(rhs == lhs);
 }
 
 /*! @brief Tombstone object for all identifiers.  */
@@ -13320,7 +14599,12 @@ struct tombstone_t {
     template<typename Entity>
     [[nodiscard]] constexpr bool operator==(const Entity entity) const noexcept {
         using traits_type = entt_traits<Entity>;
-        return traits_type::to_version(entity) == traits_type::to_version(*this);
+
+        if constexpr(traits_type::version_mask == 0u) {
+            return false;
+        } else {
+            return (traits_type::to_version(entity) == traits_type::to_version(*this));
+        }
     }
 
     /**
@@ -13338,25 +14622,25 @@ struct tombstone_t {
 /**
  * @brief Compares a tombstone object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A tombstone object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A tombstone object yet to be converted.
  * @return False if the two elements differ, true otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator==(const Entity entity, const tombstone_t other) noexcept {
-    return other.operator==(entity);
+[[nodiscard]] constexpr bool operator==(const Entity lhs, const tombstone_t rhs) noexcept {
+    return rhs.operator==(lhs);
 }
 
 /**
  * @brief Compares a tombstone object and an identifier of any type.
  * @tparam Entity Type of identifier.
- * @param entity Identifier with which to compare.
- * @param other A tombstone object yet to be converted.
+ * @param lhs Identifier with which to compare.
+ * @param rhs A tombstone object yet to be converted.
  * @return True if the two elements differ, false otherwise.
  */
 template<typename Entity>
-[[nodiscard]] constexpr bool operator!=(const Entity entity, const tombstone_t other) noexcept {
-    return !(other == entity);
+[[nodiscard]] constexpr bool operator!=(const Entity lhs, const tombstone_t rhs) noexcept {
+    return !(rhs == lhs);
 }
 
 /**
@@ -13383,2126 +14667,2655 @@ inline constexpr tombstone_t tombstone{};
 
 // #include "fwd.hpp"
 
-// #include "sparse_set.hpp"
-#ifndef ENTT_ENTITY_SPARSE_SET_HPP
-#define ENTT_ENTITY_SPARSE_SET_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <memory>
-#include <type_traits>
-#include <utility>
-#include <vector>
-// #include "../config/config.h"
-
-// #include "../core/algorithm.hpp"
-#ifndef ENTT_CORE_ALGORITHM_HPP
-#define ENTT_CORE_ALGORITHM_HPP
-
-#include <algorithm>
-#include <functional>
-#include <iterator>
-#include <utility>
-#include <vector>
-// #include "utility.hpp"
-#ifndef ENTT_CORE_UTILITY_HPP
-#define ENTT_CORE_UTILITY_HPP
-
-#include <type_traits>
-#include <utility>
 
 namespace entt {
 
-/*! @brief Identity function object (waiting for C++20). */
-struct identity {
-    /*! @brief Indicates that this is a transparent function object. */
-    using is_transparent = void;
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-    /**
-     * @brief Returns its argument unchanged.
-     * @tparam Type Type of the argument.
-     * @param value The actual argument.
-     * @return The submitted value as-is.
-     */
+template<typename, typename, typename>
+class extended_group_iterator;
+
+template<typename It, typename... Owned, typename... Get>
+class extended_group_iterator<It, owned_t<Owned...>, get_t<Get...>> {
     template<typename Type>
-    [[nodiscard]] constexpr Type &&operator()(Type &&value) const noexcept {
-        return std::forward<Type>(value);
+    [[nodiscard]] auto index_to_element([[maybe_unused]] Type &cpool) const {
+        if constexpr(std::is_void_v<typename Type::value_type>) {
+            return std::make_tuple();
+        } else {
+            return std::forward_as_tuple(cpool.rbegin()[it.index()]);
+        }
     }
-};
 
-/**
- * @brief Constant utility to disambiguate overloaded members of a class.
- * @tparam Type Type of the desired overload.
- * @tparam Class Type of class to which the member belongs.
- * @param member A valid pointer to a member.
- * @return Pointer to the member.
- */
-template<typename Type, typename Class>
-[[nodiscard]] constexpr auto overload(Type Class::*member) noexcept {
-    return member;
-}
+public:
+    using iterator_type = It;
+    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Owned>().get_as_tuple({})..., std::declval<Get>().get_as_tuple({})...));
+    using pointer = input_iterator_pointer<value_type>;
+    using reference = value_type;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::input_iterator_tag;
+    using iterator_concept = std::forward_iterator_tag;
 
-/**
- * @brief Constant utility to disambiguate overloaded functions.
- * @tparam Func Function type of the desired overload.
- * @param func A valid pointer to a function.
- * @return Pointer to the function.
- */
-template<typename Func>
-[[nodiscard]] constexpr auto overload(Func *func) noexcept {
-    return func;
-}
+    constexpr extended_group_iterator()
+        : it{},
+          pools{} {}
 
-/**
- * @brief Helper type for visitors.
- * @tparam Func Types of function objects.
- */
-template<typename... Func>
-struct overloaded: Func... {
-    using Func::operator()...;
-};
+    extended_group_iterator(iterator_type from, std::tuple<Owned *..., Get *...> cpools)
+        : it{from},
+          pools{std::move(cpools)} {}
 
-/**
- * @brief Deduction guide.
- * @tparam Func Types of function objects.
- */
-template<typename... Func>
-overloaded(Func...) -> overloaded<Func...>;
+    extended_group_iterator &operator++() noexcept {
+        return ++it, *this;
+    }
 
-/**
- * @brief Basic implementation of a y-combinator.
- * @tparam Func Type of a potentially recursive function.
- */
-template<typename Func>
-struct y_combinator {
-    /**
-     * @brief Constructs a y-combinator from a given function.
-     * @param recursive A potentially recursive function.
-     */
-    constexpr y_combinator(Func recursive) noexcept(std::is_nothrow_move_constructible_v<Func>)
-        : func{std::move(recursive)} {}
+    extended_group_iterator operator++(int) noexcept {
+        extended_group_iterator orig = *this;
+        return ++(*this), orig;
+    }
 
-    /**
-     * @brief Invokes a y-combinator and therefore its underlying function.
-     * @tparam Args Types of arguments to use to invoke the underlying function.
-     * @param args Parameters to use to invoke the underlying function.
-     * @return Return value of the underlying function, if any.
-     */
-    template<typename... Args>
-    constexpr decltype(auto) operator()(Args &&...args) const noexcept(std::is_nothrow_invocable_v<Func, const y_combinator &, Args...>) {
-        return func(*this, std::forward<Args>(args)...);
+    [[nodiscard]] reference operator*() const noexcept {
+        return std::tuple_cat(std::make_tuple(*it), index_to_element(*std::get<Owned *>(pools))..., std::get<Get *>(pools)->get_as_tuple(*it)...);
     }
 
-    /*! @copydoc operator()() */
-    template<typename... Args>
-    constexpr decltype(auto) operator()(Args &&...args) noexcept(std::is_nothrow_invocable_v<Func, y_combinator &, Args...>) {
-        return func(*this, std::forward<Args>(args)...);
+    [[nodiscard]] pointer operator->() const noexcept {
+        return operator*();
     }
 
-private:
-    Func func;
-};
+    [[nodiscard]] constexpr iterator_type base() const noexcept {
+        return it;
+    }
 
-} // namespace entt
+    template<typename... Lhs, typename... Rhs>
+    friend constexpr bool operator==(const extended_group_iterator<Lhs...> &, const extended_group_iterator<Rhs...> &) noexcept;
 
-#endif
+private:
+    It it;
+    std::tuple<Owned *..., Get *...> pools;
+};
 
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator==(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
+    return lhs.it == rhs.it;
+}
 
-namespace entt {
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator!=(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
+    return !(lhs == rhs);
+}
 
-/**
- * @brief Function object to wrap `std::sort` in a class type.
- *
- * Unfortunately, `std::sort` cannot be passed as template argument to a class
- * template or a function template.<br/>
- * This class fills the gap by wrapping some flavors of `std::sort` in a
- * function object.
- */
-struct std_sort {
-    /**
-     * @brief Sorts the elements in a range.
-     *
-     * Sorts the elements in a range using the given binary comparison function.
-     *
-     * @tparam It Type of random access iterator.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Args Types of arguments to forward to the sort function.
-     * @param first An iterator to the first element of the range to sort.
-     * @param last An iterator past the last element of the range to sort.
-     * @param compare A valid comparison function object.
-     * @param args Arguments to forward to the sort function, if any.
-     */
-    template<typename It, typename Compare = std::less<>, typename... Args>
-    void operator()(It first, It last, Compare compare = Compare{}, Args &&...args) const {
-        std::sort(std::forward<Args>(args)..., std::move(first), std::move(last), std::move(compare));
+struct group_descriptor {
+    using size_type = std::size_t;
+    virtual ~group_descriptor() = default;
+    [[nodiscard]] virtual bool owned(const id_type) const noexcept {
+        return false;
     }
 };
 
-/*! @brief Function object for performing insertion sort. */
-struct insertion_sort {
-    /**
-     * @brief Sorts the elements in a range.
-     *
-     * Sorts the elements in a range using the given binary comparison function.
-     *
-     * @tparam It Type of random access iterator.
-     * @tparam Compare Type of comparison function object.
-     * @param first An iterator to the first element of the range to sort.
-     * @param last An iterator past the last element of the range to sort.
-     * @param compare A valid comparison function object.
-     */
-    template<typename It, typename Compare = std::less<>>
-    void operator()(It first, It last, Compare compare = Compare{}) const {
-        if(first < last) {
-            for(auto it = first + 1; it < last; ++it) {
-                auto value = std::move(*it);
-                auto pre = it;
-
-                for(; pre > first && compare(value, *(pre - 1)); --pre) {
-                    *pre = std::move(*(pre - 1));
-                }
+template<typename Type, std::size_t Owned, std::size_t Get, std::size_t Exclude>
+class group_handler final: public group_descriptor {
+    using entity_type = typename Type::entity_type;
 
-                *pre = std::move(value);
-            }
+    void swap_elements(const std::size_t pos, const entity_type entt) {
+        for(size_type next{}; next < Owned; ++next) {
+            pools[next]->swap_elements((*pools[next])[pos], entt);
         }
     }
-};
 
-/**
- * @brief Function object for performing LSD radix sort.
- * @tparam Bit Number of bits processed per pass.
- * @tparam N Maximum number of bits to sort.
- */
-template<std::size_t Bit, std::size_t N>
-struct radix_sort {
-    static_assert((N % Bit) == 0, "The maximum number of bits to sort must be a multiple of the number of bits processed per pass");
+    void push_on_construct(const entity_type entt) {
+        if(std::apply([entt, pos = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < pos) && (other->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
+            swap_elements(len++, entt);
+        }
+    }
 
-    /**
-     * @brief Sorts the elements in a range.
-     *
-     * Sorts the elements in a range using the given _getter_ to access the
-     * actual data to be sorted.
-     *
-     * This implementation is inspired by the online book
-     * [Physically Based Rendering](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#RadixSort).
-     *
-     * @tparam It Type of random access iterator.
-     * @tparam Getter Type of _getter_ function object.
-     * @param first An iterator to the first element of the range to sort.
-     * @param last An iterator past the last element of the range to sort.
-     * @param getter A valid _getter_ function object.
-     */
-    template<typename It, typename Getter = identity>
-    void operator()(It first, It last, Getter getter = Getter{}) const {
-        if(first < last) {
-            constexpr auto passes = N / Bit;
+    void push_on_destroy(const entity_type entt) {
+        if(std::apply([entt, pos = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < pos) && (other->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
+            swap_elements(len++, entt);
+        }
+    }
 
-            using value_type = typename std::iterator_traits<It>::value_type;
-            std::vector<value_type> aux(std::distance(first, last));
+    void remove_if(const entity_type entt) {
+        if(pools[0u]->contains(entt) && (pools[0u]->index(entt) < len)) {
+            swap_elements(--len, entt);
+        }
+    }
 
-            auto part = [getter = std::move(getter)](auto from, auto to, auto out, auto start) {
-                constexpr auto mask = (1 << Bit) - 1;
-                constexpr auto buckets = 1 << Bit;
+    void common_setup() {
+        // we cannot iterate backwards because we want to leave behind valid entities in case of owned types
+        for(auto first = pools[0u]->rbegin(), last = first + pools[0u]->size(); first != last; ++first) {
+            push_on_construct(*first);
+        }
+    }
 
-                std::size_t index[buckets]{};
-                std::size_t count[buckets]{};
+public:
+    using common_type = Type;
+    using size_type = typename Type::size_type;
 
-                for(auto it = from; it != to; ++it) {
-                    ++count[(getter(*it) >> start) & mask];
-                }
+    template<typename... OGType, typename... EType>
+    group_handler(std::tuple<OGType &...> ogpool, std::tuple<EType &...> epool)
+        : pools{std::apply([](auto &&...cpool) { return std::array<common_type *, (Owned + Get)>{&cpool...}; }, ogpool)},
+          filter{std::apply([](auto &&...cpool) { return std::array<common_type *, Exclude>{&cpool...}; }, epool)} {
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::push_on_construct>(*this), cpool.on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, ogpool);
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::remove_if>(*this), cpool.on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, epool);
+        common_setup();
+    }
 
-                for(std::size_t pos{}, end = buckets - 1u; pos < end; ++pos) {
-                    index[pos + 1u] = index[pos] + count[pos];
-                }
+    [[nodiscard]] bool owned(const id_type hash) const noexcept override {
+        for(size_type pos{}; pos < Owned; ++pos) {
+            if(pools[pos]->type().hash() == hash) {
+                return true;
+            }
+        }
 
-                for(auto it = from; it != to; ++it) {
-                    out[index[(getter(*it) >> start) & mask]++] = std::move(*it);
-                }
-            };
+        return false;
+    }
 
-            for(std::size_t pass = 0; pass < (passes & ~1); pass += 2) {
-                part(first, last, aux.begin(), pass * Bit);
-                part(aux.begin(), aux.end(), first, (pass + 1) * Bit);
-            }
+    [[nodiscard]] size_type length() const noexcept {
+        return len;
+    }
 
-            if constexpr(passes & 1) {
-                part(first, last, aux.begin(), (passes - 1) * Bit);
-                std::move(aux.begin(), aux.end(), first);
-            }
+    template<std::size_t Index>
+    [[nodiscard]] common_type *storage() const noexcept {
+        if constexpr(Index < (Owned + Get)) {
+            return pools[Index];
+        } else {
+            return filter[Index - (Owned + Get)];
         }
     }
+
+private:
+    std::array<common_type *, (Owned + Get)> pools;
+    std::array<common_type *, Exclude> filter;
+    std::size_t len{};
 };
 
-} // namespace entt
+template<typename Type, std::size_t Get, std::size_t Exclude>
+class group_handler<Type, 0u, Get, Exclude> final: public group_descriptor {
+    using entity_type = typename Type::entity_type;
 
-#endif
+    void push_on_construct(const entity_type entt) {
+        if(!elem.contains(entt)
+           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
+            elem.push(entt);
+        }
+    }
 
-// #include "../core/any.hpp"
-#ifndef ENTT_CORE_ANY_HPP
-#define ENTT_CORE_ANY_HPP
+    void push_on_destroy(const entity_type entt) {
+        if(!elem.contains(entt)
+           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
+            elem.push(entt);
+        }
+    }
 
-#include <cstddef>
-#include <memory>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
+    void remove_if(const entity_type entt) {
+        elem.remove(entt);
+    }
 
-// #include "../core/utility.hpp"
-#ifndef ENTT_CORE_UTILITY_HPP
-#define ENTT_CORE_UTILITY_HPP
+    void common_setup() {
+        for(const auto entity: *pools[0u]) {
+            push_on_construct(entity);
+        }
+    }
 
-#include <type_traits>
-#include <utility>
+public:
+    using common_type = Type;
 
-namespace entt {
+    template<typename Allocator, typename... GType, typename... EType>
+    group_handler(const Allocator &allocator, std::tuple<GType &...> gpool, std::tuple<EType &...> epool)
+        : pools{std::apply([](auto &&...cpool) { return std::array<common_type *, Get>{&cpool...}; }, gpool)},
+          filter{std::apply([](auto &&...cpool) { return std::array<common_type *, Exclude>{&cpool...}; }, epool)},
+          elem{allocator} {
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::push_on_construct>(*this), cpool.on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, gpool);
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::remove_if>(*this), cpool.on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, epool);
+        common_setup();
+    }
 
-/*! @brief Identity function object (waiting for C++20). */
-struct identity {
-    /*! @brief Indicates that this is a transparent function object. */
-    using is_transparent = void;
+    [[nodiscard]] common_type &handle() noexcept {
+        return elem;
+    }
 
-    /**
-     * @brief Returns its argument unchanged.
-     * @tparam Type Type of the argument.
-     * @param value The actual argument.
-     * @return The submitted value as-is.
-     */
-    template<typename Type>
-    [[nodiscard]] constexpr Type &&operator()(Type &&value) const noexcept {
-        return std::forward<Type>(value);
+    [[nodiscard]] const common_type &handle() const noexcept {
+        return elem;
+    }
+
+    template<std::size_t Index>
+    [[nodiscard]] common_type *storage() const noexcept {
+        if constexpr(Index < Get) {
+            return pools[Index];
+        } else {
+            return filter[Index - Get];
+        }
     }
+
+private:
+    std::array<common_type *, Get> pools;
+    std::array<common_type *, Exclude> filter;
+    common_type elem;
 };
 
-/**
- * @brief Constant utility to disambiguate overloaded members of a class.
- * @tparam Type Type of the desired overload.
- * @tparam Class Type of class to which the member belongs.
- * @param member A valid pointer to a member.
- * @return Pointer to the member.
- */
-template<typename Type, typename Class>
-[[nodiscard]] constexpr auto overload(Type Class::*member) noexcept {
-    return member;
-}
+} // namespace internal
+/*! @endcond */
 
 /**
- * @brief Constant utility to disambiguate overloaded functions.
- * @tparam Func Function type of the desired overload.
- * @param func A valid pointer to a function.
- * @return Pointer to the function.
+ * @brief Group.
+ *
+ * Primary template isn't defined on purpose. All the specializations give a
+ * compile-time error, but for a few reasonable cases.
  */
-template<typename Func>
-[[nodiscard]] constexpr auto overload(Func *func) noexcept {
-    return func;
-}
+template<typename, typename, typename>
+class basic_group;
 
 /**
- * @brief Helper type for visitors.
- * @tparam Func Types of function objects.
+ * @brief Non-owning group.
+ *
+ * A non-owning group returns all entities and only the entities that are at
+ * least in the given storage. Moreover, it's guaranteed that the entity list is
+ * tightly packed in memory for fast iterations.
+ *
+ * @b Important
+ *
+ * Iterators aren't invalidated if:
+ *
+ * * New elements are added to the storage.
+ * * The entity currently pointed is modified (for example, elements are added
+ *   or removed from it).
+ * * The entity currently pointed is destroyed.
+ *
+ * In all other cases, modifying the pools iterated by the group in any way
+ * invalidates all the iterators.
+ *
+ * @tparam Get Types of storage _observed_ by the group.
+ * @tparam Exclude Types of storage used to filter the group.
  */
-template<typename... Func>
-struct overloaded: Func... {
-    using Func::operator()...;
-};
+template<typename... Get, typename... Exclude>
+class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
+    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
+    using underlying_type = typename base_type::entity_type;
 
-/**
- * @brief Deduction guide.
- * @tparam Func Types of function objects.
- */
-template<typename... Func>
-overloaded(Func...) -> overloaded<Func...>;
+    template<typename Type>
+    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::element_type..., typename Exclude::element_type...>>;
+
+    template<std::size_t... Index>
+    [[nodiscard]] auto pools_for(std::index_sequence<Index...>) const noexcept {
+        using return_type = std::tuple<Get *...>;
+        return descriptor ? return_type{static_cast<Get *>(descriptor->template storage<Index>())...} : return_type{};
+    }
+
+public:
+    /*! @brief Underlying entity identifier. */
+    using entity_type = underlying_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Common type among all storage types. */
+    using common_type = base_type;
+    /*! @brief Random access iterator type. */
+    using iterator = typename common_type::iterator;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = typename common_type::reverse_iterator;
+    /*! @brief Iterable group type. */
+    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<>, get_t<Get...>>>;
+    /*! @brief Group handler type. */
+    using handler = internal::group_handler<common_type, 0u, sizeof...(Get), sizeof...(Exclude)>;
 
-/**
- * @brief Basic implementation of a y-combinator.
- * @tparam Func Type of a potentially recursive function.
- */
-template<typename Func>
-struct y_combinator {
     /**
-     * @brief Constructs a y-combinator from a given function.
-     * @param recursive A potentially recursive function.
+     * @brief Group opaque identifier.
+     * @return Group opaque identifier.
      */
-    constexpr y_combinator(Func recursive) noexcept(std::is_nothrow_move_constructible_v<Func>)
-        : func{std::move(recursive)} {}
+    static id_type group_id() noexcept {
+        return type_hash<basic_group<owned_t<>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>>::value();
+    }
+
+    /*! @brief Default constructor to use to create empty, invalid groups. */
+    basic_group() noexcept
+        : descriptor{} {}
 
     /**
-     * @brief Invokes a y-combinator and therefore its underlying function.
-     * @tparam Args Types of arguments to use to invoke the underlying function.
-     * @param args Parameters to use to invoke the underlying function.
-     * @return Return value of the underlying function, if any.
+     * @brief Constructs a group from a set of storage classes.
+     * @param ref A reference to a group handler.
      */
-    template<typename... Args>
-    constexpr decltype(auto) operator()(Args &&...args) const noexcept(std::is_nothrow_invocable_v<Func, const y_combinator &, Args...>) {
-        return func(*this, std::forward<Args>(args)...);
-    }
+    basic_group(handler &ref) noexcept
+        : descriptor{&ref} {}
 
-    /*! @copydoc operator()() */
-    template<typename... Args>
-    constexpr decltype(auto) operator()(Args &&...args) noexcept(std::is_nothrow_invocable_v<Func, y_combinator &, Args...>) {
-        return func(*this, std::forward<Args>(args)...);
+    /**
+     * @brief Returns the leading storage of a group.
+     * @return The leading storage of the group.
+     */
+    [[nodiscard]] const common_type &handle() const noexcept {
+        return descriptor->handle();
     }
 
-private:
-    Func func;
-};
-
-} // namespace entt
-
-#endif
-
-// #include "fwd.hpp"
-
-// #include "type_info.hpp"
-#ifndef ENTT_CORE_TYPE_INFO_HPP
-#define ENTT_CORE_TYPE_INFO_HPP
-
-#include <string_view>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
-
-// #include "../core/attribute.h"
+    /**
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
+     */
+    template<typename Type>
+    [[nodiscard]] auto *storage() const noexcept {
+        return storage<index_of<Type>>();
+    }
 
-// #include "fwd.hpp"
+    /**
+     * @brief Returns the storage for a given index, if any.
+     * @tparam Index Index of the storage to return.
+     * @return The storage for the given index.
+     */
+    template<std::size_t Index>
+    [[nodiscard]] auto *storage() const noexcept {
+        using type = type_list_element_t<Index, type_list<Get..., Exclude...>>;
+        return *this ? static_cast<type *>(descriptor->template storage<Index>()) : nullptr;
+    }
 
-// #include "hashed_string.hpp"
+    /**
+     * @brief Returns the number of entities that are part of the group.
+     * @return Number of entities that are part of the group.
+     */
+    [[nodiscard]] size_type size() const noexcept {
+        return *this ? handle().size() : size_type{};
+    }
 
+    /**
+     * @brief Returns the number of elements that a group has currently
+     * allocated space for.
+     * @return Capacity of the group.
+     */
+    [[nodiscard]] size_type capacity() const noexcept {
+        return *this ? handle().capacity() : size_type{};
+    }
 
-namespace entt {
+    /*! @brief Requests the removal of unused capacity. */
+    void shrink_to_fit() {
+        if(*this) {
+            descriptor->handle().shrink_to_fit();
+        }
+    }
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+    /**
+     * @brief Checks whether a group is empty.
+     * @return True if the group is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        return !*this || handle().empty();
+    }
 
-struct ENTT_API type_index final {
-    [[nodiscard]] static id_type next() noexcept {
-        static ENTT_MAYBE_ATOMIC(id_type) value{};
-        return value++;
+    /**
+     * @brief Returns an iterator to the first entity of the group.
+     *
+     * If the group is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first entity of the group.
+     */
+    [[nodiscard]] iterator begin() const noexcept {
+        return *this ? handle().begin() : iterator{};
     }
-};
 
-template<typename Type>
-[[nodiscard]] constexpr auto stripped_type_name() noexcept {
-#if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
-    auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
-    auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
-    return value;
-#else
-    return std::string_view{""};
-#endif
-}
+    /**
+     * @brief Returns an iterator that is past the last entity of the group.
+     * @return An iterator to the entity following the last entity of the
+     * group.
+     */
+    [[nodiscard]] iterator end() const noexcept {
+        return *this ? handle().end() : iterator{};
+    }
 
-template<typename Type, auto = stripped_type_name<Type>().find_first_of('.')>
-[[nodiscard]] constexpr std::string_view type_name(int) noexcept {
-    constexpr auto value = stripped_type_name<Type>();
-    return value;
-}
+    /**
+     * @brief Returns an iterator to the first entity of the reversed group.
+     *
+     * If the group is empty, the returned iterator will be equal to `rend()`.
+     *
+     * @return An iterator to the first entity of the reversed group.
+     */
+    [[nodiscard]] reverse_iterator rbegin() const noexcept {
+        return *this ? handle().rbegin() : reverse_iterator{};
+    }
 
-template<typename Type>
-[[nodiscard]] std::string_view type_name(char) noexcept {
-    static const auto value = stripped_type_name<Type>();
-    return value;
-}
+    /**
+     * @brief Returns an iterator that is past the last entity of the reversed
+     * group.
+     * @return An iterator to the entity following the last entity of the
+     * reversed group.
+     */
+    [[nodiscard]] reverse_iterator rend() const noexcept {
+        return *this ? handle().rend() : reverse_iterator{};
+    }
 
-template<typename Type, auto = stripped_type_name<Type>().find_first_of('.')>
-[[nodiscard]] constexpr id_type type_hash(int) noexcept {
-    constexpr auto stripped = stripped_type_name<Type>();
-    constexpr auto value = hashed_string::value(stripped.data(), stripped.size());
-    return value;
-}
+    /**
+     * @brief Returns the first entity of the group, if any.
+     * @return The first entity of the group if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type front() const noexcept {
+        const auto it = begin();
+        return it != end() ? *it : null;
+    }
 
-template<typename Type>
-[[nodiscard]] id_type type_hash(char) noexcept {
-    static const auto value = [](const auto stripped) {
-        return hashed_string::value(stripped.data(), stripped.size());
-    }(stripped_type_name<Type>());
-    return value;
-}
+    /**
+     * @brief Returns the last entity of the group, if any.
+     * @return The last entity of the group if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type back() const noexcept {
+        const auto it = rbegin();
+        return it != rend() ? *it : null;
+    }
 
-} // namespace internal
-/*! @endcond */
+    /**
+     * @brief Finds an entity.
+     * @param entt A valid identifier.
+     * @return An iterator to the given entity if it's found, past the end
+     * iterator otherwise.
+     */
+    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
+        return *this ? handle().find(entt) : iterator{};
+    }
 
-/**
- * @brief Type sequential identifier.
- * @tparam Type Type for which to generate a sequential identifier.
- */
-template<typename Type, typename = void>
-struct ENTT_API type_index final {
     /**
-     * @brief Returns the sequential identifier of a given type.
-     * @return The sequential identifier of a given type.
+     * @brief Returns the identifier that occupies the given position.
+     * @param pos Position of the element to return.
+     * @return The identifier that occupies the given position.
      */
-    [[nodiscard]] static id_type value() noexcept {
-        static const id_type value = internal::type_index::next();
-        return value;
+    [[nodiscard]] entity_type operator[](const size_type pos) const {
+        return begin()[pos];
     }
 
-    /*! @copydoc value */
-    [[nodiscard]] constexpr operator id_type() const noexcept {
-        return value();
+    /**
+     * @brief Checks if a group is properly initialized.
+     * @return True if the group is properly initialized, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return descriptor != nullptr;
     }
-};
 
-/**
- * @brief Type hash.
- * @tparam Type Type for which to generate a hash value.
- */
-template<typename Type, typename = void>
-struct type_hash final {
     /**
-     * @brief Returns the numeric representation of a given type.
-     * @return The numeric representation of the given type.
+     * @brief Checks if a group contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the group contains the given entity, false otherwise.
      */
-#if defined ENTT_PRETTY_FUNCTION
-    [[nodiscard]] static constexpr id_type value() noexcept {
-        return internal::type_hash<Type>(0);
-#else
-    [[nodiscard]] static constexpr id_type value() noexcept {
-        return type_index<Type>::value();
-#endif
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        return *this && handle().contains(entt);
     }
 
-    /*! @copydoc value */
-    [[nodiscard]] constexpr operator id_type() const noexcept {
-        return value();
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Type Type of the element to get.
+     * @tparam Other Other types of elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<typename Type, typename... Other>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        return get<index_of<Type>, index_of<Other>...>(entt);
     }
-};
 
-/**
- * @brief Type name.
- * @tparam Type Type for which to generate a name.
- */
-template<typename Type, typename = void>
-struct type_name final {
     /**
-     * @brief Returns the name of a given type.
-     * @return The name of the given type.
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Index Indexes of the elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
      */
-    [[nodiscard]] static constexpr std::string_view value() noexcept {
-        return internal::type_name<Type>(0);
+    template<std::size_t... Index>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        const auto cpools = pools_for(std::index_sequence_for<Get...>{});
+
+        if constexpr(sizeof...(Index) == 0) {
+            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
+        } else if constexpr(sizeof...(Index) == 1) {
+            return (std::get<Index>(cpools)->get(entt), ...);
+        } else {
+            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
+        }
     }
 
-    /*! @copydoc value */
-    [[nodiscard]] constexpr operator std::string_view() const noexcept {
-        return value();
+    /**
+     * @brief Iterates entities and elements and applies the given function
+     * object to them.
+     *
+     * The function object is invoked for each entity. It is provided with the
+     * entity itself and a set of references to non-empty elements. The
+     * _constness_ of the elements is as requested.<br/>
+     * The signature of the function must be equivalent to one of the following
+     * forms:
+     *
+     * @code{.cpp}
+     * void(const entity_type, Type &...);
+     * void(Type &...);
+     * @endcode
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @tparam Func Type of the function object to invoke.
+     * @param func A valid function object.
+     */
+    template<typename Func>
+    void each(Func func) const {
+        for(const auto entt: *this) {
+            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
+                std::apply(func, std::tuple_cat(std::make_tuple(entt), get(entt)));
+            } else {
+                std::apply(func, get(entt));
+            }
+        }
     }
-};
 
-/*! @brief Implementation specific information about a type. */
-struct type_info final {
     /**
-     * @brief Constructs a type info object for a given type.
-     * @tparam Type Type for which to construct a type info object.
+     * @brief Returns an iterable object to use to _visit_ a group.
+     *
+     * The iterable object returns tuples that contain the current entity and a
+     * set of references to its non-empty elements. The _constness_ of the
+     * elements is as requested.
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @return An iterable object to use to _visit_ the group.
      */
-    template<typename Type>
-    constexpr type_info(std::in_place_type_t<Type>) noexcept
-        : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
-          identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
-          alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    [[nodiscard]] iterable each() const noexcept {
+        const auto cpools = pools_for(std::index_sequence_for<Get...>{});
+        return iterable{{begin(), cpools}, {end(), cpools}};
+    }
 
     /**
-     * @brief Type index.
-     * @return Type index.
+     * @brief Sort a group according to the given comparison function.
+     *
+     * The comparison function object must return `true` if the first element
+     * is _less_ than the second one, `false` otherwise. The signature of the
+     * comparison function should be equivalent to one of the following:
+     *
+     * @code{.cpp}
+     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
+     * bool(const Type &..., const Type &...);
+     * bool(const Entity, const Entity);
+     * @endcode
+     *
+     * Where `Type` are such that they are iterated by the group.<br/>
+     * Moreover, the comparison function object shall induce a
+     * _strict weak ordering_ on the values.
+     *
+     * The sort function object must offer a member function template
+     * `operator()` that accepts three arguments:
+     *
+     * * An iterator to the first element of the range to sort.
+     * * An iterator past the last element of the range to sort.
+     * * A comparison function to use to compare the elements.
+     *
+     * @tparam Type Optional type of element to compare.
+     * @tparam Other Other optional types of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
      */
-    [[nodiscard]] constexpr id_type index() const noexcept {
-        return seq;
+    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
+        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Type hash.
-     * @return Type hash.
+     * @brief Sort a group according to the given comparison function.
+     *
+     * @sa sort
+     *
+     * @tparam Index Optional indexes of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
      */
-    [[nodiscard]] constexpr id_type hash() const noexcept {
-        return identifier;
+    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
+        if(*this) {
+            if constexpr(sizeof...(Index) == 0) {
+                static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
+                descriptor->handle().sort(std::move(compare), std::move(algo), std::forward<Args>(args)...);
+            } else {
+                auto comp = [&compare, cpools = pools_for(std::index_sequence_for<Get...>{})](const entity_type lhs, const entity_type rhs) {
+                    if constexpr(sizeof...(Index) == 1) {
+                        return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
+                    } else {
+                        return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
+                    }
+                };
+
+                descriptor->handle().sort(std::move(comp), std::move(algo), std::forward<Args>(args)...);
+            }
+        }
     }
 
     /**
-     * @brief Type name.
-     * @return Type name.
+     * @brief Sort entities according to their order in a range.
+     *
+     * The shared pool of entities and thus its order is affected by the changes
+     * to each and every pool that it tracks.
+     *
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
      */
-    [[nodiscard]] constexpr std::string_view name() const noexcept {
-        return alias;
+    template<typename It>
+    void sort_as(It first, It last) const {
+        if(*this) {
+            descriptor->handle().sort_as(first, last);
+        }
     }
 
 private:
-    id_type seq;
-    id_type identifier;
-    std::string_view alias;
+    handler *descriptor;
 };
 
 /**
- * @brief Compares the contents of two type info objects.
- * @param lhs A type info object.
- * @param rhs A type info object.
- * @return True if the two type info objects are identical, false otherwise.
- */
-[[nodiscard]] inline constexpr bool operator==(const type_info &lhs, const type_info &rhs) noexcept {
-    return lhs.hash() == rhs.hash();
-}
-
-/**
- * @brief Compares the contents of two type info objects.
- * @param lhs A type info object.
- * @param rhs A type info object.
- * @return True if the two type info objects differ, false otherwise.
+ * @brief Owning group.
+ *
+ * Owning groups returns all entities and only the entities that are at
+ * least in the given storage. Moreover:
+ *
+ * * It's guaranteed that the entity list is tightly packed in memory for fast
+ *   iterations.
+ * * It's guaranteed that all elements in the owned storage are tightly packed
+ *   in memory for even faster iterations and to allow direct access.
+ * * They stay true to the order of the owned storage and all instances have the
+ *   same order in memory.
+ *
+ * The more types of storage are owned, the faster it is to iterate a group.
+ *
+ * @b Important
+ *
+ * Iterators aren't invalidated if:
+ *
+ * * New elements are added to the storage.
+ * * The entity currently pointed is modified (for example, elements are added
+ *   or removed from it).
+ * * The entity currently pointed is destroyed.
+ *
+ * In all other cases, modifying the pools iterated by the group in any way
+ * invalidates all the iterators.
+ *
+ * @tparam Owned Types of storage _owned_ by the group.
+ * @tparam Get Types of storage _observed_ by the group.
+ * @tparam Exclude Types of storage used to filter the group.
  */
-[[nodiscard]] inline constexpr bool operator!=(const type_info &lhs, const type_info &rhs) noexcept {
-    return !(lhs == rhs);
-}
+template<typename... Owned, typename... Get, typename... Exclude>
+class basic_group<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> {
+    static_assert(((Owned::storage_policy != deletion_policy::in_place) && ...), "Groups do not support in-place delete");
 
-/**
- * @brief Compares two type info objects.
- * @param lhs A valid type info object.
- * @param rhs A valid type info object.
- * @return True if the first element is less than the second, false otherwise.
- */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
-    return lhs.index() < rhs.index();
-}
+    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
+    using underlying_type = typename base_type::entity_type;
 
-/**
- * @brief Compares two type info objects.
- * @param lhs A valid type info object.
- * @param rhs A valid type info object.
- * @return True if the first element is less than or equal to the second, false
- * otherwise.
- */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
-    return !(rhs < lhs);
-}
+    template<typename Type>
+    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Owned::element_type..., typename Get::element_type..., typename Exclude::element_type...>>;
 
-/**
- * @brief Compares two type info objects.
- * @param lhs A valid type info object.
- * @param rhs A valid type info object.
- * @return True if the first element is greater than the second, false
- * otherwise.
- */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
-    return rhs < lhs;
-}
+    template<std::size_t... Index, std::size_t... Other>
+    [[nodiscard]] auto pools_for(std::index_sequence<Index...>, std::index_sequence<Other...>) const noexcept {
+        using return_type = std::tuple<Owned *..., Get *...>;
+        return descriptor ? return_type{static_cast<Owned *>(descriptor->template storage<Index>())..., static_cast<Get *>(descriptor->template storage<sizeof...(Owned) + Other>())...} : return_type{};
+    }
 
-/**
- * @brief Compares two type info objects.
- * @param lhs A valid type info object.
- * @param rhs A valid type info object.
- * @return True if the first element is greater than or equal to the second,
- * false otherwise.
- */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
-    return !(lhs < rhs);
-}
+public:
+    /*! @brief Underlying entity identifier. */
+    using entity_type = underlying_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Common type among all storage types. */
+    using common_type = base_type;
+    /*! @brief Random access iterator type. */
+    using iterator = typename common_type::iterator;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = typename common_type::reverse_iterator;
+    /*! @brief Iterable group type. */
+    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<Owned...>, get_t<Get...>>>;
+    /*! @brief Group handler type. */
+    using handler = internal::group_handler<common_type, sizeof...(Owned), sizeof...(Get), sizeof...(Exclude)>;
 
-/**
- * @brief Returns the type info object associated to a given type.
- *
- * The returned element refers to an object with static storage duration.<br/>
- * The type doesn't need to be a complete type. If the type is a reference, the
- * result refers to the referenced type. In all cases, top-level cv-qualifiers
- * are ignored.
- *
- * @tparam Type Type for which to generate a type info object.
- * @return A reference to a properly initialized type info object.
- */
-template<typename Type>
-[[nodiscard]] const type_info &type_id() noexcept {
-    if constexpr(std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<Type>>>) {
-        static type_info instance{std::in_place_type<Type>};
-        return instance;
-    } else {
-        return type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
+    /**
+     * @brief Group opaque identifier.
+     * @return Group opaque identifier.
+     */
+    static id_type group_id() noexcept {
+        return type_hash<basic_group<owned_t<std::remove_const_t<Owned>...>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>>::value();
     }
-}
 
-/*! @copydoc type_id */
-template<typename Type>
-[[nodiscard]] const type_info &type_id(Type &&) noexcept {
-    return type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
-}
+    /*! @brief Default constructor to use to create empty, invalid groups. */
+    basic_group() noexcept
+        : descriptor{} {}
 
-} // namespace entt
+    /**
+     * @brief Constructs a group from a set of storage classes.
+     * @param ref A reference to a group handler.
+     */
+    basic_group(handler &ref) noexcept
+        : descriptor{&ref} {}
 
-#endif
+    /**
+     * @brief Returns the leading storage of a group.
+     * @return The leading storage of the group.
+     */
+    [[nodiscard]] const common_type &handle() const noexcept {
+        return *storage<0>();
+    }
 
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+    /**
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
+     */
+    template<typename Type>
+    [[nodiscard]] auto *storage() const noexcept {
+        return storage<index_of<Type>>();
+    }
 
-#include <cstddef>
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
+    /**
+     * @brief Returns the storage for a given index, if any.
+     * @tparam Index Index of the storage to return.
+     * @return The storage for the given index.
+     */
+    template<std::size_t Index>
+    [[nodiscard]] auto *storage() const noexcept {
+        using type = type_list_element_t<Index, type_list<Owned..., Get..., Exclude...>>;
+        return *this ? static_cast<type *>(descriptor->template storage<Index>()) : nullptr;
+    }
 
-// #include "fwd.hpp"
+    /**
+     * @brief Returns the number of entities that that are part of the group.
+     * @return Number of entities that that are part of the group.
+     */
+    [[nodiscard]] size_type size() const noexcept {
+        return *this ? descriptor->length() : size_type{};
+    }
 
+    /**
+     * @brief Checks whether a group is empty.
+     * @return True if the group is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        return !*this || !descriptor->length();
+    }
 
-namespace entt {
+    /**
+     * @brief Returns an iterator to the first entity of the group.
+     *
+     * If the group is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first entity of the group.
+     */
+    [[nodiscard]] iterator begin() const noexcept {
+        return *this ? (handle().end() - descriptor->length()) : iterator{};
+    }
 
-/**
- * @brief Utility class to disambiguate overloaded functions.
- * @tparam N Number of choices available.
- */
-template<std::size_t N>
-struct choice_t
-    // unfortunately, doxygen cannot parse such a construct
-    : /*! @cond TURN_OFF_DOXYGEN */ choice_t<N - 1> /*! @endcond */
-{};
+    /**
+     * @brief Returns an iterator that is past the last entity of the group.
+     * @return An iterator to the entity following the last entity of the
+     * group.
+     */
+    [[nodiscard]] iterator end() const noexcept {
+        return *this ? handle().end() : iterator{};
+    }
 
-/*! @copybrief choice_t */
-template<>
-struct choice_t<0> {};
+    /**
+     * @brief Returns an iterator to the first entity of the reversed group.
+     *
+     * If the group is empty, the returned iterator will be equal to `rend()`.
+     *
+     * @return An iterator to the first entity of the reversed group.
+     */
+    [[nodiscard]] reverse_iterator rbegin() const noexcept {
+        return *this ? handle().rbegin() : reverse_iterator{};
+    }
 
-/**
- * @brief Variable template for the choice trick.
- * @tparam N Number of choices available.
- */
-template<std::size_t N>
-inline constexpr choice_t<N> choice{};
+    /**
+     * @brief Returns an iterator that is past the last entity of the reversed
+     * group.
+     * @return An iterator to the entity following the last entity of the
+     * reversed group.
+     */
+    [[nodiscard]] reverse_iterator rend() const noexcept {
+        return *this ? (handle().rbegin() + descriptor->length()) : reverse_iterator{};
+    }
 
-/**
- * @brief Identity type trait.
- *
- * Useful to establish non-deduced contexts in template argument deduction
- * (waiting for C++20) or to provide types through function arguments.
- *
- * @tparam Type A type.
- */
-template<typename Type>
-struct type_identity {
-    /*! @brief Identity type. */
-    using type = Type;
-};
+    /**
+     * @brief Returns the first entity of the group, if any.
+     * @return The first entity of the group if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type front() const noexcept {
+        const auto it = begin();
+        return it != end() ? *it : null;
+    }
 
-/**
- * @brief Helper type.
- * @tparam Type A type.
- */
-template<typename Type>
-using type_identity_t = typename type_identity<Type>::type;
+    /**
+     * @brief Returns the last entity of the group, if any.
+     * @return The last entity of the group if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type back() const noexcept {
+        const auto it = rbegin();
+        return it != rend() ? *it : null;
+    }
 
-/**
- * @brief A type-only `sizeof` wrapper that returns 0 where `sizeof` complains.
- * @tparam Type The type of which to return the size.
- */
-template<typename Type, typename = void>
-struct size_of: std::integral_constant<std::size_t, 0u> {};
+    /**
+     * @brief Finds an entity.
+     * @param entt A valid identifier.
+     * @return An iterator to the given entity if it's found, past the end
+     * iterator otherwise.
+     */
+    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
+        const auto it = *this ? handle().find(entt) : iterator{};
+        return it >= begin() ? it : iterator{};
+    }
 
-/*! @copydoc size_of */
-template<typename Type>
-struct size_of<Type, std::void_t<decltype(sizeof(Type))>>
-    : std::integral_constant<std::size_t, sizeof(Type)> {};
+    /**
+     * @brief Returns the identifier that occupies the given position.
+     * @param pos Position of the element to return.
+     * @return The identifier that occupies the given position.
+     */
+    [[nodiscard]] entity_type operator[](const size_type pos) const {
+        return begin()[pos];
+    }
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type of which to return the size.
- */
-template<typename Type>
-inline constexpr std::size_t size_of_v = size_of<Type>::value;
+    /**
+     * @brief Checks if a group is properly initialized.
+     * @return True if the group is properly initialized, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return descriptor != nullptr;
+    }
 
-/**
- * @brief Using declaration to be used to _repeat_ the same type a number of
- * times equal to the size of a given parameter pack.
- * @tparam Type A type to repeat.
- */
-template<typename Type, typename>
-using unpack_as_type = Type;
+    /**
+     * @brief Checks if a group contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the group contains the given entity, false otherwise.
+     */
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        return *this && handle().contains(entt) && (handle().index(entt) < (descriptor->length()));
+    }
 
-/**
- * @brief Helper variable template to be used to _repeat_ the same value a
- * number of times equal to the size of a given parameter pack.
- * @tparam Value A value to repeat.
- */
-template<auto Value, typename>
-inline constexpr auto unpack_as_value = Value;
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Type Type of the element to get.
+     * @tparam Other Other types of elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<typename Type, typename... Other>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        return get<index_of<Type>, index_of<Other>...>(entt);
+    }
 
-/**
- * @brief Wraps a static constant.
- * @tparam Value A static constant.
- */
-template<auto Value>
-using integral_constant = std::integral_constant<decltype(Value), Value>;
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Index Indexes of the elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<std::size_t... Index>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        const auto cpools = pools_for(std::index_sequence_for<Owned...>{}, std::index_sequence_for<Get...>{});
 
-/**
- * @brief Alias template to facilitate the creation of named values.
- * @tparam Value A constant value at least convertible to `id_type`.
- */
-template<id_type Value>
-using tag = integral_constant<Value>;
+        if constexpr(sizeof...(Index) == 0) {
+            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
+        } else if constexpr(sizeof...(Index) == 1) {
+            return (std::get<Index>(cpools)->get(entt), ...);
+        } else {
+            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
+        }
+    }
 
-/**
- * @brief A class to use to push around lists of types, nothing more.
- * @tparam Type Types provided by the type list.
- */
-template<typename... Type>
-struct type_list {
-    /*! @brief Type list type. */
-    using type = type_list;
-    /*! @brief Compile-time number of elements in the type list. */
-    static constexpr auto size = sizeof...(Type);
-};
+    /**
+     * @brief Iterates entities and elements and applies the given function
+     * object to them.
+     *
+     * The function object is invoked for each entity. It is provided with the
+     * entity itself and a set of references to non-empty elements. The
+     * _constness_ of the elements is as requested.<br/>
+     * The signature of the function must be equivalent to one of the following
+     * forms:
+     *
+     * @code{.cpp}
+     * void(const entity_type, Type &...);
+     * void(Type &...);
+     * @endcode
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @tparam Func Type of the function object to invoke.
+     * @param func A valid function object.
+     */
+    template<typename Func>
+    void each(Func func) const {
+        for(auto args: each()) {
+            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
+                std::apply(func, args);
+            } else {
+                std::apply([&func](auto, auto &&...less) { func(std::forward<decltype(less)>(less)...); }, args);
+            }
+        }
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<std::size_t, typename>
-struct type_list_element;
+    /**
+     * @brief Returns an iterable object to use to _visit_ a group.
+     *
+     * The iterable object returns tuples that contain the current entity and a
+     * set of references to its non-empty elements. The _constness_ of the
+     * elements is as requested.
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @return An iterable object to use to _visit_ the group.
+     */
+    [[nodiscard]] iterable each() const noexcept {
+        const auto cpools = pools_for(std::index_sequence_for<Owned...>{}, std::index_sequence_for<Get...>{});
+        return iterable{{begin(), cpools}, {end(), cpools}};
+    }
 
-/**
- * @brief Provides compile-time indexed access to the types of a type list.
- * @tparam Index Index of the type to return.
- * @tparam First First type provided by the type list.
- * @tparam Other Other types provided by the type list.
- */
-template<std::size_t Index, typename First, typename... Other>
-struct type_list_element<Index, type_list<First, Other...>>
-    : type_list_element<Index - 1u, type_list<Other...>> {};
+    /**
+     * @brief Sort a group according to the given comparison function.
+     *
+     * The comparison function object must return `true` if the first element
+     * is _less_ than the second one, `false` otherwise. The signature of the
+     * comparison function should be equivalent to one of the following:
+     *
+     * @code{.cpp}
+     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
+     * bool(const Type &, const Type &);
+     * bool(const Entity, const Entity);
+     * @endcode
+     *
+     * Where `Type` are either owned types or not but still such that they are
+     * iterated by the group.<br/>
+     * Moreover, the comparison function object shall induce a
+     * _strict weak ordering_ on the values.
+     *
+     * The sort function object must offer a member function template
+     * `operator()` that accepts three arguments:
+     *
+     * * An iterator to the first element of the range to sort.
+     * * An iterator past the last element of the range to sort.
+     * * A comparison function to use to compare the elements.
+     *
+     * @tparam Type Optional type of element to compare.
+     * @tparam Other Other optional types of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
+        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
+    }
 
-/**
- * @brief Provides compile-time indexed access to the types of a type list.
- * @tparam First First type provided by the type list.
- * @tparam Other Other types provided by the type list.
- */
-template<typename First, typename... Other>
-struct type_list_element<0u, type_list<First, Other...>> {
-    /*! @brief Searched type. */
-    using type = First;
-};
+    /**
+     * @brief Sort a group according to the given comparison function.
+     *
+     * @sa sort
+     *
+     * @tparam Index Optional indexes of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
+        const auto cpools = pools_for(std::index_sequence_for<Owned...>{}, std::index_sequence_for<Get...>{});
 
-/**
- * @brief Helper type.
- * @tparam Index Index of the type to return.
- * @tparam List Type list to search into.
- */
-template<std::size_t Index, typename List>
-using type_list_element_t = typename type_list_element<Index, List>::type;
+        if constexpr(sizeof...(Index) == 0) {
+            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
+            storage<0>()->sort_n(descriptor->length(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
+        } else {
+            auto comp = [&compare, &cpools](const entity_type lhs, const entity_type rhs) {
+                if constexpr(sizeof...(Index) == 1) {
+                    return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
+                } else {
+                    return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
+                }
+            };
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename, typename>
-struct type_list_index;
+            storage<0>()->sort_n(descriptor->length(), std::move(comp), std::move(algo), std::forward<Args>(args)...);
+        }
 
-/**
- * @brief Provides compile-time type access to the types of a type list.
- * @tparam Type Type to look for and for which to return the index.
- * @tparam First First type provided by the type list.
- * @tparam Other Other types provided by the type list.
- */
-template<typename Type, typename First, typename... Other>
-struct type_list_index<Type, type_list<First, Other...>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 1u + type_list_index<Type, type_list<Other...>>::value;
-};
+        auto cb = [this](auto *head, auto *...other) {
+            for(auto next = descriptor->length(); next; --next) {
+                const auto pos = next - 1;
+                [[maybe_unused]] const auto entt = head->data()[pos];
+                (other->swap_elements(other->data()[pos], entt), ...);
+            }
+        };
 
-/**
- * @brief Provides compile-time type access to the types of a type list.
- * @tparam Type Type to look for and for which to return the index.
- * @tparam Other Other types provided by the type list.
- */
-template<typename Type, typename... Other>
-struct type_list_index<Type, type_list<Type, Other...>> {
-    static_assert(type_list_index<Type, type_list<Other...>>::value == sizeof...(Other), "Non-unique type");
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 0u;
-};
+        std::apply(cb, cpools);
+    }
 
-/**
- * @brief Provides compile-time type access to the types of a type list.
- * @tparam Type Type to look for and for which to return the index.
- */
-template<typename Type>
-struct type_list_index<Type, type_list<>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 0u;
+private:
+    handler *descriptor;
 };
 
-/**
- * @brief Helper variable template.
- * @tparam List Type list.
- * @tparam Type Type to look for and for which to return the index.
- */
-template<typename Type, typename List>
-inline constexpr std::size_t type_list_index_v = type_list_index<Type, List>::value;
+} // namespace entt
 
-/**
- * @brief Concatenates multiple type lists.
- * @tparam Type Types provided by the first type list.
- * @tparam Other Types provided by the second type list.
- * @return A type list composed by the types of both the type lists.
- */
-template<typename... Type, typename... Other>
-constexpr type_list<Type..., Other...> operator+(type_list<Type...>, type_list<Other...>) {
-    return {};
-}
+#endif
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct type_list_cat;
+// #include "entity/handle.hpp"
+#ifndef ENTT_ENTITY_HANDLE_HPP
+#define ENTT_ENTITY_HANDLE_HPP
 
-/*! @brief Concatenates multiple type lists. */
-template<>
-struct type_list_cat<> {
-    /*! @brief A type list composed by the types of all the type lists. */
-    using type = type_list<>;
-};
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
 
-/**
- * @brief Concatenates multiple type lists.
- * @tparam Type Types provided by the first type list.
- * @tparam Other Types provided by the second type list.
- * @tparam List Other type lists, if any.
- */
-template<typename... Type, typename... Other, typename... List>
-struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
-    /*! @brief A type list composed by the types of all the type lists. */
-    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
-};
+// #include "../core/iterator.hpp"
 
-/**
- * @brief Concatenates multiple type lists.
- * @tparam Type Types provided by the type list.
- */
-template<typename... Type>
-struct type_list_cat<type_list<Type...>> {
-    /*! @brief A type list composed by the types of all the type lists. */
-    using type = type_list<Type...>;
-};
+// #include "../core/type_traits.hpp"
+
+// #include "entity.hpp"
+
+// #include "fwd.hpp"
 
-/**
- * @brief Helper type.
- * @tparam List Type lists to concatenate.
- */
-template<typename... List>
-using type_list_cat_t = typename type_list_cat<List...>::type;
+
+namespace entt {
 
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename...>
-struct type_list_unique;
+template<typename It>
+class handle_storage_iterator final {
+    template<typename Other>
+    friend class handle_storage_iterator;
 
-template<typename First, typename... Other, typename... Type>
-struct type_list_unique<type_list<First, Other...>, Type...>
-    : std::conditional_t<(std::is_same_v<First, Type> || ...), type_list_unique<type_list<Other...>, Type...>, type_list_unique<type_list<Other...>, Type..., First>> {};
+    using underlying_type = std::remove_reference_t<typename It::value_type::second_type>;
+    using entity_type = typename underlying_type::entity_type;
 
-template<typename... Type>
-struct type_list_unique<type_list<>, Type...> {
-    using type = type_list<Type...>;
+public:
+    using value_type = typename std::iterator_traits<It>::value_type;
+    using pointer = input_iterator_pointer<value_type>;
+    using reference = value_type;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::input_iterator_tag;
+    using iterator_concept = std::forward_iterator_tag;
+
+    constexpr handle_storage_iterator() noexcept
+        : entt{null},
+          it{},
+          last{} {}
+
+    constexpr handle_storage_iterator(entity_type value, It from, It to) noexcept
+        : entt{value},
+          it{from},
+          last{to} {
+        while(it != last && !it->second.contains(entt)) {
+            ++it;
+        }
+    }
+
+    constexpr handle_storage_iterator &operator++() noexcept {
+        while(++it != last && !it->second.contains(entt)) {}
+        return *this;
+    }
+
+    constexpr handle_storage_iterator operator++(int) noexcept {
+        handle_storage_iterator orig = *this;
+        return ++(*this), orig;
+    }
+
+    [[nodiscard]] constexpr reference operator*() const noexcept {
+        return *it;
+    }
+
+    [[nodiscard]] constexpr pointer operator->() const noexcept {
+        return operator*();
+    }
+
+    template<typename ILhs, typename IRhs>
+    friend constexpr bool operator==(const handle_storage_iterator<ILhs> &, const handle_storage_iterator<IRhs> &) noexcept;
+
+private:
+    entity_type entt;
+    It it;
+    It last;
 };
 
+template<typename ILhs, typename IRhs>
+[[nodiscard]] constexpr bool operator==(const handle_storage_iterator<ILhs> &lhs, const handle_storage_iterator<IRhs> &rhs) noexcept {
+    return lhs.it == rhs.it;
+}
+
+template<typename ILhs, typename IRhs>
+[[nodiscard]] constexpr bool operator!=(const handle_storage_iterator<ILhs> &lhs, const handle_storage_iterator<IRhs> &rhs) noexcept {
+    return !(lhs == rhs);
+}
+
 } // namespace internal
 /*! @endcond */
 
 /**
- * @brief Removes duplicates types from a type list.
- * @tparam List Type list.
+ * @brief Non-owning handle to an entity.
+ *
+ * Tiny wrapper around a registry and an entity.
+ *
+ * @tparam Registry Basic registry type.
+ * @tparam Scope Types to which to restrict the scope of a handle.
  */
-template<typename List>
-struct type_list_unique {
-    /*! @brief A type list without duplicate types. */
-    using type = typename internal::type_list_unique<List>::type;
-};
+template<typename Registry, typename... Scope>
+class basic_handle {
+    using traits_type = entt_traits<typename Registry::entity_type>;
 
-/**
- * @brief Helper type.
- * @tparam List Type list.
- */
-template<typename List>
-using type_list_unique_t = typename type_list_unique<List>::type;
+    [[nodiscard]] auto &owner_or_assert() const noexcept {
+        ENTT_ASSERT(owner != nullptr, "Invalid pointer to registry");
+        return static_cast<Registry &>(*owner);
+    }
 
-/**
- * @brief Provides the member constant `value` to true if a type list contains a
- * given type, false otherwise.
- * @tparam List Type list.
- * @tparam Type Type to look for.
- */
-template<typename List, typename Type>
-struct type_list_contains;
+public:
+    /*! @brief Type of registry accepted by the handle. */
+    using registry_type = Registry;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename traits_type::value_type;
+    /*! @brief Underlying version type. */
+    using version_type = typename traits_type::version_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Iterable handle type. */
+    using iterable = iterable_adaptor<internal::handle_storage_iterator<typename decltype(std::declval<registry_type>().storage())::iterator>>;
 
-/**
- * @copybrief type_list_contains
- * @tparam Type Types provided by the type list.
- * @tparam Other Type to look for.
- */
-template<typename... Type, typename Other>
-struct type_list_contains<type_list<Type...>, Other>
-    : std::bool_constant<(std::is_same_v<Type, Other> || ...)> {};
+    /*! @brief Constructs an invalid handle. */
+    basic_handle() noexcept
+        : owner{},
+          entt{null} {}
 
-/**
- * @brief Helper variable template.
- * @tparam List Type list.
- * @tparam Type Type to look for.
- */
-template<typename List, typename Type>
-inline constexpr bool type_list_contains_v = type_list_contains<List, Type>::value;
+    /**
+     * @brief Constructs a handle from a given registry and entity.
+     * @param ref An instance of the registry class.
+     * @param value A valid identifier.
+     */
+    basic_handle(registry_type &ref, entity_type value) noexcept
+        : owner{&ref},
+          entt{value} {}
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct type_list_diff;
+    /**
+     * @brief Returns an iterable object to use to _visit_ a handle.
+     *
+     * The iterable object returns a pair that contains the name and a reference
+     * to the current storage.<br/>
+     * Returned storage are those that contain the entity associated with the
+     * handle.
+     *
+     * @return An iterable object to use to _visit_ the handle.
+     */
+    [[nodiscard]] iterable storage() const noexcept {
+        auto underlying = owner_or_assert().storage();
+        return iterable{{entt, underlying.begin(), underlying.end()}, {entt, underlying.end(), underlying.end()}};
+    }
 
-/**
- * @brief Computes the difference between two type lists.
- * @tparam Type Types provided by the first type list.
- * @tparam Other Types provided by the second type list.
- */
-template<typename... Type, typename... Other>
-struct type_list_diff<type_list<Type...>, type_list<Other...>> {
-    /*! @brief A type list that is the difference between the two type lists. */
-    using type = type_list_cat_t<std::conditional_t<type_list_contains_v<type_list<Other...>, Type>, type_list<>, type_list<Type>>...>;
-};
+    /*! @copydoc valid */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return owner && owner->valid(entt);
+    }
 
-/**
- * @brief Helper type.
- * @tparam List Type lists between which to compute the difference.
- */
-template<typename... List>
-using type_list_diff_t = typename type_list_diff<List...>::type;
+    /**
+     * @brief Checks if a handle refers to a valid registry and entity.
+     * @return True if the handle refers to a valid registry and entity, false
+     * otherwise.
+     */
+    [[nodiscard]] bool valid() const {
+        return static_cast<bool>(*this);
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename, template<typename...> class>
-struct type_list_transform;
+    /**
+     * @brief Returns a pointer to the underlying registry, if any.
+     * @return A pointer to the underlying registry, if any.
+     */
+    [[nodiscard]] registry_type *registry() const noexcept {
+        return owner;
+    }
 
-/**
- * @brief Applies a given _function_ to a type list and generate a new list.
- * @tparam Type Types provided by the type list.
- * @tparam Op Unary operation as template class with a type member named `type`.
- */
-template<typename... Type, template<typename...> class Op>
-struct type_list_transform<type_list<Type...>, Op> {
-    /*! @brief Resulting type list after applying the transform function. */
-    using type = type_list<typename Op<Type>::type...>;
-};
+    /**
+     * @brief Returns the entity associated with a handle.
+     * @return The entity associated with the handle.
+     */
+    [[nodiscard]] entity_type entity() const noexcept {
+        return entt;
+    }
 
-/**
- * @brief Helper type.
- * @tparam List Type list.
- * @tparam Op Unary operation as template class with a type member named `type`.
- */
-template<typename List, template<typename...> class Op>
-using type_list_transform_t = typename type_list_transform<List, Op>::type;
+    /*! @copydoc entity */
+    [[nodiscard]] operator entity_type() const noexcept {
+        return entity();
+    }
 
-/**
- * @brief A class to use to push around lists of constant values, nothing more.
- * @tparam Value Values provided by the value list.
- */
-template<auto... Value>
-struct value_list {
-    /*! @brief Value list type. */
-    using type = value_list;
-    /*! @brief Compile-time number of elements in the value list. */
-    static constexpr auto size = sizeof...(Value);
-};
+    /*! @brief Destroys the entity associated with a handle. */
+    void destroy() {
+        owner_or_assert().destroy(std::exchange(entt, null));
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<std::size_t, typename>
-struct value_list_element;
+    /**
+     * @brief Destroys the entity associated with a handle.
+     * @param version A desired version upon destruction.
+     */
+    void destroy(const version_type version) {
+        owner_or_assert().destroy(std::exchange(entt, null), version);
+    }
 
-/**
- * @brief Provides compile-time indexed access to the values of a value list.
- * @tparam Index Index of the value to return.
- * @tparam Value First value provided by the value list.
- * @tparam Other Other values provided by the value list.
- */
-template<std::size_t Index, auto Value, auto... Other>
-struct value_list_element<Index, value_list<Value, Other...>>
-    : value_list_element<Index - 1u, value_list<Other...>> {};
+    /**
+     * @brief Assigns the given element to a handle.
+     * @tparam Type Type of element to create.
+     * @tparam Args Types of arguments to use to construct the element.
+     * @param args Parameters to use to initialize the element.
+     * @return A reference to the newly created element.
+     */
+    template<typename Type, typename... Args>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
+    decltype(auto) emplace(Args &&...args) const {
+        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Type, Scope>), "Invalid type");
+        return owner_or_assert().template emplace<Type>(entt, std::forward<Args>(args)...);
+    }
 
-/**
- * @brief Provides compile-time indexed access to the types of a type list.
- * @tparam Value First value provided by the value list.
- * @tparam Other Other values provided by the value list.
- */
-template<auto Value, auto... Other>
-struct value_list_element<0u, value_list<Value, Other...>> {
-    /*! @brief Searched type. */
-    using type = decltype(Value);
-    /*! @brief Searched value. */
-    static constexpr auto value = Value;
-};
+    /**
+     * @brief Assigns or replaces the given element for a handle.
+     * @tparam Type Type of element to assign or replace.
+     * @tparam Args Types of arguments to use to construct the element.
+     * @param args Parameters to use to initialize the element.
+     * @return A reference to the newly created element.
+     */
+    template<typename Type, typename... Args>
+    decltype(auto) emplace_or_replace(Args &&...args) const {
+        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Type, Scope>), "Invalid type");
+        return owner_or_assert().template emplace_or_replace<Type>(entt, std::forward<Args>(args)...);
+    }
 
-/**
- * @brief Helper type.
- * @tparam Index Index of the type to return.
- * @tparam List Value list to search into.
- */
-template<std::size_t Index, typename List>
-using value_list_element_t = typename value_list_element<Index, List>::type;
+    /**
+     * @brief Patches the given element for a handle.
+     * @tparam Type Type of element to patch.
+     * @tparam Func Types of the function objects to invoke.
+     * @param func Valid function objects.
+     * @return A reference to the patched element.
+     */
+    template<typename Type, typename... Func>
+    decltype(auto) patch(Func &&...func) const {
+        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Type, Scope>), "Invalid type");
+        return owner_or_assert().template patch<Type>(entt, std::forward<Func>(func)...);
+    }
 
-/**
- * @brief Helper type.
- * @tparam Index Index of the value to return.
- * @tparam List Value list to search into.
- */
-template<std::size_t Index, typename List>
-inline constexpr auto value_list_element_v = value_list_element<Index, List>::value;
+    /**
+     * @brief Replaces the given element for a handle.
+     * @tparam Type Type of element to replace.
+     * @tparam Args Types of arguments to use to construct the element.
+     * @param args Parameters to use to initialize the element.
+     * @return A reference to the element being replaced.
+     */
+    template<typename Type, typename... Args>
+    decltype(auto) replace(Args &&...args) const {
+        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Type, Scope>), "Invalid type");
+        return owner_or_assert().template replace<Type>(entt, std::forward<Args>(args)...);
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<auto, typename>
-struct value_list_index;
+    /**
+     * @brief Removes the given elements from a handle.
+     * @tparam Type Types of elements to remove.
+     * @return The number of elements actually removed.
+     */
+    template<typename... Type>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
+    size_type remove() const {
+        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Type> && ...), "Invalid type");
+        return owner_or_assert().template remove<Type...>(entt);
+    }
 
-/**
- * @brief Provides compile-time type access to the values of a value list.
- * @tparam Value Value to look for and for which to return the index.
- * @tparam First First value provided by the value list.
- * @tparam Other Other values provided by the value list.
- */
-template<auto Value, auto First, auto... Other>
-struct value_list_index<Value, value_list<First, Other...>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given value in the sublist. */
-    static constexpr value_type value = 1u + value_list_index<Value, value_list<Other...>>::value;
-};
+    /**
+     * @brief Erases the given elements from a handle.
+     * @tparam Type Types of elements to erase.
+     */
+    template<typename... Type>
+    void erase() const {
+        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Type> && ...), "Invalid type");
+        owner_or_assert().template erase<Type...>(entt);
+    }
 
-/**
- * @brief Provides compile-time type access to the values of a value list.
- * @tparam Value Value to look for and for which to return the index.
- * @tparam Other Other values provided by the value list.
- */
-template<auto Value, auto... Other>
-struct value_list_index<Value, value_list<Value, Other...>> {
-    static_assert(value_list_index<Value, value_list<Other...>>::value == sizeof...(Other), "Non-unique type");
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given value in the sublist. */
-    static constexpr value_type value = 0u;
-};
+    /**
+     * @brief Checks if a handle has all the given elements.
+     * @tparam Type Elements for which to perform the check.
+     * @return True if the handle has all the elements, false otherwise.
+     */
+    template<typename... Type>
+    [[nodiscard]] decltype(auto) all_of() const {
+        return owner_or_assert().template all_of<Type...>(entt);
+    }
 
-/**
- * @brief Provides compile-time type access to the values of a value list.
- * @tparam Value Value to look for and for which to return the index.
- */
-template<auto Value>
-struct value_list_index<Value, value_list<>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 0u;
-};
+    /**
+     * @brief Checks if a handle has at least one of the given elements.
+     * @tparam Type Elements for which to perform the check.
+     * @return True if the handle has at least one of the given elements,
+     * false otherwise.
+     */
+    template<typename... Type>
+    [[nodiscard]] decltype(auto) any_of() const {
+        return owner_or_assert().template any_of<Type...>(entt);
+    }
 
-/**
- * @brief Helper variable template.
- * @tparam List Value list.
- * @tparam Value Value to look for and for which to return the index.
- */
-template<auto Value, typename List>
-inline constexpr std::size_t value_list_index_v = value_list_index<Value, List>::value;
+    /**
+     * @brief Returns references to the given elements for a handle.
+     * @tparam Type Types of elements to get.
+     * @return References to the elements owned by the handle.
+     */
+    template<typename... Type>
+    [[nodiscard]] decltype(auto) get() const {
+        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Type> && ...), "Invalid type");
+        return owner_or_assert().template get<Type...>(entt);
+    }
 
-/**
- * @brief Concatenates multiple value lists.
- * @tparam Value Values provided by the first value list.
- * @tparam Other Values provided by the second value list.
- * @return A value list composed by the values of both the value lists.
- */
-template<auto... Value, auto... Other>
-constexpr value_list<Value..., Other...> operator+(value_list<Value...>, value_list<Other...>) {
-    return {};
-}
+    /**
+     * @brief Returns a reference to the given element for a handle.
+     * @tparam Type Type of element to get.
+     * @tparam Args Types of arguments to use to construct the element.
+     * @param args Parameters to use to initialize the element.
+     * @return Reference to the element owned by the handle.
+     */
+    template<typename Type, typename... Args>
+    [[nodiscard]] decltype(auto) get_or_emplace(Args &&...args) const {
+        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Type, Scope>), "Invalid type");
+        return owner_or_assert().template get_or_emplace<Type>(entt, std::forward<Args>(args)...);
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct value_list_cat;
+    /**
+     * @brief Returns pointers to the given elements for a handle.
+     * @tparam Type Types of elements to get.
+     * @return Pointers to the elements owned by the handle.
+     */
+    template<typename... Type>
+    [[nodiscard]] auto try_get() const {
+        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Type> && ...), "Invalid type");
+        return owner_or_assert().template try_get<Type...>(entt);
+    }
 
-/*! @brief Concatenates multiple value lists. */
-template<>
-struct value_list_cat<> {
-    /*! @brief A value list composed by the values of all the value lists. */
-    using type = value_list<>;
-};
+    /**
+     * @brief Checks if a handle has elements assigned.
+     * @return True if the handle has no elements assigned, false otherwise.
+     */
+    [[nodiscard]] bool orphan() const {
+        return owner_or_assert().orphan(entt);
+    }
 
-/**
- * @brief Concatenates multiple value lists.
- * @tparam Value Values provided by the first value list.
- * @tparam Other Values provided by the second value list.
- * @tparam List Other value lists, if any.
- */
-template<auto... Value, auto... Other, typename... List>
-struct value_list_cat<value_list<Value...>, value_list<Other...>, List...> {
-    /*! @brief A value list composed by the values of all the value lists. */
-    using type = typename value_list_cat<value_list<Value..., Other...>, List...>::type;
-};
+    /**
+     * @brief Returns a const handle from a non-const one.
+     * @tparam Other A valid entity type.
+     * @tparam Args Scope of the handle to construct.
+     * @return A const handle referring to the same registry and the same
+     * entity.
+     */
+    template<typename Other, typename... Args>
+    operator basic_handle<Other, Args...>() const noexcept {
+        static_assert(std::is_same_v<Other, Registry> || std::is_same_v<std::remove_const_t<Other>, Registry>, "Invalid conversion between different handles");
+        static_assert((sizeof...(Scope) == 0 || ((sizeof...(Args) != 0 && sizeof...(Args) <= sizeof...(Scope)) && ... && (type_list_contains_v<type_list<Scope...>, Args>))), "Invalid conversion between different handles");
+        return owner ? basic_handle<Other, Args...>{*owner, entt} : basic_handle<Other, Args...>{};
+    }
 
-/**
- * @brief Concatenates multiple value lists.
- * @tparam Value Values provided by the value list.
- */
-template<auto... Value>
-struct value_list_cat<value_list<Value...>> {
-    /*! @brief A value list composed by the values of all the value lists. */
-    using type = value_list<Value...>;
+private:
+    registry_type *owner;
+    entity_type entt;
 };
 
 /**
- * @brief Helper type.
- * @tparam List Value lists to concatenate.
+ * @brief Compares two handles.
+ * @tparam Args Scope of the first handle.
+ * @tparam Other Scope of the second handle.
+ * @param lhs A valid handle.
+ * @param rhs A valid handle.
+ * @return True if both handles refer to the same registry and the same
+ * entity, false otherwise.
  */
-template<typename... List>
-using value_list_cat_t = typename value_list_cat<List...>::type;
-
-/*! @brief Primary template isn't defined on purpose. */
-template<typename>
-struct value_list_unique;
+template<typename... Args, typename... Other>
+[[nodiscard]] bool operator==(const basic_handle<Args...> &lhs, const basic_handle<Other...> &rhs) noexcept {
+    return lhs.registry() == rhs.registry() && lhs.entity() == rhs.entity();
+}
 
 /**
- * @brief Removes duplicates values from a value list.
- * @tparam Value One of the values provided by the given value list.
- * @tparam Other The other values provided by the given value list.
+ * @brief Compares two handles.
+ * @tparam Args Scope of the first handle.
+ * @tparam Other Scope of the second handle.
+ * @param lhs A valid handle.
+ * @param rhs A valid handle.
+ * @return False if both handles refer to the same registry and the same
+ * entity, true otherwise.
  */
-template<auto Value, auto... Other>
-struct value_list_unique<value_list<Value, Other...>> {
-    /*! @brief A value list without duplicate types. */
-    using type = std::conditional_t<
-        ((Value == Other) || ...),
-        typename value_list_unique<value_list<Other...>>::type,
-        value_list_cat_t<value_list<Value>, typename value_list_unique<value_list<Other...>>::type>>;
-};
-
-/*! @brief Removes duplicates values from a value list. */
-template<>
-struct value_list_unique<value_list<>> {
-    /*! @brief A value list without duplicate types. */
-    using type = value_list<>;
-};
+template<typename... Args, typename... Other>
+[[nodiscard]] bool operator!=(const basic_handle<Args...> &lhs, const basic_handle<Other...> &rhs) noexcept {
+    return !(lhs == rhs);
+}
 
 /**
- * @brief Helper type.
- * @tparam Type A value list.
+ * @brief Compares a handle with the null object.
+ * @tparam Args Scope of the handle.
+ * @param lhs A valid handle.
+ * @param rhs A null object yet to be converted.
+ * @return False if the two elements differ, true otherwise.
  */
-template<typename Type>
-using value_list_unique_t = typename value_list_unique<Type>::type;
+template<typename... Args>
+[[nodiscard]] constexpr bool operator==(const basic_handle<Args...> &lhs, const null_t rhs) noexcept {
+    return (lhs.entity() == rhs);
+}
 
 /**
- * @brief Provides the member constant `value` to true if a value list contains
- * a given value, false otherwise.
- * @tparam List Value list.
- * @tparam Value Value to look for.
+ * @brief Compares a handle with the null object.
+ * @tparam Args Scope of the handle.
+ * @param lhs A null object yet to be converted.
+ * @param rhs A valid handle.
+ * @return False if the two elements differ, true otherwise.
  */
-template<typename List, auto Value>
-struct value_list_contains;
+template<typename... Args>
+[[nodiscard]] constexpr bool operator==(const null_t lhs, const basic_handle<Args...> &rhs) noexcept {
+    return (rhs == lhs);
+}
 
 /**
- * @copybrief value_list_contains
- * @tparam Value Values provided by the value list.
- * @tparam Other Value to look for.
+ * @brief Compares a handle with the null object.
+ * @tparam Args Scope of the handle.
+ * @param lhs A valid handle.
+ * @param rhs A null object yet to be converted.
+ * @return True if the two elements differ, false otherwise.
  */
-template<auto... Value, auto Other>
-struct value_list_contains<value_list<Value...>, Other>
-    : std::bool_constant<((Value == Other) || ...)> {};
+template<typename... Args>
+[[nodiscard]] constexpr bool operator!=(const basic_handle<Args...> &lhs, const null_t rhs) noexcept {
+    return (lhs.entity() != rhs);
+}
 
 /**
- * @brief Helper variable template.
- * @tparam List Value list.
- * @tparam Value Value to look for.
+ * @brief Compares a handle with the null object.
+ * @tparam Args Scope of the handle.
+ * @param lhs A null object yet to be converted.
+ * @param rhs A valid handle.
+ * @return True if the two elements differ, false otherwise.
  */
-template<typename List, auto Value>
-inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::value;
+template<typename... Args>
+[[nodiscard]] constexpr bool operator!=(const null_t lhs, const basic_handle<Args...> &rhs) noexcept {
+    return (rhs != lhs);
+}
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-class value_list_diff;
+} // namespace entt
 
-/**
- * @brief Computes the difference between two value lists.
- * @tparam Value Values provided by the first value list.
- * @tparam Other Values provided by the second value list.
- */
-template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
+#endif
 
-public:
-    /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
-};
+// #include "entity/helper.hpp"
+#ifndef ENTT_ENTITY_HELPER_HPP
+#define ENTT_ENTITY_HELPER_HPP
 
-/**
- * @brief Helper type.
- * @tparam List Value lists between which to compute the difference.
- */
-template<typename... List>
-using value_list_diff_t = typename value_list_diff<List...>::type;
+#include <memory>
+#include <type_traits>
+#include <utility>
+// #include "../core/fwd.hpp"
 
-/*! @brief Same as std::is_invocable, but with tuples. */
-template<typename, typename>
-struct is_applicable: std::false_type {};
+// #include "../core/type_traits.hpp"
 
-/**
- * @copybrief is_applicable
- * @tparam Func A valid function type.
- * @tparam Tuple Tuple-like type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Func, template<typename...> class Tuple, typename... Args>
-struct is_applicable<Func, Tuple<Args...>>: std::is_invocable<Func, Args...> {};
+// #include "component.hpp"
+#ifndef ENTT_ENTITY_COMPONENT_HPP
+#define ENTT_ENTITY_COMPONENT_HPP
 
-/**
- * @copybrief is_applicable
- * @tparam Func A valid function type.
- * @tparam Tuple Tuple-like type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Func, template<typename...> class Tuple, typename... Args>
-struct is_applicable<Func, const Tuple<Args...>>: std::is_invocable<Func, Args...> {};
+#include <cstddef>
+#include <type_traits>
+// #include "../config/config.h"
 
-/**
- * @brief Helper variable template.
- * @tparam Func A valid function type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Func, typename Args>
-inline constexpr bool is_applicable_v = is_applicable<Func, Args>::value;
+// #include "fwd.hpp"
 
-/*! @brief Same as std::is_invocable_r, but with tuples for arguments. */
-template<typename, typename, typename>
-struct is_applicable_r: std::false_type {};
 
-/**
- * @copybrief is_applicable_r
- * @tparam Ret The type to which the return type of the function should be
- * convertible.
- * @tparam Func A valid function type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Ret, typename Func, typename... Args>
-struct is_applicable_r<Ret, Func, std::tuple<Args...>>: std::is_invocable_r<Ret, Func, Args...> {};
+namespace entt {
 
-/**
- * @brief Helper variable template.
- * @tparam Ret The type to which the return type of the function should be
- * convertible.
- * @tparam Func A valid function type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Ret, typename Func, typename Args>
-inline constexpr bool is_applicable_r_v = is_applicable_r<Ret, Func, Args>::value;
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-/**
- * @brief Provides the member constant `value` to true if a given type is
- * complete, false otherwise.
- * @tparam Type The type to test.
- */
 template<typename Type, typename = void>
-struct is_complete: std::false_type {};
+struct in_place_delete: std::bool_constant<!(std::is_move_constructible_v<Type> && std::is_move_assignable_v<Type>)> {};
 
-/*! @copydoc is_complete */
-template<typename Type>
-struct is_complete<Type, std::void_t<decltype(sizeof(Type))>>: std::true_type {};
+template<>
+struct in_place_delete<void>: std::false_type {};
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
 template<typename Type>
-inline constexpr bool is_complete_v = is_complete<Type>::value;
+struct in_place_delete<Type, std::enable_if_t<Type::in_place_delete>>
+    : std::true_type {};
 
-/**
- * @brief Provides the member constant `value` to true if a given type is an
- * iterator, false otherwise.
- * @tparam Type The type to test.
- */
 template<typename Type, typename = void>
-struct is_iterator: std::false_type {};
-
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+struct page_size: std::integral_constant<std::size_t, !std::is_empty_v<ENTT_ETO_TYPE(Type)> * ENTT_PACKED_PAGE> {};
 
-template<typename, typename = void>
-struct has_iterator_category: std::false_type {};
+template<>
+struct page_size<void>: std::integral_constant<std::size_t, 0u> {};
 
 template<typename Type>
-struct has_iterator_category<Type, std::void_t<typename std::iterator_traits<Type>::iterator_category>>: std::true_type {};
+struct page_size<Type, std::void_t<decltype(Type::page_size)>>
+    : std::integral_constant<std::size_t, Type::page_size> {};
 
 } // namespace internal
 /*! @endcond */
 
-/*! @copydoc is_iterator */
-template<typename Type>
-struct is_iterator<Type, std::enable_if_t<!std::is_void_v<std::remove_cv_t<std::remove_pointer_t<Type>>>>>
-    : internal::has_iterator_category<Type> {};
-
 /**
- * @brief Helper variable template.
- * @tparam Type The type to test.
+ * @brief Common way to access various properties of components.
+ * @tparam Type Type of component.
  */
-template<typename Type>
-inline constexpr bool is_iterator_v = is_iterator<Type>::value;
+template<typename Type, typename = void>
+struct component_traits {
+    static_assert(std::is_same_v<std::decay_t<Type>, Type>, "Unsupported type");
 
-/**
- * @brief Provides the member constant `value` to true if a given type is both
- * an empty and non-final class, false otherwise.
- * @tparam Type The type to test
- */
-template<typename Type>
-struct is_ebco_eligible
-    : std::bool_constant<std::is_empty_v<Type> && !std::is_final_v<Type>> {};
+    /*! @brief Component type. */
+    using type = Type;
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_ebco_eligible_v = is_ebco_eligible<Type>::value;
+    /*! @brief Pointer stability, default is `false`. */
+    static constexpr bool in_place_delete = internal::in_place_delete<Type>::value;
+    /*! @brief Page size, default is `ENTT_PACKED_PAGE` for non-empty types. */
+    static constexpr std::size_t page_size = internal::page_size<Type>::value;
+};
 
-/**
- * @brief Provides the member constant `value` to true if `Type::is_transparent`
- * is valid and denotes a type, false otherwise.
- * @tparam Type The type to test.
- */
-template<typename Type, typename = void>
-struct is_transparent: std::false_type {};
+} // namespace entt
 
-/*! @copydoc is_transparent */
-template<typename Type>
-struct is_transparent<Type, std::void_t<typename Type::is_transparent>>: std::true_type {};
+#endif
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_transparent_v = is_transparent<Type>::value;
+// #include "fwd.hpp"
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+// #include "group.hpp"
+#ifndef ENTT_ENTITY_GROUP_HPP
+#define ENTT_ENTITY_GROUP_HPP
 
-template<typename, typename = void>
-struct has_tuple_size_value: std::false_type {};
+#include <array>
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
 
-template<typename Type>
-struct has_tuple_size_value<Type, std::void_t<decltype(std::tuple_size<const Type>::value)>>: std::true_type {};
+// #include "../core/algorithm.hpp"
 
-template<typename, typename = void>
-struct has_value_type: std::false_type {};
+// #include "../core/fwd.hpp"
 
-template<typename Type>
-struct has_value_type<Type, std::void_t<typename Type::value_type>>: std::true_type {};
+// #include "../core/iterator.hpp"
 
-template<typename>
-[[nodiscard]] constexpr bool dispatch_is_equality_comparable();
+// #include "../core/type_info.hpp"
 
-template<typename Type, std::size_t... Index>
-[[nodiscard]] constexpr bool unpack_maybe_equality_comparable(std::index_sequence<Index...>) {
-    return (dispatch_is_equality_comparable<std::tuple_element_t<Index, Type>>() && ...);
-}
+// #include "../core/type_traits.hpp"
 
-template<typename>
-[[nodiscard]] constexpr bool maybe_equality_comparable(char) {
-    return false;
-}
+// #include "entity.hpp"
 
-template<typename Type>
-[[nodiscard]] constexpr auto maybe_equality_comparable(int) -> decltype(std::declval<Type>() == std::declval<Type>()) {
-    return true;
-}
+// #include "fwd.hpp"
 
-template<typename Type>
-[[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
-    if constexpr(std::is_array_v<Type>) {
-        return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
-            return maybe_equality_comparable<Type>(0);
-        } else {
-            return false;
-        }
-    } else if constexpr(is_complete_v<std::tuple_size<std::remove_cv_t<Type>>>) {
-        if constexpr(has_tuple_size_value<Type>::value) {
-            return maybe_equality_comparable<Type>(0) && unpack_maybe_equality_comparable<Type>(std::make_index_sequence<std::tuple_size<Type>::value>{});
+
+namespace entt {
+
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+template<typename, typename, typename>
+class extended_group_iterator;
+
+template<typename It, typename... Owned, typename... Get>
+class extended_group_iterator<It, owned_t<Owned...>, get_t<Get...>> {
+    template<typename Type>
+    [[nodiscard]] auto index_to_element([[maybe_unused]] Type &cpool) const {
+        if constexpr(std::is_void_v<typename Type::value_type>) {
+            return std::make_tuple();
         } else {
-            return maybe_equality_comparable<Type>(0);
+            return std::forward_as_tuple(cpool.rbegin()[it.index()]);
         }
-    } else {
-        return maybe_equality_comparable<Type>(0);
     }
-}
 
-} // namespace internal
-/*! @endcond */
+public:
+    using iterator_type = It;
+    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Owned>().get_as_tuple({})..., std::declval<Get>().get_as_tuple({})...));
+    using pointer = input_iterator_pointer<value_type>;
+    using reference = value_type;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::input_iterator_tag;
+    using iterator_concept = std::forward_iterator_tag;
 
-/**
- * @brief Provides the member constant `value` to true if a given type is
- * equality comparable, false otherwise.
- * @tparam Type The type to test.
- */
-template<typename Type>
-struct is_equality_comparable: std::bool_constant<internal::dispatch_is_equality_comparable<Type>()> {};
+    constexpr extended_group_iterator()
+        : it{},
+          pools{} {}
 
-/*! @copydoc is_equality_comparable */
-template<typename Type>
-struct is_equality_comparable<const Type>: is_equality_comparable<Type> {};
+    extended_group_iterator(iterator_type from, std::tuple<Owned *..., Get *...> cpools)
+        : it{from},
+          pools{std::move(cpools)} {}
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_equality_comparable_v = is_equality_comparable<Type>::value;
+    extended_group_iterator &operator++() noexcept {
+        return ++it, *this;
+    }
 
-/**
- * @brief Transcribes the constness of a type to another type.
- * @tparam To The type to which to transcribe the constness.
- * @tparam From The type from which to transcribe the constness.
- */
-template<typename To, typename From>
-struct constness_as {
-    /*! @brief The type resulting from the transcription of the constness. */
-    using type = std::remove_const_t<To>;
+    extended_group_iterator operator++(int) noexcept {
+        extended_group_iterator orig = *this;
+        return ++(*this), orig;
+    }
+
+    [[nodiscard]] reference operator*() const noexcept {
+        return std::tuple_cat(std::make_tuple(*it), index_to_element(*std::get<Owned *>(pools))..., std::get<Get *>(pools)->get_as_tuple(*it)...);
+    }
+
+    [[nodiscard]] pointer operator->() const noexcept {
+        return operator*();
+    }
+
+    [[nodiscard]] constexpr iterator_type base() const noexcept {
+        return it;
+    }
+
+    template<typename... Lhs, typename... Rhs>
+    friend constexpr bool operator==(const extended_group_iterator<Lhs...> &, const extended_group_iterator<Rhs...> &) noexcept;
+
+private:
+    It it;
+    std::tuple<Owned *..., Get *...> pools;
 };
 
-/*! @copydoc constness_as */
-template<typename To, typename From>
-struct constness_as<To, const From> {
-    /*! @brief The type resulting from the transcription of the constness. */
-    using type = const To;
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator==(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
+    return lhs.it == rhs.it;
+}
+
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator!=(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
+    return !(lhs == rhs);
+}
+
+struct group_descriptor {
+    using size_type = std::size_t;
+    virtual ~group_descriptor() = default;
+    [[nodiscard]] virtual bool owned(const id_type) const noexcept {
+        return false;
+    }
 };
 
-/**
- * @brief Alias template to facilitate the transcription of the constness.
- * @tparam To The type to which to transcribe the constness.
- * @tparam From The type from which to transcribe the constness.
- */
-template<typename To, typename From>
-using constness_as_t = typename constness_as<To, From>::type;
+template<typename Type, std::size_t Owned, std::size_t Get, std::size_t Exclude>
+class group_handler final: public group_descriptor {
+    using entity_type = typename Type::entity_type;
 
-/**
- * @brief Extracts the class of a non-static member object or function.
- * @tparam Member A pointer to a non-static member object or function.
- */
-template<typename Member>
-class member_class {
-    static_assert(std::is_member_pointer_v<Member>, "Invalid pointer type to non-static member object or function");
+    void swap_elements(const std::size_t pos, const entity_type entt) {
+        for(size_type next{}; next < Owned; ++next) {
+            pools[next]->swap_elements((*pools[next])[pos], entt);
+        }
+    }
 
-    template<typename Class, typename Ret, typename... Args>
-    static Class *clazz(Ret (Class::*)(Args...));
+    void push_on_construct(const entity_type entt) {
+        if(std::apply([entt, pos = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < pos) && (other->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
+            swap_elements(len++, entt);
+        }
+    }
 
-    template<typename Class, typename Ret, typename... Args>
-    static Class *clazz(Ret (Class::*)(Args...) const);
+    void push_on_destroy(const entity_type entt) {
+        if(std::apply([entt, pos = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < pos) && (other->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
+            swap_elements(len++, entt);
+        }
+    }
 
-    template<typename Class, typename Type>
-    static Class *clazz(Type Class::*);
+    void remove_if(const entity_type entt) {
+        if(pools[0u]->contains(entt) && (pools[0u]->index(entt) < len)) {
+            swap_elements(--len, entt);
+        }
+    }
+
+    void common_setup() {
+        // we cannot iterate backwards because we want to leave behind valid entities in case of owned types
+        for(auto first = pools[0u]->rbegin(), last = first + pools[0u]->size(); first != last; ++first) {
+            push_on_construct(*first);
+        }
+    }
 
 public:
-    /*! @brief The class of the given non-static member object or function. */
-    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
-};
+    using common_type = Type;
+    using size_type = typename Type::size_type;
 
-/**
- * @brief Helper type.
- * @tparam Member A pointer to a non-static member object or function.
- */
-template<typename Member>
-using member_class_t = typename member_class<Member>::type;
+    template<typename... OGType, typename... EType>
+    group_handler(std::tuple<OGType &...> ogpool, std::tuple<EType &...> epool)
+        : pools{std::apply([](auto &&...cpool) { return std::array<common_type *, (Owned + Get)>{&cpool...}; }, ogpool)},
+          filter{std::apply([](auto &&...cpool) { return std::array<common_type *, Exclude>{&cpool...}; }, epool)} {
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::push_on_construct>(*this), cpool.on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, ogpool);
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::remove_if>(*this), cpool.on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, epool);
+        common_setup();
+    }
 
-/**
- * @brief Extracts the n-th argument of a given function or member function.
- * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
- */
-template<std::size_t Index, typename Candidate>
-class nth_argument {
-    template<typename Ret, typename... Args>
-    static constexpr type_list<Args...> pick_up(Ret (*)(Args...));
+    [[nodiscard]] bool owned(const id_type hash) const noexcept override {
+        for(size_type pos{}; pos < Owned; ++pos) {
+            if(pools[pos]->type().hash() == hash) {
+                return true;
+            }
+        }
 
-    template<typename Ret, typename Class, typename... Args>
-    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...));
+        return false;
+    }
 
-    template<typename Ret, typename Class, typename... Args>
-    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...) const);
+    [[nodiscard]] size_type length() const noexcept {
+        return len;
+    }
 
-    template<typename Type, typename Class>
-    static constexpr type_list<Type> pick_up(Type Class ::*);
+    template<std::size_t Index>
+    [[nodiscard]] common_type *storage() const noexcept {
+        if constexpr(Index < (Owned + Get)) {
+            return pools[Index];
+        } else {
+            return filter[Index - (Owned + Get)];
+        }
+    }
 
-public:
-    /*! @brief N-th argument of the given function or member function. */
-    using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
+private:
+    std::array<common_type *, (Owned + Get)> pools;
+    std::array<common_type *, Exclude> filter;
+    std::size_t len{};
 };
 
-/**
- * @brief Helper type.
- * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
- */
-template<std::size_t Index, typename Candidate>
-using nth_argument_t = typename nth_argument<Index, Candidate>::type;
+template<typename Type, std::size_t Get, std::size_t Exclude>
+class group_handler<Type, 0u, Get, Exclude> final: public group_descriptor {
+    using entity_type = typename Type::entity_type;
 
-} // namespace entt
+    void push_on_construct(const entity_type entt) {
+        if(!elem.contains(entt)
+           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
+            elem.push(entt);
+        }
+    }
 
-template<typename... Type>
-struct std::tuple_size<entt::type_list<Type...>>: std::integral_constant<std::size_t, entt::type_list<Type...>::size> {};
+    void push_on_destroy(const entity_type entt) {
+        if(!elem.contains(entt)
+           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
+           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
+            elem.push(entt);
+        }
+    }
 
-template<std::size_t Index, typename... Type>
-struct std::tuple_element<Index, entt::type_list<Type...>>: entt::type_list_element<Index, entt::type_list<Type...>> {};
+    void remove_if(const entity_type entt) {
+        elem.remove(entt);
+    }
 
-template<auto... Value>
-struct std::tuple_size<entt::value_list<Value...>>: std::integral_constant<std::size_t, entt::value_list<Value...>::size> {};
+    void common_setup() {
+        for(const auto entity: *pools[0u]) {
+            push_on_construct(entity);
+        }
+    }
 
-template<std::size_t Index, auto... Value>
-struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_element<Index, entt::value_list<Value...>> {};
+public:
+    using common_type = Type;
 
-#endif
+    template<typename Allocator, typename... GType, typename... EType>
+    group_handler(const Allocator &allocator, std::tuple<GType &...> gpool, std::tuple<EType &...> epool)
+        : pools{std::apply([](auto &&...cpool) { return std::array<common_type *, Get>{&cpool...}; }, gpool)},
+          filter{std::apply([](auto &&...cpool) { return std::array<common_type *, Exclude>{&cpool...}; }, epool)},
+          elem{allocator} {
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::push_on_construct>(*this), cpool.on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, gpool);
+        std::apply([this](auto &...cpool) { ((cpool.on_construct().template connect<&group_handler::remove_if>(*this), cpool.on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, epool);
+        common_setup();
+    }
 
+    [[nodiscard]] common_type &handle() noexcept {
+        return elem;
+    }
 
-namespace entt {
+    [[nodiscard]] const common_type &handle() const noexcept {
+        return elem;
+    }
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+    template<std::size_t Index>
+    [[nodiscard]] common_type *storage() const noexcept {
+        if constexpr(Index < Get) {
+            return pools[Index];
+        } else {
+            return filter[Index - Get];
+        }
+    }
 
-enum class any_operation : std::uint8_t {
-    copy,
-    move,
-    transfer,
-    assign,
-    destroy,
-    compare,
-    get
+private:
+    std::array<common_type *, Get> pools;
+    std::array<common_type *, Exclude> filter;
+    common_type elem;
 };
 
 } // namespace internal
 /*! @endcond */
 
-/*! @brief Possible modes of an any object. */
-enum class any_policy : std::uint8_t {
-    /*! @brief Default mode, the object owns the contained element. */
-    owner,
-    /*! @brief Aliasing mode, the object _points_ to a non-const element. */
-    ref,
-    /*! @brief Const aliasing mode, the object _points_ to a const element. */
-    cref
-};
-
 /**
- * @brief A SBO friendly, type-safe container for single values of any type.
- * @tparam Len Size of the storage reserved for the small buffer optimization.
- * @tparam Align Optional alignment requirement.
+ * @brief Group.
+ *
+ * Primary template isn't defined on purpose. All the specializations give a
+ * compile-time error, but for a few reasonable cases.
  */
-template<std::size_t Len, std::size_t Align>
-class basic_any {
-    using operation = internal::any_operation;
-    using vtable_type = const void *(const operation, const basic_any &, const void *);
-
-    struct storage_type {
-        alignas(Align) std::byte data[Len + !Len];
-    };
-
-    template<typename Type>
-    static constexpr bool in_situ = Len && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
-
-    template<typename Type>
-    static const void *basic_vtable(const operation op, const basic_any &value, const void *other) {
-        static_assert(!std::is_void_v<Type> && std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");
-        const Type *element = nullptr;
-
-        if constexpr(in_situ<Type>) {
-            element = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
-        } else {
-            element = static_cast<const Type *>(value.instance);
-        }
+template<typename, typename, typename>
+class basic_group;
 
-        switch(op) {
-        case operation::copy:
-            if constexpr(std::is_copy_constructible_v<Type>) {
-                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*element);
-            }
-            break;
-        case operation::move:
-            if constexpr(in_situ<Type>) {
-                if(value.mode == any_policy::owner) {
-                    return new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(element))};
-                }
-            }
-
-            return (static_cast<basic_any *>(const_cast<void *>(other))->instance = std::exchange(const_cast<basic_any &>(value).instance, nullptr));
-        case operation::transfer:
-            if constexpr(std::is_move_assignable_v<Type>) {
-                *const_cast<Type *>(element) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
-                return other;
-            }
-            [[fallthrough]];
-        case operation::assign:
-            if constexpr(std::is_copy_assignable_v<Type>) {
-                *const_cast<Type *>(element) = *static_cast<const Type *>(other);
-                return other;
-            }
-            break;
-        case operation::destroy:
-            if constexpr(in_situ<Type>) {
-                element->~Type();
-            } else if constexpr(std::is_array_v<Type>) {
-                delete[] element;
-            } else {
-                delete element;
-            }
-            break;
-        case operation::compare:
-            if constexpr(!std::is_function_v<Type> && !std::is_array_v<Type> && is_equality_comparable_v<Type>) {
-                return *element == *static_cast<const Type *>(other) ? other : nullptr;
-            } else {
-                return (element == other) ? other : nullptr;
-            }
-        case operation::get:
-            return element;
-        }
-
-        return nullptr;
-    }
-
-    template<typename Type, typename... Args>
-    void initialize([[maybe_unused]] Args &&...args) {
-        info = &type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
+/**
+ * @brief Non-owning group.
+ *
+ * A non-owning group returns all entities and only the entities that are at
+ * least in the given storage. Moreover, it's guaranteed that the entity list is
+ * tightly packed in memory for fast iterations.
+ *
+ * @b Important
+ *
+ * Iterators aren't invalidated if:
+ *
+ * * New elements are added to the storage.
+ * * The entity currently pointed is modified (for example, elements are added
+ *   or removed from it).
+ * * The entity currently pointed is destroyed.
+ *
+ * In all other cases, modifying the pools iterated by the group in any way
+ * invalidates all the iterators.
+ *
+ * @tparam Get Types of storage _observed_ by the group.
+ * @tparam Exclude Types of storage used to filter the group.
+ */
+template<typename... Get, typename... Exclude>
+class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
+    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
+    using underlying_type = typename base_type::entity_type;
 
-        if constexpr(!std::is_void_v<Type>) {
-            vtable = basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>;
+    template<typename Type>
+    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::element_type..., typename Exclude::element_type...>>;
 
-            if constexpr(std::is_lvalue_reference_v<Type>) {
-                static_assert((std::is_lvalue_reference_v<Args> && ...) && (sizeof...(Args) == 1u), "Invalid arguments");
-                mode = std::is_const_v<std::remove_reference_t<Type>> ? any_policy::cref : any_policy::ref;
-                instance = (std::addressof(args), ...);
-            } else if constexpr(in_situ<std::remove_cv_t<std::remove_reference_t<Type>>>) {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
-                } else {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
-                }
-            } else {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
-                } else {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
-                }
-            }
-        }
+    template<std::size_t... Index>
+    [[nodiscard]] auto pools_for(std::index_sequence<Index...>) const noexcept {
+        using return_type = std::tuple<Get *...>;
+        return descriptor ? return_type{static_cast<Get *>(descriptor->template storage<Index>())...} : return_type{};
     }
 
-    basic_any(const basic_any &other, const any_policy pol) noexcept
-        : instance{other.data()},
-          info{other.info},
-          vtable{other.vtable},
-          mode{pol} {}
-
 public:
-    /*! @brief Size of the internal storage. */
-    static constexpr auto length = Len;
-    /*! @brief Alignment requirement. */
-    static constexpr auto alignment = Align;
-
-    /*! @brief Default constructor. */
-    constexpr basic_any() noexcept
-        : basic_any{std::in_place_type<void>} {}
+    /*! @brief Underlying entity identifier. */
+    using entity_type = underlying_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Common type among all storage types. */
+    using common_type = base_type;
+    /*! @brief Random access iterator type. */
+    using iterator = typename common_type::iterator;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = typename common_type::reverse_iterator;
+    /*! @brief Iterable group type. */
+    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<>, get_t<Get...>>>;
+    /*! @brief Group handler type. */
+    using handler = internal::group_handler<common_type, 0u, sizeof...(Get), sizeof...(Exclude)>;
 
     /**
-     * @brief Constructs a wrapper by directly initializing the new object.
-     * @tparam Type Type of object to use to initialize the wrapper.
-     * @tparam Args Types of arguments to use to construct the new instance.
-     * @param args Parameters to use to construct the instance.
+     * @brief Group opaque identifier.
+     * @return Group opaque identifier.
      */
-    template<typename Type, typename... Args>
-    explicit basic_any(std::in_place_type_t<Type>, Args &&...args)
-        : instance{},
-          info{},
-          vtable{},
-          mode{any_policy::owner} {
-        initialize<Type>(std::forward<Args>(args)...);
+    static id_type group_id() noexcept {
+        return type_hash<basic_group<owned_t<>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>>::value();
     }
 
+    /*! @brief Default constructor to use to create empty, invalid groups. */
+    basic_group() noexcept
+        : descriptor{} {}
+
     /**
-     * @brief Constructs a wrapper from a given value.
-     * @tparam Type Type of object to use to initialize the wrapper.
-     * @param value An instance of an object to use to initialize the wrapper.
+     * @brief Constructs a group from a set of storage classes.
+     * @param ref A reference to a group handler.
      */
-    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
-    basic_any(Type &&value)
-        : basic_any{std::in_place_type<std::decay_t<Type>>, std::forward<Type>(value)} {}
+    basic_group(handler &ref) noexcept
+        : descriptor{&ref} {}
 
     /**
-     * @brief Copy constructor.
-     * @param other The instance to copy from.
+     * @brief Returns the leading storage of a group.
+     * @return The leading storage of the group.
      */
-    basic_any(const basic_any &other)
-        : basic_any{} {
-        if(other.vtable) {
-            other.vtable(operation::copy, other, this);
-        }
+    [[nodiscard]] const common_type &handle() const noexcept {
+        return descriptor->handle();
     }
 
     /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
      */
-    basic_any(basic_any &&other) noexcept
-        : instance{},
-          info{other.info},
-          vtable{other.vtable},
-          mode{other.mode} {
-        if(other.vtable) {
-            other.vtable(operation::move, other, this);
-        }
+    template<typename Type>
+    [[nodiscard]] auto *storage() const noexcept {
+        return storage<index_of<Type>>();
     }
 
-    /*! @brief Frees the internal storage, whatever it means. */
-    ~basic_any() {
-        if(vtable && (mode == any_policy::owner)) {
-            vtable(operation::destroy, *this, nullptr);
-        }
+    /**
+     * @brief Returns the storage for a given index, if any.
+     * @tparam Index Index of the storage to return.
+     * @return The storage for the given index.
+     */
+    template<std::size_t Index>
+    [[nodiscard]] auto *storage() const noexcept {
+        using type = type_list_element_t<Index, type_list<Get..., Exclude...>>;
+        return *this ? static_cast<type *>(descriptor->template storage<Index>()) : nullptr;
     }
 
     /**
-     * @brief Copy assignment operator.
-     * @param other The instance to copy from.
-     * @return This any object.
+     * @brief Returns the number of entities that are part of the group.
+     * @return Number of entities that are part of the group.
      */
-    basic_any &operator=(const basic_any &other) {
-        reset();
-
-        if(other.vtable) {
-            other.vtable(operation::copy, other, this);
-        }
-
-        return *this;
+    [[nodiscard]] size_type size() const noexcept {
+        return *this ? handle().size() : size_type{};
     }
 
     /**
-     * @brief Move assignment operator.
-     * @param other The instance to move from.
-     * @return This any object.
+     * @brief Returns the number of elements that a group has currently
+     * allocated space for.
+     * @return Capacity of the group.
      */
-    basic_any &operator=(basic_any &&other) noexcept {
-        reset();
+    [[nodiscard]] size_type capacity() const noexcept {
+        return *this ? handle().capacity() : size_type{};
+    }
 
-        if(other.vtable) {
-            other.vtable(operation::move, other, this);
-            info = other.info;
-            vtable = other.vtable;
-            mode = other.mode;
+    /*! @brief Requests the removal of unused capacity. */
+    void shrink_to_fit() {
+        if(*this) {
+            descriptor->handle().shrink_to_fit();
         }
-
-        return *this;
     }
 
     /**
-     * @brief Value assignment operator.
-     * @tparam Type Type of object to use to initialize the wrapper.
-     * @param value An instance of an object to use to initialize the wrapper.
-     * @return This any object.
+     * @brief Checks whether a group is empty.
+     * @return True if the group is empty, false otherwise.
      */
-    template<typename Type>
-    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>, basic_any &>
-    operator=(Type &&value) {
-        emplace<std::decay_t<Type>>(std::forward<Type>(value));
-        return *this;
+    [[nodiscard]] bool empty() const noexcept {
+        return !*this || handle().empty();
     }
 
     /**
-     * @brief Returns the object type if any, `type_id<void>()` otherwise.
-     * @return The object type if any, `type_id<void>()` otherwise.
+     * @brief Returns an iterator to the first entity of the group.
+     *
+     * If the group is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first entity of the group.
      */
-    [[nodiscard]] const type_info &type() const noexcept {
-        return *info;
+    [[nodiscard]] iterator begin() const noexcept {
+        return *this ? handle().begin() : iterator{};
     }
 
     /**
-     * @brief Returns an opaque pointer to the contained instance.
-     * @return An opaque pointer the contained instance, if any.
+     * @brief Returns an iterator that is past the last entity of the group.
+     * @return An iterator to the entity following the last entity of the
+     * group.
      */
-    [[nodiscard]] const void *data() const noexcept {
-        return vtable ? vtable(operation::get, *this, nullptr) : nullptr;
+    [[nodiscard]] iterator end() const noexcept {
+        return *this ? handle().end() : iterator{};
     }
 
     /**
-     * @brief Returns an opaque pointer to the contained instance.
-     * @param req Expected type.
-     * @return An opaque pointer the contained instance, if any.
+     * @brief Returns an iterator to the first entity of the reversed group.
+     *
+     * If the group is empty, the returned iterator will be equal to `rend()`.
+     *
+     * @return An iterator to the first entity of the reversed group.
      */
-    [[nodiscard]] const void *data(const type_info &req) const noexcept {
-        return *info == req ? data() : nullptr;
+    [[nodiscard]] reverse_iterator rbegin() const noexcept {
+        return *this ? handle().rbegin() : reverse_iterator{};
     }
 
     /**
-     * @brief Returns an opaque pointer to the contained instance.
-     * @return An opaque pointer the contained instance, if any.
+     * @brief Returns an iterator that is past the last entity of the reversed
+     * group.
+     * @return An iterator to the entity following the last entity of the
+     * reversed group.
      */
-    [[nodiscard]] void *data() noexcept {
-        return mode == any_policy::cref ? nullptr : const_cast<void *>(std::as_const(*this).data());
+    [[nodiscard]] reverse_iterator rend() const noexcept {
+        return *this ? handle().rend() : reverse_iterator{};
     }
 
     /**
-     * @brief Returns an opaque pointer to the contained instance.
-     * @param req Expected type.
-     * @return An opaque pointer the contained instance, if any.
+     * @brief Returns the first entity of the group, if any.
+     * @return The first entity of the group if one exists, the null entity
+     * otherwise.
      */
-    [[nodiscard]] void *data(const type_info &req) noexcept {
-        return mode == any_policy::cref ? nullptr : const_cast<void *>(std::as_const(*this).data(req));
+    [[nodiscard]] entity_type front() const noexcept {
+        const auto it = begin();
+        return it != end() ? *it : null;
     }
 
     /**
-     * @brief Replaces the contained object by creating a new instance directly.
-     * @tparam Type Type of object to use to initialize the wrapper.
-     * @tparam Args Types of arguments to use to construct the new instance.
-     * @param args Parameters to use to construct the instance.
+     * @brief Returns the last entity of the group, if any.
+     * @return The last entity of the group if one exists, the null entity
+     * otherwise.
      */
-    template<typename Type, typename... Args>
-    void emplace(Args &&...args) {
-        reset();
-        initialize<Type>(std::forward<Args>(args)...);
+    [[nodiscard]] entity_type back() const noexcept {
+        const auto it = rbegin();
+        return it != rend() ? *it : null;
     }
 
     /**
-     * @brief Assigns a value to the contained object without replacing it.
-     * @param other The value to assign to the contained object.
-     * @return True in case of success, false otherwise.
+     * @brief Finds an entity.
+     * @param entt A valid identifier.
+     * @return An iterator to the given entity if it's found, past the end
+     * iterator otherwise.
      */
-    bool assign(const basic_any &other) {
-        if(vtable && mode != any_policy::cref && *info == *other.info) {
-            return (vtable(operation::assign, *this, other.data()) != nullptr);
-        }
-
-        return false;
+    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
+        return *this ? handle().find(entt) : iterator{};
     }
 
-    /*! @copydoc assign */
-    bool assign(basic_any &&other) {
-        if(vtable && mode != any_policy::cref && *info == *other.info) {
-            if(auto *val = other.data(); val) {
-                return (vtable(operation::transfer, *this, val) != nullptr);
-            } else {
-                return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
-            }
-        }
-
-        return false;
+    /**
+     * @brief Returns the identifier that occupies the given position.
+     * @param pos Position of the element to return.
+     * @return The identifier that occupies the given position.
+     */
+    [[nodiscard]] entity_type operator[](const size_type pos) const {
+        return begin()[pos];
     }
 
-    /*! @brief Destroys contained object */
-    void reset() {
-        if(vtable && (mode == any_policy::owner)) {
-            vtable(operation::destroy, *this, nullptr);
-        }
+    /**
+     * @brief Checks if a group is properly initialized.
+     * @return True if the group is properly initialized, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return descriptor != nullptr;
+    }
 
-        // unnecessary but it helps to detect nasty bugs
-        ENTT_ASSERT((instance = nullptr) == nullptr, "");
-        info = &type_id<void>();
-        vtable = nullptr;
-        mode = any_policy::owner;
+    /**
+     * @brief Checks if a group contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the group contains the given entity, false otherwise.
+     */
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        return *this && handle().contains(entt);
     }
 
     /**
-     * @brief Returns false if a wrapper is empty, true otherwise.
-     * @return False if the wrapper is empty, true otherwise.
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Type Type of the element to get.
+     * @tparam Other Other types of elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
      */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return vtable != nullptr;
+    template<typename Type, typename... Other>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        return get<index_of<Type>, index_of<Other>...>(entt);
     }
 
     /**
-     * @brief Checks if two wrappers differ in their content.
-     * @param other Wrapper with which to compare.
-     * @return False if the two objects differ in their content, true otherwise.
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Index Indexes of the elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
      */
-    [[nodiscard]] bool operator==(const basic_any &other) const noexcept {
-        if(vtable && *info == *other.info) {
-            return (vtable(operation::compare, *this, other.data()) != nullptr);
-        }
+    template<std::size_t... Index>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        const auto cpools = pools_for(std::index_sequence_for<Get...>{});
 
-        return (!vtable && !other.vtable);
+        if constexpr(sizeof...(Index) == 0) {
+            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
+        } else if constexpr(sizeof...(Index) == 1) {
+            return (std::get<Index>(cpools)->get(entt), ...);
+        } else {
+            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
+        }
     }
 
     /**
-     * @brief Checks if two wrappers differ in their content.
-     * @param other Wrapper with which to compare.
-     * @return True if the two objects differ in their content, false otherwise.
+     * @brief Iterates entities and elements and applies the given function
+     * object to them.
+     *
+     * The function object is invoked for each entity. It is provided with the
+     * entity itself and a set of references to non-empty elements. The
+     * _constness_ of the elements is as requested.<br/>
+     * The signature of the function must be equivalent to one of the following
+     * forms:
+     *
+     * @code{.cpp}
+     * void(const entity_type, Type &...);
+     * void(Type &...);
+     * @endcode
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @tparam Func Type of the function object to invoke.
+     * @param func A valid function object.
      */
-    [[nodiscard]] bool operator!=(const basic_any &other) const noexcept {
-        return !(*this == other);
+    template<typename Func>
+    void each(Func func) const {
+        for(const auto entt: *this) {
+            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
+                std::apply(func, std::tuple_cat(std::make_tuple(entt), get(entt)));
+            } else {
+                std::apply(func, get(entt));
+            }
+        }
     }
 
     /**
-     * @brief Aliasing constructor.
-     * @return A wrapper that shares a reference to an unmanaged object.
+     * @brief Returns an iterable object to use to _visit_ a group.
+     *
+     * The iterable object returns tuples that contain the current entity and a
+     * set of references to its non-empty elements. The _constness_ of the
+     * elements is as requested.
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @return An iterable object to use to _visit_ the group.
      */
-    [[nodiscard]] basic_any as_ref() noexcept {
-        return basic_any{*this, (mode == any_policy::cref ? any_policy::cref : any_policy::ref)};
+    [[nodiscard]] iterable each() const noexcept {
+        const auto cpools = pools_for(std::index_sequence_for<Get...>{});
+        return iterable{{begin(), cpools}, {end(), cpools}};
     }
 
-    /*! @copydoc as_ref */
-    [[nodiscard]] basic_any as_ref() const noexcept {
-        return basic_any{*this, any_policy::cref};
+    /**
+     * @brief Sort a group according to the given comparison function.
+     *
+     * The comparison function object must return `true` if the first element
+     * is _less_ than the second one, `false` otherwise. The signature of the
+     * comparison function should be equivalent to one of the following:
+     *
+     * @code{.cpp}
+     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
+     * bool(const Type &..., const Type &...);
+     * bool(const Entity, const Entity);
+     * @endcode
+     *
+     * Where `Type` are such that they are iterated by the group.<br/>
+     * Moreover, the comparison function object shall induce a
+     * _strict weak ordering_ on the values.
+     *
+     * The sort function object must offer a member function template
+     * `operator()` that accepts three arguments:
+     *
+     * * An iterator to the first element of the range to sort.
+     * * An iterator past the last element of the range to sort.
+     * * A comparison function to use to compare the elements.
+     *
+     * @tparam Type Optional type of element to compare.
+     * @tparam Other Other optional types of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
+        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Returns true if a wrapper owns its object, false otherwise.
-     * @return True if the wrapper owns its object, false otherwise.
+     * @brief Sort a group according to the given comparison function.
+     *
+     * @sa sort
+     *
+     * @tparam Index Optional indexes of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
      */
-    [[deprecated("use policy() and any_policy instead")]] [[nodiscard]] bool owner() const noexcept {
-        return (mode == any_policy::owner);
+    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
+        if(*this) {
+            if constexpr(sizeof...(Index) == 0) {
+                static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
+                descriptor->handle().sort(std::move(compare), std::move(algo), std::forward<Args>(args)...);
+            } else {
+                auto comp = [&compare, cpools = pools_for(std::index_sequence_for<Get...>{})](const entity_type lhs, const entity_type rhs) {
+                    if constexpr(sizeof...(Index) == 1) {
+                        return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
+                    } else {
+                        return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
+                    }
+                };
+
+                descriptor->handle().sort(std::move(comp), std::move(algo), std::forward<Args>(args)...);
+            }
+        }
     }
 
     /**
-     * @brief Returns the current mode of an any object.
-     * @return The current mode of the any object.
+     * @brief Sort entities according to their order in a range.
+     *
+     * The shared pool of entities and thus its order is affected by the changes
+     * to each and every pool that it tracks.
+     *
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
      */
-    [[nodiscard]] any_policy policy() const noexcept {
-        return mode;
+    template<typename It>
+    void sort_as(It first, It last) const {
+        if(*this) {
+            descriptor->handle().sort_as(first, last);
+        }
     }
 
 private:
-    union {
-        const void *instance;
-        storage_type storage;
-    };
-    const type_info *info;
-    vtable_type *vtable;
-    any_policy mode;
+    handler *descriptor;
 };
 
 /**
- * @brief Performs type-safe access to the contained object.
- * @tparam Type Type to which conversion is required.
- * @tparam Len Size of the storage reserved for the small buffer optimization.
- * @tparam Align Alignment requirement.
- * @param data Target any object.
- * @return The element converted to the requested type.
- */
-template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(const basic_any<Len, Align> &data) noexcept {
-    const auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
-    ENTT_ASSERT(instance, "Invalid instance");
-    return static_cast<Type>(*instance);
-}
-
-/*! @copydoc any_cast */
-template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &data) noexcept {
-    // forces const on non-reference types to make them work also with wrappers for const references
-    auto *const instance = any_cast<std::remove_reference_t<const Type>>(&data);
-    ENTT_ASSERT(instance, "Invalid instance");
-    return static_cast<Type>(*instance);
-}
+ * @brief Owning group.
+ *
+ * Owning groups returns all entities and only the entities that are at
+ * least in the given storage. Moreover:
+ *
+ * * It's guaranteed that the entity list is tightly packed in memory for fast
+ *   iterations.
+ * * It's guaranteed that all elements in the owned storage are tightly packed
+ *   in memory for even faster iterations and to allow direct access.
+ * * They stay true to the order of the owned storage and all instances have the
+ *   same order in memory.
+ *
+ * The more types of storage are owned, the faster it is to iterate a group.
+ *
+ * @b Important
+ *
+ * Iterators aren't invalidated if:
+ *
+ * * New elements are added to the storage.
+ * * The entity currently pointed is modified (for example, elements are added
+ *   or removed from it).
+ * * The entity currently pointed is destroyed.
+ *
+ * In all other cases, modifying the pools iterated by the group in any way
+ * invalidates all the iterators.
+ *
+ * @tparam Owned Types of storage _owned_ by the group.
+ * @tparam Get Types of storage _observed_ by the group.
+ * @tparam Exclude Types of storage used to filter the group.
+ */
+template<typename... Owned, typename... Get, typename... Exclude>
+class basic_group<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> {
+    static_assert(((Owned::storage_policy != deletion_policy::in_place) && ...), "Groups do not support in-place delete");
 
-/*! @copydoc any_cast */
-template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &&data) noexcept {
-    if constexpr(std::is_copy_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>) {
-        if(auto *const instance = any_cast<std::remove_reference_t<Type>>(&data); instance) {
-            return static_cast<Type>(std::move(*instance));
+    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
+    using underlying_type = typename base_type::entity_type;
+
+    template<typename Type>
+    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Owned::element_type..., typename Get::element_type..., typename Exclude::element_type...>>;
+
+    template<std::size_t... Index, std::size_t... Other>
+    [[nodiscard]] auto pools_for(std::index_sequence<Index...>, std::index_sequence<Other...>) const noexcept {
+        using return_type = std::tuple<Owned *..., Get *...>;
+        return descriptor ? return_type{static_cast<Owned *>(descriptor->template storage<Index>())..., static_cast<Get *>(descriptor->template storage<sizeof...(Owned) + Other>())...} : return_type{};
+    }
+
+public:
+    /*! @brief Underlying entity identifier. */
+    using entity_type = underlying_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Common type among all storage types. */
+    using common_type = base_type;
+    /*! @brief Random access iterator type. */
+    using iterator = typename common_type::iterator;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = typename common_type::reverse_iterator;
+    /*! @brief Iterable group type. */
+    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<Owned...>, get_t<Get...>>>;
+    /*! @brief Group handler type. */
+    using handler = internal::group_handler<common_type, sizeof...(Owned), sizeof...(Get), sizeof...(Exclude)>;
+
+    /**
+     * @brief Group opaque identifier.
+     * @return Group opaque identifier.
+     */
+    static id_type group_id() noexcept {
+        return type_hash<basic_group<owned_t<std::remove_const_t<Owned>...>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>>::value();
+    }
+
+    /*! @brief Default constructor to use to create empty, invalid groups. */
+    basic_group() noexcept
+        : descriptor{} {}
+
+    /**
+     * @brief Constructs a group from a set of storage classes.
+     * @param ref A reference to a group handler.
+     */
+    basic_group(handler &ref) noexcept
+        : descriptor{&ref} {}
+
+    /**
+     * @brief Returns the leading storage of a group.
+     * @return The leading storage of the group.
+     */
+    [[nodiscard]] const common_type &handle() const noexcept {
+        return *storage<0>();
+    }
+
+    /**
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
+     */
+    template<typename Type>
+    [[nodiscard]] auto *storage() const noexcept {
+        return storage<index_of<Type>>();
+    }
+
+    /**
+     * @brief Returns the storage for a given index, if any.
+     * @tparam Index Index of the storage to return.
+     * @return The storage for the given index.
+     */
+    template<std::size_t Index>
+    [[nodiscard]] auto *storage() const noexcept {
+        using type = type_list_element_t<Index, type_list<Owned..., Get..., Exclude...>>;
+        return *this ? static_cast<type *>(descriptor->template storage<Index>()) : nullptr;
+    }
+
+    /**
+     * @brief Returns the number of entities that that are part of the group.
+     * @return Number of entities that that are part of the group.
+     */
+    [[nodiscard]] size_type size() const noexcept {
+        return *this ? descriptor->length() : size_type{};
+    }
+
+    /**
+     * @brief Checks whether a group is empty.
+     * @return True if the group is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        return !*this || !descriptor->length();
+    }
+
+    /**
+     * @brief Returns an iterator to the first entity of the group.
+     *
+     * If the group is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first entity of the group.
+     */
+    [[nodiscard]] iterator begin() const noexcept {
+        return *this ? (handle().end() - descriptor->length()) : iterator{};
+    }
+
+    /**
+     * @brief Returns an iterator that is past the last entity of the group.
+     * @return An iterator to the entity following the last entity of the
+     * group.
+     */
+    [[nodiscard]] iterator end() const noexcept {
+        return *this ? handle().end() : iterator{};
+    }
+
+    /**
+     * @brief Returns an iterator to the first entity of the reversed group.
+     *
+     * If the group is empty, the returned iterator will be equal to `rend()`.
+     *
+     * @return An iterator to the first entity of the reversed group.
+     */
+    [[nodiscard]] reverse_iterator rbegin() const noexcept {
+        return *this ? handle().rbegin() : reverse_iterator{};
+    }
+
+    /**
+     * @brief Returns an iterator that is past the last entity of the reversed
+     * group.
+     * @return An iterator to the entity following the last entity of the
+     * reversed group.
+     */
+    [[nodiscard]] reverse_iterator rend() const noexcept {
+        return *this ? (handle().rbegin() + descriptor->length()) : reverse_iterator{};
+    }
+
+    /**
+     * @brief Returns the first entity of the group, if any.
+     * @return The first entity of the group if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type front() const noexcept {
+        const auto it = begin();
+        return it != end() ? *it : null;
+    }
+
+    /**
+     * @brief Returns the last entity of the group, if any.
+     * @return The last entity of the group if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type back() const noexcept {
+        const auto it = rbegin();
+        return it != rend() ? *it : null;
+    }
+
+    /**
+     * @brief Finds an entity.
+     * @param entt A valid identifier.
+     * @return An iterator to the given entity if it's found, past the end
+     * iterator otherwise.
+     */
+    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
+        const auto it = *this ? handle().find(entt) : iterator{};
+        return it >= begin() ? it : iterator{};
+    }
+
+    /**
+     * @brief Returns the identifier that occupies the given position.
+     * @param pos Position of the element to return.
+     * @return The identifier that occupies the given position.
+     */
+    [[nodiscard]] entity_type operator[](const size_type pos) const {
+        return begin()[pos];
+    }
+
+    /**
+     * @brief Checks if a group is properly initialized.
+     * @return True if the group is properly initialized, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return descriptor != nullptr;
+    }
+
+    /**
+     * @brief Checks if a group contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the group contains the given entity, false otherwise.
+     */
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        return *this && handle().contains(entt) && (handle().index(entt) < (descriptor->length()));
+    }
+
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Type Type of the element to get.
+     * @tparam Other Other types of elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<typename Type, typename... Other>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        return get<index_of<Type>, index_of<Other>...>(entt);
+    }
+
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Index Indexes of the elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<std::size_t... Index>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        const auto cpools = pools_for(std::index_sequence_for<Owned...>{}, std::index_sequence_for<Get...>{});
+
+        if constexpr(sizeof...(Index) == 0) {
+            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
+        } else if constexpr(sizeof...(Index) == 1) {
+            return (std::get<Index>(cpools)->get(entt), ...);
         } else {
-            return any_cast<Type>(data);
+            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
         }
-    } else {
-        auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
-        ENTT_ASSERT(instance, "Invalid instance");
-        return static_cast<Type>(std::move(*instance));
     }
-}
 
-/*! @copydoc any_cast */
-template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] const Type *any_cast(const basic_any<Len, Align> *data) noexcept {
-    const auto &info = type_id<std::remove_cv_t<Type>>();
-    return static_cast<const Type *>(data->data(info));
-}
+    /**
+     * @brief Iterates entities and elements and applies the given function
+     * object to them.
+     *
+     * The function object is invoked for each entity. It is provided with the
+     * entity itself and a set of references to non-empty elements. The
+     * _constness_ of the elements is as requested.<br/>
+     * The signature of the function must be equivalent to one of the following
+     * forms:
+     *
+     * @code{.cpp}
+     * void(const entity_type, Type &...);
+     * void(Type &...);
+     * @endcode
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @tparam Func Type of the function object to invoke.
+     * @param func A valid function object.
+     */
+    template<typename Func>
+    void each(Func func) const {
+        for(auto args: each()) {
+            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
+                std::apply(func, args);
+            } else {
+                std::apply([&func](auto, auto &&...less) { func(std::forward<decltype(less)>(less)...); }, args);
+            }
+        }
+    }
 
-/*! @copydoc any_cast */
-template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type *any_cast(basic_any<Len, Align> *data) noexcept {
-    if constexpr(std::is_const_v<Type>) {
-        // last attempt to make wrappers for const references return their values
-        return any_cast<Type>(&std::as_const(*data));
-    } else {
-        const auto &info = type_id<std::remove_cv_t<Type>>();
-        return static_cast<Type *>(data->data(info));
+    /**
+     * @brief Returns an iterable object to use to _visit_ a group.
+     *
+     * The iterable object returns tuples that contain the current entity and a
+     * set of references to its non-empty elements. The _constness_ of the
+     * elements is as requested.
+     *
+     * @note
+     * Empty types aren't explicitly instantiated and therefore they are never
+     * returned during iterations.
+     *
+     * @return An iterable object to use to _visit_ the group.
+     */
+    [[nodiscard]] iterable each() const noexcept {
+        const auto cpools = pools_for(std::index_sequence_for<Owned...>{}, std::index_sequence_for<Get...>{});
+        return iterable{{begin(), cpools}, {end(), cpools}};
     }
-}
 
-/**
- * @brief Constructs a wrapper from a given type, passing it all arguments.
- * @tparam Type Type of object to use to initialize the wrapper.
- * @tparam Len Size of the storage reserved for the small buffer optimization.
- * @tparam Align Optional alignment requirement.
- * @tparam Args Types of arguments to use to construct the new instance.
- * @param args Parameters to use to construct the instance.
- * @return A properly initialized wrapper for an object of the given type.
- */
-template<typename Type, std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Len>::alignment, typename... Args>
-[[nodiscard]] basic_any<Len, Align> make_any(Args &&...args) {
-    return basic_any<Len, Align>{std::in_place_type<Type>, std::forward<Args>(args)...};
-}
+    /**
+     * @brief Sort a group according to the given comparison function.
+     *
+     * The comparison function object must return `true` if the first element
+     * is _less_ than the second one, `false` otherwise. The signature of the
+     * comparison function should be equivalent to one of the following:
+     *
+     * @code{.cpp}
+     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
+     * bool(const Type &, const Type &);
+     * bool(const Entity, const Entity);
+     * @endcode
+     *
+     * Where `Type` are either owned types or not but still such that they are
+     * iterated by the group.<br/>
+     * Moreover, the comparison function object shall induce a
+     * _strict weak ordering_ on the values.
+     *
+     * The sort function object must offer a member function template
+     * `operator()` that accepts three arguments:
+     *
+     * * An iterator to the first element of the range to sort.
+     * * An iterator past the last element of the range to sort.
+     * * A comparison function to use to compare the elements.
+     *
+     * @tparam Type Optional type of element to compare.
+     * @tparam Other Other optional types of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
+        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
+    }
 
-/**
- * @brief Forwards its argument and avoids copies for lvalue references.
- * @tparam Len Size of the storage reserved for the small buffer optimization.
- * @tparam Align Optional alignment requirement.
- * @tparam Type Type of argument to use to construct the new instance.
- * @param value Parameter to use to construct the instance.
- * @return A properly initialized and not necessarily owning wrapper.
- */
-template<std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Len>::alignment, typename Type>
-[[nodiscard]] basic_any<Len, Align> forward_as_any(Type &&value) {
-    return basic_any<Len, Align>{std::in_place_type<Type &&>, std::forward<Type>(value)};
-}
+    /**
+     * @brief Sort a group according to the given comparison function.
+     *
+     * @sa sort
+     *
+     * @tparam Index Optional indexes of elements to compare.
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
+        const auto cpools = pools_for(std::index_sequence_for<Owned...>{}, std::index_sequence_for<Get...>{});
+
+        if constexpr(sizeof...(Index) == 0) {
+            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
+            storage<0>()->sort_n(descriptor->length(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
+        } else {
+            auto comp = [&compare, &cpools](const entity_type lhs, const entity_type rhs) {
+                if constexpr(sizeof...(Index) == 1) {
+                    return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
+                } else {
+                    return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
+                }
+            };
+
+            storage<0>()->sort_n(descriptor->length(), std::move(comp), std::move(algo), std::forward<Args>(args)...);
+        }
+
+        auto cb = [this](auto *head, auto *...other) {
+            for(auto next = descriptor->length(); next; --next) {
+                const auto pos = next - 1;
+                [[maybe_unused]] const auto entt = head->data()[pos];
+                (other->swap_elements(other->data()[pos], entt), ...);
+            }
+        };
+
+        std::apply(cb, cpools);
+    }
+
+private:
+    handler *descriptor;
+};
 
 } // namespace entt
 
 #endif
 
-// #include "../core/memory.hpp"
-#ifndef ENTT_CORE_MEMORY_HPP
-#define ENTT_CORE_MEMORY_HPP
+// #include "storage.hpp"
+#ifndef ENTT_ENTITY_STORAGE_HPP
+#define ENTT_ENTITY_STORAGE_HPP
 
 #include <cstddef>
-#include <limits>
+#include <iterator>
 #include <memory>
 #include <tuple>
 #include <type_traits>
 #include <utility>
+#include <vector>
 // #include "../config/config.h"
 
+// #include "../core/bit.hpp"
 
-namespace entt {
-
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
+// #include "../core/iterator.hpp"
 
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
+// #include "../core/memory.hpp"
+#ifndef ENTT_CORE_MEMORY_HPP
+#define ENTT_CORE_MEMORY_HPP
 
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
+#include <cstddef>
+#include <memory>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
 
-    return ++curr;
-}
 
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
+namespace entt {
 
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
@@ -15730,7 +17543,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -15739,5430 +17552,4279 @@ constexpr Type *uninitialized_construct_using_allocator(Type *value, const Alloc
 
 // #include "../core/type_info.hpp"
 
+// #include "component.hpp"
+
 // #include "entity.hpp"
 
 // #include "fwd.hpp"
 
+// #include "sparse_set.hpp"
+#ifndef ENTT_ENTITY_SPARSE_SET_HPP
+#define ENTT_ENTITY_SPARSE_SET_HPP
 
-namespace entt {
+#include <cstddef>
+#include <iterator>
+#include <memory>
+#include <type_traits>
+#include <utility>
+#include <vector>
+// #include "../config/config.h"
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+// #include "../core/algorithm.hpp"
 
-template<typename Container>
-struct sparse_set_iterator final {
-    using value_type = typename Container::value_type;
-    using pointer = typename Container::const_pointer;
-    using reference = typename Container::const_reference;
-    using difference_type = typename Container::difference_type;
-    using iterator_category = std::random_access_iterator_tag;
+// #include "../core/any.hpp"
+#ifndef ENTT_CORE_ANY_HPP
+#define ENTT_CORE_ANY_HPP
 
-    constexpr sparse_set_iterator() noexcept
-        : packed{},
-          offset{} {}
+#include <cstddef>
+#include <memory>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
 
-    constexpr sparse_set_iterator(const Container &ref, const difference_type idx) noexcept
-        : packed{std::addressof(ref)},
-          offset{idx} {}
+// #include "../core/utility.hpp"
+#ifndef ENTT_CORE_UTILITY_HPP
+#define ENTT_CORE_UTILITY_HPP
 
-    constexpr sparse_set_iterator &operator++() noexcept {
-        return --offset, *this;
-    }
+#include <type_traits>
+#include <utility>
 
-    constexpr sparse_set_iterator operator++(int) noexcept {
-        sparse_set_iterator orig = *this;
-        return ++(*this), orig;
-    }
+namespace entt {
 
-    constexpr sparse_set_iterator &operator--() noexcept {
-        return ++offset, *this;
+/*! @brief Identity function object (waiting for C++20). */
+struct identity {
+    /*! @brief Indicates that this is a transparent function object. */
+    using is_transparent = void;
+
+    /**
+     * @brief Returns its argument unchanged.
+     * @tparam Type Type of the argument.
+     * @param value The actual argument.
+     * @return The submitted value as-is.
+     */
+    template<typename Type>
+    [[nodiscard]] constexpr Type &&operator()(Type &&value) const noexcept {
+        return std::forward<Type>(value);
     }
+};
 
-    constexpr sparse_set_iterator operator--(int) noexcept {
-        sparse_set_iterator orig = *this;
-        return operator--(), orig;
-    }
+/**
+ * @brief Constant utility to disambiguate overloaded members of a class.
+ * @tparam Type Type of the desired overload.
+ * @tparam Class Type of class to which the member belongs.
+ * @param member A valid pointer to a member.
+ * @return Pointer to the member.
+ */
+template<typename Type, typename Class>
+[[nodiscard]] constexpr auto overload(Type Class::*member) noexcept {
+    return member;
+}
 
-    constexpr sparse_set_iterator &operator+=(const difference_type value) noexcept {
-        offset -= value;
-        return *this;
-    }
+/**
+ * @brief Constant utility to disambiguate overloaded functions.
+ * @tparam Func Function type of the desired overload.
+ * @param func A valid pointer to a function.
+ * @return Pointer to the function.
+ */
+template<typename Func>
+[[nodiscard]] constexpr auto overload(Func *func) noexcept {
+    return func;
+}
 
-    constexpr sparse_set_iterator operator+(const difference_type value) const noexcept {
-        sparse_set_iterator copy = *this;
-        return (copy += value);
-    }
+/**
+ * @brief Helper type for visitors.
+ * @tparam Func Types of function objects.
+ */
+template<typename... Func>
+struct overloaded: Func... {
+    using Func::operator()...;
+};
 
-    constexpr sparse_set_iterator &operator-=(const difference_type value) noexcept {
-        return (*this += -value);
-    }
+/**
+ * @brief Deduction guide.
+ * @tparam Func Types of function objects.
+ */
+template<typename... Func>
+overloaded(Func...) -> overloaded<Func...>;
 
-    constexpr sparse_set_iterator operator-(const difference_type value) const noexcept {
-        return (*this + -value);
-    }
+/**
+ * @brief Basic implementation of a y-combinator.
+ * @tparam Func Type of a potentially recursive function.
+ */
+template<typename Func>
+struct y_combinator {
+    /**
+     * @brief Constructs a y-combinator from a given function.
+     * @param recursive A potentially recursive function.
+     */
+    constexpr y_combinator(Func recursive) noexcept(std::is_nothrow_move_constructible_v<Func>)
+        : func{std::move(recursive)} {}
 
-    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
-        return packed->data()[index() - value];
+    /**
+     * @brief Invokes a y-combinator and therefore its underlying function.
+     * @tparam Args Types of arguments to use to invoke the underlying function.
+     * @param args Parameters to use to invoke the underlying function.
+     * @return Return value of the underlying function, if any.
+     */
+    template<typename... Args>
+    constexpr decltype(auto) operator()(Args &&...args) const noexcept(std::is_nothrow_invocable_v<Func, const y_combinator &, Args...>) {
+        return func(*this, std::forward<Args>(args)...);
     }
 
-    [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return packed->data() + index();
+    /*! @copydoc operator()() */
+    template<typename... Args>
+    constexpr decltype(auto) operator()(Args &&...args) noexcept(std::is_nothrow_invocable_v<Func, y_combinator &, Args...>) {
+        return func(*this, std::forward<Args>(args)...);
     }
 
-    [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
-    }
+private:
+    Func func;
+};
 
-    [[nodiscard]] constexpr pointer data() const noexcept {
-        return packed ? packed->data() : nullptr;
-    }
+} // namespace entt
 
-    [[nodiscard]] constexpr difference_type index() const noexcept {
-        return offset - 1;
-    }
+#endif
 
-private:
-    const Container *packed;
-    difference_type offset;
-};
+// #include "fwd.hpp"
 
-template<typename Container>
-[[nodiscard]] constexpr std::ptrdiff_t operator-(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return rhs.index() - lhs.index();
-}
+// #include "type_info.hpp"
+#ifndef ENTT_CORE_TYPE_INFO_HPP
+#define ENTT_CORE_TYPE_INFO_HPP
 
-template<typename Container>
-[[nodiscard]] constexpr bool operator==(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return lhs.index() == rhs.index();
-}
+#include <string_view>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
 
-template<typename Container>
-[[nodiscard]] constexpr bool operator!=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return !(lhs == rhs);
+// #include "../core/attribute.h"
+
+// #include "fwd.hpp"
+
+// #include "hashed_string.hpp"
+
+
+namespace entt {
+
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+struct ENTT_API type_index final {
+    [[nodiscard]] static id_type next() noexcept {
+        static ENTT_MAYBE_ATOMIC(id_type) value{};
+        return value++;
+    }
+};
+
+template<typename Type>
+[[nodiscard]] constexpr auto stripped_type_name() noexcept {
+#if defined ENTT_PRETTY_FUNCTION
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
+    auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
+    auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
+    return value;
+#else
+    return std::string_view{""};
+#endif
 }
 
-template<typename Container>
-[[nodiscard]] constexpr bool operator<(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return lhs.index() > rhs.index();
+template<typename Type, auto = stripped_type_name<Type>().find_first_of('.')>
+[[nodiscard]] constexpr std::string_view type_name(int) noexcept {
+    constexpr auto value = stripped_type_name<Type>();
+    return value;
 }
 
-template<typename Container>
-[[nodiscard]] constexpr bool operator>(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return rhs < lhs;
+template<typename Type>
+[[nodiscard]] std::string_view type_name(char) noexcept {
+    static const auto value = stripped_type_name<Type>();
+    return value;
 }
 
-template<typename Container>
-[[nodiscard]] constexpr bool operator<=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return !(lhs > rhs);
+template<typename Type, auto = stripped_type_name<Type>().find_first_of('.')>
+[[nodiscard]] constexpr id_type type_hash(int) noexcept {
+    constexpr auto stripped = stripped_type_name<Type>();
+    constexpr auto value = hashed_string::value(stripped.data(), stripped.size());
+    return value;
 }
 
-template<typename Container>
-[[nodiscard]] constexpr bool operator>=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
-    return !(lhs < rhs);
+template<typename Type>
+[[nodiscard]] id_type type_hash(char) noexcept {
+    static const auto value = [](const auto stripped) {
+        return hashed_string::value(stripped.data(), stripped.size());
+    }(stripped_type_name<Type>());
+    return value;
 }
 
 } // namespace internal
 /*! @endcond */
 
 /**
- * @brief Basic sparse set implementation.
- *
- * Sparse set or packed array or whatever is the name users give it.<br/>
- * Two arrays: an _external_ one and an _internal_ one; a _sparse_ one and a
- * _packed_ one; one used for direct access through contiguous memory, the other
- * one used to get the data through an extra level of indirection.<br/>
- * This type of data structure is widely documented in the literature and on the
- * web. This is nothing more than a customized implementation suitable for the
- * purpose of the framework.
- *
- * @note
- * Internal data structures arrange elements to maximize performance. There are
- * no guarantees that entities are returned in the insertion order when iterate
- * a sparse set. Do not make assumption on the order in any case.
- *
- * @tparam Entity A valid entity type.
- * @tparam Allocator Type of allocator used to manage memory and elements.
+ * @brief Type sequential identifier.
+ * @tparam Type Type for which to generate a sequential identifier.
  */
-template<typename Entity, typename Allocator>
-class basic_sparse_set {
-    using alloc_traits = std::allocator_traits<Allocator>;
-    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
-    using sparse_container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
-    using packed_container_type = std::vector<Entity, Allocator>;
-    using underlying_type = typename entt_traits<Entity>::entity_type;
-
-    [[nodiscard]] auto sparse_ptr(const Entity entt) const {
-        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
-        const auto page = pos / traits_type::page_size;
-        return (page < sparse.size() && sparse[page]) ? (sparse[page] + fast_mod(pos, traits_type::page_size)) : nullptr;
-    }
-
-    [[nodiscard]] auto &sparse_ref(const Entity entt) const {
-        ENTT_ASSERT(sparse_ptr(entt), "Invalid element");
-        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
-        return sparse[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
-    }
-
-    [[nodiscard]] auto to_iterator(const Entity entt) const {
-        return --(end() - index(entt));
-    }
-
-    [[nodiscard]] auto &assure_at_least(const Entity entt) {
-        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
-        const auto page = pos / traits_type::page_size;
-
-        if(!(page < sparse.size())) {
-            sparse.resize(page + 1u, nullptr);
-        }
-
-        if(!sparse[page]) {
-            constexpr entity_type init = null;
-            auto page_allocator{packed.get_allocator()};
-            sparse[page] = alloc_traits::allocate(page_allocator, traits_type::page_size);
-            std::uninitialized_fill(sparse[page], sparse[page] + traits_type::page_size, init);
-        }
-
-        return sparse[page][fast_mod(pos, traits_type::page_size)];
+template<typename Type, typename = void>
+struct ENTT_API type_index final {
+    /**
+     * @brief Returns the sequential identifier of a given type.
+     * @return The sequential identifier of a given type.
+     */
+    [[nodiscard]] static id_type value() noexcept {
+        static const id_type value = internal::type_index::next();
+        return value;
     }
 
-    void release_sparse_pages() {
-        auto page_allocator{packed.get_allocator()};
-
-        for(auto &&page: sparse) {
-            if(page != nullptr) {
-                std::destroy(page, page + traits_type::page_size);
-                alloc_traits::deallocate(page_allocator, page, traits_type::page_size);
-                page = nullptr;
-            }
-        }
+    /*! @copydoc value */
+    [[nodiscard]] constexpr operator id_type() const noexcept {
+        return value();
     }
+};
 
-    void swap_at(const std::size_t from, const std::size_t to) {
-        auto &lhs = packed[from];
-        auto &rhs = packed[to];
-
-        sparse_ref(lhs) = traits_type::combine(static_cast<typename traits_type::entity_type>(to), traits_type::to_integral(lhs));
-        sparse_ref(rhs) = traits_type::combine(static_cast<typename traits_type::entity_type>(from), traits_type::to_integral(rhs));
-
-        std::swap(lhs, rhs);
+/**
+ * @brief Type hash.
+ * @tparam Type Type for which to generate a hash value.
+ */
+template<typename Type, typename = void>
+struct type_hash final {
+    /**
+     * @brief Returns the numeric representation of a given type.
+     * @return The numeric representation of the given type.
+     */
+#if defined ENTT_PRETTY_FUNCTION
+    [[nodiscard]] static constexpr id_type value() noexcept {
+        return internal::type_hash<Type>(0);
+#else
+    [[nodiscard]] static constexpr id_type value() noexcept {
+        return type_index<Type>::value();
+#endif
     }
 
-    underlying_type policy_to_head() {
-        return traits_type::entity_mask * (mode != deletion_policy::swap_only);
+    /*! @copydoc value */
+    [[nodiscard]] constexpr operator id_type() const noexcept {
+        return value();
     }
+};
 
-private:
-    virtual const void *get_at(const std::size_t) const {
-        return nullptr;
+/**
+ * @brief Type name.
+ * @tparam Type Type for which to generate a name.
+ */
+template<typename Type, typename = void>
+struct type_name final {
+    /**
+     * @brief Returns the name of a given type.
+     * @return The name of the given type.
+     */
+    [[nodiscard]] static constexpr std::string_view value() noexcept {
+        return internal::type_name<Type>(0);
     }
 
-    virtual void swap_or_move([[maybe_unused]] const std::size_t lhs, [[maybe_unused]] const std::size_t rhs) {
-        ENTT_ASSERT((mode != deletion_policy::swap_only) || (((lhs < free_list()) + (rhs < free_list())) != 1u), "Cross swapping is not supported");
+    /*! @copydoc value */
+    [[nodiscard]] constexpr operator std::string_view() const noexcept {
+        return value();
     }
+};
 
-protected:
-    /*! @brief Random access iterator type. */
-    using basic_iterator = internal::sparse_set_iterator<packed_container_type>;
-
+/*! @brief Implementation specific information about a type. */
+struct type_info final {
     /**
-     * @brief Erases an entity from a sparse set.
-     * @param it An iterator to the element to pop.
+     * @brief Constructs a type info object for a given type.
+     * @tparam Type Type for which to construct a type info object.
      */
-    void swap_only(const basic_iterator it) {
-        ENTT_ASSERT(mode == deletion_policy::swap_only, "Deletion policy mismatch");
-        const auto pos = static_cast<underlying_type>(index(*it));
-        bump(traits_type::next(*it));
-        swap_at(pos, static_cast<size_type>(head -= (pos < head)));
-    }
+    template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
+    constexpr type_info(std::in_place_type_t<Type>) noexcept
+        : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
+          identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
+          alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
-     * @brief Erases an entity from a sparse set.
-     * @param it An iterator to the element to pop.
+     * @brief Type index.
+     * @return Type index.
      */
-    void swap_and_pop(const basic_iterator it) {
-        ENTT_ASSERT(mode == deletion_policy::swap_and_pop, "Deletion policy mismatch");
-        auto &self = sparse_ref(*it);
-        const auto entt = traits_type::to_entity(self);
-        sparse_ref(packed.back()) = traits_type::combine(entt, traits_type::to_integral(packed.back()));
-        packed[static_cast<size_type>(entt)] = packed.back();
-        // unnecessary but it helps to detect nasty bugs
-        ENTT_ASSERT((packed.back() = null, true), "");
-        // lazy self-assignment guard
-        self = null;
-        packed.pop_back();
+    [[nodiscard]] constexpr id_type index() const noexcept {
+        return seq;
     }
 
     /**
-     * @brief Erases an entity from a sparse set.
-     * @param it An iterator to the element to pop.
+     * @brief Type hash.
+     * @return Type hash.
      */
-    void in_place_pop(const basic_iterator it) {
-        ENTT_ASSERT(mode == deletion_policy::in_place, "Deletion policy mismatch");
-        const auto entt = traits_type::to_entity(std::exchange(sparse_ref(*it), null));
-        packed[static_cast<size_type>(entt)] = traits_type::combine(std::exchange(head, entt), tombstone);
+    [[nodiscard]] constexpr id_type hash() const noexcept {
+        return identifier;
     }
 
-protected:
     /**
-     * @brief Erases entities from a sparse set.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
+     * @brief Type name.
+     * @return Type name.
      */
-    virtual void pop(basic_iterator first, basic_iterator last) {
-        switch(mode) {
-        case deletion_policy::swap_and_pop:
-            for(; first != last; ++first) {
-                swap_and_pop(first);
-            }
-            break;
-        case deletion_policy::in_place:
-            for(; first != last; ++first) {
-                in_place_pop(first);
-            }
-            break;
-        case deletion_policy::swap_only:
-            for(; first != last; ++first) {
-                swap_only(first);
-            }
-            break;
-        }
+    [[nodiscard]] constexpr std::string_view name() const noexcept {
+        return alias;
     }
 
-    /*! @brief Erases all entities of a sparse set. */
-    virtual void pop_all() {
-        switch(mode) {
-        case deletion_policy::in_place:
-            if(head != traits_type::to_entity(null)) {
-                for(auto first = begin(); !(first.index() < 0); ++first) {
-                    if(*first != tombstone) {
-                        sparse_ref(*first) = null;
-                    }
-                }
-                break;
-            }
-            [[fallthrough]];
-        case deletion_policy::swap_only:
-        case deletion_policy::swap_and_pop:
-            for(auto first = begin(); !(first.index() < 0); ++first) {
-                sparse_ref(*first) = null;
-            }
-            break;
-        }
+private:
+    id_type seq;
+    id_type identifier;
+    std::string_view alias;
+};
 
-        head = policy_to_head();
-        packed.clear();
-    }
+/**
+ * @brief Compares the contents of two type info objects.
+ * @param lhs A type info object.
+ * @param rhs A type info object.
+ * @return True if the two type info objects are identical, false otherwise.
+ */
+[[nodiscard]] inline constexpr bool operator==(const type_info &lhs, const type_info &rhs) noexcept {
+    return lhs.hash() == rhs.hash();
+}
 
-    /**
-     * @brief Assigns an entity to a sparse set.
-     * @param entt A valid identifier.
-     * @param force_back Force back insertion.
-     * @return Iterator pointing to the emplaced element.
-     */
-    virtual basic_iterator try_emplace(const Entity entt, const bool force_back, const void * = nullptr) {
-        auto &elem = assure_at_least(entt);
-        auto pos = size();
+/**
+ * @brief Compares the contents of two type info objects.
+ * @param lhs A type info object.
+ * @param rhs A type info object.
+ * @return True if the two type info objects differ, false otherwise.
+ */
+[[nodiscard]] inline constexpr bool operator!=(const type_info &lhs, const type_info &rhs) noexcept {
+    return !(lhs == rhs);
+}
 
-        switch(mode) {
-        case deletion_policy::in_place:
-            if(head != traits_type::to_entity(null) && !force_back) {
-                pos = static_cast<size_type>(head);
-                ENTT_ASSERT(elem == null, "Slot not available");
-                elem = traits_type::combine(head, traits_type::to_integral(entt));
-                head = traits_type::to_entity(std::exchange(packed[pos], entt));
-                break;
-            }
-            [[fallthrough]];
-        case deletion_policy::swap_and_pop:
-            packed.push_back(entt);
-            ENTT_ASSERT(elem == null, "Slot not available");
-            elem = traits_type::combine(static_cast<typename traits_type::entity_type>(packed.size() - 1u), traits_type::to_integral(entt));
-            break;
-        case deletion_policy::swap_only:
-            if(elem == null) {
-                packed.push_back(entt);
-                elem = traits_type::combine(static_cast<typename traits_type::entity_type>(packed.size() - 1u), traits_type::to_integral(entt));
-            } else {
-                ENTT_ASSERT(!(traits_type::to_entity(elem) < head), "Slot not available");
-                bump(entt);
-            }
+/**
+ * @brief Compares two type info objects.
+ * @param lhs A valid type info object.
+ * @param rhs A valid type info object.
+ * @return True if the first element is less than the second, false otherwise.
+ */
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+    return lhs.index() < rhs.index();
+}
 
-            if(force_back) {
-                pos = static_cast<size_type>(head++);
-                swap_at(static_cast<size_type>(traits_type::to_entity(elem)), pos);
-            }
+/**
+ * @brief Compares two type info objects.
+ * @param lhs A valid type info object.
+ * @param rhs A valid type info object.
+ * @return True if the first element is less than or equal to the second, false
+ * otherwise.
+ */
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+    return !(rhs < lhs);
+}
 
-            break;
-        }
+/**
+ * @brief Compares two type info objects.
+ * @param lhs A valid type info object.
+ * @param rhs A valid type info object.
+ * @return True if the first element is greater than the second, false
+ * otherwise.
+ */
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+    return rhs < lhs;
+}
+
+/**
+ * @brief Compares two type info objects.
+ * @param lhs A valid type info object.
+ * @param rhs A valid type info object.
+ * @return True if the first element is greater than or equal to the second,
+ * false otherwise.
+ */
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+    return !(lhs < rhs);
+}
 
-        return --(end() - pos);
+/**
+ * @brief Returns the type info object associated to a given type.
+ *
+ * The returned element refers to an object with static storage duration.<br/>
+ * The type doesn't need to be a complete type. If the type is a reference, the
+ * result refers to the referenced type. In all cases, top-level cv-qualifiers
+ * are ignored.
+ *
+ * @tparam Type Type for which to generate a type info object.
+ * @return A reference to a properly initialized type info object.
+ */
+template<typename Type>
+[[nodiscard]] const type_info &type_id() noexcept {
+    if constexpr(std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<Type>>>) {
+        static type_info instance{std::in_place_type<Type>};
+        return instance;
+    } else {
+        return type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
     }
+}
 
-public:
-    /*! @brief Entity traits. */
-    using traits_type = entt_traits<Entity>;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename traits_type::value_type;
-    /*! @brief Underlying version type. */
-    using version_type = typename traits_type::version_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
-    /*! @brief Pointer type to contained entities. */
-    using pointer = typename packed_container_type::const_pointer;
-    /*! @brief Random access iterator type. */
-    using iterator = basic_iterator;
-    /*! @brief Constant random access iterator type. */
-    using const_iterator = iterator;
-    /*! @brief Reverse iterator type. */
-    using reverse_iterator = std::reverse_iterator<iterator>;
-    /*! @brief Constant reverse iterator type. */
-    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
-
-    /*! @brief Default constructor. */
-    basic_sparse_set()
-        : basic_sparse_set{type_id<void>()} {}
+/*! @copydoc type_id */
+template<typename Type>
+[[nodiscard]] const type_info &type_id(Type &&) noexcept {
+    return type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
+}
 
-    /**
-     * @brief Constructs an empty container with a given allocator.
-     * @param allocator The allocator to use.
-     */
-    explicit basic_sparse_set(const allocator_type &allocator)
-        : basic_sparse_set{type_id<void>(), deletion_policy::swap_and_pop, allocator} {}
+} // namespace entt
 
-    /**
-     * @brief Constructs an empty container with the given policy and allocator.
-     * @param pol Type of deletion policy.
-     * @param allocator The allocator to use (possibly default-constructed).
-     */
-    explicit basic_sparse_set(deletion_policy pol, const allocator_type &allocator = {})
-        : basic_sparse_set{type_id<void>(), pol, allocator} {}
+#endif
 
-    /**
-     * @brief Constructs an empty container with the given value type, policy
-     * and allocator.
-     * @param elem Returned value type, if any.
-     * @param pol Type of deletion policy.
-     * @param allocator The allocator to use (possibly default-constructed).
-     */
-    explicit basic_sparse_set(const type_info &elem, deletion_policy pol = deletion_policy::swap_and_pop, const allocator_type &allocator = {})
-        : sparse{allocator},
-          packed{allocator},
-          info{&elem},
-          mode{pol},
-          head{policy_to_head()} {}
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
 
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    basic_sparse_set(basic_sparse_set &&other) noexcept
-        : sparse{std::move(other.sparse)},
-          packed{std::move(other.packed)},
-          info{other.info},
-          mode{other.mode},
-          head{std::exchange(other.head, policy_to_head())} {}
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
 
-    /**
-     * @brief Allocator-extended move constructor.
-     * @param other The instance to move from.
-     * @param allocator The allocator to use.
-     */
-    basic_sparse_set(basic_sparse_set &&other, const allocator_type &allocator) noexcept
-        : sparse{std::move(other.sparse), allocator},
-          packed{std::move(other.packed), allocator},
-          info{other.info},
-          mode{other.mode},
-          head{std::exchange(other.head, policy_to_head())} {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || packed.get_allocator() == other.packed.get_allocator(), "Copying a sparse set is not allowed");
-    }
+// #include "fwd.hpp"
 
-    /*! @brief Default destructor. */
-    virtual ~basic_sparse_set() {
-        release_sparse_pages();
-    }
 
-    /**
-     * @brief Move assignment operator.
-     * @param other The instance to move from.
-     * @return This sparse set.
-     */
-    basic_sparse_set &operator=(basic_sparse_set &&other) noexcept {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || packed.get_allocator() == other.packed.get_allocator(), "Copying a sparse set is not allowed");
+namespace entt {
 
-        release_sparse_pages();
-        sparse = std::move(other.sparse);
-        packed = std::move(other.packed);
-        info = other.info;
-        mode = other.mode;
-        head = std::exchange(other.head, policy_to_head());
-        return *this;
-    }
+/**
+ * @brief Utility class to disambiguate overloaded functions.
+ * @tparam N Number of choices available.
+ */
+template<std::size_t N>
+struct choice_t
+    // unfortunately, doxygen cannot parse such a construct
+    : /*! @cond TURN_OFF_DOXYGEN */ choice_t<N - 1> /*! @endcond */
+{};
 
-    /**
-     * @brief Exchanges the contents with those of a given sparse set.
-     * @param other Sparse set to exchange the content with.
-     */
-    void swap(basic_sparse_set &other) {
-        using std::swap;
-        swap(sparse, other.sparse);
-        swap(packed, other.packed);
-        swap(info, other.info);
-        swap(mode, other.mode);
-        swap(head, other.head);
-    }
+/*! @copybrief choice_t */
+template<>
+struct choice_t<0> {};
 
-    /**
-     * @brief Returns the associated allocator.
-     * @return The associated allocator.
-     */
-    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
-        return packed.get_allocator();
-    }
+/**
+ * @brief Variable template for the choice trick.
+ * @tparam N Number of choices available.
+ */
+template<std::size_t N>
+inline constexpr choice_t<N> choice{};
 
-    /**
-     * @brief Returns the deletion policy of a sparse set.
-     * @return The deletion policy of the sparse set.
-     */
-    [[nodiscard]] deletion_policy policy() const noexcept {
-        return mode;
-    }
+/**
+ * @brief Identity type trait.
+ *
+ * Useful to establish non-deduced contexts in template argument deduction
+ * (waiting for C++20) or to provide types through function arguments.
+ *
+ * @tparam Type A type.
+ */
+template<typename Type>
+struct type_identity {
+    /*! @brief Identity type. */
+    using type = Type;
+};
 
-    /**
-     * @brief Returns the head of the free list, if any.
-     * @return The head of the free list.
-     */
-    [[nodiscard]] size_type free_list() const noexcept {
-        return static_cast<size_type>(head);
-    }
+/**
+ * @brief Helper type.
+ * @tparam Type A type.
+ */
+template<typename Type>
+using type_identity_t = typename type_identity<Type>::type;
 
-    /**
-     * @brief Sets the head of the free list, if possible.
-     * @param len The value to use as the new head of the free list.
-     */
-    void free_list(const size_type len) noexcept {
-        ENTT_ASSERT((mode == deletion_policy::swap_only) && !(len > packed.size()), "Invalid value");
-        head = static_cast<underlying_type>(len);
-    }
+/**
+ * @brief A type-only `sizeof` wrapper that returns 0 where `sizeof` complains.
+ * @tparam Type The type of which to return the size.
+ */
+template<typename Type, typename = void>
+struct size_of: std::integral_constant<std::size_t, 0u> {};
 
-    /**
-     * @brief Increases the capacity of a sparse set.
-     *
-     * If the new capacity is greater than the current capacity, new storage is
-     * allocated, otherwise the method does nothing.
-     *
-     * @param cap Desired capacity.
-     */
-    virtual void reserve(const size_type cap) {
-        packed.reserve(cap);
-    }
+/*! @copydoc size_of */
+template<typename Type>
+struct size_of<Type, std::void_t<decltype(sizeof(Type))>>
+    : std::integral_constant<std::size_t, sizeof(Type)> {};
 
-    /**
-     * @brief Returns the number of elements that a sparse set has currently
-     * allocated space for.
-     * @return Capacity of the sparse set.
-     */
-    [[nodiscard]] virtual size_type capacity() const noexcept {
-        return packed.capacity();
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type of which to return the size.
+ */
+template<typename Type>
+inline constexpr std::size_t size_of_v = size_of<Type>::value;
 
-    /*! @brief Requests the removal of unused capacity. */
-    virtual void shrink_to_fit() {
-        packed.shrink_to_fit();
-    }
+/**
+ * @brief Using declaration to be used to _repeat_ the same type a number of
+ * times equal to the size of a given parameter pack.
+ * @tparam Type A type to repeat.
+ */
+template<typename Type, typename>
+using unpack_as_type = Type;
 
-    /**
-     * @brief Returns the extent of a sparse set.
-     *
-     * The extent of a sparse set is also the size of the internal sparse array.
-     * There is no guarantee that the internal packed array has the same size.
-     * Usually the size of the internal sparse array is equal or greater than
-     * the one of the internal packed array.
-     *
-     * @return Extent of the sparse set.
-     */
-    [[nodiscard]] size_type extent() const noexcept {
-        return sparse.size() * traits_type::page_size;
-    }
+/**
+ * @brief Helper variable template to be used to _repeat_ the same value a
+ * number of times equal to the size of a given parameter pack.
+ * @tparam Value A value to repeat.
+ */
+template<auto Value, typename>
+inline constexpr auto unpack_as_value = Value;
 
-    /**
-     * @brief Returns the number of elements in a sparse set.
-     *
-     * The number of elements is also the size of the internal packed array.
-     * There is no guarantee that the internal sparse array has the same size.
-     * Usually the size of the internal sparse array is equal or greater than
-     * the one of the internal packed array.
-     *
-     * @return Number of elements.
-     */
-    [[nodiscard]] size_type size() const noexcept {
-        return packed.size();
-    }
+/**
+ * @brief Wraps a static constant.
+ * @tparam Value A static constant.
+ */
+template<auto Value>
+using integral_constant = std::integral_constant<decltype(Value), Value>;
 
-    /**
-     * @brief Checks whether a sparse set is empty.
-     * @return True if the sparse set is empty, false otherwise.
-     */
-    [[nodiscard]] bool empty() const noexcept {
-        return packed.empty();
-    }
+/**
+ * @brief Alias template to facilitate the creation of named values.
+ * @tparam Value A constant value at least convertible to `id_type`.
+ */
+template<id_type Value>
+using tag = integral_constant<Value>;
 
-    /**
-     * @brief Checks whether a sparse set is fully packed.
-     * @return True if the sparse set is fully packed, false otherwise.
-     */
-    [[nodiscard]] bool contiguous() const noexcept {
-        return (mode != deletion_policy::in_place) || (head == traits_type::to_entity(null));
-    }
+/**
+ * @brief A class to use to push around lists of types, nothing more.
+ * @tparam Type Types provided by the type list.
+ */
+template<typename... Type>
+struct type_list {
+    /*! @brief Type list type. */
+    using type = type_list;
+    /*! @brief Compile-time number of elements in the type list. */
+    static constexpr auto size = sizeof...(Type);
+};
 
-    /**
-     * @brief Direct access to the internal packed array.
-     * @return A pointer to the internal packed array.
-     */
-    [[nodiscard]] pointer data() const noexcept {
-        return packed.data();
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<std::size_t, typename>
+struct type_list_element;
 
-    /**
-     * @brief Returns an iterator to the beginning.
-     *
-     * If the sparse set is empty, the returned iterator will be equal to
-     * `end()`.
-     *
-     * @return An iterator to the first entity of the sparse set.
-     */
-    [[nodiscard]] iterator begin() const noexcept {
-        const auto pos = static_cast<typename iterator::difference_type>(packed.size());
-        return iterator{packed, pos};
-    }
+/**
+ * @brief Provides compile-time indexed access to the types of a type list.
+ * @tparam Index Index of the type to return.
+ * @tparam First First type provided by the type list.
+ * @tparam Other Other types provided by the type list.
+ */
+template<std::size_t Index, typename First, typename... Other>
+struct type_list_element<Index, type_list<First, Other...>>
+    : type_list_element<Index - 1u, type_list<Other...>> {};
 
-    /*! @copydoc begin */
-    [[nodiscard]] const_iterator cbegin() const noexcept {
-        return begin();
-    }
+/**
+ * @brief Provides compile-time indexed access to the types of a type list.
+ * @tparam First First type provided by the type list.
+ * @tparam Other Other types provided by the type list.
+ */
+template<typename First, typename... Other>
+struct type_list_element<0u, type_list<First, Other...>> {
+    /*! @brief Searched type. */
+    using type = First;
+};
 
-    /**
-     * @brief Returns an iterator to the end.
-     * @return An iterator to the element following the last entity of a sparse
-     * set.
-     */
-    [[nodiscard]] iterator end() const noexcept {
-        return iterator{packed, {}};
-    }
+/**
+ * @brief Helper type.
+ * @tparam Index Index of the type to return.
+ * @tparam List Type list to search into.
+ */
+template<std::size_t Index, typename List>
+using type_list_element_t = typename type_list_element<Index, List>::type;
 
-    /*! @copydoc end */
-    [[nodiscard]] const_iterator cend() const noexcept {
-        return end();
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename, typename>
+struct type_list_index;
 
-    /**
-     * @brief Returns a reverse iterator to the beginning.
-     *
-     * If the sparse set is empty, the returned iterator will be equal to
-     * `rend()`.
-     *
-     * @return An iterator to the first entity of the reversed internal packed
-     * array.
-     */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
-        return std::make_reverse_iterator(end());
-    }
+/**
+ * @brief Provides compile-time type access to the types of a type list.
+ * @tparam Type Type to look for and for which to return the index.
+ * @tparam First First type provided by the type list.
+ * @tparam Other Other types provided by the type list.
+ */
+template<typename Type, typename First, typename... Other>
+struct type_list_index<Type, type_list<First, Other...>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 1u + type_list_index<Type, type_list<Other...>>::value;
+};
 
-    /*! @copydoc rbegin */
-    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
-        return rbegin();
-    }
+/**
+ * @brief Provides compile-time type access to the types of a type list.
+ * @tparam Type Type to look for and for which to return the index.
+ * @tparam Other Other types provided by the type list.
+ */
+template<typename Type, typename... Other>
+struct type_list_index<Type, type_list<Type, Other...>> {
+    static_assert(type_list_index<Type, type_list<Other...>>::value == sizeof...(Other), "Non-unique type");
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    /**
-     * @brief Returns a reverse iterator to the end.
-     * @return An iterator to the element following the last entity of the
-     * reversed sparse set.
-     */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return std::make_reverse_iterator(begin());
-    }
+/**
+ * @brief Provides compile-time type access to the types of a type list.
+ * @tparam Type Type to look for and for which to return the index.
+ */
+template<typename Type>
+struct type_list_index<Type, type_list<>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    /*! @copydoc rend */
-    [[nodiscard]] const_reverse_iterator crend() const noexcept {
-        return rend();
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam List Type list.
+ * @tparam Type Type to look for and for which to return the index.
+ */
+template<typename Type, typename List>
+inline constexpr std::size_t type_list_index_v = type_list_index<Type, List>::value;
 
-    /*! @copydoc begin Useful only in case of swap-only policy. */
-    [[nodiscard]] iterator begin(int) const noexcept {
-        return (mode == deletion_policy::swap_only) ? (end() - static_cast<typename iterator::difference_type>(head)) : begin();
-    }
+/**
+ * @brief Concatenates multiple type lists.
+ * @tparam Type Types provided by the first type list.
+ * @tparam Other Types provided by the second type list.
+ * @return A type list composed by the types of both the type lists.
+ */
+template<typename... Type, typename... Other>
+constexpr type_list<Type..., Other...> operator+(type_list<Type...>, type_list<Other...>) {
+    return {};
+}
 
-    /*! @copydoc cbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] const_iterator cbegin(int) const noexcept {
-        return begin(0);
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct type_list_cat;
 
-    /*! @copydoc end Useful only in case of swap-only policy. */
-    [[nodiscard]] iterator end(int) const noexcept {
-        return end();
-    }
+/*! @brief Concatenates multiple type lists. */
+template<>
+struct type_list_cat<> {
+    /*! @brief A type list composed by the types of all the type lists. */
+    using type = type_list<>;
+};
 
-    /*! @copydoc cend Useful only in case of swap-only policy. */
-    [[nodiscard]] const_iterator cend(int) const noexcept {
-        return end(0);
-    }
+/**
+ * @brief Concatenates multiple type lists.
+ * @tparam Type Types provided by the first type list.
+ * @tparam Other Types provided by the second type list.
+ * @tparam List Other type lists, if any.
+ */
+template<typename... Type, typename... Other, typename... List>
+struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
+    /*! @brief A type list composed by the types of all the type lists. */
+    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
+};
 
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] reverse_iterator rbegin(int) const noexcept {
-        return std::make_reverse_iterator(end(0));
-    }
+/**
+ * @brief Concatenates multiple type lists.
+ * @tparam Type Types provided by the type list.
+ */
+template<typename... Type>
+struct type_list_cat<type_list<Type...>> {
+    /*! @brief A type list composed by the types of all the type lists. */
+    using type = type_list<Type...>;
+};
 
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] const_reverse_iterator crbegin(int) const noexcept {
-        return rbegin(0);
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Type lists to concatenate.
+ */
+template<typename... List>
+using type_list_cat_t = typename type_list_cat<List...>::type;
 
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] reverse_iterator rend(int) const noexcept {
-        return std::make_reverse_iterator(begin(0));
-    }
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] const_reverse_iterator crend(int) const noexcept {
-        return rend(0);
-    }
+template<typename...>
+struct type_list_unique;
 
-    /**
-     * @brief Finds an entity.
-     * @param entt A valid identifier.
-     * @return An iterator to the given entity if it's found, past the end
-     * iterator otherwise.
-     */
-    [[nodiscard]] const_iterator find(const entity_type entt) const noexcept {
-        return contains(entt) ? to_iterator(entt) : end();
-    }
+template<typename First, typename... Other, typename... Type>
+struct type_list_unique<type_list<First, Other...>, Type...>
+    : std::conditional_t<(std::is_same_v<First, Type> || ...), type_list_unique<type_list<Other...>, Type...>, type_list_unique<type_list<Other...>, Type..., First>> {};
 
-    /**
-     * @brief Checks if a sparse set contains an entity.
-     * @param entt A valid identifier.
-     * @return True if the sparse set contains the entity, false otherwise.
-     */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        const auto elem = sparse_ptr(entt);
-        constexpr auto cap = traits_type::entity_mask;
-        constexpr auto mask = traits_type::to_integral(null) & ~cap;
-        // testing versions permits to avoid accessing the packed array
-        return elem && (((mask & traits_type::to_integral(entt)) ^ traits_type::to_integral(*elem)) < cap);
-    }
+template<typename... Type>
+struct type_list_unique<type_list<>, Type...> {
+    using type = type_list<Type...>;
+};
 
-    /**
-     * @brief Returns the contained version for an identifier.
-     * @param entt A valid identifier.
-     * @return The version for the given identifier if present, the tombstone
-     * version otherwise.
-     */
-    [[nodiscard]] version_type current(const entity_type entt) const noexcept {
-        const auto elem = sparse_ptr(entt);
-        constexpr auto fallback = traits_type::to_version(tombstone);
-        return elem ? traits_type::to_version(*elem) : fallback;
-    }
+} // namespace internal
+/*! @endcond */
 
-    /**
-     * @brief Returns the position of an entity in a sparse set.
-     *
-     * @warning
-     * Attempting to get the position of an entity that doesn't belong to the
-     * sparse set results in undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @return The position of the entity in the sparse set.
-     */
-    [[nodiscard]] size_type index(const entity_type entt) const noexcept {
-        ENTT_ASSERT(contains(entt), "Set does not contain entity");
-        return static_cast<size_type>(traits_type::to_entity(sparse_ref(entt)));
-    }
-
-    /**
-     * @brief Returns the entity at specified location, with bounds checking.
-     * @param pos The position for which to return the entity.
-     * @return The entity at specified location if any, a null entity otherwise.
-     */
-    [[deprecated("use .begin()[pos] instead")]] [[nodiscard]] entity_type at(const size_type pos) const noexcept {
-        return pos < packed.size() ? packed[pos] : null;
-    }
-
-    /**
-     * @brief Returns the entity at specified location, without bounds checking.
-     * @param pos The position for which to return the entity.
-     * @return The entity at specified location.
-     */
-    [[nodiscard]] entity_type operator[](const size_type pos) const noexcept {
-        ENTT_ASSERT(pos < packed.size(), "Position is out of bounds");
-        return packed[pos];
-    }
-
-    /**
-     * @brief Returns the element assigned to an entity, if any.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the sparse set results
-     * in undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @return An opaque pointer to the element assigned to the entity, if any.
-     */
-    [[nodiscard]] const void *value(const entity_type entt) const noexcept {
-        return get_at(index(entt));
-    }
-
-    /*! @copydoc value */
-    [[nodiscard]] void *value(const entity_type entt) noexcept {
-        return const_cast<void *>(std::as_const(*this).value(entt));
-    }
-
-    /**
-     * @brief Assigns an entity to a sparse set.
-     *
-     * @warning
-     * Attempting to assign an entity that already belongs to the sparse set
-     * results in undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @param elem Optional opaque element to forward to mixins, if any.
-     * @return Iterator pointing to the emplaced element in case of success, the
-     * `end()` iterator otherwise.
-     */
-    iterator push(const entity_type entt, const void *elem = nullptr) {
-        return try_emplace(entt, (mode == deletion_policy::swap_only), elem);
-    }
-
-    /**
-     * @brief Assigns one or more entities to a sparse set.
-     *
-     * @warning
-     * Attempting to assign an entity that already belongs to the sparse set
-     * results in undefined behavior.
-     *
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     * @return Iterator pointing to the first element inserted in case of
-     * success, the `end()` iterator otherwise.
-     */
-    template<typename It>
-    iterator push(It first, It last) {
-        for(auto it = first; it != last; ++it) {
-            try_emplace(*it, true);
-        }
-
-        return first == last ? end() : find(*first);
-    }
-
-    /**
-     * @brief Bump the version number of an entity.
-     *
-     * @warning
-     * Attempting to bump the version of an entity that doesn't belong to the
-     * sparse set results in undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @return The version of the given identifier.
-     */
-    version_type bump(const entity_type entt) {
-        auto &entity = sparse_ref(entt);
-        ENTT_ASSERT(entt != tombstone && entity != null, "Cannot set the required version");
-        entity = traits_type::combine(traits_type::to_integral(entity), traits_type::to_integral(entt));
-        packed[static_cast<size_type>(traits_type::to_entity(entity))] = entt;
-        return traits_type::to_version(entt);
-    }
-
-    /**
-     * @brief Erases an entity from a sparse set.
-     *
-     * @warning
-     * Attempting to erase an entity that doesn't belong to the sparse set
-     * results in undefined behavior.
-     *
-     * @param entt A valid identifier.
-     */
-    void erase(const entity_type entt) {
-        const auto it = to_iterator(entt);
-        pop(it, it + 1u);
-    }
-
-    /**
-     * @brief Erases entities from a set.
-     *
-     * @sa erase
-     *
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     */
-    template<typename It>
-    void erase(It first, It last) {
-        if constexpr(std::is_same_v<It, basic_iterator>) {
-            pop(first, last);
-        } else {
-            for(; first != last; ++first) {
-                erase(*first);
-            }
-        }
-    }
-
-    /**
-     * @brief Removes an entity from a sparse set if it exists.
-     * @param entt A valid identifier.
-     * @return True if the entity is actually removed, false otherwise.
-     */
-    bool remove(const entity_type entt) {
-        return contains(entt) && (erase(entt), true);
-    }
-
-    /**
-     * @brief Removes entities from a sparse set if they exist.
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     * @return The number of entities actually removed.
-     */
-    template<typename It>
-    size_type remove(It first, It last) {
-        size_type count{};
-
-        if constexpr(std::is_same_v<It, basic_iterator>) {
-            while(first != last) {
-                while(first != last && !contains(*first)) {
-                    ++first;
-                }
-
-                const auto it = first;
-
-                while(first != last && contains(*first)) {
-                    ++first;
-                }
-
-                count += std::distance(it, first);
-                erase(it, first);
-            }
-        } else {
-            for(; first != last; ++first) {
-                count += remove(*first);
-            }
-        }
-
-        return count;
-    }
-
-    /*! @brief Removes all tombstones from a sparse set. */
-    void compact() {
-        if(mode == deletion_policy::in_place) {
-            size_type from = packed.size();
-            for(; from && packed[from - 1u] == tombstone; --from) {}
-            underlying_type pos = std::exchange(head, traits_type::entity_mask);
-
-            while(pos != traits_type::to_entity(null)) {
-                if(const auto to = static_cast<size_type>(std::exchange(pos, traits_type::to_entity(packed[pos]))); to < from) {
-                    --from;
-                    swap_or_move(from, to);
-
-                    packed[to] = packed[from];
-                    const auto entity = static_cast<typename traits_type::entity_type>(to);
-                    sparse_ref(packed[to]) = traits_type::combine(entity, traits_type::to_integral(packed[to]));
-
-                    for(; from && packed[from - 1u] == tombstone; --from) {}
-                }
-            }
-
-            packed.erase(packed.begin() + from, packed.end());
-        }
-    }
-
-    /**
-     * @brief Swaps two entities in a sparse set.
-     *
-     * For what it's worth, this function affects both the internal sparse array
-     * and the internal packed array. Users should not care of that anyway.
-     *
-     * @warning
-     * Attempting to swap entities that don't belong to the sparse set results
-     * in undefined behavior.
-     *
-     * @param lhs A valid identifier.
-     * @param rhs A valid identifier.
-     */
-    void swap_elements(const entity_type lhs, const entity_type rhs) {
-        const auto from = index(lhs);
-        const auto to = index(rhs);
-
-        // basic no-leak guarantee if swapping throws
-        swap_or_move(from, to);
-        swap_at(from, to);
-    }
-
-    /**
-     * @brief Sort the first count elements according to the given comparison
-     * function.
-     *
-     * The comparison function object must return `true` if the first element
-     * is _less_ than the second one, `false` otherwise. The signature of the
-     * comparison function should be equivalent to the following:
-     *
-     * @code{.cpp}
-     * bool(const Entity, const Entity);
-     * @endcode
-     *
-     * Moreover, the comparison function object shall induce a
-     * _strict weak ordering_ on the values.
-     *
-     * The sort function object must offer a member function template
-     * `operator()` that accepts three arguments:
-     *
-     * * An iterator to the first element of the range to sort.
-     * * An iterator past the last element of the range to sort.
-     * * A comparison function to use to compare the elements.
-     *
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param length Number of elements to sort.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<typename Compare, typename Sort = std_sort, typename... Args>
-    void sort_n(const size_type length, Compare compare, Sort algo = Sort{}, Args &&...args) {
-        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == traits_type::to_entity(null)), "Sorting with tombstones not allowed");
-        ENTT_ASSERT(!(length > packed.size()), "Length exceeds the number of elements");
-
-        algo(packed.rend() - length, packed.rend(), std::move(compare), std::forward<Args>(args)...);
-
-        for(size_type pos{}; pos < length; ++pos) {
-            auto curr = pos;
-            auto next = index(packed[curr]);
-
-            while(curr != next) {
-                const auto idx = index(packed[next]);
-                const auto entt = packed[curr];
-
-                swap_or_move(next, idx);
-                const auto entity = static_cast<typename traits_type::entity_type>(curr);
-                sparse_ref(entt) = traits_type::combine(entity, traits_type::to_integral(packed[curr]));
-                curr = std::exchange(next, idx);
-            }
-        }
-    }
-
-    /**
-     * @brief Sort all elements according to the given comparison function.
-     *
-     * @sa sort_n
-     *
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
-        sort_n(static_cast<size_type>(end(0) - begin(0)), std::move(compare), std::move(algo), std::forward<Args>(args)...);
-    }
-
-    /**
-     * @brief Sort entities according to their order in a range.
-     *
-     * Entities that are part of both the sparse set and the range are ordered
-     * internally according to the order they have in the range.<br/>
-     * All other entities goes to the end of the sparse set and there are no
-     * guarantees on their order.
-     *
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     */
-    template<typename It>
-    void sort_as(It first, It last) {
-        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == traits_type::to_entity(null)), "Sorting with tombstones not allowed");
-
-        for(auto it = begin(0); it.index() && first != last; ++first) {
-            if(const auto curr = *first; contains(curr)) {
-                if(const auto entt = *it; entt != curr) {
-                    // basic no-leak guarantee (with invalid state) if swapping throws
-                    swap_elements(entt, curr);
-                }
-
-                ++it;
-            }
-        }
-    }
-
-    /**
-     * @copybrief sort_as
-     * @param other The sparse sets that imposes the order of the entities.
-     */
-    [[deprecated("use iterator based sort_as instead")]] void sort_as(const basic_sparse_set &other) {
-        sort_as(other.begin(), other.end());
-    }
-
-    /*! @brief Clears a sparse set. */
-    void clear() {
-        pop_all();
-        // sanity check to avoid subtle issues due to storage classes
-        ENTT_ASSERT((compact(), size()) == 0u, "Non-empty set");
-        head = policy_to_head();
-        packed.clear();
-    }
-
-    /**
-     * @brief Returned value type, if any.
-     * @return Returned value type, if any.
-     */
-    const type_info &type() const noexcept {
-        return *info;
-    }
-
-    /*! @brief Forwards variables to derived classes, if any. */
-    virtual void bind(any) noexcept {}
-
-private:
-    sparse_container_type sparse;
-    packed_container_type packed;
-    const type_info *info;
-    deletion_policy mode;
-    underlying_type head;
+/**
+ * @brief Removes duplicates types from a type list.
+ * @tparam List Type list.
+ */
+template<typename List>
+struct type_list_unique {
+    /*! @brief A type list without duplicate types. */
+    using type = typename internal::type_list_unique<List>::type;
 };
 
-} // namespace entt
-
-#endif
-
-// #include "storage.hpp"
-#ifndef ENTT_ENTITY_STORAGE_HPP
-#define ENTT_ENTITY_STORAGE_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <memory>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-#include <vector>
-// #include "../config/config.h"
-
-// #include "../core/iterator.hpp"
-
-// #include "../core/memory.hpp"
-
-// #include "../core/type_info.hpp"
-
-// #include "component.hpp"
-#ifndef ENTT_ENTITY_COMPONENT_HPP
-#define ENTT_ENTITY_COMPONENT_HPP
-
-#include <cstddef>
-#include <type_traits>
-// #include "../config/config.h"
-
-// #include "fwd.hpp"
-
-
-namespace entt {
-
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
-
-template<typename Type, typename = void>
-struct in_place_delete: std::bool_constant<!(std::is_move_constructible_v<Type> && std::is_move_assignable_v<Type>)> {};
-
-template<>
-struct in_place_delete<void>: std::false_type {};
-
-template<typename Type>
-struct in_place_delete<Type, std::enable_if_t<Type::in_place_delete>>
-    : std::true_type {};
-
-template<typename Type, typename = void>
-struct page_size: std::integral_constant<std::size_t, !std::is_empty_v<ENTT_ETO_TYPE(Type)> * ENTT_PACKED_PAGE> {};
-
-template<>
-struct page_size<void>: std::integral_constant<std::size_t, 0u> {};
+/**
+ * @brief Helper type.
+ * @tparam List Type list.
+ */
+template<typename List>
+using type_list_unique_t = typename type_list_unique<List>::type;
 
-template<typename Type>
-struct page_size<Type, std::void_t<decltype(Type::page_size)>>
-    : std::integral_constant<std::size_t, Type::page_size> {};
+/**
+ * @brief Provides the member constant `value` to true if a type list contains a
+ * given type, false otherwise.
+ * @tparam List Type list.
+ * @tparam Type Type to look for.
+ */
+template<typename List, typename Type>
+struct type_list_contains;
 
-} // namespace internal
-/*! @endcond */
+/**
+ * @copybrief type_list_contains
+ * @tparam Type Types provided by the type list.
+ * @tparam Other Type to look for.
+ */
+template<typename... Type, typename Other>
+struct type_list_contains<type_list<Type...>, Other>
+    : std::bool_constant<(std::is_same_v<Type, Other> || ...)> {};
 
 /**
- * @brief Common way to access various properties of components.
- * @tparam Type Type of component.
+ * @brief Helper variable template.
+ * @tparam List Type list.
+ * @tparam Type Type to look for.
  */
-template<typename Type, typename = void>
-struct component_traits {
-    static_assert(std::is_same_v<std::decay_t<Type>, Type>, "Unsupported type");
+template<typename List, typename Type>
+inline constexpr bool type_list_contains_v = type_list_contains<List, Type>::value;
 
-    /*! @brief Component type. */
-    using type = Type;
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct type_list_diff;
 
-    /*! @brief Pointer stability, default is `false`. */
-    static constexpr bool in_place_delete = internal::in_place_delete<Type>::value;
-    /*! @brief Page size, default is `ENTT_PACKED_PAGE` for non-empty types. */
-    static constexpr std::size_t page_size = internal::page_size<Type>::value;
+/**
+ * @brief Computes the difference between two type lists.
+ * @tparam Type Types provided by the first type list.
+ * @tparam Other Types provided by the second type list.
+ */
+template<typename... Type, typename... Other>
+struct type_list_diff<type_list<Type...>, type_list<Other...>> {
+    /*! @brief A type list that is the difference between the two type lists. */
+    using type = type_list_cat_t<std::conditional_t<type_list_contains_v<type_list<Other...>, Type>, type_list<>, type_list<Type>>...>;
 };
 
-} // namespace entt
-
-#endif
-
-// #include "entity.hpp"
-
-// #include "fwd.hpp"
-
-// #include "sparse_set.hpp"
-
-
-namespace entt {
-
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
-
-template<typename Container, std::size_t Size>
-class storage_iterator final {
-    friend storage_iterator<const Container, Size>;
-
-    using container_type = std::remove_const_t<Container>;
-    using alloc_traits = std::allocator_traits<typename container_type::allocator_type>;
-
-    using iterator_traits = std::iterator_traits<std::conditional_t<
-        std::is_const_v<Container>,
-        typename alloc_traits::template rebind_traits<typename std::pointer_traits<typename container_type::value_type>::element_type>::const_pointer,
-        typename alloc_traits::template rebind_traits<typename std::pointer_traits<typename container_type::value_type>::element_type>::pointer>>;
-
-public:
-    using value_type = typename iterator_traits::value_type;
-    using pointer = typename iterator_traits::pointer;
-    using reference = typename iterator_traits::reference;
-    using difference_type = typename iterator_traits::difference_type;
-    using iterator_category = std::random_access_iterator_tag;
-
-    constexpr storage_iterator() noexcept = default;
-
-    constexpr storage_iterator(Container *ref, const difference_type idx) noexcept
-        : payload{ref},
-          offset{idx} {}
-
-    template<bool Const = std::is_const_v<Container>, typename = std::enable_if_t<Const>>
-    constexpr storage_iterator(const storage_iterator<std::remove_const_t<Container>, Size> &other) noexcept
-        : storage_iterator{other.payload, other.offset} {}
+/**
+ * @brief Helper type.
+ * @tparam List Type lists between which to compute the difference.
+ */
+template<typename... List>
+using type_list_diff_t = typename type_list_diff<List...>::type;
 
-    constexpr storage_iterator &operator++() noexcept {
-        return --offset, *this;
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename, template<typename...> class>
+struct type_list_transform;
 
-    constexpr storage_iterator operator++(int) noexcept {
-        storage_iterator orig = *this;
-        return ++(*this), orig;
-    }
-
-    constexpr storage_iterator &operator--() noexcept {
-        return ++offset, *this;
-    }
-
-    constexpr storage_iterator operator--(int) noexcept {
-        storage_iterator orig = *this;
-        return operator--(), orig;
-    }
-
-    constexpr storage_iterator &operator+=(const difference_type value) noexcept {
-        offset -= value;
-        return *this;
-    }
-
-    constexpr storage_iterator operator+(const difference_type value) const noexcept {
-        storage_iterator copy = *this;
-        return (copy += value);
-    }
-
-    constexpr storage_iterator &operator-=(const difference_type value) noexcept {
-        return (*this += -value);
-    }
-
-    constexpr storage_iterator operator-(const difference_type value) const noexcept {
-        return (*this + -value);
-    }
-
-    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
-        const auto pos = index() - value;
-        return (*payload)[pos / Size][fast_mod(pos, Size)];
-    }
-
-    [[nodiscard]] constexpr pointer operator->() const noexcept {
-        const auto pos = index();
-        return (*payload)[pos / Size] + fast_mod(pos, Size);
-    }
-
-    [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
-    }
-
-    [[nodiscard]] constexpr difference_type index() const noexcept {
-        return offset - 1;
-    }
-
-private:
-    Container *payload;
-    difference_type offset;
-};
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr std::ptrdiff_t operator-(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return rhs.index() - lhs.index();
-}
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator==(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return lhs.index() == rhs.index();
-}
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator!=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return !(lhs == rhs);
-}
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator<(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return lhs.index() > rhs.index();
-}
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator>(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return rhs < lhs;
-}
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator<=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return !(lhs > rhs);
-}
-
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator>=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
-    return !(lhs < rhs);
-}
-
-template<typename It, typename... Other>
-class extended_storage_iterator final {
-    template<typename Iter, typename... Args>
-    friend class extended_storage_iterator;
-
-public:
-    using iterator_type = It;
-    using difference_type = std::ptrdiff_t;
-    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::forward_as_tuple(*std::declval<Other>()...)));
-    using pointer = input_iterator_pointer<value_type>;
-    using reference = value_type;
-    using iterator_category = std::input_iterator_tag;
-    using iterator_concept = std::forward_iterator_tag;
-
-    constexpr extended_storage_iterator()
-        : it{} {}
-
-    constexpr extended_storage_iterator(iterator_type base, Other... other)
-        : it{base, other...} {}
-
-    template<typename... Args, typename = std::enable_if_t<(!std::is_same_v<Other, Args> && ...) && (std::is_constructible_v<Other, Args> && ...)>>
-    constexpr extended_storage_iterator(const extended_storage_iterator<It, Args...> &other)
-        : it{other.it} {}
-
-    constexpr extended_storage_iterator &operator++() noexcept {
-        return ++std::get<It>(it), (++std::get<Other>(it), ...), *this;
-    }
-
-    constexpr extended_storage_iterator operator++(int) noexcept {
-        extended_storage_iterator orig = *this;
-        return ++(*this), orig;
-    }
-
-    [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return operator*();
-    }
-
-    [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {*std::get<It>(it), *std::get<Other>(it)...};
-    }
-
-    [[nodiscard]] constexpr iterator_type base() const noexcept {
-        return std::get<It>(it);
-    }
-
-    template<typename... Lhs, typename... Rhs>
-    friend constexpr bool operator==(const extended_storage_iterator<Lhs...> &, const extended_storage_iterator<Rhs...> &) noexcept;
-
-private:
-    std::tuple<It, Other...> it;
-};
-
-template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator==(const extended_storage_iterator<Lhs...> &lhs, const extended_storage_iterator<Rhs...> &rhs) noexcept {
-    return std::get<0>(lhs.it) == std::get<0>(rhs.it);
-}
-
-template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator!=(const extended_storage_iterator<Lhs...> &lhs, const extended_storage_iterator<Rhs...> &rhs) noexcept {
-    return !(lhs == rhs);
-}
-
-} // namespace internal
-/*! @endcond */
+/**
+ * @brief Applies a given _function_ to a type list and generate a new list.
+ * @tparam Type Types provided by the type list.
+ * @tparam Op Unary operation as template class with a type member named `type`.
+ */
+template<typename... Type, template<typename...> class Op>
+struct type_list_transform<type_list<Type...>, Op> {
+    /*! @brief Resulting type list after applying the transform function. */
+    using type = type_list<typename Op<Type>::type...>;
+};
 
 /**
- * @brief Basic storage implementation.
- *
- * Internal data structures arrange elements to maximize performance. There are
- * no guarantees that objects are returned in the insertion order when iterate
- * a storage. Do not make assumption on the order in any case.
- *
- * @warning
- * Empty types aren't explicitly instantiated. Therefore, many of the functions
- * normally available for non-empty types will not be available for empty ones.
- *
- * @tparam Type Type of objects assigned to the entities.
- * @tparam Entity A valid entity type.
- * @tparam Allocator Type of allocator used to manage memory and elements.
+ * @brief Helper type.
+ * @tparam List Type list.
+ * @tparam Op Unary operation as template class with a type member named `type`.
  */
-template<typename Type, typename Entity, typename Allocator, typename>
-class basic_storage: public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
-    using alloc_traits = std::allocator_traits<Allocator>;
-    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
-    using container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
-    using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
-    using underlying_iterator = typename underlying_type::basic_iterator;
-
-    [[nodiscard]] auto &element_at(const std::size_t pos) const {
-        return payload[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
-    }
-
-    auto assure_at_least(const std::size_t pos) {
-        const auto idx = pos / traits_type::page_size;
-
-        if(!(idx < payload.size())) {
-            auto curr = payload.size();
-            allocator_type allocator{get_allocator()};
-            payload.resize(idx + 1u, nullptr);
-
-            ENTT_TRY {
-                for(const auto last = payload.size(); curr < last; ++curr) {
-                    payload[curr] = alloc_traits::allocate(allocator, traits_type::page_size);
-                }
-            }
-            ENTT_CATCH {
-                payload.resize(curr);
-                ENTT_THROW;
-            }
-        }
-
-        return payload[idx] + fast_mod(pos, traits_type::page_size);
-    }
-
-    template<typename... Args>
-    auto emplace_element(const Entity entt, const bool force_back, Args &&...args) {
-        const auto it = base_type::try_emplace(entt, force_back);
-
-        ENTT_TRY {
-            auto elem = assure_at_least(static_cast<size_type>(it.index()));
-            entt::uninitialized_construct_using_allocator(to_address(elem), get_allocator(), std::forward<Args>(args)...);
-        }
-        ENTT_CATCH {
-            base_type::pop(it, it + 1u);
-            ENTT_THROW;
-        }
-
-        return it;
-    }
-
-    void shrink_to_size(const std::size_t sz) {
-        const auto from = (sz + traits_type::page_size - 1u) / traits_type::page_size;
-        allocator_type allocator{get_allocator()};
-
-        for(auto pos = sz, length = base_type::size(); pos < length; ++pos) {
-            if constexpr(traits_type::in_place_delete) {
-                if(base_type::data()[pos] != tombstone) {
-                    alloc_traits::destroy(allocator, std::addressof(element_at(pos)));
-                }
-            } else {
-                alloc_traits::destroy(allocator, std::addressof(element_at(pos)));
-            }
-        }
-
-        for(auto pos = from, last = payload.size(); pos < last; ++pos) {
-            alloc_traits::deallocate(allocator, payload[pos], traits_type::page_size);
-        }
-
-        payload.resize(from);
-    }
-
-private:
-    const void *get_at(const std::size_t pos) const final {
-        return std::addressof(element_at(pos));
-    }
-
-    void swap_or_move([[maybe_unused]] const std::size_t from, [[maybe_unused]] const std::size_t to) override {
-        static constexpr bool is_pinned_type_v = !(std::is_move_constructible_v<Type> && std::is_move_assignable_v<Type>);
-        // use a runtime value to avoid compile-time suppression that drives the code coverage tool crazy
-        ENTT_ASSERT((from + 1u) && !is_pinned_type_v, "Pinned type");
-
-        if constexpr(!is_pinned_type_v) {
-            auto &elem = element_at(from);
-
-            if constexpr(traits_type::in_place_delete) {
-                if(base_type::operator[](to) == tombstone) {
-                    allocator_type allocator{get_allocator()};
-                    entt::uninitialized_construct_using_allocator(to_address(assure_at_least(to)), allocator, std::move(elem));
-                    alloc_traits::destroy(allocator, std::addressof(elem));
-                    return;
-                }
-            }
-
-            using std::swap;
-            swap(elem, element_at(to));
-        }
-    }
-
-protected:
-    /**
-     * @brief Erases entities from a storage.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     */
-    void pop(underlying_iterator first, underlying_iterator last) override {
-        for(allocator_type allocator{get_allocator()}; first != last; ++first) {
-            // cannot use first.index() because it would break with cross iterators
-            auto &elem = element_at(base_type::index(*first));
-
-            if constexpr(traits_type::in_place_delete) {
-                base_type::in_place_pop(first);
-                alloc_traits::destroy(allocator, std::addressof(elem));
-            } else {
-                auto &other = element_at(base_type::size() - 1u);
-                // destroying on exit allows reentrant destructors
-                [[maybe_unused]] auto unused = std::exchange(elem, std::move(other));
-                alloc_traits::destroy(allocator, std::addressof(other));
-                base_type::swap_and_pop(first);
-            }
-        }
-    }
-
-    /*! @brief Erases all entities of a storage. */
-    void pop_all() override {
-        allocator_type allocator{get_allocator()};
-
-        for(auto first = base_type::begin(); !(first.index() < 0); ++first) {
-            if constexpr(traits_type::in_place_delete) {
-                if(*first != tombstone) {
-                    base_type::in_place_pop(first);
-                    alloc_traits::destroy(allocator, std::addressof(element_at(static_cast<size_type>(first.index()))));
-                }
-            } else {
-                base_type::swap_and_pop(first);
-                alloc_traits::destroy(allocator, std::addressof(element_at(static_cast<size_type>(first.index()))));
-            }
-        }
-    }
-
-    /**
-     * @brief Assigns an entity to a storage.
-     * @param entt A valid identifier.
-     * @param value Optional opaque value.
-     * @param force_back Force back insertion.
-     * @return Iterator pointing to the emplaced element.
-     */
-    underlying_iterator try_emplace([[maybe_unused]] const Entity entt, [[maybe_unused]] const bool force_back, const void *value) override {
-        if(value) {
-            if constexpr(std::is_copy_constructible_v<value_type>) {
-                return emplace_element(entt, force_back, *static_cast<const value_type *>(value));
-            } else {
-                return base_type::end();
-            }
-        } else {
-            if constexpr(std::is_default_constructible_v<value_type>) {
-                return emplace_element(entt, force_back);
-            } else {
-                return base_type::end();
-            }
-        }
-    }
-
-public:
-    /*! @brief Base type. */
-    using base_type = underlying_type;
-    /*! @brief Type of the objects assigned to entities. */
-    using value_type = Type;
-    /*! @brief Component traits. */
-    using traits_type = component_traits<value_type>;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = Entity;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
-    /*! @brief Pointer type to contained elements. */
-    using pointer = typename container_type::pointer;
-    /*! @brief Constant pointer type to contained elements. */
-    using const_pointer = typename alloc_traits::template rebind_traits<typename alloc_traits::const_pointer>::const_pointer;
-    /*! @brief Random access iterator type. */
-    using iterator = internal::storage_iterator<container_type, traits_type::page_size>;
-    /*! @brief Constant random access iterator type. */
-    using const_iterator = internal::storage_iterator<const container_type, traits_type::page_size>;
-    /*! @brief Reverse iterator type. */
-    using reverse_iterator = std::reverse_iterator<iterator>;
-    /*! @brief Constant reverse iterator type. */
-    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
-    /*! @brief Extended iterable storage proxy. */
-    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator, iterator>>;
-    /*! @brief Constant extended iterable storage proxy. */
-    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator, const_iterator>>;
-    /*! @brief Extended reverse iterable storage proxy. */
-    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator, reverse_iterator>>;
-    /*! @brief Constant extended reverse iterable storage proxy. */
-    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator, const_reverse_iterator>>;
-
-    /*! @brief Default constructor. */
-    basic_storage()
-        : basic_storage{allocator_type{}} {}
-
-    /**
-     * @brief Constructs an empty storage with a given allocator.
-     * @param allocator The allocator to use.
-     */
-    explicit basic_storage(const allocator_type &allocator)
-        : base_type{type_id<value_type>(), deletion_policy{traits_type::in_place_delete}, allocator},
-          payload{allocator} {}
-
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    basic_storage(basic_storage &&other) noexcept
-        : base_type{std::move(other)},
-          payload{std::move(other.payload)} {}
-
-    /**
-     * @brief Allocator-extended move constructor.
-     * @param other The instance to move from.
-     * @param allocator The allocator to use.
-     */
-    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
-        : base_type{std::move(other), allocator},
-          payload{std::move(other.payload), allocator} {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || payload.get_allocator() == other.payload.get_allocator(), "Copying a storage is not allowed");
-    }
-
-    /*! @brief Default destructor. */
-    ~basic_storage() override {
-        shrink_to_size(0u);
-    }
-
-    /**
-     * @brief Move assignment operator.
-     * @param other The instance to move from.
-     * @return This storage.
-     */
-    basic_storage &operator=(basic_storage &&other) noexcept {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || payload.get_allocator() == other.payload.get_allocator(), "Copying a storage is not allowed");
-
-        shrink_to_size(0u);
-        base_type::operator=(std::move(other));
-        payload = std::move(other.payload);
-        return *this;
-    }
-
-    /**
-     * @brief Exchanges the contents with those of a given storage.
-     * @param other Storage to exchange the content with.
-     */
-    void swap(basic_storage &other) {
-        using std::swap;
-        base_type::swap(other);
-        swap(payload, other.payload);
-    }
-
-    /**
-     * @brief Returns the associated allocator.
-     * @return The associated allocator.
-     */
-    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
-        return payload.get_allocator();
-    }
-
-    /**
-     * @brief Increases the capacity of a storage.
-     *
-     * If the new capacity is greater than the current capacity, new storage is
-     * allocated, otherwise the method does nothing.
-     *
-     * @param cap Desired capacity.
-     */
-    void reserve(const size_type cap) override {
-        if(cap != 0u) {
-            base_type::reserve(cap);
-            assure_at_least(cap - 1u);
-        }
-    }
-
-    /**
-     * @brief Returns the number of elements that a storage has currently
-     * allocated space for.
-     * @return Capacity of the storage.
-     */
-    [[nodiscard]] size_type capacity() const noexcept override {
-        return payload.size() * traits_type::page_size;
-    }
-
-    /*! @brief Requests the removal of unused capacity. */
-    void shrink_to_fit() override {
-        base_type::shrink_to_fit();
-        shrink_to_size(base_type::size());
-    }
-
-    /**
-     * @brief Direct access to the array of objects.
-     * @return A pointer to the array of objects.
-     */
-    [[nodiscard]] const_pointer raw() const noexcept {
-        return payload.data();
-    }
-
-    /*! @copydoc raw */
-    [[nodiscard]] pointer raw() noexcept {
-        return payload.data();
-    }
-
-    /**
-     * @brief Returns an iterator to the beginning.
-     *
-     * If the storage is empty, the returned iterator will be equal to `end()`.
-     *
-     * @return An iterator to the first instance of the internal array.
-     */
-    [[nodiscard]] const_iterator cbegin() const noexcept {
-        const auto pos = static_cast<typename iterator::difference_type>(base_type::size());
-        return const_iterator{&payload, pos};
-    }
-
-    /*! @copydoc cbegin */
-    [[nodiscard]] const_iterator begin() const noexcept {
-        return cbegin();
-    }
-
-    /*! @copydoc begin */
-    [[nodiscard]] iterator begin() noexcept {
-        const auto pos = static_cast<typename iterator::difference_type>(base_type::size());
-        return iterator{&payload, pos};
-    }
-
-    /**
-     * @brief Returns an iterator to the end.
-     * @return An iterator to the element following the last instance of the
-     * internal array.
-     */
-    [[nodiscard]] const_iterator cend() const noexcept {
-        return const_iterator{&payload, {}};
-    }
-
-    /*! @copydoc cend */
-    [[nodiscard]] const_iterator end() const noexcept {
-        return cend();
-    }
-
-    /*! @copydoc end */
-    [[nodiscard]] iterator end() noexcept {
-        return iterator{&payload, {}};
-    }
-
-    /**
-     * @brief Returns a reverse iterator to the beginning.
-     *
-     * If the storage is empty, the returned iterator will be equal to `rend()`.
-     *
-     * @return An iterator to the first instance of the reversed internal array.
-     */
-    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
-        return std::make_reverse_iterator(cend());
-    }
-
-    /*! @copydoc crbegin */
-    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
-        return crbegin();
-    }
-
-    /*! @copydoc rbegin */
-    [[nodiscard]] reverse_iterator rbegin() noexcept {
-        return std::make_reverse_iterator(end());
-    }
-
-    /**
-     * @brief Returns a reverse iterator to the end.
-     * @return An iterator to the element following the last instance of the
-     * reversed internal array.
-     */
-    [[nodiscard]] const_reverse_iterator crend() const noexcept {
-        return std::make_reverse_iterator(cbegin());
-    }
-
-    /*! @copydoc crend */
-    [[nodiscard]] const_reverse_iterator rend() const noexcept {
-        return crend();
-    }
-
-    /*! @copydoc rend */
-    [[nodiscard]] reverse_iterator rend() noexcept {
-        return std::make_reverse_iterator(begin());
-    }
-
-    /**
-     * @brief Returns the object assigned to an entity.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @return The object assigned to the entity.
-     */
-    [[nodiscard]] const value_type &get(const entity_type entt) const noexcept {
-        return element_at(base_type::index(entt));
-    }
-
-    /*! @copydoc get */
-    [[nodiscard]] value_type &get(const entity_type entt) noexcept {
-        return const_cast<value_type &>(std::as_const(*this).get(entt));
-    }
-
-    /**
-     * @brief Returns the object assigned to an entity as a tuple.
-     * @param entt A valid identifier.
-     * @return The object assigned to the entity as a tuple.
-     */
-    [[nodiscard]] std::tuple<const value_type &> get_as_tuple(const entity_type entt) const noexcept {
-        return std::forward_as_tuple(get(entt));
-    }
-
-    /*! @copydoc get_as_tuple */
-    [[nodiscard]] std::tuple<value_type &> get_as_tuple(const entity_type entt) noexcept {
-        return std::forward_as_tuple(get(entt));
-    }
-
-    /**
-     * @brief Assigns an entity to a storage and constructs its object.
-     *
-     * @warning
-     * Attempting to use an entity that already belongs to the storage results
-     * in undefined behavior.
-     *
-     * @tparam Args Types of arguments to use to construct the object.
-     * @param entt A valid identifier.
-     * @param args Parameters to use to construct an object for the entity.
-     * @return A reference to the newly created object.
-     */
-    template<typename... Args>
-    value_type &emplace(const entity_type entt, Args &&...args) {
-        if constexpr(std::is_aggregate_v<value_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<value_type>)) {
-            const auto it = emplace_element(entt, false, Type{std::forward<Args>(args)...});
-            return element_at(static_cast<size_type>(it.index()));
-        } else {
-            const auto it = emplace_element(entt, false, std::forward<Args>(args)...);
-            return element_at(static_cast<size_type>(it.index()));
-        }
-    }
-
-    /**
-     * @brief Updates the instance assigned to a given entity in-place.
-     * @tparam Func Types of the function objects to invoke.
-     * @param entt A valid identifier.
-     * @param func Valid function objects.
-     * @return A reference to the updated instance.
-     */
-    template<typename... Func>
-    value_type &patch(const entity_type entt, Func &&...func) {
-        const auto idx = base_type::index(entt);
-        auto &elem = element_at(idx);
-        (std::forward<Func>(func)(elem), ...);
-        return elem;
-    }
-
-    /**
-     * @brief Assigns one or more entities to a storage and constructs their
-     * objects from a given instance.
-     *
-     * @warning
-     * Attempting to assign an entity that already belongs to the storage
-     * results in undefined behavior.
-     *
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     * @param value An instance of the object to construct.
-     * @return Iterator pointing to the last element inserted, if any.
-     */
-    template<typename It>
-    iterator insert(It first, It last, const value_type &value = {}) {
-        for(; first != last; ++first) {
-            emplace_element(*first, true, value);
-        }
-
-        return begin();
-    }
-
-    /**
-     * @brief Assigns one or more entities to a storage and constructs their
-     * objects from a given range.
-     *
-     * @sa construct
-     *
-     * @tparam EIt Type of input iterator.
-     * @tparam CIt Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     * @param from An iterator to the first element of the range of objects.
-     * @return Iterator pointing to the first element inserted, if any.
-     */
-    template<typename EIt, typename CIt, typename = std::enable_if_t<std::is_same_v<typename std::iterator_traits<CIt>::value_type, value_type>>>
-    iterator insert(EIt first, EIt last, CIt from) {
-        for(; first != last; ++first, ++from) {
-            emplace_element(*first, true, *from);
-        }
-
-        return begin();
-    }
-
-    /**
-     * @brief Returns an iterable object to use to _visit_ a storage.
-     *
-     * The iterable object returns a tuple that contains the current entity and
-     * a reference to its component.
-     *
-     * @return An iterable object to use to _visit_ the storage.
-     */
-    [[nodiscard]] iterable each() noexcept {
-        return {internal::extended_storage_iterator{base_type::begin(), begin()}, internal::extended_storage_iterator{base_type::end(), end()}};
-    }
-
-    /*! @copydoc each */
-    [[nodiscard]] const_iterable each() const noexcept {
-        return {internal::extended_storage_iterator{base_type::cbegin(), cbegin()}, internal::extended_storage_iterator{base_type::cend(), cend()}};
-    }
-
-    /**
-     * @brief Returns a reverse iterable object to use to _visit_ a storage.
-     *
-     * @sa each
-     *
-     * @return A reverse iterable object to use to _visit_ the storage.
-     */
-    [[nodiscard]] reverse_iterable reach() noexcept {
-        return {internal::extended_storage_iterator{base_type::rbegin(), rbegin()}, internal::extended_storage_iterator{base_type::rend(), rend()}};
-    }
-
-    /*! @copydoc reach */
-    [[nodiscard]] const_reverse_iterable reach() const noexcept {
-        return {internal::extended_storage_iterator{base_type::crbegin(), crbegin()}, internal::extended_storage_iterator{base_type::crend(), crend()}};
-    }
-
-private:
-    container_type payload;
-};
-
-/*! @copydoc basic_storage */
-template<typename Type, typename Entity, typename Allocator>
-class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<Type>::page_size == 0u>>
-    : public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
-    using alloc_traits = std::allocator_traits<Allocator>;
-    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
-
-public:
-    /*! @brief Base type. */
-    using base_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
-    /*! @brief Type of the objects assigned to entities. */
-    using value_type = Type;
-    /*! @brief Component traits. */
-    using traits_type = component_traits<value_type>;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = Entity;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
-    /*! @brief Extended iterable storage proxy. */
-    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
-    /*! @brief Constant extended iterable storage proxy. */
-    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator>>;
-    /*! @brief Extended reverse iterable storage proxy. */
-    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
-    /*! @brief Constant extended reverse iterable storage proxy. */
-    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;
-
-    /*! @brief Default constructor. */
-    basic_storage()
-        : basic_storage{allocator_type{}} {}
-
-    /**
-     * @brief Constructs an empty container with a given allocator.
-     * @param allocator The allocator to use.
-     */
-    explicit basic_storage(const allocator_type &allocator)
-        : base_type{type_id<value_type>(), deletion_policy{traits_type::in_place_delete}, allocator} {}
-
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    basic_storage(basic_storage &&other) noexcept = default;
-
-    /**
-     * @brief Allocator-extended move constructor.
-     * @param other The instance to move from.
-     * @param allocator The allocator to use.
-     */
-    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
-        : base_type{std::move(other), allocator} {}
-
-    /**
-     * @brief Move assignment operator.
-     * @param other The instance to move from.
-     * @return This storage.
-     */
-    basic_storage &operator=(basic_storage &&other) noexcept = default;
+template<typename List, template<typename...> class Op>
+using type_list_transform_t = typename type_list_transform<List, Op>::type;
 
-    /**
-     * @brief Returns the associated allocator.
-     * @return The associated allocator.
-     */
-    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
-        // std::allocator<void> has no cross constructors (waiting for C++20)
-        if constexpr(std::is_void_v<value_type> && !std::is_constructible_v<allocator_type, typename base_type::allocator_type>) {
-            return allocator_type{};
-        } else {
-            return allocator_type{base_type::get_allocator()};
-        }
-    }
+/**
+ * @brief A class to use to push around lists of constant values, nothing more.
+ * @tparam Value Values provided by the value list.
+ */
+template<auto... Value>
+struct value_list {
+    /*! @brief Value list type. */
+    using type = value_list;
+    /*! @brief Compile-time number of elements in the value list. */
+    static constexpr auto size = sizeof...(Value);
+};
 
-    /**
-     * @brief Returns the object assigned to an entity, that is `void`.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
-     * @param entt A valid identifier.
-     */
-    void get([[maybe_unused]] const entity_type entt) const noexcept {
-        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<std::size_t, typename>
+struct value_list_element;
 
-    /**
-     * @brief Returns an empty tuple.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @return Returns an empty tuple.
-     */
-    [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
-        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
-        return std::tuple{};
-    }
+/**
+ * @brief Provides compile-time indexed access to the values of a value list.
+ * @tparam Index Index of the value to return.
+ * @tparam Value First value provided by the value list.
+ * @tparam Other Other values provided by the value list.
+ */
+template<std::size_t Index, auto Value, auto... Other>
+struct value_list_element<Index, value_list<Value, Other...>>
+    : value_list_element<Index - 1u, value_list<Other...>> {};
 
-    /**
-     * @brief Assigns an entity to a storage and constructs its object.
-     *
-     * @warning
-     * Attempting to use an entity that already belongs to the storage results
-     * in undefined behavior.
-     *
-     * @tparam Args Types of arguments to use to construct the object.
-     * @param entt A valid identifier.
-     */
-    template<typename... Args>
-    void emplace(const entity_type entt, Args &&...) {
-        base_type::try_emplace(entt, false);
-    }
+/**
+ * @brief Provides compile-time indexed access to the types of a type list.
+ * @tparam Value First value provided by the value list.
+ * @tparam Other Other values provided by the value list.
+ */
+template<auto Value, auto... Other>
+struct value_list_element<0u, value_list<Value, Other...>> {
+    /*! @brief Searched type. */
+    using type = decltype(Value);
+    /*! @brief Searched value. */
+    static constexpr auto value = Value;
+};
 
-    /**
-     * @brief Updates the instance assigned to a given entity in-place.
-     * @tparam Func Types of the function objects to invoke.
-     * @param entt A valid identifier.
-     * @param func Valid function objects.
-     */
-    template<typename... Func>
-    void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
-        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
-        (std::forward<Func>(func)(), ...);
-    }
+/**
+ * @brief Helper type.
+ * @tparam Index Index of the type to return.
+ * @tparam List Value list to search into.
+ */
+template<std::size_t Index, typename List>
+using value_list_element_t = typename value_list_element<Index, List>::type;
 
-    /**
-     * @brief Assigns entities to a storage.
-     * @tparam It Type of input iterator.
-     * @tparam Args Types of optional arguments.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
-     */
-    template<typename It, typename... Args>
-    void insert(It first, It last, Args &&...) {
-        for(; first != last; ++first) {
-            base_type::try_emplace(*first, true);
-        }
-    }
+/**
+ * @brief Helper type.
+ * @tparam Index Index of the value to return.
+ * @tparam List Value list to search into.
+ */
+template<std::size_t Index, typename List>
+inline constexpr auto value_list_element_v = value_list_element<Index, List>::value;
 
-    /**
-     * @brief Returns an iterable object to use to _visit_ a storage.
-     *
-     * The iterable object returns a tuple that contains the current entity.
-     *
-     * @return An iterable object to use to _visit_ the storage.
-     */
-    [[nodiscard]] iterable each() noexcept {
-        return {internal::extended_storage_iterator{base_type::begin()}, internal::extended_storage_iterator{base_type::end()}};
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<auto, typename>
+struct value_list_index;
 
-    /*! @copydoc each */
-    [[nodiscard]] const_iterable each() const noexcept {
-        return {internal::extended_storage_iterator{base_type::cbegin()}, internal::extended_storage_iterator{base_type::cend()}};
-    }
+/**
+ * @brief Provides compile-time type access to the values of a value list.
+ * @tparam Value Value to look for and for which to return the index.
+ * @tparam First First value provided by the value list.
+ * @tparam Other Other values provided by the value list.
+ */
+template<auto Value, auto First, auto... Other>
+struct value_list_index<Value, value_list<First, Other...>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given value in the sublist. */
+    static constexpr value_type value = 1u + value_list_index<Value, value_list<Other...>>::value;
+};
 
-    /**
-     * @brief Returns a reverse iterable object to use to _visit_ a storage.
-     *
-     * @sa each
-     *
-     * @return A reverse iterable object to use to _visit_ the storage.
-     */
-    [[nodiscard]] reverse_iterable reach() noexcept {
-        return {internal::extended_storage_iterator{base_type::rbegin()}, internal::extended_storage_iterator{base_type::rend()}};
-    }
+/**
+ * @brief Provides compile-time type access to the values of a value list.
+ * @tparam Value Value to look for and for which to return the index.
+ * @tparam Other Other values provided by the value list.
+ */
+template<auto Value, auto... Other>
+struct value_list_index<Value, value_list<Value, Other...>> {
+    static_assert(value_list_index<Value, value_list<Other...>>::value == sizeof...(Other), "Non-unique type");
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given value in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    /*! @copydoc reach */
-    [[nodiscard]] const_reverse_iterable reach() const noexcept {
-        return {internal::extended_storage_iterator{base_type::crbegin()}, internal::extended_storage_iterator{base_type::crend()}};
-    }
+/**
+ * @brief Provides compile-time type access to the values of a value list.
+ * @tparam Value Value to look for and for which to return the index.
+ */
+template<auto Value>
+struct value_list_index<Value, value_list<>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 0u;
 };
 
 /**
- * @brief Swap-only entity storage specialization.
- * @tparam Entity A valid entity type.
- * @tparam Allocator Type of allocator used to manage memory and elements.
+ * @brief Helper variable template.
+ * @tparam List Value list.
+ * @tparam Value Value to look for and for which to return the index.
  */
-template<typename Entity, typename Allocator>
-class basic_storage<Entity, Entity, Allocator>
-    : public basic_sparse_set<Entity, Allocator> {
-    using alloc_traits = std::allocator_traits<Allocator>;
-    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
-    using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
-    using underlying_iterator = typename underlying_type::basic_iterator;
+template<auto Value, typename List>
+inline constexpr std::size_t value_list_index_v = value_list_index<Value, List>::value;
 
-    auto entity_at(const std::size_t pos) const noexcept {
-        ENTT_ASSERT(pos < underlying_type::traits_type::to_entity(null), "Invalid element");
-        return underlying_type::traits_type::combine(static_cast<typename underlying_type::traits_type::entity_type>(pos), {});
-    }
+/**
+ * @brief Concatenates multiple value lists.
+ * @tparam Value Values provided by the first value list.
+ * @tparam Other Values provided by the second value list.
+ * @return A value list composed by the values of both the value lists.
+ */
+template<auto... Value, auto... Other>
+constexpr value_list<Value..., Other...> operator+(value_list<Value...>, value_list<Other...>) {
+    return {};
+}
 
-protected:
-    /**
-     * @brief Assigns an entity to a storage.
-     * @param hint A valid identifier.
-     * @return Iterator pointing to the emplaced element.
-     */
-    underlying_iterator try_emplace(const Entity hint, const bool, const void *) override {
-        return base_type::find(emplace(hint));
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct value_list_cat;
 
-public:
-    /*! @brief Base type. */
-    using base_type = basic_sparse_set<Entity, Allocator>;
-    /*! @brief Type of the objects assigned to entities. */
-    using value_type = Entity;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = Entity;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
-    /*! @brief Extended iterable storage proxy. */
-    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
-    /*! @brief Constant extended iterable storage proxy. */
-    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator>>;
-    /*! @brief Extended reverse iterable storage proxy. */
-    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
-    /*! @brief Constant extended reverse iterable storage proxy. */
-    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;
+/*! @brief Concatenates multiple value lists. */
+template<>
+struct value_list_cat<> {
+    /*! @brief A value list composed by the values of all the value lists. */
+    using type = value_list<>;
+};
 
-    /*! @brief Default constructor. */
-    basic_storage()
-        : basic_storage{allocator_type{}} {
-    }
+/**
+ * @brief Concatenates multiple value lists.
+ * @tparam Value Values provided by the first value list.
+ * @tparam Other Values provided by the second value list.
+ * @tparam List Other value lists, if any.
+ */
+template<auto... Value, auto... Other, typename... List>
+struct value_list_cat<value_list<Value...>, value_list<Other...>, List...> {
+    /*! @brief A value list composed by the values of all the value lists. */
+    using type = typename value_list_cat<value_list<Value..., Other...>, List...>::type;
+};
 
-    /**
-     * @brief Constructs an empty container with a given allocator.
-     * @param allocator The allocator to use.
-     */
-    explicit basic_storage(const allocator_type &allocator)
-        : base_type{type_id<void>(), deletion_policy::swap_only, allocator} {}
+/**
+ * @brief Concatenates multiple value lists.
+ * @tparam Value Values provided by the value list.
+ */
+template<auto... Value>
+struct value_list_cat<value_list<Value...>> {
+    /*! @brief A value list composed by the values of all the value lists. */
+    using type = value_list<Value...>;
+};
 
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    basic_storage(basic_storage &&other) noexcept
-        : base_type{std::move(other)} {}
+/**
+ * @brief Helper type.
+ * @tparam List Value lists to concatenate.
+ */
+template<typename... List>
+using value_list_cat_t = typename value_list_cat<List...>::type;
 
-    /**
-     * @brief Allocator-extended move constructor.
-     * @param other The instance to move from.
-     * @param allocator The allocator to use.
-     */
-    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
-        : base_type{std::move(other), allocator} {}
+/*! @brief Primary template isn't defined on purpose. */
+template<typename>
+struct value_list_unique;
 
-    /**
-     * @brief Move assignment operator.
-     * @param other The instance to move from.
-     * @return This storage.
-     */
-    basic_storage &operator=(basic_storage &&other) noexcept {
-        base_type::operator=(std::move(other));
-        return *this;
-    }
+/**
+ * @brief Removes duplicates values from a value list.
+ * @tparam Value One of the values provided by the given value list.
+ * @tparam Other The other values provided by the given value list.
+ */
+template<auto Value, auto... Other>
+struct value_list_unique<value_list<Value, Other...>> {
+    /*! @brief A value list without duplicate types. */
+    using type = std::conditional_t<
+        ((Value == Other) || ...),
+        typename value_list_unique<value_list<Other...>>::type,
+        value_list_cat_t<value_list<Value>, typename value_list_unique<value_list<Other...>>::type>>;
+};
 
-    /**
-     * @brief Returns the object assigned to an entity, that is `void`.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
-     * @param entt A valid identifier.
-     */
-    void get([[maybe_unused]] const entity_type entt) const noexcept {
-        ENTT_ASSERT(base_type::index(entt) < base_type::free_list(), "The requested entity is not a live one");
-    }
+/*! @brief Removes duplicates values from a value list. */
+template<>
+struct value_list_unique<value_list<>> {
+    /*! @brief A value list without duplicate types. */
+    using type = value_list<>;
+};
 
-    /**
-     * @brief Returns an empty tuple.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
-     * @param entt A valid identifier.
-     * @return Returns an empty tuple.
-     */
-    [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
-        ENTT_ASSERT(base_type::index(entt) < base_type::free_list(), "The requested entity is not a live one");
-        return std::tuple{};
-    }
+/**
+ * @brief Helper type.
+ * @tparam Type A value list.
+ */
+template<typename Type>
+using value_list_unique_t = typename value_list_unique<Type>::type;
 
-    /**
-     * @brief Creates a new identifier or recycles a destroyed one.
-     * @return A valid identifier.
-     */
-    entity_type emplace() {
-        const auto len = base_type::free_list();
-        const auto entt = (len == base_type::size()) ? entity_at(len) : base_type::data()[len];
-        return *base_type::try_emplace(entt, true);
-    }
+/**
+ * @brief Provides the member constant `value` to true if a value list contains
+ * a given value, false otherwise.
+ * @tparam List Value list.
+ * @tparam Value Value to look for.
+ */
+template<typename List, auto Value>
+struct value_list_contains;
 
-    /**
-     * @brief Creates a new identifier or recycles a destroyed one.
-     *
-     * If the requested identifier isn't in use, the suggested one is used.
-     * Otherwise, a new identifier is returned.
-     *
-     * @param hint Required identifier.
-     * @return A valid identifier.
-     */
-    entity_type emplace(const entity_type hint) {
-        if(hint == null || hint == tombstone) {
-            return emplace();
-        } else if(const auto curr = underlying_type::traits_type::construct(underlying_type::traits_type::to_entity(hint), base_type::current(hint)); curr == tombstone) {
-            const auto pos = static_cast<size_type>(underlying_type::traits_type::to_entity(hint));
-            const auto entt = *base_type::try_emplace(hint, true);
-
-            while(!(pos < base_type::size())) {
-                base_type::try_emplace(entity_at(base_type::size() - 1u), false);
-            }
+/**
+ * @copybrief value_list_contains
+ * @tparam Value Values provided by the value list.
+ * @tparam Other Value to look for.
+ */
+template<auto... Value, auto Other>
+struct value_list_contains<value_list<Value...>, Other>
+    : std::bool_constant<((Value == Other) || ...)> {};
 
-            return entt;
-        } else if(const auto idx = base_type::index(curr); idx < base_type::free_list()) {
-            return emplace();
-        } else {
-            return *base_type::try_emplace(hint, true);
-        }
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam List Value list.
+ * @tparam Value Value to look for.
+ */
+template<typename List, auto Value>
+inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::value;
 
-    /**
-     * @brief Updates a given identifier.
-     * @tparam Func Types of the function objects to invoke.
-     * @param entt A valid identifier.
-     * @param func Valid function objects.
-     */
-    template<typename... Func>
-    void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
-        ENTT_ASSERT(base_type::index(entt) < base_type::free_list(), "The requested entity is not a live one");
-        (std::forward<Func>(func)(), ...);
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct value_list_diff;
 
-    /**
-     * @brief Assigns each element in a range an identifier.
-     * @tparam It Type of mutable forward iterator.
-     * @param first An iterator to the first element of the range to generate.
-     * @param last An iterator past the last element of the range to generate.
-     */
-    template<typename It>
-    void insert(It first, It last) {
-        for(const auto sz = base_type::size(); first != last && base_type::free_list() != sz; ++first) {
-            *first = *base_type::try_emplace(base_type::data()[base_type::free_list()], true);
-        }
+/**
+ * @brief Computes the difference between two value lists.
+ * @tparam Value Values provided by the first value list.
+ * @tparam Other Values provided by the second value list.
+ */
+template<auto... Value, auto... Other>
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
+    /*! @brief A value list that is the difference between the two value lists. */
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
+};
 
-        for(; first != last; ++first) {
-            *first = *base_type::try_emplace(entity_at(base_type::free_list()), true);
-        }
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Value lists between which to compute the difference.
+ */
+template<typename... List>
+using value_list_diff_t = typename value_list_diff<List...>::type;
 
-    /**
-     * @brief Makes all elements in a range contiguous.
-     * @tparam It Type of forward iterator.
-     * @param first An iterator to the first element of the range to pack.
-     * @param last An iterator past the last element of the range to pack.
-     * @return The number of elements within the newly created range.
-     */
-    template<typename It>
-    [[deprecated("use sort_as instead")]] size_type pack(It first, It last) {
-        base_type::sort_as(first, last);
-        return static_cast<size_type>(std::distance(first, last));
-    }
+/*! @brief Same as std::is_invocable, but with tuples. */
+template<typename, typename>
+struct is_applicable: std::false_type {};
 
-    /**
-     * @brief Returns the number of elements considered still in use.
-     * @return The number of elements considered still in use.
-     */
-    [[deprecated("use free_list() instead")]] [[nodiscard]] size_type in_use() const noexcept {
-        return base_type::free_list();
-    }
+/**
+ * @copybrief is_applicable
+ * @tparam Func A valid function type.
+ * @tparam Tuple Tuple-like type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Func, template<typename...> class Tuple, typename... Args>
+struct is_applicable<Func, Tuple<Args...>>: std::is_invocable<Func, Args...> {};
 
-    /**
-     * @brief Sets the number of elements considered still in use.
-     * @param len The number of elements considered still in use.
-     */
-    [[deprecated("use free_list(len) instead")]] void in_use(const size_type len) noexcept {
-        base_type::free_list(len);
-    }
+/**
+ * @copybrief is_applicable
+ * @tparam Func A valid function type.
+ * @tparam Tuple Tuple-like type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Func, template<typename...> class Tuple, typename... Args>
+struct is_applicable<Func, const Tuple<Args...>>: std::is_invocable<Func, Args...> {};
 
-    /**
-     * @brief Returns an iterable object to use to _visit_ a storage.
-     *
-     * The iterable object returns a tuple that contains the current entity.
-     *
-     * @return An iterable object to use to _visit_ the storage.
-     */
-    [[nodiscard]] iterable each() noexcept {
-        return {internal::extended_storage_iterator{base_type::begin(0)}, internal::extended_storage_iterator{base_type::end(0)}};
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam Func A valid function type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Func, typename Args>
+inline constexpr bool is_applicable_v = is_applicable<Func, Args>::value;
 
-    /*! @copydoc each */
-    [[nodiscard]] const_iterable each() const noexcept {
-        return {internal::extended_storage_iterator{base_type::cbegin(0)}, internal::extended_storage_iterator{base_type::cend(0)}};
-    }
+/*! @brief Same as std::is_invocable_r, but with tuples for arguments. */
+template<typename, typename, typename>
+struct is_applicable_r: std::false_type {};
 
-    /**
-     * @brief Returns a reverse iterable object to use to _visit_ a storage.
-     *
-     * @sa each
-     *
-     * @return A reverse iterable object to use to _visit_ the storage.
-     */
-    [[nodiscard]] reverse_iterable reach() noexcept {
-        return {internal::extended_storage_iterator{base_type::rbegin()}, internal::extended_storage_iterator{base_type::rend(0)}};
-    }
+/**
+ * @copybrief is_applicable_r
+ * @tparam Ret The type to which the return type of the function should be
+ * convertible.
+ * @tparam Func A valid function type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Ret, typename Func, typename... Args>
+struct is_applicable_r<Ret, Func, std::tuple<Args...>>: std::is_invocable_r<Ret, Func, Args...> {};
 
-    /*! @copydoc reach */
-    [[nodiscard]] const_reverse_iterable reach() const noexcept {
-        return {internal::extended_storage_iterator{base_type::crbegin()}, internal::extended_storage_iterator{base_type::crend(0)}};
-    }
-};
+/**
+ * @brief Helper variable template.
+ * @tparam Ret The type to which the return type of the function should be
+ * convertible.
+ * @tparam Func A valid function type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Ret, typename Func, typename Args>
+inline constexpr bool is_applicable_r_v = is_applicable_r<Ret, Func, Args>::value;
 
-} // namespace entt
+/**
+ * @brief Provides the member constant `value` to true if a given type is
+ * complete, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type, typename = void>
+struct is_complete: std::false_type {};
 
-#endif
+/*! @copydoc is_complete */
+template<typename Type>
+struct is_complete<Type, std::void_t<decltype(sizeof(Type))>>: std::true_type {};
 
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_complete_v = is_complete<Type>::value;
 
-namespace entt {
+/**
+ * @brief Provides the member constant `value` to true if a given type is an
+ * iterator, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type, typename = void>
+struct is_iterator: std::false_type {};
 
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename, typename, typename>
-class extended_group_iterator;
+template<typename, typename = void>
+struct has_iterator_category: std::false_type {};
 
-template<typename It, typename... Owned, typename... Get>
-class extended_group_iterator<It, owned_t<Owned...>, get_t<Get...>> {
-    template<typename Type>
-    auto index_to_element([[maybe_unused]] Type &cpool) const {
-        if constexpr(Type::traits_type::page_size == 0u) {
-            return std::make_tuple();
-        } else {
-            return std::forward_as_tuple(cpool.rbegin()[it.index()]);
-        }
-    }
+template<typename Type>
+struct has_iterator_category<Type, std::void_t<typename std::iterator_traits<Type>::iterator_category>>: std::true_type {};
 
-public:
-    using iterator_type = It;
-    using difference_type = std::ptrdiff_t;
-    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Owned>().get_as_tuple({})..., std::declval<Get>().get_as_tuple({})...));
-    using pointer = input_iterator_pointer<value_type>;
-    using reference = value_type;
-    using iterator_category = std::input_iterator_tag;
-    using iterator_concept = std::forward_iterator_tag;
+} // namespace internal
+/*! @endcond */
 
-    constexpr extended_group_iterator()
-        : it{},
-          pools{} {}
+/*! @copydoc is_iterator */
+template<typename Type>
+struct is_iterator<Type, std::enable_if_t<!std::is_void_v<std::remove_cv_t<std::remove_pointer_t<Type>>>>>
+    : internal::has_iterator_category<Type> {};
 
-    extended_group_iterator(iterator_type from, const std::tuple<Owned *..., Get *...> &cpools)
-        : it{from},
-          pools{cpools} {}
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_iterator_v = is_iterator<Type>::value;
 
-    extended_group_iterator &operator++() noexcept {
-        return ++it, *this;
-    }
+/**
+ * @brief Provides the member constant `value` to true if a given type is both
+ * an empty and non-final class, false otherwise.
+ * @tparam Type The type to test
+ */
+template<typename Type>
+struct is_ebco_eligible
+    : std::bool_constant<std::is_empty_v<Type> && !std::is_final_v<Type>> {};
 
-    extended_group_iterator operator++(int) noexcept {
-        extended_group_iterator orig = *this;
-        return ++(*this), orig;
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_ebco_eligible_v = is_ebco_eligible<Type>::value;
 
-    [[nodiscard]] reference operator*() const noexcept {
-        return std::tuple_cat(std::make_tuple(*it), index_to_element(*std::get<Owned *>(pools))..., std::get<Get *>(pools)->get_as_tuple(*it)...);
-    }
+/**
+ * @brief Provides the member constant `value` to true if `Type::is_transparent`
+ * is valid and denotes a type, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type, typename = void>
+struct is_transparent: std::false_type {};
 
-    [[nodiscard]] pointer operator->() const noexcept {
-        return operator*();
-    }
+/*! @copydoc is_transparent */
+template<typename Type>
+struct is_transparent<Type, std::void_t<typename Type::is_transparent>>: std::true_type {};
 
-    [[nodiscard]] constexpr iterator_type base() const noexcept {
-        return it;
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_transparent_v = is_transparent<Type>::value;
 
-    template<typename... Lhs, typename... Rhs>
-    friend constexpr bool operator==(const extended_group_iterator<Lhs...> &, const extended_group_iterator<Rhs...> &) noexcept;
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-private:
-    It it;
-    std::tuple<Owned *..., Get *...> pools;
-};
+template<typename, typename = void>
+struct has_tuple_size_value: std::false_type {};
 
-template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator==(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
-    return lhs.it == rhs.it;
-}
+template<typename Type>
+struct has_tuple_size_value<Type, std::void_t<decltype(std::tuple_size<const Type>::value)>>: std::true_type {};
 
-template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator!=(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
-    return !(lhs == rhs);
-}
+template<typename, typename = void>
+struct has_value_type: std::false_type {};
 
-struct group_descriptor {
-    using size_type = std::size_t;
-    virtual ~group_descriptor() = default;
-    virtual size_type owned(const id_type *, const size_type) const noexcept {
-        return 0u;
-    }
-};
+template<typename Type>
+struct has_value_type<Type, std::void_t<typename Type::value_type>>: std::true_type {};
 
-template<typename, typename, typename>
-class group_handler;
+template<typename>
+[[nodiscard]] constexpr bool dispatch_is_equality_comparable();
 
-template<typename... Owned, typename... Get, typename... Exclude>
-class group_handler<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> final: public group_descriptor {
-    // nasty workaround for an issue with the toolset v141 that doesn't accept a fold expression here
-    static_assert(!std::disjunction_v<std::bool_constant<Owned::traits_type::in_place_delete>...>, "Groups do not support in-place delete");
-    static_assert(!std::disjunction_v<std::is_const<Owned>..., std::is_const<Get>..., std::is_const<Exclude>...>, "Const storage type not allowed");
+template<typename Type, std::size_t... Index>
+[[nodiscard]] constexpr bool unpack_maybe_equality_comparable(std::index_sequence<Index...>) {
+    return (dispatch_is_equality_comparable<std::tuple_element_t<Index, Type>>() && ...);
+}
 
-    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
-    using entity_type = typename base_type::entity_type;
+template<typename>
+[[nodiscard]] constexpr bool maybe_equality_comparable(char) {
+    return false;
+}
 
-    template<std::size_t... Index>
-    void swap_elements(const std::size_t pos, const entity_type entt, std::index_sequence<Index...>) {
-        (std::get<Index>(pools)->swap_elements(std::get<Index>(pools)->data()[pos], entt), ...);
-    }
+template<typename Type>
+[[nodiscard]] constexpr auto maybe_equality_comparable(int) -> decltype(std::declval<Type>() == std::declval<Type>()) {
+    return true;
+}
 
-    void push_on_construct(const entity_type entt) {
-        if(std::apply([entt, len = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < len) && (other->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
-            swap_elements(len++, entt, std::index_sequence_for<Owned...>{});
+template<typename Type>
+[[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
+    if constexpr(std::is_array_v<Type>) {
+        return false;
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
+            return maybe_equality_comparable<Type>(0);
+        } else {
+            return false;
         }
-    }
-
-    void push_on_destroy(const entity_type entt) {
-        if(std::apply([entt, len = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < len) && (other->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
-            swap_elements(len++, entt, std::index_sequence_for<Owned...>{});
+    } else if constexpr(is_complete_v<std::tuple_size<std::remove_cv_t<Type>>>) {
+        if constexpr(has_tuple_size_value<Type>::value) {
+            return maybe_equality_comparable<Type>(0) && unpack_maybe_equality_comparable<Type>(std::make_index_sequence<std::tuple_size<Type>::value>{});
+        } else {
+            return maybe_equality_comparable<Type>(0);
         }
+    } else {
+        return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
+}
 
-    void remove_if(const entity_type entt) {
-        if(std::get<0>(pools)->contains(entt) && (std::get<0>(pools)->index(entt) < len)) {
-            swap_elements(--len, entt, std::index_sequence_for<Owned...>{});
-        }
-    }
+} // namespace internal
+/*! @endcond */
 
-public:
-    using size_type = typename base_type::size_type;
+/**
+ * @brief Provides the member constant `value` to true if a given type is
+ * equality comparable, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+struct is_equality_comparable: std::bool_constant<internal::dispatch_is_equality_comparable<Type>()> {};
 
-    group_handler(Owned &...opool, Get &...gpool, Exclude &...epool)
-        : pools{&opool..., &gpool...},
-          filter{&epool...},
-          len{} {
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::push_on_construct>(*this), cpool->on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, pools);
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::remove_if>(*this), cpool->on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, filter);
+/*! @copydoc is_equality_comparable */
+template<typename Type>
+struct is_equality_comparable<const Type>: is_equality_comparable<Type> {};
 
-        // we cannot iterate backwards because we want to leave behind valid entities in case of owned types
-        for(auto *first = std::get<0>(pools)->data(), *last = first + std::get<0>(pools)->size(); first != last; ++first) {
-            push_on_construct(*first);
-        }
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_equality_comparable_v = is_equality_comparable<Type>::value;
 
-    size_type owned(const id_type *elem, const size_type length) const noexcept final {
-        size_type cnt = 0u;
+/**
+ * @brief Transcribes the constness of a type to another type.
+ * @tparam To The type to which to transcribe the constness.
+ * @tparam From The type from which to transcribe the constness.
+ */
+template<typename To, typename From>
+struct constness_as {
+    /*! @brief The type resulting from the transcription of the constness. */
+    using type = std::remove_const_t<To>;
+};
 
-        for(auto pos = 0u; pos < length; ++pos) {
-            cnt += ((elem[pos] == entt::type_hash<typename Owned::value_type>::value()) || ...);
-        }
+/*! @copydoc constness_as */
+template<typename To, typename From>
+struct constness_as<To, const From> {
+    /*! @brief The type resulting from the transcription of the constness. */
+    using type = const To;
+};
 
-        return cnt;
-    }
+/**
+ * @brief Alias template to facilitate the transcription of the constness.
+ * @tparam To The type to which to transcribe the constness.
+ * @tparam From The type from which to transcribe the constness.
+ */
+template<typename To, typename From>
+using constness_as_t = typename constness_as<To, From>::type;
 
-    [[nodiscard]] size_type length() const noexcept {
-        return len;
-    }
+/**
+ * @brief Extracts the class of a non-static member object or function.
+ * @tparam Member A pointer to a non-static member object or function.
+ */
+template<typename Member>
+class member_class {
+    static_assert(std::is_member_pointer_v<Member>, "Invalid pointer type to non-static member object or function");
 
-    auto pools_as_tuple() const noexcept {
-        return pools;
-    }
+    template<typename Class, typename Ret, typename... Args>
+    static Class *clazz(Ret (Class::*)(Args...));
 
-    auto filter_as_tuple() const noexcept {
-        return filter;
-    }
+    template<typename Class, typename Ret, typename... Args>
+    static Class *clazz(Ret (Class::*)(Args...) const);
 
-private:
-    std::tuple<Owned *..., Get *...> pools;
-    std::tuple<Exclude *...> filter;
-    std::size_t len;
+    template<typename Class, typename Type>
+    static Class *clazz(Type Class::*);
+
+public:
+    /*! @brief The class of the given non-static member object or function. */
+    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
 };
 
-template<typename... Get, typename... Exclude>
-class group_handler<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> final: public group_descriptor {
-    // nasty workaround for an issue with the toolset v141 that doesn't accept a fold expression here
-    static_assert(!std::disjunction_v<std::is_const<Get>..., std::is_const<Exclude>...>, "Const storage type not allowed");
+/**
+ * @brief Helper type.
+ * @tparam Member A pointer to a non-static member object or function.
+ */
+template<typename Member>
+using member_class_t = typename member_class<Member>::type;
 
-    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
-    using entity_type = typename base_type::entity_type;
+/**
+ * @brief Extracts the n-th argument of a _callable_ type.
+ * @tparam Index The index of the argument to extract.
+ * @tparam Candidate A valid _callable_ type.
+ */
+template<std::size_t Index, typename Candidate>
+class nth_argument {
+    template<typename Ret, typename... Args>
+    static constexpr type_list<Args...> pick_up(Ret (*)(Args...));
 
-    void push_on_construct(const entity_type entt) {
-        if(!elem.contains(entt)
-           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
-            elem.push(entt);
-        }
-    }
+    template<typename Ret, typename Class, typename... Args>
+    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...));
 
-    void push_on_destroy(const entity_type entt) {
-        if(!elem.contains(entt)
-           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
-            elem.push(entt);
-        }
-    }
+    template<typename Ret, typename Class, typename... Args>
+    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...) const);
 
-    void remove_if(const entity_type entt) {
-        elem.remove(entt);
-    }
+    template<typename Type, typename Class>
+    static constexpr type_list<Type> pick_up(Type Class ::*);
+
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
 
 public:
-    using common_type = base_type;
+    /*! @brief N-th argument of the _callable_ type. */
+    using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
+};
+
+/**
+ * @brief Helper type.
+ * @tparam Index The index of the argument to extract.
+ * @tparam Candidate A valid function, member function or data member type.
+ */
+template<std::size_t Index, typename Candidate>
+using nth_argument_t = typename nth_argument<Index, Candidate>::type;
 
-    template<typename Alloc>
-    group_handler(const Alloc &alloc, Get &...gpool, Exclude &...epool)
-        : pools{&gpool...},
-          filter{&epool...},
-          elem{alloc} {
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::push_on_construct>(*this), cpool->on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, pools);
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::remove_if>(*this), cpool->on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, filter);
+} // namespace entt
 
-        for(const auto entity: static_cast<base_type &>(*std::get<0>(pools))) {
-            push_on_construct(entity);
-        }
-    }
+template<typename... Type>
+struct std::tuple_size<entt::type_list<Type...>>: std::integral_constant<std::size_t, entt::type_list<Type...>::size> {};
 
-    common_type &handle() noexcept {
-        return elem;
-    }
+template<std::size_t Index, typename... Type>
+struct std::tuple_element<Index, entt::type_list<Type...>>: entt::type_list_element<Index, entt::type_list<Type...>> {};
 
-    const common_type &handle() const noexcept {
-        return elem;
-    }
+template<auto... Value>
+struct std::tuple_size<entt::value_list<Value...>>: std::integral_constant<std::size_t, entt::value_list<Value...>::size> {};
 
-    auto pools_as_tuple() const noexcept {
-        return pools;
-    }
+template<std::size_t Index, auto... Value>
+struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_element<Index, entt::value_list<Value...>> {};
 
-    auto filter_as_tuple() const noexcept {
-        return filter;
-    }
+#endif
 
-private:
-    std::tuple<Get *...> pools;
-    std::tuple<Exclude *...> filter;
-    base_type elem;
+
+namespace entt {
+
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+enum class any_operation : std::uint8_t {
+    copy,
+    move,
+    transfer,
+    assign,
+    destroy,
+    compare,
+    get
 };
 
 } // namespace internal
 /*! @endcond */
 
-/**
- * @brief Group.
- *
- * Primary template isn't defined on purpose. All the specializations give a
- * compile-time error, but for a few reasonable cases.
- */
-template<typename, typename, typename>
-class basic_group;
+/*! @brief Possible modes of an any object. */
+enum class any_policy : std::uint8_t {
+    /*! @brief Default mode, the object owns the contained element. */
+    owner,
+    /*! @brief Aliasing mode, the object _points_ to a non-const element. */
+    ref,
+    /*! @brief Const aliasing mode, the object _points_ to a const element. */
+    cref
+};
 
 /**
- * @brief Non-owning group.
- *
- * A non-owning group returns all entities and only the entities that are at
- * least in the given storage. Moreover, it's guaranteed that the entity list is
- * tightly packed in memory for fast iterations.
- *
- * @b Important
- *
- * Iterators aren't invalidated if:
- *
- * * New elements are added to the storage.
- * * The entity currently pointed is modified (for example, components are added
- *   or removed from it).
- * * The entity currently pointed is destroyed.
- *
- * In all other cases, modifying the pools iterated by the group in any way
- * invalidates all the iterators.
- *
- * @tparam Get Types of storage _observed_ by the group.
- * @tparam Exclude Types of storage used to filter the group.
+ * @brief A SBO friendly, type-safe container for single values of any type.
+ * @tparam Len Size of the storage reserved for the small buffer optimization.
+ * @tparam Align Optional alignment requirement.
  */
-template<typename... Get, typename... Exclude>
-class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
-    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
-    using underlying_type = typename base_type::entity_type;
+template<std::size_t Len, std::size_t Align>
+class basic_any {
+    using operation = internal::any_operation;
+    using vtable_type = const void *(const operation, const basic_any &, const void *);
+
+    struct storage_type {
+        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+        alignas(Align) std::byte data[Len + static_cast<std::size_t>(Len == 0u)];
+    };
 
     template<typename Type>
-    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::value_type..., typename Exclude::value_type...>>;
+    static constexpr bool in_situ = (Len != 0u) && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
 
-    auto pools() const noexcept {
-        using return_type = std::tuple<Get *...>;
-        return descriptor ? descriptor->pools_as_tuple() : return_type{};
-    }
+    template<typename Type>
+    static const void *basic_vtable(const operation op, const basic_any &value, const void *other) {
+        static_assert(!std::is_void_v<Type> && std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");
+        const Type *elem = nullptr;
 
-    auto filter() const noexcept {
-        using return_type = std::tuple<Exclude *...>;
-        return descriptor ? descriptor->filter_as_tuple() : return_type{};
-    }
+        if constexpr(in_situ<Type>) {
+            elem = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
+        } else {
+            elem = static_cast<const Type *>(value.instance);
+        }
 
-public:
-    /*! @brief Underlying entity identifier. */
-    using entity_type = underlying_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Common type among all storage types. */
-    using common_type = base_type;
-    /*! @brief Random access iterator type. */
-    using iterator = typename common_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename common_type::reverse_iterator;
-    /*! @brief Iterable group type. */
-    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<>, get_t<Get...>>>;
-    /*! @brief Group handler type. */
-    using handler = internal::group_handler<owned_t<>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>;
+        switch(op) {
+        case operation::copy:
+            if constexpr(std::is_copy_constructible_v<Type>) {
+                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*elem);
+            }
+            break;
+        case operation::move:
+            if constexpr(in_situ<Type>) {
+                if(value.mode == any_policy::owner) {
+                    return ::new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(elem))};
+                }
+            }
 
-    /*! @brief Default constructor to use to create empty, invalid groups. */
-    basic_group() noexcept
-        : descriptor{} {}
+            return (static_cast<basic_any *>(const_cast<void *>(other))->instance = std::exchange(const_cast<basic_any &>(value).instance, nullptr));
+        case operation::transfer:
+            if constexpr(std::is_move_assignable_v<Type>) {
+                *const_cast<Type *>(elem) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
+                return other;
+            }
+            [[fallthrough]];
+        case operation::assign:
+            if constexpr(std::is_copy_assignable_v<Type>) {
+                *const_cast<Type *>(elem) = *static_cast<const Type *>(other);
+                return other;
+            }
+            break;
+        case operation::destroy:
+            if constexpr(in_situ<Type>) {
+                elem->~Type();
+            } else if constexpr(std::is_array_v<Type>) {
+                delete[] elem;
+            } else {
+                delete elem;
+            }
+            break;
+        case operation::compare:
+            if constexpr(!std::is_function_v<Type> && !std::is_array_v<Type> && is_equality_comparable_v<Type>) {
+                return *elem == *static_cast<const Type *>(other) ? other : nullptr;
+            } else {
+                return (elem == other) ? other : nullptr;
+            }
+        case operation::get:
+            return elem;
+        }
 
-    /**
-     * @brief Constructs a group from a set of storage classes.
-     * @param ref A reference to a group handler.
-     */
-    basic_group(handler &ref) noexcept
-        : descriptor{&ref} {}
+        return nullptr;
+    }
 
-    /**
-     * @brief Returns the leading storage of a group.
-     * @return The leading storage of the group.
-     */
-    [[nodiscard]] const common_type &handle() const noexcept {
-        return descriptor->handle();
+    template<typename Type, typename... Args>
+    void initialize([[maybe_unused]] Args &&...args) {
+        using plain_type = std::remove_cv_t<std::remove_reference_t<Type>>;
+        info = &type_id<plain_type>();
+
+        if constexpr(!std::is_void_v<Type>) {
+            vtable = basic_vtable<plain_type>;
+
+            if constexpr(std::is_lvalue_reference_v<Type>) {
+                static_assert((std::is_lvalue_reference_v<Args> && ...) && (sizeof...(Args) == 1u), "Invalid arguments");
+                mode = std::is_const_v<std::remove_reference_t<Type>> ? any_policy::cref : any_policy::ref;
+                instance = (std::addressof(args), ...);
+            } else if constexpr(in_situ<plain_type>) {
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    ::new(&storage) plain_type{std::forward<Args>(args)...};
+                } else {
+                    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
+                    ::new(&storage) plain_type(std::forward<Args>(args)...);
+                }
+            } else {
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    instance = new plain_type{std::forward<Args>(args)...};
+                } else if constexpr(std::is_array_v<plain_type>) {
+                    static_assert(sizeof...(Args) == 0u, "Invalid arguments");
+                    instance = new plain_type[std::extent_v<plain_type>]();
+                } else {
+                    instance = new plain_type(std::forward<Args>(args)...);
+                }
+            }
+        }
     }
 
+    basic_any(const basic_any &other, const any_policy pol) noexcept
+        : instance{other.data()},
+          info{other.info},
+          vtable{other.vtable},
+          mode{pol} {}
+
+public:
+    /*! @brief Size of the internal storage. */
+    static constexpr auto length = Len;
+    /*! @brief Alignment requirement. */
+    static constexpr auto alignment = Align;
+
+    /*! @brief Default constructor. */
+    constexpr basic_any() noexcept
+        : basic_any{std::in_place_type<void>} {}
+
     /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
+     * @brief Constructs a wrapper by directly initializing the new object.
+     * @tparam Type Type of object to use to initialize the wrapper.
+     * @tparam Args Types of arguments to use to construct the new instance.
+     * @param args Parameters to use to construct the instance.
      */
-    template<typename Type>
-    [[nodiscard]] auto *storage() const noexcept {
-        return storage<index_of<Type>>();
+    template<typename Type, typename... Args>
+    explicit basic_any(std::in_place_type_t<Type>, Args &&...args)
+        : instance{},
+          info{},
+          vtable{},
+          mode{any_policy::owner} {
+        initialize<Type>(std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Returns the storage for a given index, if any.
-     * @tparam Index Index of the storage to return.
-     * @return The storage for the given index.
+     * @brief Constructs a wrapper from a given value.
+     * @tparam Type Type of object to use to initialize the wrapper.
+     * @param value An instance of an object to use to initialize the wrapper.
      */
-    template<std::size_t Index>
-    [[nodiscard]] auto *storage() const noexcept {
-        constexpr auto offset = sizeof...(Get);
-
-        if constexpr(Index < offset) {
-            return std::get<Index>(pools());
-        } else {
-            return std::get<Index - offset>(filter());
-        }
-    }
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
+    basic_any(Type &&value)
+        : basic_any{std::in_place_type<std::decay_t<Type>>, std::forward<Type>(value)} {}
 
     /**
-     * @brief Returns the number of entities that are part of the group.
-     * @return Number of entities that are part of the group.
+     * @brief Copy constructor.
+     * @param other The instance to copy from.
      */
-    [[nodiscard]] size_type size() const noexcept {
-        return *this ? handle().size() : size_type{};
+    basic_any(const basic_any &other)
+        : basic_any{} {
+        if(other.vtable) {
+            other.vtable(operation::copy, other, this);
+        }
     }
 
     /**
-     * @brief Returns the number of elements that a group has currently
-     * allocated space for.
-     * @return Capacity of the group.
+     * @brief Move constructor.
+     * @param other The instance to move from.
      */
-    [[nodiscard]] size_type capacity() const noexcept {
-        return *this ? handle().capacity() : size_type{};
+    basic_any(basic_any &&other) noexcept
+        : instance{},
+          info{other.info},
+          vtable{other.vtable},
+          mode{other.mode} {
+        if(other.vtable) {
+            other.vtable(operation::move, other, this);
+        }
     }
 
-    /*! @brief Requests the removal of unused capacity. */
-    void shrink_to_fit() {
-        if(*this) {
-            descriptor->handle().shrink_to_fit();
+    /*! @brief Frees the internal storage, whatever it means. */
+    ~basic_any() {
+        if(vtable && (mode == any_policy::owner)) {
+            vtable(operation::destroy, *this, nullptr);
         }
     }
 
     /**
-     * @brief Checks whether a group is empty.
-     * @return True if the group is empty, false otherwise.
+     * @brief Copy assignment operator.
+     * @param other The instance to copy from.
+     * @return This any object.
      */
-    [[nodiscard]] bool empty() const noexcept {
-        return !*this || handle().empty();
-    }
+    basic_any &operator=(const basic_any &other) {
+        if(this != &other) {
+            reset();
 
-    /**
-     * @brief Returns an iterator to the first entity of the group.
-     *
-     * If the group is empty, the returned iterator will be equal to `end()`.
-     *
-     * @return An iterator to the first entity of the group.
-     */
-    [[nodiscard]] iterator begin() const noexcept {
-        return *this ? handle().begin() : iterator{};
-    }
+            if(other.vtable) {
+                other.vtable(operation::copy, other, this);
+            }
+        }
 
-    /**
-     * @brief Returns an iterator that is past the last entity of the group.
-     * @return An iterator to the entity following the last entity of the
-     * group.
-     */
-    [[nodiscard]] iterator end() const noexcept {
-        return *this ? handle().end() : iterator{};
+        return *this;
     }
 
     /**
-     * @brief Returns an iterator to the first entity of the reversed group.
-     *
-     * If the group is empty, the returned iterator will be equal to `rend()`.
-     *
-     * @return An iterator to the first entity of the reversed group.
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This any object.
      */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
-        return *this ? handle().rbegin() : reverse_iterator{};
+    basic_any &operator=(basic_any &&other) noexcept {
+        ENTT_ASSERT(this != &other, "Self move assignment");
+
+        reset();
+
+        if(other.vtable) {
+            other.vtable(operation::move, other, this);
+            info = other.info;
+            vtable = other.vtable;
+            mode = other.mode;
+        }
+
+        return *this;
     }
 
     /**
-     * @brief Returns an iterator that is past the last entity of the reversed
-     * group.
-     * @return An iterator to the entity following the last entity of the
-     * reversed group.
+     * @brief Value assignment operator.
+     * @tparam Type Type of object to use to initialize the wrapper.
+     * @param value An instance of an object to use to initialize the wrapper.
+     * @return This any object.
      */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return *this ? handle().rend() : reverse_iterator{};
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
+    basic_any &operator=(Type &&value) {
+        emplace<std::decay_t<Type>>(std::forward<Type>(value));
+        return *this;
     }
 
     /**
-     * @brief Returns the first entity of the group, if any.
-     * @return The first entity of the group if one exists, the null entity
-     * otherwise.
+     * @brief Returns the object type if any, `type_id<void>()` otherwise.
+     * @return The object type if any, `type_id<void>()` otherwise.
      */
-    [[nodiscard]] entity_type front() const noexcept {
-        const auto it = begin();
-        return it != end() ? *it : null;
+    [[nodiscard]] const type_info &type() const noexcept {
+        return *info;
     }
 
     /**
-     * @brief Returns the last entity of the group, if any.
-     * @return The last entity of the group if one exists, the null entity
-     * otherwise.
+     * @brief Returns an opaque pointer to the contained instance.
+     * @return An opaque pointer the contained instance, if any.
      */
-    [[nodiscard]] entity_type back() const noexcept {
-        const auto it = rbegin();
-        return it != rend() ? *it : null;
+    [[nodiscard]] const void *data() const noexcept {
+        return vtable ? vtable(operation::get, *this, nullptr) : nullptr;
     }
 
     /**
-     * @brief Finds an entity.
-     * @param entt A valid identifier.
-     * @return An iterator to the given entity if it's found, past the end
-     * iterator otherwise.
+     * @brief Returns an opaque pointer to the contained instance.
+     * @param req Expected type.
+     * @return An opaque pointer the contained instance, if any.
      */
-    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        return *this ? handle().find(entt) : iterator{};
+    [[nodiscard]] const void *data(const type_info &req) const noexcept {
+        return *info == req ? data() : nullptr;
     }
 
     /**
-     * @brief Returns the identifier that occupies the given position.
-     * @param pos Position of the element to return.
-     * @return The identifier that occupies the given position.
+     * @brief Returns an opaque pointer to the contained instance.
+     * @return An opaque pointer the contained instance, if any.
      */
-    [[nodiscard]] entity_type operator[](const size_type pos) const {
-        return begin()[pos];
+    [[nodiscard]] void *data() noexcept {
+        return mode == any_policy::cref ? nullptr : const_cast<void *>(std::as_const(*this).data());
     }
 
     /**
-     * @brief Checks if a group is properly initialized.
-     * @return True if the group is properly initialized, false otherwise.
+     * @brief Returns an opaque pointer to the contained instance.
+     * @param req Expected type.
+     * @return An opaque pointer the contained instance, if any.
      */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return descriptor != nullptr;
+    [[nodiscard]] void *data(const type_info &req) noexcept {
+        return mode == any_policy::cref ? nullptr : const_cast<void *>(std::as_const(*this).data(req));
     }
 
     /**
-     * @brief Checks if a group contains an entity.
-     * @param entt A valid identifier.
-     * @return True if the group contains the given entity, false otherwise.
+     * @brief Replaces the contained object by creating a new instance directly.
+     * @tparam Type Type of object to use to initialize the wrapper.
+     * @tparam Args Types of arguments to use to construct the new instance.
+     * @param args Parameters to use to construct the instance.
      */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        return *this && handle().contains(entt);
+    template<typename Type, typename... Args>
+    void emplace(Args &&...args) {
+        reset();
+        initialize<Type>(std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Type Type of the component to get.
-     * @tparam Other Other types of components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
+     * @brief Assigns a value to the contained object without replacing it.
+     * @param other The value to assign to the contained object.
+     * @return True in case of success, false otherwise.
      */
-    template<typename Type, typename... Other>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        return get<index_of<Type>, index_of<Other>...>(entt);
+    bool assign(const basic_any &other) {
+        if(vtable && mode != any_policy::cref && *info == *other.info) {
+            return (vtable(operation::assign, *this, other.data()) != nullptr);
+        }
+
+        return false;
     }
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Index Indexes of the components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<std::size_t... Index>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        const auto cpools = pools();
+    /*! @copydoc assign */
+    bool assign(basic_any &&other) {
+        if(vtable && mode != any_policy::cref && *info == *other.info) {
+            if(auto *val = other.data(); val) {
+                return (vtable(operation::transfer, *this, val) != nullptr);
+            }
 
-        if constexpr(sizeof...(Index) == 0) {
-            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
-        } else if constexpr(sizeof...(Index) == 1) {
-            return (std::get<Index>(cpools)->get(entt), ...);
-        } else {
-            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
+            return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
         }
+
+        return false;
     }
 
-    /**
-     * @brief Iterates entities and components and applies the given function
-     * object to them.
-     *
-     * The function object is invoked for each entity. It is provided with the
-     * entity itself and a set of references to non-empty components. The
-     * _constness_ of the components is as requested.<br/>
-     * The signature of the function must be equivalent to one of the following
-     * forms:
-     *
-     * @code{.cpp}
-     * void(const entity_type, Type &...);
-     * void(Type &...);
-     * @endcode
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @tparam Func Type of the function object to invoke.
-     * @param func A valid function object.
-     */
-    template<typename Func>
-    void each(Func func) const {
-        for(const auto entt: *this) {
-            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
-                std::apply(func, std::tuple_cat(std::make_tuple(entt), get(entt)));
-            } else {
-                std::apply(func, get(entt));
-            }
+    /*! @brief Destroys contained object */
+    void reset() {
+        if(vtable && (mode == any_policy::owner)) {
+            vtable(operation::destroy, *this, nullptr);
         }
+
+        // unnecessary but it helps to detect nasty bugs
+        ENTT_ASSERT((instance = nullptr) == nullptr, "");
+        info = &type_id<void>();
+        vtable = nullptr;
+        mode = any_policy::owner;
     }
 
     /**
-     * @brief Returns an iterable object to use to _visit_ a group.
-     *
-     * The iterable object returns tuples that contain the current entity and a
-     * set of references to its non-empty components. The _constness_ of the
-     * components is as requested.
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @return An iterable object to use to _visit_ the group.
+     * @brief Returns false if a wrapper is empty, true otherwise.
+     * @return False if the wrapper is empty, true otherwise.
      */
-    [[nodiscard]] iterable each() const noexcept {
-        const auto cpools = pools();
-        return iterable{{begin(), cpools}, {end(), cpools}};
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return vtable != nullptr;
     }
 
     /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * The comparison function object must return `true` if the first element
-     * is _less_ than the second one, `false` otherwise. The signature of the
-     * comparison function should be equivalent to one of the following:
-     *
-     * @code{.cpp}
-     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
-     * bool(const Type &..., const Type &...);
-     * bool(const Entity, const Entity);
-     * @endcode
-     *
-     * Where `Type` are such that they are iterated by the group.<br/>
-     * Moreover, the comparison function object shall induce a
-     * _strict weak ordering_ on the values.
-     *
-     * The sort function object must offer a member function template
-     * `operator()` that accepts three arguments:
-     *
-     * * An iterator to the first element of the range to sort.
-     * * An iterator past the last element of the range to sort.
-     * * A comparison function to use to compare the elements.
-     *
-     * @tparam Type Optional type of component to compare.
-     * @tparam Other Other optional types of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
+     * @brief Checks if two wrappers differ in their content.
+     * @param other Wrapper with which to compare.
+     * @return False if the two objects differ in their content, true otherwise.
      */
-    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
-        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
+    [[nodiscard]] bool operator==(const basic_any &other) const noexcept {
+        if(vtable && *info == *other.info) {
+            return (vtable(operation::compare, *this, other.data()) != nullptr);
+        }
+
+        return (!vtable && !other.vtable);
     }
 
     /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * @sa sort
-     *
-     * @tparam Index Optional indexes of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
+     * @brief Checks if two wrappers differ in their content.
+     * @param other Wrapper with which to compare.
+     * @return True if the two objects differ in their content, false otherwise.
      */
-    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
-        if(*this) {
-            if constexpr(sizeof...(Index) == 0) {
-                static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
-                descriptor->handle().sort(std::move(compare), std::move(algo), std::forward<Args>(args)...);
-            } else {
-                auto comp = [&compare, cpools = pools()](const entity_type lhs, const entity_type rhs) {
-                    if constexpr(sizeof...(Index) == 1) {
-                        return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
-                    } else {
-                        return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
-                    }
-                };
-
-                descriptor->handle().sort(std::move(comp), std::move(algo), std::forward<Args>(args)...);
-            }
-        }
+    [[nodiscard]] bool operator!=(const basic_any &other) const noexcept {
+        return !(*this == other);
     }
 
     /**
-     * @brief Sort entities according to their order in a range.
-     *
-     * The shared pool of entities and thus its order is affected by the changes
-     * to each and every pool that it tracks.
-     *
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
+     * @brief Aliasing constructor.
+     * @return A wrapper that shares a reference to an unmanaged object.
      */
-    template<typename It>
-    void sort_as(It first, It last) const {
-        if(*this) {
-            descriptor->handle().sort_as(first, last);
-        }
+    [[nodiscard]] basic_any as_ref() noexcept {
+        return basic_any{*this, (mode == any_policy::cref ? any_policy::cref : any_policy::ref)};
+    }
+
+    /*! @copydoc as_ref */
+    [[nodiscard]] basic_any as_ref() const noexcept {
+        return basic_any{*this, any_policy::cref};
     }
 
     /**
-     * @brief Sort entities according to their order in a range.
-     * @param other The storage to use to impose the order.
+     * @brief Returns the current mode of an any object.
+     * @return The current mode of the any object.
      */
-    [[deprecated("use iterator based sort_as instead")]] void sort_as(const common_type &other) const {
-        sort_as(other.begin(), other.end());
+    [[nodiscard]] any_policy policy() const noexcept {
+        return mode;
     }
 
 private:
-    handler *descriptor;
+    union {
+        const void *instance;
+        storage_type storage;
+    };
+    const type_info *info;
+    vtable_type *vtable;
+    any_policy mode;
 };
 
 /**
- * @brief Owning group.
- *
- * Owning groups returns all entities and only the entities that are at
- * least in the given storage. Moreover:
- *
- * * It's guaranteed that the entity list is tightly packed in memory for fast
- *   iterations.
- * * It's guaranteed that all components in the owned storage are tightly packed
- *   in memory for even faster iterations and to allow direct access.
- * * They stay true to the order of the owned storage and all instances have the
- *   same order in memory.
- *
- * The more types of storage are owned, the faster it is to iterate a group.
- *
- * @b Important
- *
- * Iterators aren't invalidated if:
- *
- * * New elements are added to the storage.
- * * The entity currently pointed is modified (for example, components are added
- *   or removed from it).
- * * The entity currently pointed is destroyed.
- *
- * In all other cases, modifying the pools iterated by the group in any way
- * invalidates all the iterators.
- *
- * @tparam Owned Types of storage _owned_ by the group.
- * @tparam Get Types of storage _observed_ by the group.
- * @tparam Exclude Types of storage used to filter the group.
+ * @brief Performs type-safe access to the contained object.
+ * @tparam Type Type to which conversion is required.
+ * @tparam Len Size of the storage reserved for the small buffer optimization.
+ * @tparam Align Alignment requirement.
+ * @param data Target any object.
+ * @return The element converted to the requested type.
  */
-template<typename... Owned, typename... Get, typename... Exclude>
-class basic_group<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> {
-    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
-    using underlying_type = typename base_type::entity_type;
+template<typename Type, std::size_t Len, std::size_t Align>
+[[nodiscard]] std::remove_const_t<Type> any_cast(const basic_any<Len, Align> &data) noexcept {
+    const auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
+    ENTT_ASSERT(instance, "Invalid instance");
+    return static_cast<Type>(*instance);
+}
 
-    template<typename Type>
-    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Owned::value_type..., typename Get::value_type..., typename Exclude::value_type...>>;
+/*! @copydoc any_cast */
+template<typename Type, std::size_t Len, std::size_t Align>
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &data) noexcept {
+    // forces const on non-reference types to make them work also with wrappers for const references
+    auto *const instance = any_cast<std::remove_reference_t<const Type>>(&data);
+    ENTT_ASSERT(instance, "Invalid instance");
+    return static_cast<Type>(*instance);
+}
 
-    auto pools() const noexcept {
-        using return_type = std::tuple<Owned *..., Get *...>;
-        return descriptor ? descriptor->pools_as_tuple() : return_type{};
+/*! @copydoc any_cast */
+template<typename Type, std::size_t Len, std::size_t Align>
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &&data) noexcept {
+    if constexpr(std::is_copy_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>) {
+        if(auto *const instance = any_cast<std::remove_reference_t<Type>>(&data); instance) {
+            return static_cast<Type>(std::move(*instance));
+        }
+
+        return any_cast<Type>(data);
+    } else {
+        auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
+        ENTT_ASSERT(instance, "Invalid instance");
+        return static_cast<Type>(std::move(*instance));
     }
+}
+
+/*! @copydoc any_cast */
+template<typename Type, std::size_t Len, std::size_t Align>
+[[nodiscard]] const Type *any_cast(const basic_any<Len, Align> *data) noexcept {
+    const auto &info = type_id<std::remove_cv_t<Type>>();
+    return static_cast<const Type *>(data->data(info));
+}
 
-    auto filter() const noexcept {
-        using return_type = std::tuple<Exclude *...>;
-        return descriptor ? descriptor->filter_as_tuple() : return_type{};
+/*! @copydoc any_cast */
+template<typename Type, std::size_t Len, std::size_t Align>
+[[nodiscard]] Type *any_cast(basic_any<Len, Align> *data) noexcept {
+    if constexpr(std::is_const_v<Type>) {
+        // last attempt to make wrappers for const references return their values
+        return any_cast<Type>(&std::as_const(*data));
+    } else {
+        const auto &info = type_id<std::remove_cv_t<Type>>();
+        return static_cast<Type *>(data->data(info));
     }
+}
+
+/**
+ * @brief Constructs a wrapper from a given type, passing it all arguments.
+ * @tparam Type Type of object to use to initialize the wrapper.
+ * @tparam Len Size of the storage reserved for the small buffer optimization.
+ * @tparam Align Optional alignment requirement.
+ * @tparam Args Types of arguments to use to construct the new instance.
+ * @param args Parameters to use to construct the instance.
+ * @return A properly initialized wrapper for an object of the given type.
+ */
+template<typename Type, std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Len>::alignment, typename... Args>
+[[nodiscard]] basic_any<Len, Align> make_any(Args &&...args) {
+    return basic_any<Len, Align>{std::in_place_type<Type>, std::forward<Args>(args)...};
+}
+
+/**
+ * @brief Forwards its argument and avoids copies for lvalue references.
+ * @tparam Len Size of the storage reserved for the small buffer optimization.
+ * @tparam Align Optional alignment requirement.
+ * @tparam Type Type of argument to use to construct the new instance.
+ * @param value Parameter to use to construct the instance.
+ * @return A properly initialized and not necessarily owning wrapper.
+ */
+template<std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Len>::alignment, typename Type>
+[[nodiscard]] basic_any<Len, Align> forward_as_any(Type &&value) {
+    return basic_any<Len, Align>{std::in_place_type<Type &&>, std::forward<Type>(value)};
+}
+
+} // namespace entt
+
+#endif
+
+// #include "../core/bit.hpp"
+
+// #include "../core/type_info.hpp"
+
+// #include "entity.hpp"
+
+// #include "fwd.hpp"
 
-public:
-    /*! @brief Underlying entity identifier. */
-    using entity_type = underlying_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Common type among all storage types. */
-    using common_type = base_type;
-    /*! @brief Random access iterator type. */
-    using iterator = typename common_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename common_type::reverse_iterator;
-    /*! @brief Iterable group type. */
-    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<Owned...>, get_t<Get...>>>;
-    /*! @brief Group handler type. */
-    using handler = internal::group_handler<owned_t<std::remove_const_t<Owned>...>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>;
 
-    /*! @brief Default constructor to use to create empty, invalid groups. */
-    basic_group() noexcept
-        : descriptor{} {}
+namespace entt {
 
-    /**
-     * @brief Constructs a group from a set of storage classes.
-     * @param ref A reference to a group handler.
-     */
-    basic_group(handler &ref) noexcept
-        : descriptor{&ref} {}
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-    /**
-     * @brief Returns the leading storage of a group.
-     * @return The leading storage of the group.
-     */
-    [[nodiscard]] const common_type &handle() const noexcept {
-        return *storage<0>();
-    }
+template<typename Container>
+struct sparse_set_iterator final {
+    using value_type = typename Container::value_type;
+    using pointer = typename Container::const_pointer;
+    using reference = typename Container::const_reference;
+    using difference_type = typename Container::difference_type;
+    using iterator_category = std::random_access_iterator_tag;
 
-    /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
-     */
-    template<typename Type>
-    [[nodiscard]] auto *storage() const noexcept {
-        return storage<index_of<Type>>();
-    }
+    constexpr sparse_set_iterator() noexcept
+        : packed{},
+          offset{} {}
 
-    /**
-     * @brief Returns the storage for a given index, if any.
-     * @tparam Index Index of the storage to return.
-     * @return The storage for the given index.
-     */
-    template<std::size_t Index>
-    [[nodiscard]] auto *storage() const noexcept {
-        constexpr auto offset = sizeof...(Owned) + sizeof...(Get);
+    constexpr sparse_set_iterator(const Container &ref, const difference_type idx) noexcept
+        : packed{&ref},
+          offset{idx} {}
 
-        if constexpr(Index < offset) {
-            return std::get<Index>(pools());
-        } else {
-            return std::get<Index - offset>(filter());
-        }
+    constexpr sparse_set_iterator &operator++() noexcept {
+        return --offset, *this;
     }
 
-    /**
-     * @brief Returns the number of entities that that are part of the group.
-     * @return Number of entities that that are part of the group.
-     */
-    [[nodiscard]] size_type size() const noexcept {
-        return *this ? descriptor->length() : size_type{};
+    constexpr sparse_set_iterator operator++(int) noexcept {
+        sparse_set_iterator orig = *this;
+        return ++(*this), orig;
     }
 
-    /**
-     * @brief Checks whether a group is empty.
-     * @return True if the group is empty, false otherwise.
-     */
-    [[nodiscard]] bool empty() const noexcept {
-        return !*this || !descriptor->length();
+    constexpr sparse_set_iterator &operator--() noexcept {
+        return ++offset, *this;
     }
 
-    /**
-     * @brief Returns an iterator to the first entity of the group.
-     *
-     * If the group is empty, the returned iterator will be equal to `end()`.
-     *
-     * @return An iterator to the first entity of the group.
-     */
-    [[nodiscard]] iterator begin() const noexcept {
-        return *this ? (handle().end() - descriptor->length()) : iterator{};
+    constexpr sparse_set_iterator operator--(int) noexcept {
+        sparse_set_iterator orig = *this;
+        return operator--(), orig;
     }
 
-    /**
-     * @brief Returns an iterator that is past the last entity of the group.
-     * @return An iterator to the entity following the last entity of the
-     * group.
-     */
-    [[nodiscard]] iterator end() const noexcept {
-        return *this ? handle().end() : iterator{};
+    constexpr sparse_set_iterator &operator+=(const difference_type value) noexcept {
+        offset -= value;
+        return *this;
     }
 
-    /**
-     * @brief Returns an iterator to the first entity of the reversed group.
-     *
-     * If the group is empty, the returned iterator will be equal to `rend()`.
-     *
-     * @return An iterator to the first entity of the reversed group.
-     */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
-        return *this ? handle().rbegin() : reverse_iterator{};
+    constexpr sparse_set_iterator operator+(const difference_type value) const noexcept {
+        sparse_set_iterator copy = *this;
+        return (copy += value);
     }
 
-    /**
-     * @brief Returns an iterator that is past the last entity of the reversed
-     * group.
-     * @return An iterator to the entity following the last entity of the
-     * reversed group.
-     */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return *this ? (handle().rbegin() + descriptor->length()) : reverse_iterator{};
+    constexpr sparse_set_iterator &operator-=(const difference_type value) noexcept {
+        return (*this += -value);
     }
 
-    /**
-     * @brief Returns the first entity of the group, if any.
-     * @return The first entity of the group if one exists, the null entity
-     * otherwise.
-     */
-    [[nodiscard]] entity_type front() const noexcept {
-        const auto it = begin();
-        return it != end() ? *it : null;
+    constexpr sparse_set_iterator operator-(const difference_type value) const noexcept {
+        return (*this + -value);
     }
 
-    /**
-     * @brief Returns the last entity of the group, if any.
-     * @return The last entity of the group if one exists, the null entity
-     * otherwise.
-     */
-    [[nodiscard]] entity_type back() const noexcept {
-        const auto it = rbegin();
-        return it != rend() ? *it : null;
+    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
+        return (*packed)[index() - value];
     }
 
-    /**
-     * @brief Finds an entity.
-     * @param entt A valid identifier.
-     * @return An iterator to the given entity if it's found, past the end
-     * iterator otherwise.
-     */
-    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        const auto it = *this ? handle().find(entt) : iterator{};
-        return it >= begin() ? it : iterator{};
+    [[nodiscard]] constexpr pointer operator->() const noexcept {
+        return std::addressof(operator[](0));
     }
 
-    /**
-     * @brief Returns the identifier that occupies the given position.
-     * @param pos Position of the element to return.
-     * @return The identifier that occupies the given position.
-     */
-    [[nodiscard]] entity_type operator[](const size_type pos) const {
-        return begin()[pos];
+    [[nodiscard]] constexpr reference operator*() const noexcept {
+        return operator[](0);
     }
 
-    /**
-     * @brief Checks if a group is properly initialized.
-     * @return True if the group is properly initialized, false otherwise.
-     */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return descriptor != nullptr;
+    [[nodiscard]] constexpr pointer data() const noexcept {
+        return packed ? packed->data() : nullptr;
     }
 
-    /**
-     * @brief Checks if a group contains an entity.
-     * @param entt A valid identifier.
-     * @return True if the group contains the given entity, false otherwise.
-     */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        return *this && handle().contains(entt) && (handle().index(entt) < (descriptor->length()));
+    [[nodiscard]] constexpr difference_type index() const noexcept {
+        return offset - 1;
     }
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Type Type of the component to get.
-     * @tparam Other Other types of components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<typename Type, typename... Other>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        return get<index_of<Type>, index_of<Other>...>(entt);
-    }
+private:
+    const Container *packed;
+    difference_type offset;
+};
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Index Indexes of the components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<std::size_t... Index>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        const auto cpools = pools();
+template<typename Container>
+[[nodiscard]] constexpr std::ptrdiff_t operator-(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return rhs.index() - lhs.index();
+}
 
-        if constexpr(sizeof...(Index) == 0) {
-            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
-        } else if constexpr(sizeof...(Index) == 1) {
-            return (std::get<Index>(cpools)->get(entt), ...);
-        } else {
-            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
-        }
-    }
+template<typename Container>
+[[nodiscard]] constexpr bool operator==(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return lhs.index() == rhs.index();
+}
 
-    /**
-     * @brief Iterates entities and components and applies the given function
-     * object to them.
-     *
-     * The function object is invoked for each entity. It is provided with the
-     * entity itself and a set of references to non-empty components. The
-     * _constness_ of the components is as requested.<br/>
-     * The signature of the function must be equivalent to one of the following
-     * forms:
-     *
-     * @code{.cpp}
-     * void(const entity_type, Type &...);
-     * void(Type &...);
-     * @endcode
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @tparam Func Type of the function object to invoke.
-     * @param func A valid function object.
-     */
-    template<typename Func>
-    void each(Func func) const {
-        for(auto args: each()) {
-            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
-                std::apply(func, args);
-            } else {
-                std::apply([&func](auto, auto &&...less) { func(std::forward<decltype(less)>(less)...); }, args);
-            }
-        }
-    }
+template<typename Container>
+[[nodiscard]] constexpr bool operator!=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return !(lhs == rhs);
+}
 
-    /**
-     * @brief Returns an iterable object to use to _visit_ a group.
-     *
-     * The iterable object returns tuples that contain the current entity and a
-     * set of references to its non-empty components. The _constness_ of the
-     * components is as requested.
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @return An iterable object to use to _visit_ the group.
-     */
-    [[nodiscard]] iterable each() const noexcept {
-        const auto cpools = pools();
-        return {{begin(), cpools}, {end(), cpools}};
-    }
+template<typename Container>
+[[nodiscard]] constexpr bool operator<(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return lhs.index() > rhs.index();
+}
 
-    /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * The comparison function object must return `true` if the first element
-     * is _less_ than the second one, `false` otherwise. The signature of the
-     * comparison function should be equivalent to one of the following:
-     *
-     * @code{.cpp}
-     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
-     * bool(const Type &, const Type &);
-     * bool(const Entity, const Entity);
-     * @endcode
-     *
-     * Where `Type` are either owned types or not but still such that they are
-     * iterated by the group.<br/>
-     * Moreover, the comparison function object shall induce a
-     * _strict weak ordering_ on the values.
-     *
-     * The sort function object must offer a member function template
-     * `operator()` that accepts three arguments:
-     *
-     * * An iterator to the first element of the range to sort.
-     * * An iterator past the last element of the range to sort.
-     * * A comparison function to use to compare the elements.
-     *
-     * @tparam Type Optional type of component to compare.
-     * @tparam Other Other optional types of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
-        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
-    }
+template<typename Container>
+[[nodiscard]] constexpr bool operator>(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return rhs < lhs;
+}
 
-    /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * @sa sort
-     *
-     * @tparam Index Optional indexes of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
-        const auto cpools = pools();
+template<typename Container>
+[[nodiscard]] constexpr bool operator<=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return !(lhs > rhs);
+}
 
-        if constexpr(sizeof...(Index) == 0) {
-            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
-            storage<0>()->sort_n(descriptor->length(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
-        } else {
-            auto comp = [&compare, &cpools](const entity_type lhs, const entity_type rhs) {
-                if constexpr(sizeof...(Index) == 1) {
-                    return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
-                } else {
-                    return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
-                }
-            };
+template<typename Container>
+[[nodiscard]] constexpr bool operator>=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
+    return !(lhs < rhs);
+}
 
-            storage<0>()->sort_n(descriptor->length(), std::move(comp), std::move(algo), std::forward<Args>(args)...);
-        }
+} // namespace internal
+/*! @endcond */
 
-        auto cb = [this](auto *head, auto *...other) {
-            for(auto next = descriptor->length(); next; --next) {
-                const auto pos = next - 1;
-                [[maybe_unused]] const auto entt = head->data()[pos];
-                (other->swap_elements(other->data()[pos], entt), ...);
-            }
-        };
+/**
+ * @brief Sparse set implementation.
+ *
+ * Sparse set or packed array or whatever is the name users give it.<br/>
+ * Two arrays: an _external_ one and an _internal_ one; a _sparse_ one and a
+ * _packed_ one; one used for direct access through contiguous memory, the other
+ * one used to get the data through an extra level of indirection.<br/>
+ * This type of data structure is widely documented in the literature and on the
+ * web. This is nothing more than a customized implementation suitable for the
+ * purpose of the framework.
+ *
+ * @note
+ * Internal data structures arrange elements to maximize performance. There are
+ * no guarantees that entities are returned in the insertion order when iterate
+ * a sparse set. Do not make assumption on the order in any case.
+ *
+ * @tparam Entity A valid entity type.
+ * @tparam Allocator Type of allocator used to manage memory and elements.
+ */
+template<typename Entity, typename Allocator>
+class basic_sparse_set {
+    using alloc_traits = std::allocator_traits<Allocator>;
+    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
+    using sparse_container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
+    using packed_container_type = std::vector<Entity, Allocator>;
+    using traits_type = entt_traits<Entity>;
 
-        std::apply(cb, cpools);
+    static constexpr auto max_size = static_cast<std::size_t>(traits_type::to_entity(null));
+
+    [[nodiscard]] auto policy_to_head() const noexcept {
+        return static_cast<size_type>(max_size * static_cast<decltype(max_size)>(mode != deletion_policy::swap_only));
     }
 
-private:
-    handler *descriptor;
-};
+    [[nodiscard]] auto sparse_ptr(const Entity entt) const {
+        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
+        const auto page = pos / traits_type::page_size;
+        return (page < sparse.size() && sparse[page]) ? (sparse[page] + fast_mod(pos, traits_type::page_size)) : nullptr;
+    }
 
-} // namespace entt
+    [[nodiscard]] auto &sparse_ref(const Entity entt) const {
+        ENTT_ASSERT(sparse_ptr(entt), "Invalid element");
+        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
+        return sparse[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
+    }
 
-#endif
+    [[nodiscard]] auto to_iterator(const Entity entt) const {
+        return --(end() - index(entt));
+    }
 
-// #include "entity/handle.hpp"
-#ifndef ENTT_ENTITY_HANDLE_HPP
-#define ENTT_ENTITY_HANDLE_HPP
+    [[nodiscard]] auto &assure_at_least(const Entity entt) {
+        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
+        const auto page = pos / traits_type::page_size;
 
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../core/iterator.hpp"
+        if(!(page < sparse.size())) {
+            sparse.resize(page + 1u, nullptr);
+        }
 
-// #include "../core/type_traits.hpp"
+        if(!sparse[page]) {
+            constexpr entity_type init = null;
+            auto page_allocator{packed.get_allocator()};
+            sparse[page] = alloc_traits::allocate(page_allocator, traits_type::page_size);
+            std::uninitialized_fill(sparse[page], sparse[page] + traits_type::page_size, init);
+        }
 
-// #include "entity.hpp"
+        return sparse[page][fast_mod(pos, traits_type::page_size)];
+    }
 
-// #include "fwd.hpp"
+    void release_sparse_pages() {
+        auto page_allocator{packed.get_allocator()};
 
+        for(auto &&page: sparse) {
+            if(page != nullptr) {
+                std::destroy(page, page + traits_type::page_size);
+                alloc_traits::deallocate(page_allocator, page, traits_type::page_size);
+                page = nullptr;
+            }
+        }
+    }
 
-namespace entt {
+    void swap_at(const std::size_t lhs, const std::size_t rhs) {
+        auto &from = packed[lhs];
+        auto &to = packed[rhs];
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+        sparse_ref(from) = traits_type::combine(static_cast<typename traits_type::entity_type>(rhs), traits_type::to_integral(from));
+        sparse_ref(to) = traits_type::combine(static_cast<typename traits_type::entity_type>(lhs), traits_type::to_integral(to));
 
-template<typename It>
-class handle_storage_iterator final {
-    template<typename Other>
-    friend class handle_storage_iterator;
+        std::swap(from, to);
+    }
 
-    using underlying_type = std::remove_reference_t<typename It::value_type::second_type>;
-    using entity_type = typename underlying_type::entity_type;
+private:
+    [[nodiscard]] virtual const void *get_at(const std::size_t) const {
+        return nullptr;
+    }
 
-public:
-    using value_type = typename std::iterator_traits<It>::value_type;
-    using pointer = input_iterator_pointer<value_type>;
-    using reference = value_type;
-    using difference_type = std::ptrdiff_t;
-    using iterator_category = std::input_iterator_tag;
-    using iterator_concept = std::forward_iterator_tag;
+    virtual void swap_or_move([[maybe_unused]] const std::size_t lhs, [[maybe_unused]] const std::size_t rhs) {
+        ENTT_ASSERT((mode != deletion_policy::swap_only) || ((lhs < head) == (rhs < head)), "Cross swapping is not supported");
+    }
 
-    constexpr handle_storage_iterator() noexcept
-        : entt{null},
-          it{},
-          last{} {}
+protected:
+    /*! @brief Random access iterator type. */
+    using basic_iterator = internal::sparse_set_iterator<packed_container_type>;
 
-    constexpr handle_storage_iterator(entity_type value, It from, It to) noexcept
-        : entt{value},
-          it{from},
-          last{to} {
-        while(it != last && !it->second.contains(entt)) {
-            ++it;
-        }
+    /**
+     * @brief Erases an entity from a sparse set.
+     * @param it An iterator to the element to pop.
+     */
+    void swap_only(const basic_iterator it) {
+        ENTT_ASSERT(mode == deletion_policy::swap_only, "Deletion policy mismatch");
+        const auto pos = index(*it);
+        bump(traits_type::next(*it));
+        swap_at(pos, head -= (pos < head));
     }
 
-    constexpr handle_storage_iterator &operator++() noexcept {
-        while(++it != last && !it->second.contains(entt)) {}
-        return *this;
+    /**
+     * @brief Erases an entity from a sparse set.
+     * @param it An iterator to the element to pop.
+     */
+    void swap_and_pop(const basic_iterator it) {
+        ENTT_ASSERT(mode == deletion_policy::swap_and_pop, "Deletion policy mismatch");
+        auto &self = sparse_ref(*it);
+        const auto entt = traits_type::to_entity(self);
+        sparse_ref(packed.back()) = traits_type::combine(entt, traits_type::to_integral(packed.back()));
+        packed[static_cast<size_type>(entt)] = packed.back();
+        // unnecessary but it helps to detect nasty bugs
+        ENTT_ASSERT((packed.back() = null, true), "");
+        // lazy self-assignment guard
+        self = null;
+        packed.pop_back();
     }
 
-    constexpr handle_storage_iterator operator++(int) noexcept {
-        handle_storage_iterator orig = *this;
-        return ++(*this), orig;
+    /**
+     * @brief Erases an entity from a sparse set.
+     * @param it An iterator to the element to pop.
+     */
+    void in_place_pop(const basic_iterator it) {
+        ENTT_ASSERT(mode == deletion_policy::in_place, "Deletion policy mismatch");
+        const auto pos = static_cast<size_type>(traits_type::to_entity(std::exchange(sparse_ref(*it), null)));
+        packed[pos] = traits_type::combine(static_cast<typename traits_type::entity_type>(std::exchange(head, pos)), tombstone);
     }
 
-    [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *it;
+    /**
+     * @brief Erases entities from a sparse set.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     */
+    virtual void pop(basic_iterator first, basic_iterator last) {
+        switch(mode) {
+        case deletion_policy::swap_and_pop:
+            for(; first != last; ++first) {
+                swap_and_pop(first);
+            }
+            break;
+        case deletion_policy::in_place:
+            for(; first != last; ++first) {
+                in_place_pop(first);
+            }
+            break;
+        case deletion_policy::swap_only:
+            for(; first != last; ++first) {
+                swap_only(first);
+            }
+            break;
+        }
     }
 
-    [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return operator*();
+    /*! @brief Erases all entities of a sparse set. */
+    virtual void pop_all() {
+        switch(mode) {
+        case deletion_policy::in_place:
+            if(head != max_size) {
+                for(auto first = begin(); !(first.index() < 0); ++first) {
+                    if(*first != tombstone) {
+                        sparse_ref(*first) = null;
+                    }
+                }
+                break;
+            }
+            [[fallthrough]];
+        case deletion_policy::swap_only:
+        case deletion_policy::swap_and_pop:
+            for(auto first = begin(); !(first.index() < 0); ++first) {
+                sparse_ref(*first) = null;
+            }
+            break;
+        }
+
+        head = policy_to_head();
+        packed.clear();
     }
 
-    template<typename ILhs, typename IRhs>
-    friend constexpr bool operator==(const handle_storage_iterator<ILhs> &, const handle_storage_iterator<IRhs> &) noexcept;
+    /**
+     * @brief Assigns an entity to a sparse set.
+     * @param entt A valid identifier.
+     * @param force_back Force back insertion.
+     * @return Iterator pointing to the emplaced element.
+     */
+    virtual basic_iterator try_emplace(const Entity entt, const bool force_back, const void * = nullptr) {
+        ENTT_ASSERT(entt != null && entt != tombstone, "Invalid element");
+        auto &elem = assure_at_least(entt);
+        auto pos = size();
 
-private:
-    entity_type entt;
-    It it;
-    It last;
-};
+        switch(mode) {
+        case deletion_policy::in_place:
+            if(head != max_size && !force_back) {
+                pos = head;
+                ENTT_ASSERT(elem == null, "Slot not available");
+                elem = traits_type::combine(static_cast<typename traits_type::entity_type>(head), traits_type::to_integral(entt));
+                head = static_cast<size_type>(traits_type::to_entity(std::exchange(packed[pos], entt)));
+                break;
+            }
+            [[fallthrough]];
+        case deletion_policy::swap_and_pop:
+            packed.push_back(entt);
+            ENTT_ASSERT(elem == null, "Slot not available");
+            elem = traits_type::combine(static_cast<typename traits_type::entity_type>(packed.size() - 1u), traits_type::to_integral(entt));
+            break;
+        case deletion_policy::swap_only:
+            if(elem == null) {
+                packed.push_back(entt);
+                elem = traits_type::combine(static_cast<typename traits_type::entity_type>(packed.size() - 1u), traits_type::to_integral(entt));
+            } else {
+                ENTT_ASSERT(!(static_cast<size_type>(traits_type::to_entity(elem)) < head), "Slot not available");
+                bump(entt);
+            }
 
-template<typename ILhs, typename IRhs>
-[[nodiscard]] constexpr bool operator==(const handle_storage_iterator<ILhs> &lhs, const handle_storage_iterator<IRhs> &rhs) noexcept {
-    return lhs.it == rhs.it;
-}
+            pos = head++;
+            swap_at(static_cast<size_type>(traits_type::to_entity(elem)), pos);
+            break;
+        }
 
-template<typename ILhs, typename IRhs>
-[[nodiscard]] constexpr bool operator!=(const handle_storage_iterator<ILhs> &lhs, const handle_storage_iterator<IRhs> &rhs) noexcept {
-    return !(lhs == rhs);
-}
+        return --(end() - static_cast<typename iterator::difference_type>(pos));
+    }
 
-} // namespace internal
-/*! @endcond */
+    /*! @brief Forwards variables to derived classes, if any. */
+    // NOLINTNEXTLINE(performance-unnecessary-value-param)
+    virtual void bind_any(any) noexcept {}
 
-/**
- * @brief Non-owning handle to an entity.
- *
- * Tiny wrapper around a registry and an entity.
- *
- * @tparam Registry Basic registry type.
- * @tparam Scope Types to which to restrict the scope of a handle.
- */
-template<typename Registry, typename... Scope>
-struct basic_handle {
-    /*! @brief Type of registry accepted by the handle. */
-    using registry_type = Registry;
+public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Underlying entity identifier. */
-    using entity_type = typename registry_type::entity_type;
+    using entity_type = typename traits_type::value_type;
     /*! @brief Underlying version type. */
-    using version_type = typename registry_type::version_type;
+    using version_type = typename traits_type::version_type;
     /*! @brief Unsigned integer type. */
-    using size_type = typename registry_type::size_type;
+    using size_type = std::size_t;
+    /*! @brief Pointer type to contained entities. */
+    using pointer = typename packed_container_type::const_pointer;
+    /*! @brief Random access iterator type. */
+    using iterator = basic_iterator;
+    /*! @brief Constant random access iterator type. */
+    using const_iterator = iterator;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = std::reverse_iterator<iterator>;
+    /*! @brief Constant reverse iterator type. */
+    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
 
-    /*! @brief Constructs an invalid handle. */
-    basic_handle() noexcept
-        : reg{},
-          entt{null} {}
+    /*! @brief Default constructor. */
+    basic_sparse_set()
+        : basic_sparse_set{type_id<void>()} {}
 
     /**
-     * @brief Constructs a handle from a given registry and entity.
-     * @param ref An instance of the registry class.
-     * @param value A valid identifier.
+     * @brief Constructs an empty container with a given allocator.
+     * @param allocator The allocator to use.
      */
-    basic_handle(registry_type &ref, entity_type value) noexcept
-        : reg{&ref},
-          entt{value} {}
+    explicit basic_sparse_set(const allocator_type &allocator)
+        : basic_sparse_set{deletion_policy::swap_and_pop, allocator} {}
 
     /**
-     * @brief Returns an iterable object to use to _visit_ a handle.
-     *
-     * The iterable object returns a pair that contains the name and a reference
-     * to the current storage.<br/>
-     * Returned storage are those that contain the entity associated with the
-     * handle.
-     *
-     * @return An iterable object to use to _visit_ the handle.
+     * @brief Constructs an empty container with the given policy and allocator.
+     * @param pol Type of deletion policy.
+     * @param allocator The allocator to use (possibly default-constructed).
      */
-    [[nodiscard]] auto storage() const noexcept {
-        auto iterable = reg->storage();
-        using iterator_type = internal::handle_storage_iterator<typename decltype(iterable)::iterator>;
-        return iterable_adaptor{iterator_type{entt, iterable.begin(), iterable.end()}, iterator_type{entt, iterable.end(), iterable.end()}};
-    }
+    explicit basic_sparse_set(deletion_policy pol, const allocator_type &allocator = {})
+        : basic_sparse_set{type_id<void>(), pol, allocator} {}
 
     /**
-     * @brief Constructs a const handle from a non-const one.
-     * @tparam Other A valid entity type.
-     * @tparam Args Scope of the handle to construct.
-     * @return A const handle referring to the same registry and the same
-     * entity.
+     * @brief Constructs an empty container with the given value type, policy
+     * and allocator.
+     * @param elem Returned value type, if any.
+     * @param pol Type of deletion policy.
+     * @param allocator The allocator to use (possibly default-constructed).
      */
-    template<typename Other, typename... Args>
-    operator basic_handle<Other, Args...>() const noexcept {
-        static_assert(std::is_same_v<Other, Registry> || std::is_same_v<std::remove_const_t<Other>, Registry>, "Invalid conversion between different handles");
-        static_assert((sizeof...(Scope) == 0 || ((sizeof...(Args) != 0 && sizeof...(Args) <= sizeof...(Scope)) && ... && (type_list_contains_v<type_list<Scope...>, Args>))), "Invalid conversion between different handles");
-
-        return reg ? basic_handle<Other, Args...>{*reg, entt} : basic_handle<Other, Args...>{};
+    explicit basic_sparse_set(const type_info &elem, deletion_policy pol = deletion_policy::swap_and_pop, const allocator_type &allocator = {})
+        : sparse{allocator},
+          packed{allocator},
+          info{&elem},
+          mode{pol},
+          head{policy_to_head()} {
+        ENTT_ASSERT(traits_type::version_mask || mode != deletion_policy::in_place, "Policy does not support zero-sized versions");
     }
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_sparse_set(const basic_sparse_set &) = delete;
+
     /**
-     * @brief Converts a handle to its underlying entity.
-     * @return The contained identifier.
+     * @brief Move constructor.
+     * @param other The instance to move from.
      */
-    [[nodiscard]] operator entity_type() const noexcept {
-        return entity();
-    }
+    basic_sparse_set(basic_sparse_set &&other) noexcept
+        : sparse{std::move(other.sparse)},
+          packed{std::move(other.packed)},
+          info{other.info},
+          mode{other.mode},
+          head{std::exchange(other.head, policy_to_head())} {}
 
     /**
-     * @brief Checks if a handle refers to non-null registry pointer and entity.
-     * @return True if the handle refers to non-null registry and entity, false otherwise.
+     * @brief Allocator-extended move constructor.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
      */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return reg && reg->valid(entt);
+    basic_sparse_set(basic_sparse_set &&other, const allocator_type &allocator)
+        : sparse{std::move(other.sparse), allocator},
+          packed{std::move(other.packed), allocator},
+          info{other.info},
+          mode{other.mode},
+          head{std::exchange(other.head, policy_to_head())} {
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a sparse set is not allowed");
     }
 
-    /**
-     * @brief Checks if a handle refers to a valid entity or not.
-     * @return True if the handle refers to a valid entity, false otherwise.
-     */
-    [[nodiscard]] bool valid() const {
-        return reg->valid(entt);
+    /*! @brief Default destructor. */
+    virtual ~basic_sparse_set() {
+        release_sparse_pages();
     }
 
     /**
-     * @brief Returns a pointer to the underlying registry, if any.
-     * @return A pointer to the underlying registry, if any.
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This sparse set.
      */
-    [[nodiscard]] registry_type *registry() const noexcept {
-        return reg;
-    }
+    basic_sparse_set &operator=(const basic_sparse_set &) = delete;
 
     /**
-     * @brief Returns the entity associated with a handle.
-     * @return The entity associated with the handle.
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This sparse set.
      */
-    [[nodiscard]] entity_type entity() const noexcept {
-        return entt;
-    }
-
-    /*! @brief Destroys the entity associated with a handle. */
-    void destroy() {
-        reg->destroy(std::exchange(entt, null));
+    basic_sparse_set &operator=(basic_sparse_set &&other) noexcept {
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a sparse set is not allowed");
+        swap(other);
+        return *this;
     }
 
     /**
-     * @brief Destroys the entity associated with a handle.
-     * @param version A desired version upon destruction.
+     * @brief Exchanges the contents with those of a given sparse set.
+     * @param other Sparse set to exchange the content with.
      */
-    void destroy(const version_type version) {
-        reg->destroy(std::exchange(entt, null), version);
+    void swap(basic_sparse_set &other) noexcept {
+        using std::swap;
+        swap(sparse, other.sparse);
+        swap(packed, other.packed);
+        swap(info, other.info);
+        swap(mode, other.mode);
+        swap(head, other.head);
     }
 
     /**
-     * @brief Assigns the given component to a handle.
-     * @tparam Component Type of component to create.
-     * @tparam Args Types of arguments to use to construct the component.
-     * @param args Parameters to use to initialize the component.
-     * @return A reference to the newly created component.
+     * @brief Returns the associated allocator.
+     * @return The associated allocator.
      */
-    template<typename Component, typename... Args>
-    decltype(auto) emplace(Args &&...args) const {
-        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
-        return reg->template emplace<Component>(entt, std::forward<Args>(args)...);
+    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
+        return packed.get_allocator();
     }
 
     /**
-     * @brief Assigns or replaces the given component for a handle.
-     * @tparam Component Type of component to assign or replace.
-     * @tparam Args Types of arguments to use to construct the component.
-     * @param args Parameters to use to initialize the component.
-     * @return A reference to the newly created component.
+     * @brief Returns the deletion policy of a sparse set.
+     * @return The deletion policy of the sparse set.
      */
-    template<typename Component, typename... Args>
-    decltype(auto) emplace_or_replace(Args &&...args) const {
-        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
-        return reg->template emplace_or_replace<Component>(entt, std::forward<Args>(args)...);
+    [[nodiscard]] deletion_policy policy() const noexcept {
+        return mode;
     }
 
     /**
-     * @brief Patches the given component for a handle.
-     * @tparam Component Type of component to patch.
-     * @tparam Func Types of the function objects to invoke.
-     * @param func Valid function objects.
-     * @return A reference to the patched component.
+     * @brief Returns data on the free list whose meaning depends on the mode.
+     * @return Free list information that is mode dependent.
      */
-    template<typename Component, typename... Func>
-    decltype(auto) patch(Func &&...func) const {
-        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
-        return reg->template patch<Component>(entt, std::forward<Func>(func)...);
+    [[nodiscard]] size_type free_list() const noexcept {
+        return head;
     }
 
     /**
-     * @brief Replaces the given component for a handle.
-     * @tparam Component Type of component to replace.
-     * @tparam Args Types of arguments to use to construct the component.
-     * @param args Parameters to use to initialize the component.
-     * @return A reference to the component being replaced.
+     * @brief Sets data on the free list whose meaning depends on the mode.
+     * @param value Free list information that is mode dependent.
      */
-    template<typename Component, typename... Args>
-    decltype(auto) replace(Args &&...args) const {
-        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
-        return reg->template replace<Component>(entt, std::forward<Args>(args)...);
+    void free_list(const size_type value) noexcept {
+        ENTT_ASSERT((mode == deletion_policy::swap_only) && !(value > packed.size()), "Invalid value");
+        head = value;
     }
 
     /**
-     * @brief Removes the given components from a handle.
-     * @tparam Component Types of components to remove.
-     * @return The number of components actually removed.
+     * @brief Increases the capacity of a sparse set.
+     *
+     * If the new capacity is greater than the current capacity, new storage is
+     * allocated, otherwise the method does nothing.
+     *
+     * @param cap Desired capacity.
      */
-    template<typename... Component>
-    size_type remove() const {
-        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
-        return reg->template remove<Component...>(entt);
+    virtual void reserve(const size_type cap) {
+        packed.reserve(cap);
     }
 
     /**
-     * @brief Erases the given components from a handle.
-     * @tparam Component Types of components to erase.
+     * @brief Returns the number of elements that a sparse set has currently
+     * allocated space for.
+     * @return Capacity of the sparse set.
      */
-    template<typename... Component>
-    void erase() const {
-        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
-        reg->template erase<Component...>(entt);
+    [[nodiscard]] virtual size_type capacity() const noexcept {
+        return packed.capacity();
     }
 
-    /**
-     * @brief Checks if a handle has all the given components.
-     * @tparam Component Components for which to perform the check.
-     * @return True if the handle has all the components, false otherwise.
-     */
-    template<typename... Component>
-    [[nodiscard]] decltype(auto) all_of() const {
-        return reg->template all_of<Component...>(entt);
+    /*! @brief Requests the removal of unused capacity. */
+    virtual void shrink_to_fit() {
+        packed.shrink_to_fit();
     }
 
     /**
-     * @brief Checks if a handle has at least one of the given components.
-     * @tparam Component Components for which to perform the check.
-     * @return True if the handle has at least one of the given components,
-     * false otherwise.
+     * @brief Returns the extent of a sparse set.
+     *
+     * The extent of a sparse set is also the size of the internal sparse array.
+     * There is no guarantee that the internal packed array has the same size.
+     * Usually the size of the internal sparse array is equal or greater than
+     * the one of the internal packed array.
+     *
+     * @return Extent of the sparse set.
      */
-    template<typename... Component>
-    [[nodiscard]] decltype(auto) any_of() const {
-        return reg->template any_of<Component...>(entt);
+    [[nodiscard]] size_type extent() const noexcept {
+        return sparse.size() * traits_type::page_size;
     }
 
     /**
-     * @brief Returns references to the given components for a handle.
-     * @tparam Component Types of components to get.
-     * @return References to the components owned by the handle.
+     * @brief Returns the number of elements in a sparse set.
+     *
+     * The number of elements is also the size of the internal packed array.
+     * There is no guarantee that the internal sparse array has the same size.
+     * Usually the size of the internal sparse array is equal or greater than
+     * the one of the internal packed array.
+     *
+     * @return Number of elements.
      */
-    template<typename... Component>
-    [[nodiscard]] decltype(auto) get() const {
-        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
-        return reg->template get<Component...>(entt);
+    [[nodiscard]] size_type size() const noexcept {
+        return packed.size();
     }
 
     /**
-     * @brief Returns a reference to the given component for a handle.
-     * @tparam Component Type of component to get.
-     * @tparam Args Types of arguments to use to construct the component.
-     * @param args Parameters to use to initialize the component.
-     * @return Reference to the component owned by the handle.
+     * @brief Checks whether a sparse set is empty.
+     * @return True if the sparse set is empty, false otherwise.
      */
-    template<typename Component, typename... Args>
-    [[nodiscard]] decltype(auto) get_or_emplace(Args &&...args) const {
-        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
-        return reg->template get_or_emplace<Component>(entt, std::forward<Args>(args)...);
+    [[nodiscard]] bool empty() const noexcept {
+        return packed.empty();
     }
 
     /**
-     * @brief Returns pointers to the given components for a handle.
-     * @tparam Component Types of components to get.
-     * @return Pointers to the components owned by the handle.
+     * @brief Checks whether a sparse set is fully packed.
+     * @return True if the sparse set is fully packed, false otherwise.
      */
-    template<typename... Component>
-    [[nodiscard]] auto try_get() const {
-        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
-        return reg->template try_get<Component...>(entt);
+    [[nodiscard]] bool contiguous() const noexcept {
+        return (mode != deletion_policy::in_place) || (head == max_size);
     }
 
     /**
-     * @brief Checks if a handle has components assigned.
-     * @return True if the handle has no components assigned, false otherwise.
+     * @brief Direct access to the internal packed array.
+     * @return A pointer to the internal packed array.
      */
-    [[nodiscard]] bool orphan() const {
-        return reg->orphan(entt);
+    [[nodiscard]] pointer data() const noexcept {
+        return packed.data();
     }
 
-private:
-    registry_type *reg;
-    entity_type entt;
-};
-
-/**
- * @brief Compares two handles.
- * @tparam Args Scope of the first handle.
- * @tparam Other Scope of the second handle.
- * @param lhs A valid handle.
- * @param rhs A valid handle.
- * @return True if both handles refer to the same registry and the same
- * entity, false otherwise.
- */
-template<typename... Args, typename... Other>
-[[nodiscard]] bool operator==(const basic_handle<Args...> &lhs, const basic_handle<Other...> &rhs) noexcept {
-    return lhs.registry() == rhs.registry() && lhs.entity() == rhs.entity();
-}
-
-/**
- * @brief Compares two handles.
- * @tparam Args Scope of the first handle.
- * @tparam Other Scope of the second handle.
- * @param lhs A valid handle.
- * @param rhs A valid handle.
- * @return False if both handles refer to the same registry and the same
- * entity, true otherwise.
- */
-template<typename... Args, typename... Other>
-[[nodiscard]] bool operator!=(const basic_handle<Args...> &lhs, const basic_handle<Other...> &rhs) noexcept {
-    return !(lhs == rhs);
-}
-
-} // namespace entt
-
-#endif
-
-// #include "entity/helper.hpp"
-#ifndef ENTT_ENTITY_HELPER_HPP
-#define ENTT_ENTITY_HELPER_HPP
-
-#include <memory>
-#include <type_traits>
-#include <utility>
-// #include "../core/fwd.hpp"
-
-// #include "../core/type_traits.hpp"
-
-// #include "../signal/delegate.hpp"
-#ifndef ENTT_SIGNAL_DELEGATE_HPP
-#define ENTT_SIGNAL_DELEGATE_HPP
-
-#include <cstddef>
-#include <functional>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
-#ifndef ENTT_CONFIG_CONFIG_H
-#define ENTT_CONFIG_CONFIG_H
-
-// #include "version.h"
-#ifndef ENTT_CONFIG_VERSION_H
-#define ENTT_CONFIG_VERSION_H
-
-// #include "macro.h"
-#ifndef ENTT_CONFIG_MACRO_H
-#define ENTT_CONFIG_MACRO_H
-
-#define ENTT_STR(arg) #arg
-#define ENTT_XSTR(arg) ENTT_STR(arg)
-
-#endif
-
-
-#define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
-
-#define ENTT_VERSION \
-    ENTT_XSTR(ENTT_VERSION_MAJOR) \
-    "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
-
-#endif
-
-
-#if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
-#    define ENTT_CONSTEXPR
-#    define ENTT_THROW throw
-#    define ENTT_TRY try
-#    define ENTT_CATCH catch(...)
-#else
-#    define ENTT_CONSTEXPR constexpr // use only with throwing functions (waiting for C++20)
-#    define ENTT_THROW
-#    define ENTT_TRY if(true)
-#    define ENTT_CATCH if(false)
-#endif
-
-#ifdef ENTT_USE_ATOMIC
-#    include <atomic>
-#    define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
-#else
-#    define ENTT_MAYBE_ATOMIC(Type) Type
-#endif
-
-#ifndef ENTT_ID_TYPE
-#    include <cstdint>
-#    define ENTT_ID_TYPE std::uint32_t
-#else
-#    include <cstdint> // provides coverage for types in the std namespace
-#endif
-
-#ifndef ENTT_SPARSE_PAGE
-#    define ENTT_SPARSE_PAGE 4096
-#endif
-
-#ifndef ENTT_PACKED_PAGE
-#    define ENTT_PACKED_PAGE 1024
-#endif
-
-#ifdef ENTT_DISABLE_ASSERT
-#    undef ENTT_ASSERT
-#    define ENTT_ASSERT(condition, msg) (void(0))
-#elif !defined ENTT_ASSERT
-#    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
-#endif
-
-#ifdef ENTT_DISABLE_ASSERT
-#    undef ENTT_ASSERT_CONSTEXPR
-#    define ENTT_ASSERT_CONSTEXPR(condition, msg) (void(0))
-#elif !defined ENTT_ASSERT_CONSTEXPR
-#    define ENTT_ASSERT_CONSTEXPR(condition, msg) ENTT_ASSERT(condition, msg)
-#endif
-
-#define ENTT_FAIL(msg) ENTT_ASSERT(false, msg);
-
-#ifdef ENTT_NO_ETO
-#    define ENTT_ETO_TYPE(Type) void
-#else
-#    define ENTT_ETO_TYPE(Type) Type
-#endif
-
-#ifdef ENTT_STANDARD_CPP
-#    define ENTT_NONSTD false
-#else
-#    define ENTT_NONSTD true
-#    if defined __clang__ || defined __GNUC__
-#        define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
-#        define ENTT_PRETTY_FUNCTION_PREFIX '='
-#        define ENTT_PRETTY_FUNCTION_SUFFIX ']'
-#    elif defined _MSC_VER
-#        define ENTT_PRETTY_FUNCTION __FUNCSIG__
-#        define ENTT_PRETTY_FUNCTION_PREFIX '<'
-#        define ENTT_PRETTY_FUNCTION_SUFFIX '>'
-#    endif
-#endif
-
-#if defined _MSC_VER
-#    pragma detect_mismatch("entt.version", ENTT_VERSION)
-#    pragma detect_mismatch("entt.noexcept", ENTT_XSTR(ENTT_TRY))
-#    pragma detect_mismatch("entt.id", ENTT_XSTR(ENTT_ID_TYPE))
-#    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
-#endif
-
-#endif
-
-// #include "../core/type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
-#ifndef ENTT_CONFIG_CONFIG_H
-#define ENTT_CONFIG_CONFIG_H
-
-// #include "version.h"
-#ifndef ENTT_CONFIG_VERSION_H
-#define ENTT_CONFIG_VERSION_H
-
-// #include "macro.h"
-#ifndef ENTT_CONFIG_MACRO_H
-#define ENTT_CONFIG_MACRO_H
-
-#define ENTT_STR(arg) #arg
-#define ENTT_XSTR(arg) ENTT_STR(arg)
-
-#endif
-
-
-#define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
-
-#define ENTT_VERSION \
-    ENTT_XSTR(ENTT_VERSION_MAJOR) \
-    "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
-
-#endif
-
-
-#if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
-#    define ENTT_CONSTEXPR
-#    define ENTT_THROW throw
-#    define ENTT_TRY try
-#    define ENTT_CATCH catch(...)
-#else
-#    define ENTT_CONSTEXPR constexpr // use only with throwing functions (waiting for C++20)
-#    define ENTT_THROW
-#    define ENTT_TRY if(true)
-#    define ENTT_CATCH if(false)
-#endif
-
-#ifdef ENTT_USE_ATOMIC
-#    include <atomic>
-#    define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
-#else
-#    define ENTT_MAYBE_ATOMIC(Type) Type
-#endif
-
-#ifndef ENTT_ID_TYPE
-#    include <cstdint>
-#    define ENTT_ID_TYPE std::uint32_t
-#else
-#    include <cstdint> // provides coverage for types in the std namespace
-#endif
-
-#ifndef ENTT_SPARSE_PAGE
-#    define ENTT_SPARSE_PAGE 4096
-#endif
-
-#ifndef ENTT_PACKED_PAGE
-#    define ENTT_PACKED_PAGE 1024
-#endif
+    /**
+     * @brief Returns an iterator to the beginning.
+     *
+     * If the sparse set is empty, the returned iterator will be equal to
+     * `end()`.
+     *
+     * @return An iterator to the first entity of the sparse set.
+     */
+    [[nodiscard]] iterator begin() const noexcept {
+        const auto pos = static_cast<typename iterator::difference_type>(packed.size());
+        return iterator{packed, pos};
+    }
 
-#ifdef ENTT_DISABLE_ASSERT
-#    undef ENTT_ASSERT
-#    define ENTT_ASSERT(condition, msg) (void(0))
-#elif !defined ENTT_ASSERT
-#    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
-#endif
+    /*! @copydoc begin */
+    [[nodiscard]] const_iterator cbegin() const noexcept {
+        return begin();
+    }
 
-#ifdef ENTT_DISABLE_ASSERT
-#    undef ENTT_ASSERT_CONSTEXPR
-#    define ENTT_ASSERT_CONSTEXPR(condition, msg) (void(0))
-#elif !defined ENTT_ASSERT_CONSTEXPR
-#    define ENTT_ASSERT_CONSTEXPR(condition, msg) ENTT_ASSERT(condition, msg)
-#endif
+    /**
+     * @brief Returns an iterator to the end.
+     * @return An iterator to the element following the last entity of a sparse
+     * set.
+     */
+    [[nodiscard]] iterator end() const noexcept {
+        return iterator{packed, {}};
+    }
 
-#define ENTT_FAIL(msg) ENTT_ASSERT(false, msg);
+    /*! @copydoc end */
+    [[nodiscard]] const_iterator cend() const noexcept {
+        return end();
+    }
 
-#ifdef ENTT_NO_ETO
-#    define ENTT_ETO_TYPE(Type) void
-#else
-#    define ENTT_ETO_TYPE(Type) Type
-#endif
+    /**
+     * @brief Returns a reverse iterator to the beginning.
+     *
+     * If the sparse set is empty, the returned iterator will be equal to
+     * `rend()`.
+     *
+     * @return An iterator to the first entity of the reversed internal packed
+     * array.
+     */
+    [[nodiscard]] reverse_iterator rbegin() const noexcept {
+        return std::make_reverse_iterator(end());
+    }
 
-#ifdef ENTT_STANDARD_CPP
-#    define ENTT_NONSTD false
-#else
-#    define ENTT_NONSTD true
-#    if defined __clang__ || defined __GNUC__
-#        define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
-#        define ENTT_PRETTY_FUNCTION_PREFIX '='
-#        define ENTT_PRETTY_FUNCTION_SUFFIX ']'
-#    elif defined _MSC_VER
-#        define ENTT_PRETTY_FUNCTION __FUNCSIG__
-#        define ENTT_PRETTY_FUNCTION_PREFIX '<'
-#        define ENTT_PRETTY_FUNCTION_SUFFIX '>'
-#    endif
-#endif
+    /*! @copydoc rbegin */
+    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
+        return rbegin();
+    }
 
-#if defined _MSC_VER
-#    pragma detect_mismatch("entt.version", ENTT_VERSION)
-#    pragma detect_mismatch("entt.noexcept", ENTT_XSTR(ENTT_TRY))
-#    pragma detect_mismatch("entt.id", ENTT_XSTR(ENTT_ID_TYPE))
-#    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
-#endif
+    /**
+     * @brief Returns a reverse iterator to the end.
+     * @return An iterator to the element following the last entity of the
+     * reversed sparse set.
+     */
+    [[nodiscard]] reverse_iterator rend() const noexcept {
+        return std::make_reverse_iterator(begin());
+    }
 
-#endif
+    /*! @copydoc rend */
+    [[nodiscard]] const_reverse_iterator crend() const noexcept {
+        return rend();
+    }
 
-// #include "fwd.hpp"
-#ifndef ENTT_CORE_FWD_HPP
-#define ENTT_CORE_FWD_HPP
+    /**
+     * @brief Finds an entity.
+     * @param entt A valid identifier.
+     * @return An iterator to the given entity if it's found, past the end
+     * iterator otherwise.
+     */
+    [[nodiscard]] const_iterator find(const entity_type entt) const noexcept {
+        return contains(entt) ? to_iterator(entt) : end();
+    }
 
-#include <cstddef>
-// #include "../config/config.h"
+    /**
+     * @brief Checks if a sparse set contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the sparse set contains the entity, false otherwise.
+     */
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        const auto *elem = sparse_ptr(entt);
+        constexpr auto cap = traits_type::entity_mask;
+        constexpr auto mask = traits_type::to_integral(null) & ~cap;
+        // testing versions permits to avoid accessing the packed array
+        return elem && (((mask & traits_type::to_integral(entt)) ^ traits_type::to_integral(*elem)) < cap);
+    }
 
+    /**
+     * @brief Returns the contained version for an identifier.
+     * @param entt A valid identifier.
+     * @return The version for the given identifier if present, the tombstone
+     * version otherwise.
+     */
+    [[nodiscard]] version_type current(const entity_type entt) const noexcept {
+        const auto *elem = sparse_ptr(entt);
+        constexpr auto fallback = traits_type::to_version(tombstone);
+        return elem ? traits_type::to_version(*elem) : fallback;
+    }
 
-namespace entt {
+    /**
+     * @brief Returns the position of an entity in a sparse set.
+     *
+     * @warning
+     * Attempting to get the position of an entity that doesn't belong to the
+     * sparse set results in undefined behavior.
+     *
+     * @param entt A valid identifier.
+     * @return The position of the entity in the sparse set.
+     */
+    [[nodiscard]] size_type index(const entity_type entt) const noexcept {
+        ENTT_ASSERT(contains(entt), "Set does not contain entity");
+        return static_cast<size_type>(traits_type::to_entity(sparse_ref(entt)));
+    }
 
-template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
-class basic_any;
+    /**
+     * @brief Returns the entity at specified location.
+     * @param pos The position for which to return the entity.
+     * @return The entity at specified location.
+     */
+    [[nodiscard]] entity_type operator[](const size_type pos) const noexcept {
+        ENTT_ASSERT(pos < packed.size(), "Index out of bounds");
+        return packed[pos];
+    }
 
-/*! @brief Alias declaration for type identifiers. */
-using id_type = ENTT_ID_TYPE;
+    /**
+     * @brief Returns the element assigned to an entity, if any.
+     *
+     * @warning
+     * Attempting to use an entity that doesn't belong to the sparse set results
+     * in undefined behavior.
+     *
+     * @param entt A valid identifier.
+     * @return An opaque pointer to the element assigned to the entity, if any.
+     */
+    [[nodiscard]] const void *value(const entity_type entt) const noexcept {
+        return get_at(index(entt));
+    }
 
-/*! @brief Alias declaration for the most common use case. */
-using any = basic_any<>;
+    /*! @copydoc value */
+    [[nodiscard]] void *value(const entity_type entt) noexcept {
+        return const_cast<void *>(std::as_const(*this).value(entt));
+    }
 
-} // namespace entt
+    /**
+     * @brief Assigns an entity to a sparse set.
+     *
+     * @warning
+     * Attempting to assign an entity that already belongs to the sparse set
+     * results in undefined behavior.
+     *
+     * @param entt A valid identifier.
+     * @param elem Optional opaque element to forward to mixins, if any.
+     * @return Iterator pointing to the emplaced element in case of success, the
+     * `end()` iterator otherwise.
+     */
+    iterator push(const entity_type entt, const void *elem = nullptr) {
+        return try_emplace(entt, false, elem);
+    }
 
-#endif
+    /**
+     * @brief Assigns one or more entities to a sparse set.
+     *
+     * @warning
+     * Attempting to assign an entity that already belongs to the sparse set
+     * results in undefined behavior.
+     *
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     * @return Iterator pointing to the first element inserted in case of
+     * success, the `end()` iterator otherwise.
+     */
+    template<typename It>
+    iterator push(It first, It last) {
+        auto curr = end();
 
+        for(; first != last; ++first) {
+            curr = try_emplace(*first, true);
+        }
 
-namespace entt {
+        return curr;
+    }
 
-/**
- * @brief Utility class to disambiguate overloaded functions.
- * @tparam N Number of choices available.
- */
-template<std::size_t N>
-struct choice_t
-    // unfortunately, doxygen cannot parse such a construct
-    : /*! @cond TURN_OFF_DOXYGEN */ choice_t<N - 1> /*! @endcond */
-{};
+    /**
+     * @brief Bump the version number of an entity.
+     *
+     * @warning
+     * Attempting to bump the version of an entity that doesn't belong to the
+     * sparse set results in undefined behavior.
+     *
+     * @param entt A valid identifier.
+     * @return The version of the given identifier.
+     */
+    version_type bump(const entity_type entt) {
+        auto &elem = sparse_ref(entt);
+        ENTT_ASSERT(entt != null && elem != tombstone, "Cannot set the required version");
+        elem = traits_type::combine(traits_type::to_integral(elem), traits_type::to_integral(entt));
+        packed[static_cast<size_type>(traits_type::to_entity(elem))] = entt;
+        return traits_type::to_version(entt);
+    }
 
-/*! @copybrief choice_t */
-template<>
-struct choice_t<0> {};
+    /**
+     * @brief Erases an entity from a sparse set.
+     *
+     * @warning
+     * Attempting to erase an entity that doesn't belong to the sparse set
+     * results in undefined behavior.
+     *
+     * @param entt A valid identifier.
+     */
+    void erase(const entity_type entt) {
+        const auto it = to_iterator(entt);
+        pop(it, it + 1u);
+    }
 
-/**
- * @brief Variable template for the choice trick.
- * @tparam N Number of choices available.
- */
-template<std::size_t N>
-inline constexpr choice_t<N> choice{};
+    /**
+     * @brief Erases entities from a set.
+     *
+     * @sa erase
+     *
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     */
+    template<typename It>
+    void erase(It first, It last) {
+        if constexpr(std::is_same_v<It, basic_iterator>) {
+            pop(first, last);
+        } else {
+            for(; first != last; ++first) {
+                erase(*first);
+            }
+        }
+    }
 
-/**
- * @brief Identity type trait.
- *
- * Useful to establish non-deduced contexts in template argument deduction
- * (waiting for C++20) or to provide types through function arguments.
- *
- * @tparam Type A type.
- */
-template<typename Type>
-struct type_identity {
-    /*! @brief Identity type. */
-    using type = Type;
-};
+    /**
+     * @brief Removes an entity from a sparse set if it exists.
+     * @param entt A valid identifier.
+     * @return True if the entity is actually removed, false otherwise.
+     */
+    bool remove(const entity_type entt) {
+        return contains(entt) && (erase(entt), true);
+    }
 
-/**
- * @brief Helper type.
- * @tparam Type A type.
- */
-template<typename Type>
-using type_identity_t = typename type_identity<Type>::type;
+    /**
+     * @brief Removes entities from a sparse set if they exist.
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     * @return The number of entities actually removed.
+     */
+    template<typename It>
+    size_type remove(It first, It last) {
+        size_type count{};
 
-/**
- * @brief A type-only `sizeof` wrapper that returns 0 where `sizeof` complains.
- * @tparam Type The type of which to return the size.
- */
-template<typename Type, typename = void>
-struct size_of: std::integral_constant<std::size_t, 0u> {};
+        if constexpr(std::is_same_v<It, basic_iterator>) {
+            while(first != last) {
+                while(first != last && !contains(*first)) {
+                    ++first;
+                }
 
-/*! @copydoc size_of */
-template<typename Type>
-struct size_of<Type, std::void_t<decltype(sizeof(Type))>>
-    : std::integral_constant<std::size_t, sizeof(Type)> {};
+                const auto it = first;
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type of which to return the size.
- */
-template<typename Type>
-inline constexpr std::size_t size_of_v = size_of<Type>::value;
+                while(first != last && contains(*first)) {
+                    ++first;
+                }
 
-/**
- * @brief Using declaration to be used to _repeat_ the same type a number of
- * times equal to the size of a given parameter pack.
- * @tparam Type A type to repeat.
- */
-template<typename Type, typename>
-using unpack_as_type = Type;
+                count += std::distance(it, first);
+                erase(it, first);
+            }
+        } else {
+            for(; first != last; ++first) {
+                count += remove(*first);
+            }
+        }
 
-/**
- * @brief Helper variable template to be used to _repeat_ the same value a
- * number of times equal to the size of a given parameter pack.
- * @tparam Value A value to repeat.
- */
-template<auto Value, typename>
-inline constexpr auto unpack_as_value = Value;
+        return count;
+    }
 
-/**
- * @brief Wraps a static constant.
- * @tparam Value A static constant.
- */
-template<auto Value>
-using integral_constant = std::integral_constant<decltype(Value), Value>;
+    /*! @brief Removes all tombstones from a sparse set. */
+    void compact() {
+        if(mode == deletion_policy::in_place) {
+            size_type from = packed.size();
+            size_type pos = std::exchange(head, max_size);
 
-/**
- * @brief Alias template to facilitate the creation of named values.
- * @tparam Value A constant value at least convertible to `id_type`.
- */
-template<id_type Value>
-using tag = integral_constant<Value>;
+            for(; from && packed[from - 1u] == tombstone; --from) {}
 
-/**
- * @brief A class to use to push around lists of types, nothing more.
- * @tparam Type Types provided by the type list.
- */
-template<typename... Type>
-struct type_list {
-    /*! @brief Type list type. */
-    using type = type_list;
-    /*! @brief Compile-time number of elements in the type list. */
-    static constexpr auto size = sizeof...(Type);
-};
+            while(pos != max_size) {
+                if(const auto to = std::exchange(pos, static_cast<size_type>(traits_type::to_entity(packed[pos]))); to < from) {
+                    --from;
+                    swap_or_move(from, to);
 
-/*! @brief Primary template isn't defined on purpose. */
-template<std::size_t, typename>
-struct type_list_element;
+                    packed[to] = packed[from];
+                    const auto elem = static_cast<typename traits_type::entity_type>(to);
+                    sparse_ref(packed[to]) = traits_type::combine(elem, traits_type::to_integral(packed[to]));
 
-/**
- * @brief Provides compile-time indexed access to the types of a type list.
- * @tparam Index Index of the type to return.
- * @tparam First First type provided by the type list.
- * @tparam Other Other types provided by the type list.
- */
-template<std::size_t Index, typename First, typename... Other>
-struct type_list_element<Index, type_list<First, Other...>>
-    : type_list_element<Index - 1u, type_list<Other...>> {};
+                    for(; from && packed[from - 1u] == tombstone; --from) {}
+                }
+            }
 
-/**
- * @brief Provides compile-time indexed access to the types of a type list.
- * @tparam First First type provided by the type list.
- * @tparam Other Other types provided by the type list.
- */
-template<typename First, typename... Other>
-struct type_list_element<0u, type_list<First, Other...>> {
-    /*! @brief Searched type. */
-    using type = First;
-};
+            packed.erase(packed.begin() + from, packed.end());
+        }
+    }
 
-/**
- * @brief Helper type.
- * @tparam Index Index of the type to return.
- * @tparam List Type list to search into.
- */
-template<std::size_t Index, typename List>
-using type_list_element_t = typename type_list_element<Index, List>::type;
+    /**
+     * @brief Swaps two entities in a sparse set.
+     *
+     * For what it's worth, this function affects both the internal sparse array
+     * and the internal packed array. Users should not care of that anyway.
+     *
+     * @warning
+     * Attempting to swap entities that don't belong to the sparse set results
+     * in undefined behavior.
+     *
+     * @param lhs A valid identifier.
+     * @param rhs A valid identifier.
+     */
+    void swap_elements(const entity_type lhs, const entity_type rhs) {
+        const auto from = index(lhs);
+        const auto to = index(rhs);
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename, typename>
-struct type_list_index;
+        // basic no-leak guarantee if swapping throws
+        swap_or_move(from, to);
+        swap_at(from, to);
+    }
 
-/**
- * @brief Provides compile-time type access to the types of a type list.
- * @tparam Type Type to look for and for which to return the index.
- * @tparam First First type provided by the type list.
- * @tparam Other Other types provided by the type list.
- */
-template<typename Type, typename First, typename... Other>
-struct type_list_index<Type, type_list<First, Other...>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 1u + type_list_index<Type, type_list<Other...>>::value;
-};
+    /**
+     * @brief Sort the first count elements according to the given comparison
+     * function.
+     *
+     * The comparison function object must return `true` if the first element
+     * is _less_ than the second one, `false` otherwise. The signature of the
+     * comparison function should be equivalent to the following:
+     *
+     * @code{.cpp}
+     * bool(const Entity, const Entity);
+     * @endcode
+     *
+     * Moreover, the comparison function object shall induce a
+     * _strict weak ordering_ on the values.
+     *
+     * The sort function object must offer a member function template
+     * `operator()` that accepts three arguments:
+     *
+     * * An iterator to the first element of the range to sort.
+     * * An iterator past the last element of the range to sort.
+     * * A comparison function to use to compare the elements.
+     *
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param length Number of elements to sort.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<typename Compare, typename Sort = std_sort, typename... Args>
+    void sort_n(const size_type length, Compare compare, Sort algo = Sort{}, Args &&...args) {
+        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == max_size), "Sorting with tombstones not allowed");
+        ENTT_ASSERT(!(length > packed.size()), "Length exceeds the number of elements");
 
-/**
- * @brief Provides compile-time type access to the types of a type list.
- * @tparam Type Type to look for and for which to return the index.
- * @tparam Other Other types provided by the type list.
- */
-template<typename Type, typename... Other>
-struct type_list_index<Type, type_list<Type, Other...>> {
-    static_assert(type_list_index<Type, type_list<Other...>>::value == sizeof...(Other), "Non-unique type");
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 0u;
-};
+        algo(packed.rend() - length, packed.rend(), std::move(compare), std::forward<Args>(args)...);
 
-/**
- * @brief Provides compile-time type access to the types of a type list.
- * @tparam Type Type to look for and for which to return the index.
- */
-template<typename Type>
-struct type_list_index<Type, type_list<>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 0u;
-};
+        for(size_type pos{}; pos < length; ++pos) {
+            auto curr = pos;
+            auto next = index(packed[curr]);
 
-/**
- * @brief Helper variable template.
- * @tparam List Type list.
- * @tparam Type Type to look for and for which to return the index.
- */
-template<typename Type, typename List>
-inline constexpr std::size_t type_list_index_v = type_list_index<Type, List>::value;
+            while(curr != next) {
+                const auto idx = index(packed[next]);
+                const auto entt = packed[curr];
 
-/**
- * @brief Concatenates multiple type lists.
- * @tparam Type Types provided by the first type list.
- * @tparam Other Types provided by the second type list.
- * @return A type list composed by the types of both the type lists.
- */
-template<typename... Type, typename... Other>
-constexpr type_list<Type..., Other...> operator+(type_list<Type...>, type_list<Other...>) {
-    return {};
-}
+                swap_or_move(next, idx);
+                const auto elem = static_cast<typename traits_type::entity_type>(curr);
+                sparse_ref(entt) = traits_type::combine(elem, traits_type::to_integral(packed[curr]));
+                curr = std::exchange(next, idx);
+            }
+        }
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct type_list_cat;
+    /**
+     * @brief Sort all elements according to the given comparison function.
+     *
+     * @sa sort_n
+     *
+     * @tparam Compare Type of comparison function object.
+     * @tparam Sort Type of sort function object.
+     * @tparam Args Types of arguments to forward to the sort function object.
+     * @param compare A valid comparison function object.
+     * @param algo A valid sort function object.
+     * @param args Arguments to forward to the sort function object, if any.
+     */
+    template<typename Compare, typename Sort = std_sort, typename... Args>
+    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
+        const size_type len = (mode == deletion_policy::swap_only) ? head : packed.size();
+        sort_n(len, std::move(compare), std::move(algo), std::forward<Args>(args)...);
+    }
 
-/*! @brief Concatenates multiple type lists. */
-template<>
-struct type_list_cat<> {
-    /*! @brief A type list composed by the types of all the type lists. */
-    using type = type_list<>;
-};
+    /**
+     * @brief Sort entities according to their order in a range.
+     *
+     * Entities that are part of both the sparse set and the range are ordered
+     * internally according to the order they have in the range.<br/>
+     * All other entities goes to the end of the sparse set and there are no
+     * guarantees on their order.
+     *
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     * @return An iterator past the last of the elements actually shared.
+     */
+    template<typename It>
+    iterator sort_as(It first, It last) {
+        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == max_size), "Sorting with tombstones not allowed");
+        const size_type len = (mode == deletion_policy::swap_only) ? head : packed.size();
+        auto it = end() - static_cast<typename iterator::difference_type>(len);
 
-/**
- * @brief Concatenates multiple type lists.
- * @tparam Type Types provided by the first type list.
- * @tparam Other Types provided by the second type list.
- * @tparam List Other type lists, if any.
- */
-template<typename... Type, typename... Other, typename... List>
-struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
-    /*! @brief A type list composed by the types of all the type lists. */
-    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
-};
+        for(const auto other = end(); (it != other) && (first != last); ++first) {
+            if(const auto curr = *first; contains(curr)) {
+                if(const auto entt = *it; entt != curr) {
+                    // basic no-leak guarantee (with invalid state) if swapping throws
+                    swap_elements(entt, curr);
+                }
 
-/**
- * @brief Concatenates multiple type lists.
- * @tparam Type Types provided by the type list.
- */
-template<typename... Type>
-struct type_list_cat<type_list<Type...>> {
-    /*! @brief A type list composed by the types of all the type lists. */
-    using type = type_list<Type...>;
-};
+                ++it;
+            }
+        }
 
-/**
- * @brief Helper type.
- * @tparam List Type lists to concatenate.
- */
-template<typename... List>
-using type_list_cat_t = typename type_list_cat<List...>::type;
+        return it;
+    }
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+    /*! @brief Clears a sparse set. */
+    void clear() {
+        pop_all();
+        // sanity check to avoid subtle issues due to storage classes
+        ENTT_ASSERT((compact(), size()) == 0u, "Non-empty set");
+        head = policy_to_head();
+        packed.clear();
+    }
 
-template<typename...>
-struct type_list_unique;
+    /**
+     * @brief Returned value type, if any.
+     * @return Returned value type, if any.
+     */
+    [[nodiscard]] const type_info &type() const noexcept {
+        return *info;
+    }
 
-template<typename First, typename... Other, typename... Type>
-struct type_list_unique<type_list<First, Other...>, Type...>
-    : std::conditional_t<(std::is_same_v<First, Type> || ...), type_list_unique<type_list<Other...>, Type...>, type_list_unique<type_list<Other...>, Type..., First>> {};
+    /**
+     * @brief Forwards variables to derived classes, if any.
+     * @tparam Type Type of the element to forward.
+     * @param value The element to forward.
+     * @return Nothing.
+     */
+    template<typename Type>
+    [[deprecated("avoid wrapping elements with basic_any")]] std::enable_if_t<std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, basic_any<>>>
+    bind(Type &&value) noexcept {
+        // backward compatibility
+        bind_any(std::forward<Type>(value));
+    }
 
-template<typename... Type>
-struct type_list_unique<type_list<>, Type...> {
-    using type = type_list<Type...>;
+    /**
+     * @brief Forwards variables to derived classes, if any.
+     * @tparam Type Type of the element to forward.
+     * @param value The element to forward.
+     * @return Nothing.
+     */
+    template<typename Type>
+    std::enable_if_t<!std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, basic_any<>>>
+    bind(Type &&value) noexcept {
+        bind_any(forward_as_any(std::forward<Type>(value)));
+    }
+
+private:
+    sparse_container_type sparse;
+    packed_container_type packed;
+    const type_info *info;
+    deletion_policy mode;
+    size_type head;
 };
 
-} // namespace internal
-/*! @endcond */
+} // namespace entt
 
-/**
- * @brief Removes duplicates types from a type list.
- * @tparam List Type list.
- */
-template<typename List>
-struct type_list_unique {
-    /*! @brief A type list without duplicate types. */
-    using type = typename internal::type_list_unique<List>::type;
-};
+#endif
 
-/**
- * @brief Helper type.
- * @tparam List Type list.
- */
-template<typename List>
-using type_list_unique_t = typename type_list_unique<List>::type;
 
-/**
- * @brief Provides the member constant `value` to true if a type list contains a
- * given type, false otherwise.
- * @tparam List Type list.
- * @tparam Type Type to look for.
- */
-template<typename List, typename Type>
-struct type_list_contains;
+namespace entt {
 
-/**
- * @copybrief type_list_contains
- * @tparam Type Types provided by the type list.
- * @tparam Other Type to look for.
- */
-template<typename... Type, typename Other>
-struct type_list_contains<type_list<Type...>, Other>
-    : std::bool_constant<(std::is_same_v<Type, Other> || ...)> {};
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-/**
- * @brief Helper variable template.
- * @tparam List Type list.
- * @tparam Type Type to look for.
- */
-template<typename List, typename Type>
-inline constexpr bool type_list_contains_v = type_list_contains<List, Type>::value;
+template<typename Container>
+class storage_iterator final {
+    friend storage_iterator<const Container>;
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct type_list_diff;
+    using container_type = std::remove_const_t<Container>;
+    using alloc_traits = std::allocator_traits<typename container_type::allocator_type>;
 
-/**
- * @brief Computes the difference between two type lists.
- * @tparam Type Types provided by the first type list.
- * @tparam Other Types provided by the second type list.
- */
-template<typename... Type, typename... Other>
-struct type_list_diff<type_list<Type...>, type_list<Other...>> {
-    /*! @brief A type list that is the difference between the two type lists. */
-    using type = type_list_cat_t<std::conditional_t<type_list_contains_v<type_list<Other...>, Type>, type_list<>, type_list<Type>>...>;
-};
+    using iterator_traits = std::iterator_traits<std::conditional_t<
+        std::is_const_v<Container>,
+        typename alloc_traits::template rebind_traits<typename std::pointer_traits<typename container_type::value_type>::element_type>::const_pointer,
+        typename alloc_traits::template rebind_traits<typename std::pointer_traits<typename container_type::value_type>::element_type>::pointer>>;
 
-/**
- * @brief Helper type.
- * @tparam List Type lists between which to compute the difference.
- */
-template<typename... List>
-using type_list_diff_t = typename type_list_diff<List...>::type;
+public:
+    using value_type = typename iterator_traits::value_type;
+    using pointer = typename iterator_traits::pointer;
+    using reference = typename iterator_traits::reference;
+    using difference_type = typename iterator_traits::difference_type;
+    using iterator_category = std::random_access_iterator_tag;
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename, template<typename...> class>
-struct type_list_transform;
+    constexpr storage_iterator() noexcept = default;
 
-/**
- * @brief Applies a given _function_ to a type list and generate a new list.
- * @tparam Type Types provided by the type list.
- * @tparam Op Unary operation as template class with a type member named `type`.
- */
-template<typename... Type, template<typename...> class Op>
-struct type_list_transform<type_list<Type...>, Op> {
-    /*! @brief Resulting type list after applying the transform function. */
-    using type = type_list<typename Op<Type>::type...>;
-};
+    constexpr storage_iterator(Container *ref, const difference_type idx) noexcept
+        : payload{ref},
+          offset{idx} {}
 
-/**
- * @brief Helper type.
- * @tparam List Type list.
- * @tparam Op Unary operation as template class with a type member named `type`.
- */
-template<typename List, template<typename...> class Op>
-using type_list_transform_t = typename type_list_transform<List, Op>::type;
+    template<bool Const = std::is_const_v<Container>, typename = std::enable_if_t<Const>>
+    constexpr storage_iterator(const storage_iterator<std::remove_const_t<Container>> &other) noexcept
+        : storage_iterator{other.payload, other.offset} {}
 
-/**
- * @brief A class to use to push around lists of constant values, nothing more.
- * @tparam Value Values provided by the value list.
- */
-template<auto... Value>
-struct value_list {
-    /*! @brief Value list type. */
-    using type = value_list;
-    /*! @brief Compile-time number of elements in the value list. */
-    static constexpr auto size = sizeof...(Value);
-};
+    constexpr storage_iterator &operator++() noexcept {
+        return --offset, *this;
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<std::size_t, typename>
-struct value_list_element;
+    constexpr storage_iterator operator++(int) noexcept {
+        storage_iterator orig = *this;
+        return ++(*this), orig;
+    }
 
-/**
- * @brief Provides compile-time indexed access to the values of a value list.
- * @tparam Index Index of the value to return.
- * @tparam Value First value provided by the value list.
- * @tparam Other Other values provided by the value list.
- */
-template<std::size_t Index, auto Value, auto... Other>
-struct value_list_element<Index, value_list<Value, Other...>>
-    : value_list_element<Index - 1u, value_list<Other...>> {};
+    constexpr storage_iterator &operator--() noexcept {
+        return ++offset, *this;
+    }
 
-/**
- * @brief Provides compile-time indexed access to the types of a type list.
- * @tparam Value First value provided by the value list.
- * @tparam Other Other values provided by the value list.
- */
-template<auto Value, auto... Other>
-struct value_list_element<0u, value_list<Value, Other...>> {
-    /*! @brief Searched type. */
-    using type = decltype(Value);
-    /*! @brief Searched value. */
-    static constexpr auto value = Value;
-};
+    constexpr storage_iterator operator--(int) noexcept {
+        storage_iterator orig = *this;
+        return operator--(), orig;
+    }
 
-/**
- * @brief Helper type.
- * @tparam Index Index of the type to return.
- * @tparam List Value list to search into.
- */
-template<std::size_t Index, typename List>
-using value_list_element_t = typename value_list_element<Index, List>::type;
+    constexpr storage_iterator &operator+=(const difference_type value) noexcept {
+        offset -= value;
+        return *this;
+    }
 
-/**
- * @brief Helper type.
- * @tparam Index Index of the value to return.
- * @tparam List Value list to search into.
- */
-template<std::size_t Index, typename List>
-inline constexpr auto value_list_element_v = value_list_element<Index, List>::value;
+    constexpr storage_iterator operator+(const difference_type value) const noexcept {
+        storage_iterator copy = *this;
+        return (copy += value);
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<auto, typename>
-struct value_list_index;
+    constexpr storage_iterator &operator-=(const difference_type value) noexcept {
+        return (*this += -value);
+    }
 
-/**
- * @brief Provides compile-time type access to the values of a value list.
- * @tparam Value Value to look for and for which to return the index.
- * @tparam First First value provided by the value list.
- * @tparam Other Other values provided by the value list.
- */
-template<auto Value, auto First, auto... Other>
-struct value_list_index<Value, value_list<First, Other...>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given value in the sublist. */
-    static constexpr value_type value = 1u + value_list_index<Value, value_list<Other...>>::value;
-};
+    constexpr storage_iterator operator-(const difference_type value) const noexcept {
+        return (*this + -value);
+    }
 
-/**
- * @brief Provides compile-time type access to the values of a value list.
- * @tparam Value Value to look for and for which to return the index.
- * @tparam Other Other values provided by the value list.
- */
-template<auto Value, auto... Other>
-struct value_list_index<Value, value_list<Value, Other...>> {
-    static_assert(value_list_index<Value, value_list<Other...>>::value == sizeof...(Other), "Non-unique type");
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given value in the sublist. */
-    static constexpr value_type value = 0u;
-};
+    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
+        const auto pos = index() - value;
+        constexpr auto page_size = component_traits<value_type>::page_size;
+        return (*payload)[pos / page_size][fast_mod(static_cast<std::size_t>(pos), page_size)];
+    }
 
-/**
- * @brief Provides compile-time type access to the values of a value list.
- * @tparam Value Value to look for and for which to return the index.
- */
-template<auto Value>
-struct value_list_index<Value, value_list<>> {
-    /*! @brief Unsigned integer type. */
-    using value_type = std::size_t;
-    /*! @brief Compile-time position of the given type in the sublist. */
-    static constexpr value_type value = 0u;
+    [[nodiscard]] constexpr pointer operator->() const noexcept {
+        return std::addressof(operator[](0));
+    }
+
+    [[nodiscard]] constexpr reference operator*() const noexcept {
+        return operator[](0);
+    }
+
+    [[nodiscard]] constexpr difference_type index() const noexcept {
+        return offset - 1;
+    }
+
+private:
+    Container *payload;
+    difference_type offset;
 };
 
-/**
- * @brief Helper variable template.
- * @tparam List Value list.
- * @tparam Value Value to look for and for which to return the index.
- */
-template<auto Value, typename List>
-inline constexpr std::size_t value_list_index_v = value_list_index<Value, List>::value;
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr std::ptrdiff_t operator-(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return rhs.index() - lhs.index();
+}
 
-/**
- * @brief Concatenates multiple value lists.
- * @tparam Value Values provided by the first value list.
- * @tparam Other Values provided by the second value list.
- * @return A value list composed by the values of both the value lists.
- */
-template<auto... Value, auto... Other>
-constexpr value_list<Value..., Other...> operator+(value_list<Value...>, value_list<Other...>) {
-    return {};
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator==(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return lhs.index() == rhs.index();
 }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct value_list_cat;
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator!=(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return !(lhs == rhs);
+}
 
-/*! @brief Concatenates multiple value lists. */
-template<>
-struct value_list_cat<> {
-    /*! @brief A value list composed by the values of all the value lists. */
-    using type = value_list<>;
-};
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator<(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return lhs.index() > rhs.index();
+}
 
-/**
- * @brief Concatenates multiple value lists.
- * @tparam Value Values provided by the first value list.
- * @tparam Other Values provided by the second value list.
- * @tparam List Other value lists, if any.
- */
-template<auto... Value, auto... Other, typename... List>
-struct value_list_cat<value_list<Value...>, value_list<Other...>, List...> {
-    /*! @brief A value list composed by the values of all the value lists. */
-    using type = typename value_list_cat<value_list<Value..., Other...>, List...>::type;
-};
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator>(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return rhs < lhs;
+}
 
-/**
- * @brief Concatenates multiple value lists.
- * @tparam Value Values provided by the value list.
- */
-template<auto... Value>
-struct value_list_cat<value_list<Value...>> {
-    /*! @brief A value list composed by the values of all the value lists. */
-    using type = value_list<Value...>;
-};
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator<=(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return !(lhs > rhs);
+}
 
-/**
- * @brief Helper type.
- * @tparam List Value lists to concatenate.
- */
-template<typename... List>
-using value_list_cat_t = typename value_list_cat<List...>::type;
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator>=(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
+    return !(lhs < rhs);
+}
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename>
-struct value_list_unique;
+template<typename It, typename... Other>
+class extended_storage_iterator final {
+    template<typename Iter, typename... Args>
+    friend class extended_storage_iterator;
 
-/**
- * @brief Removes duplicates values from a value list.
- * @tparam Value One of the values provided by the given value list.
- * @tparam Other The other values provided by the given value list.
- */
-template<auto Value, auto... Other>
-struct value_list_unique<value_list<Value, Other...>> {
-    /*! @brief A value list without duplicate types. */
-    using type = std::conditional_t<
-        ((Value == Other) || ...),
-        typename value_list_unique<value_list<Other...>>::type,
-        value_list_cat_t<value_list<Value>, typename value_list_unique<value_list<Other...>>::type>>;
-};
+public:
+    using iterator_type = It;
+    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::forward_as_tuple(*std::declval<Other>()...)));
+    using pointer = input_iterator_pointer<value_type>;
+    using reference = value_type;
+    using difference_type = std::ptrdiff_t;
+    using iterator_category = std::input_iterator_tag;
+    using iterator_concept = std::forward_iterator_tag;
 
-/*! @brief Removes duplicates values from a value list. */
-template<>
-struct value_list_unique<value_list<>> {
-    /*! @brief A value list without duplicate types. */
-    using type = value_list<>;
-};
+    constexpr extended_storage_iterator()
+        : it{} {}
 
-/**
- * @brief Helper type.
- * @tparam Type A value list.
- */
-template<typename Type>
-using value_list_unique_t = typename value_list_unique<Type>::type;
+    constexpr extended_storage_iterator(iterator_type base, Other... other)
+        : it{base, other...} {}
 
-/**
- * @brief Provides the member constant `value` to true if a value list contains
- * a given value, false otherwise.
- * @tparam List Value list.
- * @tparam Value Value to look for.
- */
-template<typename List, auto Value>
-struct value_list_contains;
+    template<typename... Args, typename = std::enable_if_t<(!std::is_same_v<Other, Args> && ...) && (std::is_constructible_v<Other, Args> && ...)>>
+    constexpr extended_storage_iterator(const extended_storage_iterator<It, Args...> &other)
+        : it{other.it} {}
 
-/**
- * @copybrief value_list_contains
- * @tparam Value Values provided by the value list.
- * @tparam Other Value to look for.
- */
-template<auto... Value, auto Other>
-struct value_list_contains<value_list<Value...>, Other>
-    : std::bool_constant<((Value == Other) || ...)> {};
+    constexpr extended_storage_iterator &operator++() noexcept {
+        return ++std::get<It>(it), (++std::get<Other>(it), ...), *this;
+    }
 
-/**
- * @brief Helper variable template.
- * @tparam List Value list.
- * @tparam Value Value to look for.
- */
-template<typename List, auto Value>
-inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::value;
+    constexpr extended_storage_iterator operator++(int) noexcept {
+        extended_storage_iterator orig = *this;
+        return ++(*this), orig;
+    }
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-class value_list_diff;
+    [[nodiscard]] constexpr pointer operator->() const noexcept {
+        return operator*();
+    }
 
-/**
- * @brief Computes the difference between two value lists.
- * @tparam Value Values provided by the first value list.
- * @tparam Other Values provided by the second value list.
- */
-template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
+    [[nodiscard]] constexpr reference operator*() const noexcept {
+        return {*std::get<It>(it), *std::get<Other>(it)...};
+    }
 
-public:
-    /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    [[nodiscard]] constexpr iterator_type base() const noexcept {
+        return std::get<It>(it);
+    }
+
+    template<typename... Lhs, typename... Rhs>
+    friend constexpr bool operator==(const extended_storage_iterator<Lhs...> &, const extended_storage_iterator<Rhs...> &) noexcept;
+
+private:
+    std::tuple<It, Other...> it;
 };
 
-/**
- * @brief Helper type.
- * @tparam List Value lists between which to compute the difference.
- */
-template<typename... List>
-using value_list_diff_t = typename value_list_diff<List...>::type;
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator==(const extended_storage_iterator<Lhs...> &lhs, const extended_storage_iterator<Rhs...> &rhs) noexcept {
+    return std::get<0>(lhs.it) == std::get<0>(rhs.it);
+}
 
-/*! @brief Same as std::is_invocable, but with tuples. */
-template<typename, typename>
-struct is_applicable: std::false_type {};
+template<typename... Lhs, typename... Rhs>
+[[nodiscard]] constexpr bool operator!=(const extended_storage_iterator<Lhs...> &lhs, const extended_storage_iterator<Rhs...> &rhs) noexcept {
+    return !(lhs == rhs);
+}
 
-/**
- * @copybrief is_applicable
- * @tparam Func A valid function type.
- * @tparam Tuple Tuple-like type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Func, template<typename...> class Tuple, typename... Args>
-struct is_applicable<Func, Tuple<Args...>>: std::is_invocable<Func, Args...> {};
+} // namespace internal
+/*! @endcond */
 
 /**
- * @copybrief is_applicable
- * @tparam Func A valid function type.
- * @tparam Tuple Tuple-like type.
- * @tparam Args The list of arguments to use to probe the function type.
+ * @brief Storage implementation.
+ *
+ * Internal data structures arrange elements to maximize performance. There are
+ * no guarantees that objects are returned in the insertion order when iterate
+ * a storage. Do not make assumption on the order in any case.
+ *
+ * @warning
+ * Empty types aren't explicitly instantiated. Therefore, many of the functions
+ * normally available for non-empty types will not be available for empty ones.
+ *
+ * @tparam Type Element type.
+ * @tparam Entity A valid entity type.
+ * @tparam Allocator Type of allocator used to manage memory and elements.
  */
-template<typename Func, template<typename...> class Tuple, typename... Args>
-struct is_applicable<Func, const Tuple<Args...>>: std::is_invocable<Func, Args...> {};
+template<typename Type, typename Entity, typename Allocator, typename>
+class basic_storage: public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
+    using alloc_traits = std::allocator_traits<Allocator>;
+    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
+    using container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
+    using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
+    using underlying_iterator = typename underlying_type::basic_iterator;
+    using traits_type = component_traits<Type>;
 
-/**
- * @brief Helper variable template.
- * @tparam Func A valid function type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Func, typename Args>
-inline constexpr bool is_applicable_v = is_applicable<Func, Args>::value;
+    [[nodiscard]] auto &element_at(const std::size_t pos) const {
+        return payload[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
+    }
 
-/*! @brief Same as std::is_invocable_r, but with tuples for arguments. */
-template<typename, typename, typename>
-struct is_applicable_r: std::false_type {};
+    auto assure_at_least(const std::size_t pos) {
+        const auto idx = pos / traits_type::page_size;
 
-/**
- * @copybrief is_applicable_r
- * @tparam Ret The type to which the return type of the function should be
- * convertible.
- * @tparam Func A valid function type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Ret, typename Func, typename... Args>
-struct is_applicable_r<Ret, Func, std::tuple<Args...>>: std::is_invocable_r<Ret, Func, Args...> {};
+        if(!(idx < payload.size())) {
+            auto curr = payload.size();
+            allocator_type allocator{get_allocator()};
+            payload.resize(idx + 1u, nullptr);
 
-/**
- * @brief Helper variable template.
- * @tparam Ret The type to which the return type of the function should be
- * convertible.
- * @tparam Func A valid function type.
- * @tparam Args The list of arguments to use to probe the function type.
- */
-template<typename Ret, typename Func, typename Args>
-inline constexpr bool is_applicable_r_v = is_applicable_r<Ret, Func, Args>::value;
+            ENTT_TRY {
+                for(const auto last = payload.size(); curr < last; ++curr) {
+                    payload[curr] = alloc_traits::allocate(allocator, traits_type::page_size);
+                }
+            }
+            ENTT_CATCH {
+                payload.resize(curr);
+                ENTT_THROW;
+            }
+        }
 
-/**
- * @brief Provides the member constant `value` to true if a given type is
- * complete, false otherwise.
- * @tparam Type The type to test.
- */
-template<typename Type, typename = void>
-struct is_complete: std::false_type {};
+        return payload[idx] + fast_mod(pos, traits_type::page_size);
+    }
 
-/*! @copydoc is_complete */
-template<typename Type>
-struct is_complete<Type, std::void_t<decltype(sizeof(Type))>>: std::true_type {};
+    template<typename... Args>
+    auto emplace_element(const Entity entt, const bool force_back, Args &&...args) {
+        const auto it = base_type::try_emplace(entt, force_back);
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_complete_v = is_complete<Type>::value;
+        ENTT_TRY {
+            auto *elem = to_address(assure_at_least(static_cast<size_type>(it.index())));
+            entt::uninitialized_construct_using_allocator(elem, get_allocator(), std::forward<Args>(args)...);
+        }
+        ENTT_CATCH {
+            base_type::pop(it, it + 1u);
+            ENTT_THROW;
+        }
 
-/**
- * @brief Provides the member constant `value` to true if a given type is an
- * iterator, false otherwise.
- * @tparam Type The type to test.
- */
-template<typename Type, typename = void>
-struct is_iterator: std::false_type {};
+        return it;
+    }
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+    void shrink_to_size(const std::size_t sz) {
+        const auto from = (sz + traits_type::page_size - 1u) / traits_type::page_size;
+        allocator_type allocator{get_allocator()};
 
-template<typename, typename = void>
-struct has_iterator_category: std::false_type {};
+        for(auto pos = sz, length = base_type::size(); pos < length; ++pos) {
+            if constexpr(traits_type::in_place_delete) {
+                if(base_type::data()[pos] != tombstone) {
+                    alloc_traits::destroy(allocator, std::addressof(element_at(pos)));
+                }
+            } else {
+                alloc_traits::destroy(allocator, std::addressof(element_at(pos)));
+            }
+        }
 
-template<typename Type>
-struct has_iterator_category<Type, std::void_t<typename std::iterator_traits<Type>::iterator_category>>: std::true_type {};
+        for(auto pos = from, last = payload.size(); pos < last; ++pos) {
+            alloc_traits::deallocate(allocator, payload[pos], traits_type::page_size);
+        }
 
-} // namespace internal
-/*! @endcond */
+        payload.resize(from);
+    }
 
-/*! @copydoc is_iterator */
-template<typename Type>
-struct is_iterator<Type, std::enable_if_t<!std::is_void_v<std::remove_cv_t<std::remove_pointer_t<Type>>>>>
-    : internal::has_iterator_category<Type> {};
+private:
+    [[nodiscard]] const void *get_at(const std::size_t pos) const final {
+        return std::addressof(element_at(pos));
+    }
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_iterator_v = is_iterator<Type>::value;
+    void swap_or_move([[maybe_unused]] const std::size_t from, [[maybe_unused]] const std::size_t to) override {
+        static constexpr bool is_pinned_type_v = !(std::is_move_constructible_v<Type> && std::is_move_assignable_v<Type>);
+        // use a runtime value to avoid compile-time suppression that drives the code coverage tool crazy
+        ENTT_ASSERT((from + 1u) && !is_pinned_type_v, "Pinned type");
 
-/**
- * @brief Provides the member constant `value` to true if a given type is both
- * an empty and non-final class, false otherwise.
- * @tparam Type The type to test
- */
-template<typename Type>
-struct is_ebco_eligible
-    : std::bool_constant<std::is_empty_v<Type> && !std::is_final_v<Type>> {};
+        if constexpr(!is_pinned_type_v) {
+            auto &elem = element_at(from);
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_ebco_eligible_v = is_ebco_eligible<Type>::value;
+            if constexpr(traits_type::in_place_delete) {
+                if(base_type::operator[](to) == tombstone) {
+                    allocator_type allocator{get_allocator()};
+                    entt::uninitialized_construct_using_allocator(to_address(assure_at_least(to)), allocator, std::move(elem));
+                    alloc_traits::destroy(allocator, std::addressof(elem));
+                    return;
+                }
+            }
 
-/**
- * @brief Provides the member constant `value` to true if `Type::is_transparent`
- * is valid and denotes a type, false otherwise.
- * @tparam Type The type to test.
- */
-template<typename Type, typename = void>
-struct is_transparent: std::false_type {};
+            using std::swap;
+            swap(elem, element_at(to));
+        }
+    }
 
-/*! @copydoc is_transparent */
-template<typename Type>
-struct is_transparent<Type, std::void_t<typename Type::is_transparent>>: std::true_type {};
+protected:
+    /**
+     * @brief Erases entities from a storage.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     */
+    void pop(underlying_iterator first, underlying_iterator last) override {
+        for(allocator_type allocator{get_allocator()}; first != last; ++first) {
+            // cannot use first.index() because it would break with cross iterators
+            auto &elem = element_at(base_type::index(*first));
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_transparent_v = is_transparent<Type>::value;
+            if constexpr(traits_type::in_place_delete) {
+                base_type::in_place_pop(first);
+                alloc_traits::destroy(allocator, std::addressof(elem));
+            } else {
+                auto &other = element_at(base_type::size() - 1u);
+                // destroying on exit allows reentrant destructors
+                [[maybe_unused]] auto unused = std::exchange(elem, std::move(other));
+                alloc_traits::destroy(allocator, std::addressof(other));
+                base_type::swap_and_pop(first);
+            }
+        }
+    }
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+    /*! @brief Erases all entities of a storage. */
+    void pop_all() override {
+        allocator_type allocator{get_allocator()};
 
-template<typename, typename = void>
-struct has_tuple_size_value: std::false_type {};
+        for(auto first = base_type::begin(); !(first.index() < 0); ++first) {
+            if constexpr(traits_type::in_place_delete) {
+                if(*first != tombstone) {
+                    base_type::in_place_pop(first);
+                    alloc_traits::destroy(allocator, std::addressof(element_at(static_cast<size_type>(first.index()))));
+                }
+            } else {
+                base_type::swap_and_pop(first);
+                alloc_traits::destroy(allocator, std::addressof(element_at(static_cast<size_type>(first.index()))));
+            }
+        }
+    }
 
-template<typename Type>
-struct has_tuple_size_value<Type, std::void_t<decltype(std::tuple_size<const Type>::value)>>: std::true_type {};
+    /**
+     * @brief Assigns an entity to a storage.
+     * @param entt A valid identifier.
+     * @param value Optional opaque value.
+     * @param force_back Force back insertion.
+     * @return Iterator pointing to the emplaced element.
+     */
+    underlying_iterator try_emplace([[maybe_unused]] const Entity entt, [[maybe_unused]] const bool force_back, const void *value) override {
+        if(value != nullptr) {
+            if constexpr(std::is_copy_constructible_v<element_type>) {
+                return emplace_element(entt, force_back, *static_cast<const element_type *>(value));
+            } else {
+                return base_type::end();
+            }
+        } else {
+            if constexpr(std::is_default_constructible_v<element_type>) {
+                return emplace_element(entt, force_back);
+            } else {
+                return base_type::end();
+            }
+        }
+    }
 
-template<typename, typename = void>
-struct has_value_type: std::false_type {};
+public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
+    /*! @brief Base type. */
+    using base_type = underlying_type;
+    /*! @brief Element type. */
+    using element_type = Type;
+    /*! @brief Type of the objects assigned to entities. */
+    using value_type = element_type;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = Entity;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Pointer type to contained elements. */
+    using pointer = typename container_type::pointer;
+    /*! @brief Constant pointer type to contained elements. */
+    using const_pointer = typename alloc_traits::template rebind_traits<typename alloc_traits::const_pointer>::const_pointer;
+    /*! @brief Random access iterator type. */
+    using iterator = internal::storage_iterator<container_type>;
+    /*! @brief Constant random access iterator type. */
+    using const_iterator = internal::storage_iterator<const container_type>;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = std::reverse_iterator<iterator>;
+    /*! @brief Constant reverse iterator type. */
+    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+    /*! @brief Extended iterable storage proxy. */
+    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator, iterator>>;
+    /*! @brief Constant extended iterable storage proxy. */
+    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator, const_iterator>>;
+    /*! @brief Extended reverse iterable storage proxy. */
+    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator, reverse_iterator>>;
+    /*! @brief Constant extended reverse iterable storage proxy. */
+    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator, const_reverse_iterator>>;
+    /*! @brief Storage deletion policy. */
+    static constexpr deletion_policy storage_policy{traits_type::in_place_delete};
 
-template<typename Type>
-struct has_value_type<Type, std::void_t<typename Type::value_type>>: std::true_type {};
+    /*! @brief Default constructor. */
+    basic_storage()
+        : basic_storage{allocator_type{}} {}
 
-template<typename>
-[[nodiscard]] constexpr bool dispatch_is_equality_comparable();
+    /**
+     * @brief Constructs an empty storage with a given allocator.
+     * @param allocator The allocator to use.
+     */
+    explicit basic_storage(const allocator_type &allocator)
+        : base_type{type_id<element_type>(), storage_policy, allocator},
+          payload{allocator} {}
 
-template<typename Type, std::size_t... Index>
-[[nodiscard]] constexpr bool unpack_maybe_equality_comparable(std::index_sequence<Index...>) {
-    return (dispatch_is_equality_comparable<std::tuple_element_t<Index, Type>>() && ...);
-}
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_storage(const basic_storage &) = delete;
 
-template<typename>
-[[nodiscard]] constexpr bool maybe_equality_comparable(char) {
-    return false;
-}
+    /**
+     * @brief Move constructor.
+     * @param other The instance to move from.
+     */
+    basic_storage(basic_storage &&other) noexcept
+        : base_type{std::move(other)},
+          payload{std::move(other.payload)} {}
 
-template<typename Type>
-[[nodiscard]] constexpr auto maybe_equality_comparable(int) -> decltype(std::declval<Type>() == std::declval<Type>()) {
-    return true;
-}
+    /**
+     * @brief Allocator-extended move constructor.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
+     */
+    basic_storage(basic_storage &&other, const allocator_type &allocator)
+        : base_type{std::move(other), allocator},
+          payload{std::move(other.payload), allocator} {
+        // NOLINTNEXTLINE(bugprone-use-after-move)
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a storage is not allowed");
+    }
 
-template<typename Type>
-[[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
-    if constexpr(std::is_array_v<Type>) {
-        return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
-            return maybe_equality_comparable<Type>(0);
-        } else {
-            return false;
-        }
-    } else if constexpr(is_complete_v<std::tuple_size<std::remove_cv_t<Type>>>) {
-        if constexpr(has_tuple_size_value<Type>::value) {
-            return maybe_equality_comparable<Type>(0) && unpack_maybe_equality_comparable<Type>(std::make_index_sequence<std::tuple_size<Type>::value>{});
-        } else {
-            return maybe_equality_comparable<Type>(0);
-        }
-    } else {
-        return maybe_equality_comparable<Type>(0);
+    /*! @brief Default destructor. */
+    // NOLINTNEXTLINE(bugprone-exception-escape)
+    ~basic_storage() override {
+        shrink_to_size(0u);
     }
-}
 
-} // namespace internal
-/*! @endcond */
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This storage.
+     */
+    basic_storage &operator=(const basic_storage &) = delete;
 
-/**
- * @brief Provides the member constant `value` to true if a given type is
- * equality comparable, false otherwise.
- * @tparam Type The type to test.
- */
-template<typename Type>
-struct is_equality_comparable: std::bool_constant<internal::dispatch_is_equality_comparable<Type>()> {};
+    /**
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This storage.
+     */
+    basic_storage &operator=(basic_storage &&other) noexcept {
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a storage is not allowed");
+        swap(other);
+        return *this;
+    }
 
-/*! @copydoc is_equality_comparable */
-template<typename Type>
-struct is_equality_comparable<const Type>: is_equality_comparable<Type> {};
+    /**
+     * @brief Exchanges the contents with those of a given storage.
+     * @param other Storage to exchange the content with.
+     */
+    void swap(basic_storage &other) noexcept {
+        using std::swap;
+        swap(payload, other.payload);
+        base_type::swap(other);
+    }
 
-/**
- * @brief Helper variable template.
- * @tparam Type The type to test.
- */
-template<typename Type>
-inline constexpr bool is_equality_comparable_v = is_equality_comparable<Type>::value;
+    /**
+     * @brief Returns the associated allocator.
+     * @return The associated allocator.
+     */
+    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
+        return payload.get_allocator();
+    }
 
-/**
- * @brief Transcribes the constness of a type to another type.
- * @tparam To The type to which to transcribe the constness.
- * @tparam From The type from which to transcribe the constness.
- */
-template<typename To, typename From>
-struct constness_as {
-    /*! @brief The type resulting from the transcription of the constness. */
-    using type = std::remove_const_t<To>;
-};
+    /**
+     * @brief Increases the capacity of a storage.
+     *
+     * If the new capacity is greater than the current capacity, new storage is
+     * allocated, otherwise the method does nothing.
+     *
+     * @param cap Desired capacity.
+     */
+    void reserve(const size_type cap) override {
+        if(cap != 0u) {
+            base_type::reserve(cap);
+            assure_at_least(cap - 1u);
+        }
+    }
 
-/*! @copydoc constness_as */
-template<typename To, typename From>
-struct constness_as<To, const From> {
-    /*! @brief The type resulting from the transcription of the constness. */
-    using type = const To;
-};
+    /**
+     * @brief Returns the number of elements that a storage has currently
+     * allocated space for.
+     * @return Capacity of the storage.
+     */
+    [[nodiscard]] size_type capacity() const noexcept override {
+        return payload.size() * traits_type::page_size;
+    }
 
-/**
- * @brief Alias template to facilitate the transcription of the constness.
- * @tparam To The type to which to transcribe the constness.
- * @tparam From The type from which to transcribe the constness.
- */
-template<typename To, typename From>
-using constness_as_t = typename constness_as<To, From>::type;
+    /*! @brief Requests the removal of unused capacity. */
+    void shrink_to_fit() override {
+        base_type::shrink_to_fit();
+        shrink_to_size(base_type::size());
+    }
+
+    /**
+     * @brief Direct access to the array of objects.
+     * @return A pointer to the array of objects.
+     */
+    [[nodiscard]] const_pointer raw() const noexcept {
+        return payload.data();
+    }
 
-/**
- * @brief Extracts the class of a non-static member object or function.
- * @tparam Member A pointer to a non-static member object or function.
- */
-template<typename Member>
-class member_class {
-    static_assert(std::is_member_pointer_v<Member>, "Invalid pointer type to non-static member object or function");
+    /*! @copydoc raw */
+    [[nodiscard]] pointer raw() noexcept {
+        return payload.data();
+    }
 
-    template<typename Class, typename Ret, typename... Args>
-    static Class *clazz(Ret (Class::*)(Args...));
+    /**
+     * @brief Returns an iterator to the beginning.
+     *
+     * If the storage is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first instance of the internal array.
+     */
+    [[nodiscard]] const_iterator cbegin() const noexcept {
+        const auto pos = static_cast<typename iterator::difference_type>(base_type::size());
+        return const_iterator{&payload, pos};
+    }
 
-    template<typename Class, typename Ret, typename... Args>
-    static Class *clazz(Ret (Class::*)(Args...) const);
+    /*! @copydoc cbegin */
+    [[nodiscard]] const_iterator begin() const noexcept {
+        return cbegin();
+    }
 
-    template<typename Class, typename Type>
-    static Class *clazz(Type Class::*);
+    /*! @copydoc begin */
+    [[nodiscard]] iterator begin() noexcept {
+        const auto pos = static_cast<typename iterator::difference_type>(base_type::size());
+        return iterator{&payload, pos};
+    }
 
-public:
-    /*! @brief The class of the given non-static member object or function. */
-    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
-};
+    /**
+     * @brief Returns an iterator to the end.
+     * @return An iterator to the element following the last instance of the
+     * internal array.
+     */
+    [[nodiscard]] const_iterator cend() const noexcept {
+        return const_iterator{&payload, {}};
+    }
 
-/**
- * @brief Helper type.
- * @tparam Member A pointer to a non-static member object or function.
- */
-template<typename Member>
-using member_class_t = typename member_class<Member>::type;
+    /*! @copydoc cend */
+    [[nodiscard]] const_iterator end() const noexcept {
+        return cend();
+    }
 
-/**
- * @brief Extracts the n-th argument of a given function or member function.
- * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
- */
-template<std::size_t Index, typename Candidate>
-class nth_argument {
-    template<typename Ret, typename... Args>
-    static constexpr type_list<Args...> pick_up(Ret (*)(Args...));
+    /*! @copydoc end */
+    [[nodiscard]] iterator end() noexcept {
+        return iterator{&payload, {}};
+    }
 
-    template<typename Ret, typename Class, typename... Args>
-    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...));
+    /**
+     * @brief Returns a reverse iterator to the beginning.
+     *
+     * If the storage is empty, the returned iterator will be equal to `rend()`.
+     *
+     * @return An iterator to the first instance of the reversed internal array.
+     */
+    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
+        return std::make_reverse_iterator(cend());
+    }
 
-    template<typename Ret, typename Class, typename... Args>
-    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...) const);
+    /*! @copydoc crbegin */
+    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
+        return crbegin();
+    }
 
-    template<typename Type, typename Class>
-    static constexpr type_list<Type> pick_up(Type Class ::*);
+    /*! @copydoc rbegin */
+    [[nodiscard]] reverse_iterator rbegin() noexcept {
+        return std::make_reverse_iterator(end());
+    }
 
-public:
-    /*! @brief N-th argument of the given function or member function. */
-    using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
-};
+    /**
+     * @brief Returns a reverse iterator to the end.
+     * @return An iterator to the element following the last instance of the
+     * reversed internal array.
+     */
+    [[nodiscard]] const_reverse_iterator crend() const noexcept {
+        return std::make_reverse_iterator(cbegin());
+    }
 
-/**
- * @brief Helper type.
- * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
- */
-template<std::size_t Index, typename Candidate>
-using nth_argument_t = typename nth_argument<Index, Candidate>::type;
+    /*! @copydoc crend */
+    [[nodiscard]] const_reverse_iterator rend() const noexcept {
+        return crend();
+    }
 
-} // namespace entt
+    /*! @copydoc rend */
+    [[nodiscard]] reverse_iterator rend() noexcept {
+        return std::make_reverse_iterator(begin());
+    }
 
-template<typename... Type>
-struct std::tuple_size<entt::type_list<Type...>>: std::integral_constant<std::size_t, entt::type_list<Type...>::size> {};
+    /**
+     * @brief Returns the object assigned to an entity.
+     *
+     * @warning
+     * Attempting to use an entity that doesn't belong to the storage results in
+     * undefined behavior.
+     *
+     * @param entt A valid identifier.
+     * @return The object assigned to the entity.
+     */
+    [[nodiscard]] const value_type &get(const entity_type entt) const noexcept {
+        return element_at(base_type::index(entt));
+    }
 
-template<std::size_t Index, typename... Type>
-struct std::tuple_element<Index, entt::type_list<Type...>>: entt::type_list_element<Index, entt::type_list<Type...>> {};
+    /*! @copydoc get */
+    [[nodiscard]] value_type &get(const entity_type entt) noexcept {
+        return const_cast<value_type &>(std::as_const(*this).get(entt));
+    }
 
-template<auto... Value>
-struct std::tuple_size<entt::value_list<Value...>>: std::integral_constant<std::size_t, entt::value_list<Value...>::size> {};
+    /**
+     * @brief Returns the object assigned to an entity as a tuple.
+     * @param entt A valid identifier.
+     * @return The object assigned to the entity as a tuple.
+     */
+    [[nodiscard]] std::tuple<const value_type &> get_as_tuple(const entity_type entt) const noexcept {
+        return std::forward_as_tuple(get(entt));
+    }
 
-template<std::size_t Index, auto... Value>
-struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_element<Index, entt::value_list<Value...>> {};
+    /*! @copydoc get_as_tuple */
+    [[nodiscard]] std::tuple<value_type &> get_as_tuple(const entity_type entt) noexcept {
+        return std::forward_as_tuple(get(entt));
+    }
 
-#endif
+    /**
+     * @brief Assigns an entity to a storage and constructs its object.
+     *
+     * @warning
+     * Attempting to use an entity that already belongs to the storage results
+     * in undefined behavior.
+     *
+     * @tparam Args Types of arguments to use to construct the object.
+     * @param entt A valid identifier.
+     * @param args Parameters to use to construct an object for the entity.
+     * @return A reference to the newly created object.
+     */
+    template<typename... Args>
+    value_type &emplace(const entity_type entt, Args &&...args) {
+        if constexpr(std::is_aggregate_v<value_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<value_type>)) {
+            const auto it = emplace_element(entt, false, Type{std::forward<Args>(args)...});
+            return element_at(static_cast<size_type>(it.index()));
+        } else {
+            const auto it = emplace_element(entt, false, std::forward<Args>(args)...);
+            return element_at(static_cast<size_type>(it.index()));
+        }
+    }
 
-// #include "fwd.hpp"
-#ifndef ENTT_SIGNAL_FWD_HPP
-#define ENTT_SIGNAL_FWD_HPP
+    /**
+     * @brief Updates the instance assigned to a given entity in-place.
+     * @tparam Func Types of the function objects to invoke.
+     * @param entt A valid identifier.
+     * @param func Valid function objects.
+     * @return A reference to the updated instance.
+     */
+    template<typename... Func>
+    value_type &patch(const entity_type entt, Func &&...func) {
+        const auto idx = base_type::index(entt);
+        auto &elem = element_at(idx);
+        (std::forward<Func>(func)(elem), ...);
+        return elem;
+    }
 
-#include <memory>
+    /**
+     * @brief Assigns one or more entities to a storage and constructs their
+     * objects from a given instance.
+     *
+     * @warning
+     * Attempting to assign an entity that already belongs to the storage
+     * results in undefined behavior.
+     *
+     * @tparam It Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     * @param value An instance of the object to construct.
+     * @return Iterator pointing to the first element inserted, if any.
+     */
+    template<typename It>
+    iterator insert(It first, It last, const value_type &value = {}) {
+        for(; first != last; ++first) {
+            emplace_element(*first, true, value);
+        }
 
-namespace entt {
+        return begin();
+    }
 
-template<typename>
-class delegate;
+    /**
+     * @brief Assigns one or more entities to a storage and constructs their
+     * objects from a given range.
+     *
+     * @sa construct
+     *
+     * @tparam EIt Type of input iterator.
+     * @tparam CIt Type of input iterator.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     * @param from An iterator to the first element of the range of objects.
+     * @return Iterator pointing to the first element inserted, if any.
+     */
+    template<typename EIt, typename CIt, typename = std::enable_if_t<std::is_same_v<typename std::iterator_traits<CIt>::value_type, value_type>>>
+    iterator insert(EIt first, EIt last, CIt from) {
+        for(; first != last; ++first, ++from) {
+            emplace_element(*first, true, *from);
+        }
 
-template<typename = std::allocator<void>>
-class basic_dispatcher;
+        return begin();
+    }
 
-template<typename, typename = std::allocator<void>>
-class emitter;
+    /**
+     * @brief Returns an iterable object to use to _visit_ a storage.
+     *
+     * The iterable object returns a tuple that contains the current entity and
+     * a reference to its element.
+     *
+     * @return An iterable object to use to _visit_ the storage.
+     */
+    [[nodiscard]] iterable each() noexcept {
+        return iterable{{base_type::begin(), begin()}, {base_type::end(), end()}};
+    }
 
-class connection;
+    /*! @copydoc each */
+    [[nodiscard]] const_iterable each() const noexcept {
+        return const_iterable{{base_type::cbegin(), cbegin()}, {base_type::cend(), cend()}};
+    }
 
-struct scoped_connection;
+    /**
+     * @brief Returns a reverse iterable object to use to _visit_ a storage.
+     *
+     * @sa each
+     *
+     * @return A reverse iterable object to use to _visit_ the storage.
+     */
+    [[nodiscard]] reverse_iterable reach() noexcept {
+        return reverse_iterable{{base_type::rbegin(), rbegin()}, {base_type::rend(), rend()}};
+    }
 
-template<typename>
-class sink;
+    /*! @copydoc reach */
+    [[nodiscard]] const_reverse_iterable reach() const noexcept {
+        return const_reverse_iterable{{base_type::crbegin(), crbegin()}, {base_type::crend(), crend()}};
+    }
 
-template<typename Type, typename = std::allocator<void>>
-class sigh;
+private:
+    container_type payload;
+};
 
-/*! @brief Alias declaration for the most common use case. */
-using dispatcher = basic_dispatcher<>;
+/*! @copydoc basic_storage */
+template<typename Type, typename Entity, typename Allocator>
+class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<Type>::page_size == 0u>>
+    : public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
+    using alloc_traits = std::allocator_traits<Allocator>;
+    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
+    using traits_type = component_traits<Type>;
+
+public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
+    /*! @brief Base type. */
+    using base_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
+    /*! @brief Element type. */
+    using element_type = Type;
+    /*! @brief Type of the objects assigned to entities. */
+    using value_type = void;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = Entity;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Extended iterable storage proxy. */
+    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
+    /*! @brief Constant extended iterable storage proxy. */
+    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator>>;
+    /*! @brief Extended reverse iterable storage proxy. */
+    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
+    /*! @brief Constant extended reverse iterable storage proxy. */
+    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;
+    /*! @brief Storage deletion policy. */
+    static constexpr deletion_policy storage_policy{traits_type::in_place_delete};
 
-/*! @brief Disambiguation tag for constructors and the like. */
-template<auto>
-struct connect_arg_t {
     /*! @brief Default constructor. */
-    explicit connect_arg_t() = default;
-};
+    basic_storage()
+        : basic_storage{allocator_type{}} {}
 
-/**
- * @brief Constant of type connect_arg_t used to disambiguate calls.
- * @tparam Candidate Element to connect (likely a free or member function).
- */
-template<auto Candidate>
-inline constexpr connect_arg_t<Candidate> connect_arg{};
+    /**
+     * @brief Constructs an empty container with a given allocator.
+     * @param allocator The allocator to use.
+     */
+    explicit basic_storage(const allocator_type &allocator)
+        : base_type{type_id<element_type>(), storage_policy, allocator} {}
 
-} // namespace entt
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_storage(const basic_storage &) = delete;
 
-#endif
+    /**
+     * @brief Move constructor.
+     * @param other The instance to move from.
+     */
+    basic_storage(basic_storage &&other) noexcept = default;
 
+    /**
+     * @brief Allocator-extended move constructor.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
+     */
+    basic_storage(basic_storage &&other, const allocator_type &allocator)
+        : base_type{std::move(other), allocator} {}
 
-namespace entt {
+    /*! @brief Default destructor. */
+    ~basic_storage() override = default;
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This storage.
+     */
+    basic_storage &operator=(const basic_storage &) = delete;
 
-template<typename Ret, typename... Args>
-constexpr auto function_pointer(Ret (*)(Args...)) -> Ret (*)(Args...);
+    /**
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This storage.
+     */
+    basic_storage &operator=(basic_storage &&other) noexcept = default;
 
-template<typename Ret, typename Type, typename... Args, typename Other>
-constexpr auto function_pointer(Ret (*)(Type, Args...), Other &&) -> Ret (*)(Args...);
+    /**
+     * @brief Returns the associated allocator.
+     * @return The associated allocator.
+     */
+    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
+        // std::allocator<void> has no cross constructors (waiting for C++20)
+        if constexpr(std::is_void_v<element_type> && !std::is_constructible_v<allocator_type, typename base_type::allocator_type>) {
+            return allocator_type{};
+        } else {
+            return allocator_type{base_type::get_allocator()};
+        }
+    }
 
-template<typename Class, typename Ret, typename... Args, typename... Other>
-constexpr auto function_pointer(Ret (Class::*)(Args...), Other &&...) -> Ret (*)(Args...);
+    /**
+     * @brief Returns the object assigned to an entity, that is `void`.
+     *
+     * @warning
+     * Attempting to use an entity that doesn't belong to the storage results in
+     * undefined behavior.
+     *
+     * @param entt A valid identifier.
+     */
+    void get([[maybe_unused]] const entity_type entt) const noexcept {
+        ENTT_ASSERT(base_type::contains(entt), "Invalid entity");
+    }
 
-template<typename Class, typename Ret, typename... Args, typename... Other>
-constexpr auto function_pointer(Ret (Class::*)(Args...) const, Other &&...) -> Ret (*)(Args...);
+    /**
+     * @brief Returns an empty tuple.
+     * @param entt A valid identifier.
+     * @return Returns an empty tuple.
+     */
+    [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
+        ENTT_ASSERT(base_type::contains(entt), "Invalid entity");
+        return std::tuple{};
+    }
 
-template<typename Class, typename Type, typename... Other>
-constexpr auto function_pointer(Type Class::*, Other &&...) -> Type (*)();
+    /**
+     * @brief Assigns an entity to a storage and constructs its object.
+     *
+     * @warning
+     * Attempting to use an entity that already belongs to the storage results
+     * in undefined behavior.
+     *
+     * @tparam Args Types of arguments to use to construct the object.
+     * @param entt A valid identifier.
+     */
+    template<typename... Args>
+    void emplace(const entity_type entt, Args &&...) {
+        base_type::try_emplace(entt, false);
+    }
 
-template<typename... Type>
-using function_pointer_t = decltype(function_pointer(std::declval<Type>()...));
+    /**
+     * @brief Updates the instance assigned to a given entity in-place.
+     * @tparam Func Types of the function objects to invoke.
+     * @param entt A valid identifier.
+     * @param func Valid function objects.
+     */
+    template<typename... Func>
+    void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
+        ENTT_ASSERT(base_type::contains(entt), "Invalid entity");
+        (std::forward<Func>(func)(), ...);
+    }
 
-template<typename... Class, typename Ret, typename... Args>
-[[nodiscard]] constexpr auto index_sequence_for(Ret (*)(Args...)) {
-    return std::index_sequence_for<Class..., Args...>{};
-}
+    /**
+     * @brief Assigns entities to a storage.
+     * @tparam It Type of input iterator.
+     * @tparam Args Types of optional arguments.
+     * @param first An iterator to the first element of the range of entities.
+     * @param last An iterator past the last element of the range of entities.
+     */
+    template<typename It, typename... Args>
+    void insert(It first, It last, Args &&...) {
+        for(; first != last; ++first) {
+            base_type::try_emplace(*first, true);
+        }
+    }
 
-} // namespace internal
-/*! @endcond */
+    /**
+     * @brief Returns an iterable object to use to _visit_ a storage.
+     *
+     * The iterable object returns a tuple that contains the current entity.
+     *
+     * @return An iterable object to use to _visit_ the storage.
+     */
+    [[nodiscard]] iterable each() noexcept {
+        return iterable{base_type::begin(), base_type::end()};
+    }
 
-/**
- * @brief Basic delegate implementation.
- *
- * Primary template isn't defined on purpose. All the specializations give a
- * compile-time error unless the template parameter is a function type.
- */
-template<typename>
-class delegate;
+    /*! @copydoc each */
+    [[nodiscard]] const_iterable each() const noexcept {
+        return const_iterable{base_type::cbegin(), base_type::cend()};
+    }
+
+    /**
+     * @brief Returns a reverse iterable object to use to _visit_ a storage.
+     *
+     * @sa each
+     *
+     * @return A reverse iterable object to use to _visit_ the storage.
+     */
+    [[nodiscard]] reverse_iterable reach() noexcept {
+        return reverse_iterable{{base_type::rbegin()}, {base_type::rend()}};
+    }
+
+    /*! @copydoc reach */
+    [[nodiscard]] const_reverse_iterable reach() const noexcept {
+        return const_reverse_iterable{{base_type::crbegin()}, {base_type::crend()}};
+    }
+};
 
 /**
- * @brief Utility class to use to send around functions and members.
- *
- * Unmanaged delegate for function pointers and members. Users of this class are
- * in charge of disconnecting instances before deleting them.
- *
- * A delegate can be used as a general purpose invoker without memory overhead
- * for free functions possibly with payloads and bound or unbound members.
- *
- * @tparam Ret Return type of a function type.
- * @tparam Args Types of arguments of a function type.
+ * @brief Swap-only entity storage specialization.
+ * @tparam Entity A valid entity type.
+ * @tparam Allocator Type of allocator used to manage memory and elements.
  */
-template<typename Ret, typename... Args>
-class delegate<Ret(Args...)> {
-    template<auto Candidate, std::size_t... Index>
-    [[nodiscard]] auto wrap(std::index_sequence<Index...>) noexcept {
-        return [](const void *, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+template<typename Entity, typename Allocator>
+class basic_storage<Entity, Entity, Allocator>
+    : public basic_sparse_set<Entity, Allocator> {
+    using alloc_traits = std::allocator_traits<Allocator>;
+    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
+    using underlying_iterator = typename basic_sparse_set<Entity, Allocator>::basic_iterator;
+    using traits_type = entt_traits<Entity>;
 
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
-        };
-    }
+    auto next() noexcept {
+        entity_type entt = null;
 
-    template<auto Candidate, typename Type, std::size_t... Index>
-    [[nodiscard]] auto wrap(Type &, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
-            Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
+        do {
+            ENTT_ASSERT(placeholder < traits_type::to_entity(null), "No more entities available");
+            entt = traits_type::combine(static_cast<typename traits_type::entity_type>(placeholder++), {});
+        } while(base_type::current(entt) != traits_type::to_version(tombstone) && entt != null);
 
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
-        };
+        return entt;
     }
 
-    template<auto Candidate, typename Type, std::size_t... Index>
-    [[nodiscard]] auto wrap(Type *, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
-            Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
+protected:
+    /*! @brief Erases all entities of a storage. */
+    void pop_all() override {
+        base_type::pop_all();
+        placeholder = {};
+    }
 
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
-        };
+    /**
+     * @brief Assigns an entity to a storage.
+     * @param hint A valid identifier.
+     * @return Iterator pointing to the emplaced element.
+     */
+    underlying_iterator try_emplace(const Entity hint, const bool, const void *) override {
+        return base_type::find(emplace(hint));
     }
 
 public:
-    /*! @brief Function type of the contained target. */
-    using function_type = Ret(const void *, Args...);
-    /*! @brief Function type of the delegate. */
-    using type = Ret(Args...);
-    /*! @brief Return type of the delegate. */
-    using result_type = Ret;
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
+    /*! @brief Base type. */
+    using base_type = basic_sparse_set<Entity, Allocator>;
+    /*! @brief Element type. */
+    using element_type = Entity;
+    /*! @brief Type of the objects assigned to entities. */
+    using value_type = void;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = Entity;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Extended iterable storage proxy. */
+    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
+    /*! @brief Constant extended iterable storage proxy. */
+    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator>>;
+    /*! @brief Extended reverse iterable storage proxy. */
+    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
+    /*! @brief Constant extended reverse iterable storage proxy. */
+    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;
+    /*! @brief Storage deletion policy. */
+    static constexpr deletion_policy storage_policy = deletion_policy::swap_only;
 
     /*! @brief Default constructor. */
-    delegate() noexcept
-        : instance{nullptr},
-          fn{nullptr} {}
+    basic_storage()
+        : basic_storage{allocator_type{}} {
+    }
 
     /**
-     * @brief Constructs a delegate with a given object or payload, if any.
-     * @tparam Candidate Function or member to connect to the delegate.
-     * @tparam Type Type of class or type of payload, if any.
-     * @param value_or_instance Optional valid object that fits the purpose.
+     * @brief Constructs an empty container with a given allocator.
+     * @param allocator The allocator to use.
      */
-    template<auto Candidate, typename... Type>
-    delegate(connect_arg_t<Candidate>, Type &&...value_or_instance) noexcept {
-        connect<Candidate>(std::forward<Type>(value_or_instance)...);
-    }
+    explicit basic_storage(const allocator_type &allocator)
+        : base_type{type_id<void>(), storage_policy, allocator} {}
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_storage(const basic_storage &) = delete;
 
     /**
-     * @brief Constructs a delegate and connects an user defined function with
-     * optional payload.
-     * @param function Function to connect to the delegate.
-     * @param payload User defined arbitrary data.
+     * @brief Move constructor.
+     * @param other The instance to move from.
      */
-    delegate(function_type *function, const void *payload = nullptr) noexcept {
-        connect(function, payload);
-    }
+    basic_storage(basic_storage &&other) noexcept
+        : base_type{std::move(other)},
+          placeholder{other.placeholder} {}
 
     /**
-     * @brief Connects a free function or an unbound member to a delegate.
-     * @tparam Candidate Function or member to connect to the delegate.
+     * @brief Allocator-extended move constructor.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
      */
-    template<auto Candidate>
-    void connect() noexcept {
-        instance = nullptr;
+    basic_storage(basic_storage &&other, const allocator_type &allocator)
+        : base_type{std::move(other), allocator},
+          placeholder{other.placeholder} {}
 
-        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
-            fn = [](const void *, Args... args) -> Ret {
-                return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
-            };
-        } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
-            fn = wrap<Candidate>(internal::index_sequence_for<type_list_element_t<0, type_list<Args...>>>(internal::function_pointer_t<decltype(Candidate)>{}));
-        } else {
-            fn = wrap<Candidate>(internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate)>{}));
-        }
-    }
+    /*! @brief Default destructor. */
+    ~basic_storage() override = default;
 
     /**
-     * @brief Connects a free function with payload or a bound member to a
-     * delegate.
-     *
-     * The delegate isn't responsible for the connected object or the payload.
-     * Users must always guarantee that the lifetime of the instance overcomes
-     * the one of the delegate.<br/>
-     * When used to connect a free function with payload, its signature must be
-     * such that the instance is the first argument before the ones used to
-     * define the delegate itself.
-     *
-     * @tparam Candidate Function or member to connect to the delegate.
-     * @tparam Type Type of class or type of payload.
-     * @param value_or_instance A valid reference that fits the purpose.
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This storage.
      */
-    template<auto Candidate, typename Type>
-    void connect(Type &value_or_instance) noexcept {
-        instance = &value_or_instance;
+    basic_storage &operator=(const basic_storage &) = delete;
 
-        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
-                Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-                return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
-            };
-        } else {
-            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
-        }
+    /**
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This storage.
+     */
+    basic_storage &operator=(basic_storage &&other) noexcept {
+        placeholder = other.placeholder;
+        base_type::operator=(std::move(other));
+        return *this;
     }
 
     /**
-     * @brief Connects a free function with payload or a bound member to a
-     * delegate.
+     * @brief Returns the object assigned to an entity, that is `void`.
      *
-     * @sa connect(Type &)
+     * @warning
+     * Attempting to use an entity that doesn't belong to the storage results in
+     * undefined behavior.
      *
-     * @tparam Candidate Function or member to connect to the delegate.
-     * @tparam Type Type of class or type of payload.
-     * @param value_or_instance A valid pointer that fits the purpose.
+     * @param entt A valid identifier.
      */
-    template<auto Candidate, typename Type>
-    void connect(Type *value_or_instance) noexcept {
-        instance = value_or_instance;
+    void get([[maybe_unused]] const entity_type entt) const noexcept {
+        ENTT_ASSERT(base_type::index(entt) < base_type::free_list(), "The requested entity is not a live one");
+    }
 
-        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
-                Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-                return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
-            };
-        } else {
-            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
-        }
+    /**
+     * @brief Returns an empty tuple.
+     * @param entt A valid identifier.
+     * @return Returns an empty tuple.
+     */
+    [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
+        ENTT_ASSERT(base_type::index(entt) < base_type::free_list(), "The requested entity is not a live one");
+        return std::tuple{};
     }
 
     /**
-     * @brief Connects an user defined function with optional payload to a
-     * delegate.
-     *
-     * The delegate isn't responsible for the connected object or the payload.
-     * Users must always guarantee that the lifetime of an instance overcomes
-     * the one of the delegate.<br/>
-     * The payload is returned as the first argument to the target function in
-     * all cases.
-     *
-     * @param function Function to connect to the delegate.
-     * @param payload User defined arbitrary data.
+     * @brief Creates a new identifier or recycles a destroyed one.
+     * @return A valid identifier.
      */
-    void connect(function_type *function, const void *payload = nullptr) noexcept {
-        ENTT_ASSERT(function != nullptr, "Uninitialized function pointer");
-        instance = payload;
-        fn = function;
+    entity_type emplace() {
+        const auto len = base_type::free_list();
+        const auto entt = (len == base_type::size()) ? next() : base_type::data()[len];
+        return *base_type::try_emplace(entt, true);
     }
 
     /**
-     * @brief Resets a delegate.
+     * @brief Creates a new identifier or recycles a destroyed one.
      *
-     * After a reset, a delegate cannot be invoked anymore.
+     * If the requested identifier isn't in use, the suggested one is used.
+     * Otherwise, a new identifier is returned.
+     *
+     * @param hint Required identifier.
+     * @return A valid identifier.
      */
-    void reset() noexcept {
-        instance = nullptr;
-        fn = nullptr;
+    entity_type emplace(const entity_type hint) {
+        if(hint != null && hint != tombstone) {
+            if(const auto curr = traits_type::construct(traits_type::to_entity(hint), base_type::current(hint)); curr == tombstone || !(base_type::index(curr) < base_type::free_list())) {
+                return *base_type::try_emplace(hint, true);
+            }
+        }
+
+        return emplace();
     }
 
     /**
-     * @brief Returns a pointer to the stored callable function target, if any.
-     * @return An opaque pointer to the stored callable function target.
+     * @brief Updates a given identifier.
+     * @tparam Func Types of the function objects to invoke.
+     * @param entt A valid identifier.
+     * @param func Valid function objects.
      */
-    [[nodiscard]] function_type *target() const noexcept {
-        return fn;
+    template<typename... Func>
+    void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
+        ENTT_ASSERT(base_type::index(entt) < base_type::free_list(), "The requested entity is not a live one");
+        (std::forward<Func>(func)(), ...);
     }
 
     /**
-     * @brief Returns the instance or the payload linked to a delegate, if any.
-     * @return An opaque pointer to the underlying data.
+     * @brief Assigns each element in a range an identifier.
+     * @tparam It Type of mutable forward iterator.
+     * @param first An iterator to the first element of the range to generate.
+     * @param last An iterator past the last element of the range to generate.
      */
-    [[nodiscard]] const void *data() const noexcept {
-        return instance;
+    template<typename It>
+    void insert(It first, It last) {
+        for(const auto sz = base_type::size(); first != last && base_type::free_list() != sz; ++first) {
+            *first = *base_type::try_emplace(base_type::data()[base_type::free_list()], true);
+        }
+
+        for(; first != last; ++first) {
+            *first = *base_type::try_emplace(next(), true);
+        }
     }
 
     /**
-     * @brief Triggers a delegate.
-     *
-     * The delegate invokes the underlying function and returns the result.
+     * @brief Returns an iterable object to use to _visit_ a storage.
      *
-     * @warning
-     * Attempting to trigger an invalid delegate results in undefined
-     * behavior.
+     * The iterable object returns a tuple that contains the current entity.
      *
-     * @param args Arguments to use to invoke the underlying function.
-     * @return The value returned by the underlying function.
+     * @return An iterable object to use to _visit_ the storage.
      */
-    Ret operator()(Args... args) const {
-        ENTT_ASSERT(static_cast<bool>(*this), "Uninitialized delegate");
-        return fn(instance, std::forward<Args>(args)...);
+    [[nodiscard]] iterable each() noexcept {
+        return std::as_const(*this).each();
     }
 
-    /**
-     * @brief Checks whether a delegate actually stores a listener.
-     * @return False if the delegate is empty, true otherwise.
-     */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        // no need to also test instance
-        return !(fn == nullptr);
+    /*! @copydoc each */
+    [[nodiscard]] const_iterable each() const noexcept {
+        const auto it = base_type::cend();
+        return const_iterable{it - base_type::free_list(), it};
     }
 
     /**
-     * @brief Compares the contents of two delegates.
-     * @param other Delegate with which to compare.
-     * @return False if the two contents differ, true otherwise.
+     * @brief Returns a reverse iterable object to use to _visit_ a storage.
+     *
+     * @sa each
+     *
+     * @return A reverse iterable object to use to _visit_ the storage.
      */
-    [[nodiscard]] bool operator==(const delegate<Ret(Args...)> &other) const noexcept {
-        return fn == other.fn && instance == other.instance;
+    [[nodiscard]] reverse_iterable reach() noexcept {
+        return std::as_const(*this).reach();
+    }
+
+    /*! @copydoc reach */
+    [[nodiscard]] const_reverse_iterable reach() const noexcept {
+        const auto it = base_type::crbegin();
+        return const_reverse_iterable{it, it + base_type::free_list()};
     }
 
 private:
-    const void *instance;
-    function_type *fn;
+    size_type placeholder{};
 };
 
-/**
- * @brief Compares the contents of two delegates.
- * @tparam Ret Return type of a function type.
- * @tparam Args Types of arguments of a function type.
- * @param lhs A valid delegate object.
- * @param rhs A valid delegate object.
- * @return True if the two contents differ, false otherwise.
- */
-template<typename Ret, typename... Args>
-[[nodiscard]] bool operator!=(const delegate<Ret(Args...)> &lhs, const delegate<Ret(Args...)> &rhs) noexcept {
-    return !(lhs == rhs);
-}
-
-/**
- * @brief Deduction guide.
- * @tparam Candidate Function or member to connect to the delegate.
- */
-template<auto Candidate>
-delegate(connect_arg_t<Candidate>) -> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate)>>>;
-
-/**
- * @brief Deduction guide.
- * @tparam Candidate Function or member to connect to the delegate.
- * @tparam Type Type of class or type of payload.
- */
-template<auto Candidate, typename Type>
-delegate(connect_arg_t<Candidate>, Type &&) -> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate), Type>>>;
-
-/**
- * @brief Deduction guide.
- * @tparam Ret Return type of a function type.
- * @tparam Args Types of arguments of a function type.
- */
-template<typename Ret, typename... Args>
-delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret(Args...)>;
-
 } // namespace entt
 
 #endif
 
-// #include "fwd.hpp"
-
-// #include "group.hpp"
-#ifndef ENTT_ENTITY_GROUP_HPP
-#define ENTT_ENTITY_GROUP_HPP
+// #include "view.hpp"
+#ifndef ENTT_ENTITY_VIEW_HPP
+#define ENTT_ENTITY_VIEW_HPP
 
+#include <array>
+#include <cstddef>
+#include <iterator>
 #include <tuple>
 #include <type_traits>
 #include <utility>
 // #include "../config/config.h"
 
-// #include "../core/fwd.hpp"
-
 // #include "../core/iterator.hpp"
 
-// #include "../core/type_info.hpp"
-
 // #include "../core/type_traits.hpp"
 
 // #include "entity.hpp"
 
 // #include "fwd.hpp"
 
-// #include "sparse_set.hpp"
-
-// #include "storage.hpp"
-
 
 namespace entt {
 
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename, typename, typename>
-class extended_group_iterator;
+template<typename Type>
+const Type *view_placeholder() {
+    static_assert(std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, Type>, "Unexpected type");
+    static const Type placeholder{};
+    return &placeholder;
+}
 
-template<typename It, typename... Owned, typename... Get>
-class extended_group_iterator<It, owned_t<Owned...>, get_t<Get...>> {
-    template<typename Type>
-    auto index_to_element([[maybe_unused]] Type &cpool) const {
-        if constexpr(Type::traits_type::page_size == 0u) {
-            return std::make_tuple();
-        } else {
-            return std::forward_as_tuple(cpool.rbegin()[it.index()]);
-        }
+template<typename It, typename Entity>
+[[nodiscard]] bool all_of(It first, const It last, const Entity entt) noexcept {
+    for(; (first != last) && (*first)->contains(entt); ++first) {}
+    return first == last;
+}
+
+template<typename It, typename Entity>
+[[nodiscard]] bool none_of(It first, const It last, const Entity entt) noexcept {
+    for(; (first != last) && !(*first)->contains(entt); ++first) {}
+    return first == last;
+}
+
+template<typename It>
+[[nodiscard]] bool fully_initialized(It first, const It last) noexcept {
+    for(const auto *placeholder = view_placeholder<std::remove_const_t<std::remove_pointer_t<typename std::iterator_traits<It>::value_type>>>(); (first != last) && *first != placeholder; ++first) {}
+    return first == last;
+}
+
+template<typename Result, typename View, typename Other, std::size_t... GLhs, std::size_t... ELhs, std::size_t... GRhs, std::size_t... ERhs>
+[[nodiscard]] Result view_pack(const View &view, const Other &other, std::index_sequence<GLhs...>, std::index_sequence<ELhs...>, std::index_sequence<GRhs...>, std::index_sequence<ERhs...>) {
+    Result elem{};
+    // friend-initialization, avoid multiple calls to refresh
+    elem.pools = {view.template storage<GLhs>()..., other.template storage<GRhs>()...};
+    elem.filter = {view.template storage<sizeof...(GLhs) + ELhs>()..., other.template storage<sizeof...(GRhs) + ERhs>()...};
+    elem.refresh();
+    return elem;
+}
+
+template<typename Type, std::size_t Get, std::size_t Exclude>
+class view_iterator final {
+    template<typename, typename...>
+    friend class extended_view_iterator;
+
+    using iterator_type = typename Type::const_iterator;
+    using iterator_traits = std::iterator_traits<iterator_type>;
+
+    [[nodiscard]] bool valid(const typename iterator_traits::value_type entt) const noexcept {
+        return ((Get != 1u) || (entt != tombstone))
+               && internal::all_of(pools.begin(), pools.begin() + index, entt) && internal::all_of(pools.begin() + index + 1, pools.end(), entt)
+               && internal::none_of(filter.begin(), filter.end(), entt);
+    }
+
+    void seek_next() {
+        for(constexpr iterator_type sentinel{}; it != sentinel && !valid(*it); ++it) {}
+    }
+
+public:
+    using value_type = typename iterator_traits::value_type;
+    using pointer = typename iterator_traits::pointer;
+    using reference = typename iterator_traits::reference;
+    using difference_type = typename iterator_traits::difference_type;
+    using iterator_category = std::forward_iterator_tag;
+
+    constexpr view_iterator() noexcept
+        : it{},
+          pools{},
+          filter{},
+          index{} {}
+
+    view_iterator(iterator_type first, std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl, const std::size_t idx) noexcept
+        : it{first},
+          pools{value},
+          filter{excl},
+          index{idx} {
+        seek_next();
+    }
+
+    view_iterator &operator++() noexcept {
+        ++it;
+        seek_next();
+        return *this;
+    }
+
+    view_iterator operator++(int) noexcept {
+        view_iterator orig = *this;
+        return ++(*this), orig;
+    }
+
+    [[nodiscard]] pointer operator->() const noexcept {
+        return &*it;
+    }
+
+    [[nodiscard]] reference operator*() const noexcept {
+        return *operator->();
+    }
+
+    template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
+    friend constexpr bool operator==(const view_iterator<LhsType, LhsArgs...> &, const view_iterator<RhsType, RhsArgs...> &) noexcept;
+
+private:
+    iterator_type it;
+    std::array<const Type *, Get> pools;
+    std::array<const Type *, Exclude> filter;
+    std::size_t index;
+};
+
+template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
+[[nodiscard]] constexpr bool operator==(const view_iterator<LhsType, LhsArgs...> &lhs, const view_iterator<RhsType, RhsArgs...> &rhs) noexcept {
+    return lhs.it == rhs.it;
+}
+
+template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
+[[nodiscard]] constexpr bool operator!=(const view_iterator<LhsType, LhsArgs...> &lhs, const view_iterator<RhsType, RhsArgs...> &rhs) noexcept {
+    return !(lhs == rhs);
+}
+
+template<typename It, typename... Get>
+class extended_view_iterator final {
+    template<std::size_t... Index>
+    [[nodiscard]] auto dereference(std::index_sequence<Index...>) const noexcept {
+        return std::tuple_cat(std::make_tuple(*it), static_cast<Get *>(const_cast<constness_as_t<typename Get::base_type, Get> *>(std::get<Index>(it.pools)))->get_as_tuple(*it)...);
     }
 
 public:
     using iterator_type = It;
-    using difference_type = std::ptrdiff_t;
-    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Owned>().get_as_tuple({})..., std::declval<Get>().get_as_tuple({})...));
+    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Get>().get_as_tuple({})...));
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    constexpr extended_group_iterator()
-        : it{},
-          pools{} {}
+    constexpr extended_view_iterator()
+        : it{} {}
 
-    extended_group_iterator(iterator_type from, const std::tuple<Owned *..., Get *...> &cpools)
-        : it{from},
-          pools{cpools} {}
+    extended_view_iterator(iterator_type from)
+        : it{from} {}
 
-    extended_group_iterator &operator++() noexcept {
+    extended_view_iterator &operator++() noexcept {
         return ++it, *this;
     }
 
-    extended_group_iterator operator++(int) noexcept {
-        extended_group_iterator orig = *this;
+    extended_view_iterator operator++(int) noexcept {
+        extended_view_iterator orig = *this;
         return ++(*this), orig;
     }
 
     [[nodiscard]] reference operator*() const noexcept {
-        return std::tuple_cat(std::make_tuple(*it), index_to_element(*std::get<Owned *>(pools))..., std::get<Get *>(pools)->get_as_tuple(*it)...);
+        return dereference(std::index_sequence_for<Get...>{});
     }
 
     [[nodiscard]] pointer operator->() const noexcept {
@@ -21174,269 +21836,356 @@ class extended_group_iterator<It, owned_t<Owned...>, get_t<Get...>> {
     }
 
     template<typename... Lhs, typename... Rhs>
-    friend constexpr bool operator==(const extended_group_iterator<Lhs...> &, const extended_group_iterator<Rhs...> &) noexcept;
+    friend bool constexpr operator==(const extended_view_iterator<Lhs...> &, const extended_view_iterator<Rhs...> &) noexcept;
 
 private:
     It it;
-    std::tuple<Owned *..., Get *...> pools;
 };
 
 template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator==(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
+[[nodiscard]] constexpr bool operator==(const extended_view_iterator<Lhs...> &lhs, const extended_view_iterator<Rhs...> &rhs) noexcept {
     return lhs.it == rhs.it;
 }
 
 template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator!=(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
+[[nodiscard]] constexpr bool operator!=(const extended_view_iterator<Lhs...> &lhs, const extended_view_iterator<Rhs...> &rhs) noexcept {
     return !(lhs == rhs);
 }
 
-struct group_descriptor {
-    using size_type = std::size_t;
-    virtual ~group_descriptor() = default;
-    virtual size_type owned(const id_type *, const size_type) const noexcept {
-        return 0u;
-    }
-};
+} // namespace internal
+/*! @endcond */
 
+/**
+ * @brief View implementation.
+ *
+ * Primary template isn't defined on purpose. All the specializations give a
+ * compile-time error, but for a few reasonable cases.
+ *
+ * @b Important
+ *
+ * View iterators aren't invalidated if:
+ *
+ * * New elements are added to the storage iterated by the view.
+ * * The entity currently returned is modified (for example, elements are added
+ *   or removed from it).
+ * * The entity currently returned is destroyed.
+ *
+ * In all other cases, modifying the storage iterated by a view in any way can
+ * invalidate all iterators.
+ */
 template<typename, typename, typename>
-class group_handler;
+class basic_view;
 
-template<typename... Owned, typename... Get, typename... Exclude>
-class group_handler<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> final: public group_descriptor {
-    // nasty workaround for an issue with the toolset v141 that doesn't accept a fold expression here
-    static_assert(!std::disjunction_v<std::bool_constant<Owned::traits_type::in_place_delete>...>, "Groups do not support in-place delete");
-    static_assert(!std::disjunction_v<std::is_const<Owned>..., std::is_const<Get>..., std::is_const<Exclude>...>, "Const storage type not allowed");
+/**
+ * @brief Basic storage view implementation.
+ * @warning For internal use only, backward compatibility not guaranteed.
+ * @tparam Type Common type among all storage types.
+ * @tparam Get Number of storage iterated by the view.
+ * @tparam Exclude Number of storage used to filter the view.
+ */
+template<typename Type, std::size_t Get, std::size_t Exclude>
+class basic_common_view {
+    static_assert(std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, Type>, "Unexpected type");
 
-    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
-    using entity_type = typename base_type::entity_type;
+    template<typename Return, typename View, typename Other, std::size_t... GLhs, std::size_t... ELhs, std::size_t... GRhs, std::size_t... ERhs>
+    friend Return internal::view_pack(const View &, const Other &, std::index_sequence<GLhs...>, std::index_sequence<ELhs...>, std::index_sequence<GRhs...>, std::index_sequence<ERhs...>);
 
-    template<std::size_t... Index>
-    void swap_elements(const std::size_t pos, const entity_type entt, std::index_sequence<Index...>) {
-        (std::get<Index>(pools)->swap_elements(std::get<Index>(pools)->data()[pos], entt), ...);
+    [[nodiscard]] auto offset() const noexcept {
+        ENTT_ASSERT(index != Get, "Invalid view");
+        return (pools[index]->policy() == deletion_policy::swap_only) ? pools[index]->free_list() : pools[index]->size();
     }
 
-    void push_on_construct(const entity_type entt) {
-        if(std::apply([entt, len = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < len) && (other->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
-            swap_elements(len++, entt, std::index_sequence_for<Owned...>{});
-        }
-    }
+    void unchecked_refresh() noexcept {
+        index = 0u;
 
-    void push_on_destroy(const entity_type entt) {
-        if(std::apply([entt, len = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < len) && (other->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
-            swap_elements(len++, entt, std::index_sequence_for<Owned...>{});
+        if constexpr(Get > 1u) {
+            for(size_type pos{1u}; pos < Get; ++pos) {
+                if(pools[pos]->size() < pools[index]->size()) {
+                    index = pos;
+                }
+            }
         }
     }
 
-    void remove_if(const entity_type entt) {
-        if(std::get<0>(pools)->contains(entt) && (std::get<0>(pools)->index(entt) < len)) {
-            swap_elements(--len, entt, std::index_sequence_for<Owned...>{});
+protected:
+    /*! @cond TURN_OFF_DOXYGEN */
+    basic_common_view() noexcept {
+        for(size_type pos{}; pos < Exclude; ++pos) {
+            filter[pos] = internal::view_placeholder<Type>();
         }
     }
 
-public:
-    using size_type = typename base_type::size_type;
-
-    group_handler(Owned &...opool, Get &...gpool, Exclude &...epool)
-        : pools{&opool..., &gpool...},
-          filter{&epool...},
-          len{} {
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::push_on_construct>(*this), cpool->on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, pools);
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::remove_if>(*this), cpool->on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, filter);
+    basic_common_view(std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl) noexcept
+        : pools{value},
+          filter{excl},
+          index{Get} {
+        unchecked_refresh();
+    }
 
-        // we cannot iterate backwards because we want to leave behind valid entities in case of owned types
-        for(auto *first = std::get<0>(pools)->data(), *last = first + std::get<0>(pools)->size(); first != last; ++first) {
-            push_on_construct(*first);
-        }
+    [[nodiscard]] const Type *pool_at(const std::size_t pos) const noexcept {
+        return pools[pos];
     }
 
-    size_type owned(const id_type *elem, const size_type length) const noexcept final {
-        size_type cnt = 0u;
+    [[nodiscard]] const Type *storage(const std::size_t pos) const noexcept {
+        if(pos < Get) {
+            return pools[pos];
+        }
 
-        for(auto pos = 0u; pos < length; ++pos) {
-            cnt += ((elem[pos] == entt::type_hash<typename Owned::value_type>::value()) || ...);
+        if(const auto idx = pos - Get; filter[idx] != internal::view_placeholder<Type>()) {
+            return filter[idx];
         }
 
-        return cnt;
+        return nullptr;
     }
 
-    [[nodiscard]] size_type length() const noexcept {
-        return len;
-    }
+    void storage(const std::size_t pos, const Type *elem) noexcept {
+        ENTT_ASSERT(elem != nullptr, "Unexpected element");
 
-    auto pools_as_tuple() const noexcept {
-        return pools;
+        if(pos < Get) {
+            pools[pos] = elem;
+            refresh();
+        } else {
+            filter[pos - Get] = elem;
+        }
     }
 
-    auto filter_as_tuple() const noexcept {
-        return filter;
+    [[nodiscard]] bool none_of(const typename Type::entity_type entt) const noexcept {
+        return internal::none_of(filter.begin(), filter.end(), entt);
     }
 
-private:
-    std::tuple<Owned *..., Get *...> pools;
-    std::tuple<Exclude *...> filter;
-    std::size_t len;
-};
-
-template<typename... Get, typename... Exclude>
-class group_handler<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> final: public group_descriptor {
-    // nasty workaround for an issue with the toolset v141 that doesn't accept a fold expression here
-    static_assert(!std::disjunction_v<std::is_const<Get>..., std::is_const<Exclude>...>, "Const storage type not allowed");
+    void use(const std::size_t pos) noexcept {
+        index = (index != Get) ? pos : Get;
+    }
+    /*! @endcond */
 
-    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
-    using entity_type = typename base_type::entity_type;
+public:
+    /*! @brief Common type among all storage types. */
+    using common_type = Type;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename Type::entity_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Forward iterator type. */
+    using iterator = internal::view_iterator<common_type, Get, Exclude>;
 
-    void push_on_construct(const entity_type entt) {
-        if(!elem.contains(entt)
-           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
-            elem.push(entt);
+    /*! @brief Updates the internal leading view if required. */
+    void refresh() noexcept {
+        size_type pos = static_cast<size_type>(index != Get) * Get;
+        for(; pos < Get && pools[pos] != nullptr; ++pos) {}
+
+        if(pos == Get) {
+            unchecked_refresh();
         }
     }
 
-    void push_on_destroy(const entity_type entt) {
-        if(!elem.contains(entt)
-           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
-           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
-            elem.push(entt);
-        }
+    /**
+     * @brief Returns the leading storage of a view, if any.
+     * @return The leading storage of the view.
+     */
+    [[nodiscard]] const common_type *handle() const noexcept {
+        return (index != Get) ? pools[index] : nullptr;
     }
 
-    void remove_if(const entity_type entt) {
-        elem.remove(entt);
+    /**
+     * @brief Estimates the number of entities iterated by the view.
+     * @return Estimated number of entities iterated by the view.
+     */
+    [[nodiscard]] size_type size_hint() const noexcept {
+        return (index != Get) ? offset() : size_type{};
     }
 
-public:
-    using common_type = base_type;
+    /**
+     * @brief Returns an iterator to the first entity of the view.
+     *
+     * If the view is empty, the returned iterator will be equal to `end()`.
+     *
+     * @return An iterator to the first entity of the view.
+     */
+    [[nodiscard]] iterator begin() const noexcept {
+        return (index != Get) ? iterator{pools[index]->end() - static_cast<typename iterator::difference_type>(offset()), pools, filter, index} : iterator{};
+    }
 
-    template<typename Alloc>
-    group_handler(const Alloc &alloc, Get &...gpool, Exclude &...epool)
-        : pools{&gpool...},
-          filter{&epool...},
-          elem{alloc} {
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::push_on_construct>(*this), cpool->on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, pools);
-        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::remove_if>(*this), cpool->on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, filter);
+    /**
+     * @brief Returns an iterator that is past the last entity of the view.
+     * @return An iterator to the entity following the last entity of the view.
+     */
+    [[nodiscard]] iterator end() const noexcept {
+        return (index != Get) ? iterator{pools[index]->end(), pools, filter, index} : iterator{};
+    }
 
-        for(const auto entity: static_cast<base_type &>(*std::get<0>(pools))) {
-            push_on_construct(entity);
-        }
+    /**
+     * @brief Returns the first entity of the view, if any.
+     * @return The first entity of the view if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type front() const noexcept {
+        const auto it = begin();
+        return it != end() ? *it : null;
     }
 
-    common_type &handle() noexcept {
-        return elem;
+    /**
+     * @brief Returns the last entity of the view, if any.
+     * @return The last entity of the view if one exists, the null entity
+     * otherwise.
+     */
+    [[nodiscard]] entity_type back() const noexcept {
+        if(index != Get) {
+            auto it = pools[index]->rbegin();
+            const auto last = it + static_cast<typename iterator::difference_type>(offset());
+            for(; it != last && !contains(*it); ++it) {}
+            return it == last ? null : *it;
+        }
+
+        return null;
     }
 
-    const common_type &handle() const noexcept {
-        return elem;
+    /**
+     * @brief Finds an entity.
+     * @param entt A valid identifier.
+     * @return An iterator to the given entity if it's found, past the end
+     * iterator otherwise.
+     */
+    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
+        return contains(entt) ? iterator{pools[index]->find(entt), pools, filter, index} : end();
     }
 
-    auto pools_as_tuple() const noexcept {
-        return pools;
+    /**
+     * @brief Checks if a view is fully initialized.
+     * @return True if the view is fully initialized, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return (index != Get) && internal::fully_initialized(filter.begin(), filter.end());
     }
 
-    auto filter_as_tuple() const noexcept {
-        return filter;
+    /**
+     * @brief Checks if a view contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the view contains the given entity, false otherwise.
+     */
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        return (index != Get)
+               && internal::all_of(pools.begin(), pools.end(), entt)
+               && internal::none_of(filter.begin(), filter.end(), entt)
+               && pools[index]->index(entt) < offset();
     }
 
 private:
-    std::tuple<Get *...> pools;
-    std::tuple<Exclude *...> filter;
-    base_type elem;
+    std::array<const common_type *, Get> pools{};
+    std::array<const common_type *, Exclude> filter{};
+    size_type index{Get};
 };
 
-} // namespace internal
-/*! @endcond */
-
-/**
- * @brief Group.
- *
- * Primary template isn't defined on purpose. All the specializations give a
- * compile-time error, but for a few reasonable cases.
- */
-template<typename, typename, typename>
-class basic_group;
-
 /**
- * @brief Non-owning group.
- *
- * A non-owning group returns all entities and only the entities that are at
- * least in the given storage. Moreover, it's guaranteed that the entity list is
- * tightly packed in memory for fast iterations.
- *
- * @b Important
- *
- * Iterators aren't invalidated if:
+ * @brief General purpose view.
  *
- * * New elements are added to the storage.
- * * The entity currently pointed is modified (for example, components are added
- *   or removed from it).
- * * The entity currently pointed is destroyed.
+ * This view visits all entities that are at least in the given storage. During
+ * initialization, it also looks at the number of elements available for each
+ * storage and uses the smallest set in order to get a performance boost.
  *
- * In all other cases, modifying the pools iterated by the group in any way
- * invalidates all the iterators.
+ * @sa basic_view
  *
- * @tparam Get Types of storage _observed_ by the group.
- * @tparam Exclude Types of storage used to filter the group.
+ * @tparam Get Types of storage iterated by the view.
+ * @tparam Exclude Types of storage used to filter the view.
  */
 template<typename... Get, typename... Exclude>
-class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
-    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
-    using underlying_type = typename base_type::entity_type;
+class basic_view<get_t<Get...>, exclude_t<Exclude...>, std::enable_if_t<(sizeof...(Get) != 0u)>>
+    : public basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)> {
+    using base_type = basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)>;
 
     template<typename Type>
-    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::value_type..., typename Exclude::value_type...>>;
+    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::element_type..., typename Exclude::element_type...>>;
 
-    auto pools() const noexcept {
-        using return_type = std::tuple<Get *...>;
-        return descriptor ? descriptor->pools_as_tuple() : return_type{};
+    template<std::size_t... Index>
+    [[nodiscard]] auto get(const typename base_type::entity_type entt, std::index_sequence<Index...>) const noexcept {
+        return std::tuple_cat(storage<Index>()->get_as_tuple(entt)...);
+    }
+
+    template<std::size_t Curr, std::size_t Other, typename... Args>
+    [[nodiscard]] auto dispatch_get(const std::tuple<typename base_type::entity_type, Args...> &curr) const {
+        if constexpr(Curr == Other) {
+            return std::forward_as_tuple(std::get<Args>(curr)...);
+        } else {
+            return storage<Other>()->get_as_tuple(std::get<0>(curr));
+        }
+    }
+
+    template<std::size_t Curr, typename Func, std::size_t... Index>
+    void each(Func &func, std::index_sequence<Index...>) const {
+        static constexpr bool tombstone_check_required = ((sizeof...(Get) == 1u) && ... && (Get::storage_policy == deletion_policy::in_place));
+
+        for(const auto curr: storage<Curr>()->each()) {
+            if(const auto entt = std::get<0>(curr); (!tombstone_check_required || (entt != tombstone)) && ((Curr == Index || base_type::pool_at(Index)->contains(entt)) && ...) && base_type::none_of(entt)) {
+                if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_view>().get({})))>) {
+                    std::apply(func, std::tuple_cat(std::make_tuple(entt), dispatch_get<Curr, Index>(curr)...));
+                } else {
+                    std::apply(func, std::tuple_cat(dispatch_get<Curr, Index>(curr)...));
+                }
+            }
+        }
     }
 
-    auto filter() const noexcept {
-        using return_type = std::tuple<Exclude *...>;
-        return descriptor ? descriptor->filter_as_tuple() : return_type{};
+    template<typename Func, std::size_t... Index>
+    void pick_and_each(Func &func, std::index_sequence<Index...> seq) const {
+        if(const auto *view = base_type::handle(); view != nullptr) {
+            ((view == base_type::pool_at(Index) ? each<Index>(func, seq) : void()), ...);
+        }
     }
 
 public:
+    /*! @brief Common type among all storage types. */
+    using common_type = typename base_type::common_type;
     /*! @brief Underlying entity identifier. */
-    using entity_type = underlying_type;
+    using entity_type = typename base_type::entity_type;
     /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Common type among all storage types. */
-    using common_type = base_type;
-    /*! @brief Random access iterator type. */
-    using iterator = typename common_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename common_type::reverse_iterator;
-    /*! @brief Iterable group type. */
-    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<>, get_t<Get...>>>;
-    /*! @brief Group handler type. */
-    using handler = internal::group_handler<owned_t<>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>;
+    using size_type = typename base_type::size_type;
+    /*! @brief Forward iterator type. */
+    using iterator = typename base_type::iterator;
+    /*! @brief Iterable view type. */
+    using iterable = iterable_adaptor<internal::extended_view_iterator<iterator, Get...>>;
 
-    /*! @brief Default constructor to use to create empty, invalid groups. */
-    basic_group() noexcept
-        : descriptor{} {}
+    /*! @brief Default constructor to use to create empty, invalid views. */
+    basic_view() noexcept
+        : base_type{} {}
 
     /**
-     * @brief Constructs a group from a set of storage classes.
-     * @param ref A reference to a group handler.
+     * @brief Constructs a view from a set of storage classes.
+     * @param value The storage for the types to iterate.
+     * @param excl The storage for the types used to filter the view.
      */
-    basic_group(handler &ref) noexcept
-        : descriptor{&ref} {}
+    basic_view(Get &...value, Exclude &...excl) noexcept
+        : base_type{{&value...}, {&excl...}} {
+    }
 
     /**
-     * @brief Returns the leading storage of a group.
-     * @return The leading storage of the group.
+     * @brief Constructs a view from a set of storage classes.
+     * @param value The storage for the types to iterate.
+     * @param excl The storage for the types used to filter the view.
      */
-    [[nodiscard]] const common_type &handle() const noexcept {
-        return descriptor->handle();
+    basic_view(std::tuple<Get &...> value, std::tuple<Exclude &...> excl = {}) noexcept
+        : basic_view{std::make_from_tuple<basic_view>(std::tuple_cat(value, excl))} {}
+
+    /**
+     * @brief Forces a view to use a given element to drive iterations
+     * @tparam Type Type of element to use to drive iterations.
+     */
+    template<typename Type>
+    void use() noexcept {
+        use<index_of<Type>>();
+    }
+
+    /**
+     * @brief Forces a view to use a given element to drive iterations
+     * @tparam Index Index of the element to use to drive iterations.
+     */
+    template<std::size_t Index>
+    void use() noexcept {
+        base_type::use(Index);
     }
 
     /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
      */
     template<typename Type>
     [[nodiscard]] auto *storage() const noexcept {
@@ -21450,106 +22199,295 @@ class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
      */
     template<std::size_t Index>
     [[nodiscard]] auto *storage() const noexcept {
-        constexpr auto offset = sizeof...(Get);
+        using type = type_list_element_t<Index, type_list<Get..., Exclude...>>;
+        return static_cast<type *>(const_cast<constness_as_t<common_type, type> *>(base_type::storage(Index)));
+    }
+
+    /**
+     * @brief Assigns a storage to a view.
+     * @tparam Type Type of storage to assign to the view.
+     * @param elem A storage to assign to the view.
+     */
+    template<typename Type>
+    void storage(Type &elem) noexcept {
+        storage<index_of<typename Type::element_type>>(elem);
+    }
+
+    /**
+     * @brief Assigns a storage to a view.
+     * @tparam Index Index of the storage to assign to the view.
+     * @tparam Type Type of storage to assign to the view.
+     * @param elem A storage to assign to the view.
+     */
+    template<std::size_t Index, typename Type>
+    void storage(Type &elem) noexcept {
+        static_assert(std::is_convertible_v<Type &, type_list_element_t<Index, type_list<Get..., Exclude...>> &>, "Unexpected type");
+        base_type::storage(Index, &elem);
+    }
+
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the given entity.
+     */
+    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
+        return get(entt);
+    }
+
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Type Type of the element to get.
+     * @tparam Other Other types of elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<typename Type, typename... Other>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        return get<index_of<Type>, index_of<Other>...>(entt);
+    }
 
-        if constexpr(Index < offset) {
-            return std::get<Index>(pools());
+    /**
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Index Indexes of the elements to get.
+     * @param entt A valid identifier.
+     * @return The elements assigned to the entity.
+     */
+    template<std::size_t... Index>
+    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
+        if constexpr(sizeof...(Index) == 0) {
+            return get(entt, std::index_sequence_for<Get...>{});
+        } else if constexpr(sizeof...(Index) == 1) {
+            return (storage<Index>()->get(entt), ...);
         } else {
-            return std::get<Index - offset>(filter());
+            return std::tuple_cat(storage<Index>()->get_as_tuple(entt)...);
         }
     }
 
     /**
-     * @brief Returns the number of entities that are part of the group.
-     * @return Number of entities that are part of the group.
+     * @brief Iterates entities and elements and applies the given function
+     * object to them.
+     *
+     * The signature of the function must be equivalent to one of the following
+     * (non-empty types only, constness as requested):
+     *
+     * @code{.cpp}
+     * void(const entity_type, Type &...);
+     * void(Type &...);
+     * @endcode
+     *
+     * @tparam Func Type of the function object to invoke.
+     * @param func A valid function object.
      */
-    [[nodiscard]] size_type size() const noexcept {
-        return *this ? handle().size() : size_type{};
+    template<typename Func>
+    void each(Func func) const {
+        pick_and_each(func, std::index_sequence_for<Get...>{});
     }
 
     /**
-     * @brief Returns the number of elements that a group has currently
-     * allocated space for.
-     * @return Capacity of the group.
+     * @brief Returns an iterable object to use to _visit_ a view.
+     *
+     * The iterable object returns a tuple that contains the current entity and
+     * a set of references to its non-empty elements. The _constness_ of the
+     * elements is as requested.
+     *
+     * @return An iterable object to use to _visit_ the view.
      */
-    [[nodiscard]] size_type capacity() const noexcept {
-        return *this ? handle().capacity() : size_type{};
+    [[nodiscard]] iterable each() const noexcept {
+        return iterable{base_type::begin(), base_type::end()};
     }
 
-    /*! @brief Requests the removal of unused capacity. */
-    void shrink_to_fit() {
-        if(*this) {
-            descriptor->handle().shrink_to_fit();
+    /**
+     * @brief Combines two views in a _more specific_ one.
+     * @tparam OGet Element list of the view to combine with.
+     * @tparam OExclude Filter list of the view to combine with.
+     * @param other The view to combine with.
+     * @return A more specific view.
+     */
+    template<typename... OGet, typename... OExclude>
+    [[nodiscard]] auto operator|(const basic_view<get_t<OGet...>, exclude_t<OExclude...>> &other) const noexcept {
+        return internal::view_pack<basic_view<get_t<Get..., OGet...>, exclude_t<Exclude..., OExclude...>>>(
+            *this, other, std::index_sequence_for<Get...>{}, std::index_sequence_for<Exclude...>{}, std::index_sequence_for<OGet...>{}, std::index_sequence_for<OExclude...>{});
+    }
+};
+
+/**
+ * @brief Basic storage view implementation.
+ * @warning For internal use only, backward compatibility not guaranteed.
+ * @tparam Type Common type among all storage types.
+ * @tparam Policy Storage policy.
+ */
+template<typename Type, deletion_policy Policy>
+class basic_storage_view {
+    static_assert(std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, Type>, "Unexpected type");
+
+protected:
+    /*! @cond TURN_OFF_DOXYGEN */
+    basic_storage_view() noexcept = default;
+
+    basic_storage_view(const Type *value) noexcept
+        : leading{value} {
+        ENTT_ASSERT(leading->policy() == Policy, "Unexpected storage policy");
+    }
+    /*! @endcond */
+
+public:
+    /*! @brief Common type among all storage types. */
+    using common_type = Type;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename common_type::entity_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = std::size_t;
+    /*! @brief Random access iterator type. */
+    using iterator = std::conditional_t<Policy == deletion_policy::in_place, internal::view_iterator<common_type, 1u, 0u>, typename common_type::iterator>;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = std::conditional_t<Policy == deletion_policy::in_place, void, typename common_type::reverse_iterator>;
+
+    /**
+     * @brief Returns the leading storage of a view, if any.
+     * @return The leading storage of the view.
+     */
+    [[nodiscard]] const common_type *handle() const noexcept {
+        return leading;
+    }
+
+    /**
+     * @brief Returns the number of entities that have the given element.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
+     * @return Number of entities that have the given element.
+     */
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, size_type> size() const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->size() : size_type{};
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return leading ? leading->free_list() : size_type{};
         }
     }
 
     /**
-     * @brief Checks whether a group is empty.
-     * @return True if the group is empty, false otherwise.
+     * @brief Estimates the number of entities iterated by the view.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
+     * @return Estimated number of entities iterated by the view.
      */
-    [[nodiscard]] bool empty() const noexcept {
-        return !*this || handle().empty();
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol == deletion_policy::in_place, size_type> size_hint() const noexcept {
+        return leading ? leading->size() : size_type{};
     }
 
     /**
-     * @brief Returns an iterator to the first entity of the group.
+     * @brief Checks whether a view is empty.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
+     * @return True if the view is empty, false otherwise.
+     */
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, bool> empty() const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return !leading || leading->empty();
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return !leading || (leading->free_list() == 0u);
+        }
+    }
+
+    /**
+     * @brief Returns an iterator to the first entity of the view.
      *
-     * If the group is empty, the returned iterator will be equal to `end()`.
+     * If the view is empty, the returned iterator will be equal to `end()`.
      *
-     * @return An iterator to the first entity of the group.
+     * @return An iterator to the first entity of the view.
      */
     [[nodiscard]] iterator begin() const noexcept {
-        return *this ? handle().begin() : iterator{};
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->begin() : iterator{};
+        } else if constexpr(Policy == deletion_policy::swap_only) {
+            return leading ? (leading->end() - leading->free_list()) : iterator{};
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+            return leading ? iterator{leading->begin(), {leading}, {}, 0u} : iterator{};
+        }
     }
 
     /**
-     * @brief Returns an iterator that is past the last entity of the group.
-     * @return An iterator to the entity following the last entity of the
-     * group.
+     * @brief Returns an iterator that is past the last entity of the view.
+     * @return An iterator to the entity following the last entity of the view.
      */
     [[nodiscard]] iterator end() const noexcept {
-        return *this ? handle().end() : iterator{};
+        if constexpr(Policy == deletion_policy::swap_and_pop || Policy == deletion_policy::swap_only) {
+            return leading ? leading->end() : iterator{};
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+            return leading ? iterator{leading->end(), {leading}, {}, 0u} : iterator{};
+        }
     }
 
     /**
-     * @brief Returns an iterator to the first entity of the reversed group.
+     * @brief Returns an iterator to the first entity of the reversed view.
      *
-     * If the group is empty, the returned iterator will be equal to `rend()`.
+     * If the view is empty, the returned iterator will be equal to `rend()`.
      *
-     * @return An iterator to the first entity of the reversed group.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
+     * @return An iterator to the first entity of the reversed view.
      */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
-        return *this ? handle().rbegin() : reverse_iterator{};
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, reverse_iterator> rbegin() const noexcept {
+        return leading ? leading->rbegin() : reverse_iterator{};
     }
 
     /**
      * @brief Returns an iterator that is past the last entity of the reversed
-     * group.
+     * view.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
      * @return An iterator to the entity following the last entity of the
-     * reversed group.
+     * reversed view.
      */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return *this ? handle().rend() : reverse_iterator{};
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, reverse_iterator> rend() const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->rend() : reverse_iterator{};
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return leading ? (leading->rbegin() + leading->free_list()) : reverse_iterator{};
+        }
     }
 
     /**
-     * @brief Returns the first entity of the group, if any.
-     * @return The first entity of the group if one exists, the null entity
+     * @brief Returns the first entity of the view, if any.
+     * @return The first entity of the view if one exists, the null entity
      * otherwise.
      */
     [[nodiscard]] entity_type front() const noexcept {
-        const auto it = begin();
-        return it != end() ? *it : null;
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return empty() ? null : *leading->begin();
+        } else if constexpr(Policy == deletion_policy::swap_only) {
+            return empty() ? null : *(leading->end() - leading->free_list());
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+            const auto it = begin();
+            return (it == end()) ? null : *it;
+        }
     }
 
     /**
-     * @brief Returns the last entity of the group, if any.
-     * @return The last entity of the group if one exists, the null entity
+     * @brief Returns the last entity of the view, if any.
+     * @return The last entity of the view if one exists, the null entity
      * otherwise.
      */
     [[nodiscard]] entity_type back() const noexcept {
-        const auto it = rbegin();
-        return it != rend() ? *it : null;
+        if constexpr(Policy == deletion_policy::swap_and_pop || Policy == deletion_policy::swap_only) {
+            return empty() ? null : *leading->rbegin();
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+
+            if(leading) {
+                auto it = leading->rbegin();
+                const auto last = leading->rend();
+                for(; (it != last) && (*it == tombstone); ++it) {}
+                return it == last ? null : *it;
+            }
+
+            return null;
+        }
     }
 
     /**
@@ -21559,1890 +22497,1804 @@ class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
      * iterator otherwise.
      */
     [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        return *this ? handle().find(entt) : iterator{};
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->find(entt) : iterator{};
+        } else if constexpr(Policy == deletion_policy::swap_only) {
+            const auto it = leading ? leading->find(entt) : iterator{};
+            return leading && (static_cast<size_type>(it.index()) < leading->free_list()) ? it : iterator{};
+        } else {
+            const auto it = leading ? leading->find(entt) : typename common_type::iterator{};
+            return iterator{it, {leading}, {}, 0u};
+        }
     }
 
     /**
-     * @brief Returns the identifier that occupies the given position.
-     * @param pos Position of the element to return.
-     * @return The identifier that occupies the given position.
+     * @brief Checks if a view is fully initialized.
+     * @return True if the view is fully initialized, false otherwise.
      */
-    [[nodiscard]] entity_type operator[](const size_type pos) const {
-        return begin()[pos];
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return (leading != nullptr);
+    }
+
+    /**
+     * @brief Checks if a view contains an entity.
+     * @param entt A valid identifier.
+     * @return True if the view contains the given entity, false otherwise.
+     */
+    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop || Policy == deletion_policy::in_place) {
+            return leading && leading->contains(entt);
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return leading && leading->contains(entt) && (leading->index(entt) < leading->free_list());
+        }
+    }
+
+private:
+    const common_type *leading{};
+};
+
+/**
+ * @brief Storage view specialization.
+ *
+ * This specialization offers a boost in terms of performance. It can access the
+ * underlying data structure directly and avoid superfluous checks.
+ *
+ * @sa basic_view
+ *
+ * @tparam Get Type of storage iterated by the view.
+ */
+template<typename Get>
+class basic_view<get_t<Get>, exclude_t<>>
+    : public basic_storage_view<typename Get::base_type, Get::storage_policy> {
+    using base_type = basic_storage_view<typename Get::base_type, Get::storage_policy>;
+
+public:
+    /*! @brief Common type among all storage types. */
+    using common_type = typename base_type::common_type;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename base_type::entity_type;
+    /*! @brief Unsigned integer type. */
+    using size_type = typename base_type::size_type;
+    /*! @brief Random access iterator type. */
+    using iterator = typename base_type::iterator;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = typename base_type::reverse_iterator;
+    /*! @brief Iterable view type. */
+    using iterable = std::conditional_t<Get::storage_policy == deletion_policy::in_place, iterable_adaptor<internal::extended_view_iterator<iterator, Get>>, decltype(std::declval<Get>().each())>;
+
+    /*! @brief Default constructor to use to create empty, invalid views. */
+    basic_view() noexcept
+        : base_type{} {}
+
+    /**
+     * @brief Constructs a view from a storage class.
+     * @param value The storage for the type to iterate.
+     */
+    basic_view(Get &value) noexcept
+        : base_type{&value} {
+    }
+
+    /**
+     * @brief Constructs a view from a storage class.
+     * @param value The storage for the type to iterate.
+     */
+    basic_view(std::tuple<Get &> value, std::tuple<> = {}) noexcept
+        : basic_view{std::get<0>(value)} {}
+
+    /**
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
+     */
+    template<typename Type = typename Get::element_type>
+    [[nodiscard]] auto *storage() const noexcept {
+        static_assert(std::is_same_v<std::remove_const_t<Type>, typename Get::element_type>, "Invalid element type");
+        return storage<0>();
+    }
+
+    /**
+     * @brief Returns the storage for a given index, if any.
+     * @tparam Index Index of the storage to return.
+     * @return The storage for the given index.
+     */
+    template<std::size_t Index>
+    [[nodiscard]] auto *storage() const noexcept {
+        static_assert(Index == 0u, "Index out of bounds");
+        return static_cast<Get *>(const_cast<constness_as_t<common_type, Get> *>(base_type::handle()));
+    }
+
+    /**
+     * @brief Assigns a storage to a view.
+     * @param elem A storage to assign to the view.
+     */
+    void storage(Get &elem) noexcept {
+        storage<0>(elem);
+    }
+
+    /**
+     * @brief Assigns a storage to a view.
+     * @tparam Index Index of the storage to assign to the view.
+     * @param elem A storage to assign to the view.
+     */
+    template<std::size_t Index>
+    void storage(Get &elem) noexcept {
+        static_assert(Index == 0u, "Index out of bounds");
+        *this = basic_view{elem};
     }
 
     /**
-     * @brief Checks if a group is properly initialized.
-     * @return True if the group is properly initialized, false otherwise.
+     * @brief Returns a pointer to the underlying storage.
+     * @return A pointer to the underlying storage.
      */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return descriptor != nullptr;
+    [[nodiscard]] Get *operator->() const noexcept {
+        return storage();
     }
 
     /**
-     * @brief Checks if a group contains an entity.
+     * @brief Returns the element assigned to the given entity.
      * @param entt A valid identifier.
-     * @return True if the group contains the given entity, false otherwise.
+     * @return The element assigned to the given entity.
      */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        return *this && handle().contains(entt);
+    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
+        return storage()->get(entt);
     }
 
     /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Type Type of the component to get.
-     * @tparam Other Other types of components to get.
+     * @brief Returns the element assigned to the given entity.
+     * @tparam Elem Type of the element to get.
      * @param entt A valid identifier.
-     * @return The components assigned to the entity.
+     * @return The element assigned to the entity.
      */
-    template<typename Type, typename... Other>
+    template<typename Elem>
     [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        return get<index_of<Type>, index_of<Other>...>(entt);
+        static_assert(std::is_same_v<std::remove_const_t<Elem>, typename Get::element_type>, "Invalid element type");
+        return get<0>(entt);
     }
 
     /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Index Indexes of the components to get.
+     * @brief Returns the element assigned to the given entity.
+     * @tparam Index Index of the element to get.
      * @param entt A valid identifier.
-     * @return The components assigned to the entity.
+     * @return The element assigned to the entity.
      */
     template<std::size_t... Index>
     [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        const auto cpools = pools();
-
         if constexpr(sizeof...(Index) == 0) {
-            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
-        } else if constexpr(sizeof...(Index) == 1) {
-            return (std::get<Index>(cpools)->get(entt), ...);
+            return storage()->get_as_tuple(entt);
         } else {
-            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
+            return storage<Index...>()->get(entt);
         }
     }
 
     /**
-     * @brief Iterates entities and components and applies the given function
+     * @brief Iterates entities and elements and applies the given function
      * object to them.
      *
-     * The function object is invoked for each entity. It is provided with the
-     * entity itself and a set of references to non-empty components. The
-     * _constness_ of the components is as requested.<br/>
      * The signature of the function must be equivalent to one of the following
-     * forms:
+     * (non-empty types only, constness as requested):
      *
      * @code{.cpp}
-     * void(const entity_type, Type &...);
-     * void(Type &...);
+     * void(const entity_type, Type &);
+     * void(typename Type &);
      * @endcode
      *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
      * @tparam Func Type of the function object to invoke.
      * @param func A valid function object.
      */
     template<typename Func>
     void each(Func func) const {
-        for(const auto entt: *this) {
-            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
-                std::apply(func, std::tuple_cat(std::make_tuple(entt), get(entt)));
-            } else {
-                std::apply(func, get(entt));
+        if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_view>().get({})))>) {
+            for(const auto pack: each()) {
+                std::apply(func, pack);
             }
-        }
-    }
-
-    /**
-     * @brief Returns an iterable object to use to _visit_ a group.
-     *
-     * The iterable object returns tuples that contain the current entity and a
-     * set of references to its non-empty components. The _constness_ of the
-     * components is as requested.
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @return An iterable object to use to _visit_ the group.
-     */
-    [[nodiscard]] iterable each() const noexcept {
-        const auto cpools = pools();
-        return iterable{{begin(), cpools}, {end(), cpools}};
-    }
-
-    /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * The comparison function object must return `true` if the first element
-     * is _less_ than the second one, `false` otherwise. The signature of the
-     * comparison function should be equivalent to one of the following:
-     *
-     * @code{.cpp}
-     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
-     * bool(const Type &..., const Type &...);
-     * bool(const Entity, const Entity);
-     * @endcode
-     *
-     * Where `Type` are such that they are iterated by the group.<br/>
-     * Moreover, the comparison function object shall induce a
-     * _strict weak ordering_ on the values.
-     *
-     * The sort function object must offer a member function template
-     * `operator()` that accepts three arguments:
-     *
-     * * An iterator to the first element of the range to sort.
-     * * An iterator past the last element of the range to sort.
-     * * A comparison function to use to compare the elements.
-     *
-     * @tparam Type Optional type of component to compare.
-     * @tparam Other Other optional types of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
-        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
-    }
-
-    /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * @sa sort
-     *
-     * @tparam Index Optional indexes of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
-        if(*this) {
-            if constexpr(sizeof...(Index) == 0) {
-                static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
-                descriptor->handle().sort(std::move(compare), std::move(algo), std::forward<Args>(args)...);
+        } else if constexpr(Get::storage_policy == deletion_policy::swap_and_pop || Get::storage_policy == deletion_policy::swap_only) {
+            if constexpr(std::is_void_v<typename Get::value_type>) {
+                for(size_type pos = base_type::size(); pos; --pos) {
+                    func();
+                }
             } else {
-                auto comp = [&compare, cpools = pools()](const entity_type lhs, const entity_type rhs) {
-                    if constexpr(sizeof...(Index) == 1) {
-                        return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
-                    } else {
-                        return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
+                if(const auto len = base_type::size(); len != 0u) {
+                    for(auto last = storage()->end(), first = last - len; first != last; ++first) {
+                        func(*first);
                     }
-                };
+                }
+            }
+        } else {
+            static_assert(Get::storage_policy == deletion_policy::in_place, "Unexpected storage policy");
 
-                descriptor->handle().sort(std::move(comp), std::move(algo), std::forward<Args>(args)...);
+            for(const auto pack: each()) {
+                std::apply([&func](const auto, auto &&...elem) { func(std::forward<decltype(elem)>(elem)...); }, pack);
             }
         }
     }
 
     /**
-     * @brief Sort entities according to their order in a range.
+     * @brief Returns an iterable object to use to _visit_ a view.
      *
-     * The shared pool of entities and thus its order is affected by the changes
-     * to each and every pool that it tracks.
+     * The iterable object returns a tuple that contains the current entity and
+     * a reference to its element if it's a non-empty one. The _constness_ of
+     * the element is as requested.
      *
-     * @tparam It Type of input iterator.
-     * @param first An iterator to the first element of the range of entities.
-     * @param last An iterator past the last element of the range of entities.
+     * @return An iterable object to use to _visit_ the view.
      */
-    template<typename It>
-    void sort_as(It first, It last) const {
-        if(*this) {
-            descriptor->handle().sort_as(first, last);
+    [[nodiscard]] iterable each() const noexcept {
+        if constexpr(Get::storage_policy == deletion_policy::swap_and_pop || Get::storage_policy == deletion_policy::swap_only) {
+            return base_type::handle() ? storage()->each() : iterable{};
+        } else {
+            static_assert(Get::storage_policy == deletion_policy::in_place, "Unexpected storage policy");
+            return iterable{base_type::begin(), base_type::end()};
         }
     }
 
     /**
-     * @brief Sort entities according to their order in a range.
-     * @param other The storage to use to impose the order.
+     * @brief Combines two views in a _more specific_ one.
+     * @tparam OGet Element list of the view to combine with.
+     * @tparam OExclude Filter list of the view to combine with.
+     * @param other The view to combine with.
+     * @return A more specific view.
      */
-    [[deprecated("use iterator based sort_as instead")]] void sort_as(const common_type &other) const {
-        sort_as(other.begin(), other.end());
+    template<typename... OGet, typename... OExclude>
+    [[nodiscard]] auto operator|(const basic_view<get_t<OGet...>, exclude_t<OExclude...>> &other) const noexcept {
+        return internal::view_pack<basic_view<get_t<Get, OGet...>, exclude_t<OExclude...>>>(
+            *this, other, std::index_sequence_for<Get>{}, std::index_sequence_for<>{}, std::index_sequence_for<OGet...>{}, std::index_sequence_for<OExclude...>{});
     }
-
-private:
-    handler *descriptor;
 };
 
 /**
- * @brief Owning group.
- *
- * Owning groups returns all entities and only the entities that are at
- * least in the given storage. Moreover:
- *
- * * It's guaranteed that the entity list is tightly packed in memory for fast
- *   iterations.
- * * It's guaranteed that all components in the owned storage are tightly packed
- *   in memory for even faster iterations and to allow direct access.
- * * They stay true to the order of the owned storage and all instances have the
- *   same order in memory.
- *
- * The more types of storage are owned, the faster it is to iterate a group.
- *
- * @b Important
- *
- * Iterators aren't invalidated if:
- *
- * * New elements are added to the storage.
- * * The entity currently pointed is modified (for example, components are added
- *   or removed from it).
- * * The entity currently pointed is destroyed.
- *
- * In all other cases, modifying the pools iterated by the group in any way
- * invalidates all the iterators.
- *
- * @tparam Owned Types of storage _owned_ by the group.
- * @tparam Get Types of storage _observed_ by the group.
- * @tparam Exclude Types of storage used to filter the group.
+ * @brief Deduction guide.
+ * @tparam Type Type of storage classes used to create the view.
+ * @param storage The storage for the types to iterate.
  */
-template<typename... Owned, typename... Get, typename... Exclude>
-class basic_group<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> {
-    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
-    using underlying_type = typename base_type::entity_type;
+template<typename... Type>
+basic_view(Type &...storage) -> basic_view<get_t<Type...>, exclude_t<>>;
 
-    template<typename Type>
-    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Owned::value_type..., typename Get::value_type..., typename Exclude::value_type...>>;
+/**
+ * @brief Deduction guide.
+ * @tparam Get Types of elements iterated by the view.
+ * @tparam Exclude Types of elements used to filter the view.
+ */
+template<typename... Get, typename... Exclude>
+basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<get_t<Get...>, exclude_t<Exclude...>>;
 
-    auto pools() const noexcept {
-        using return_type = std::tuple<Owned *..., Get *...>;
-        return descriptor ? descriptor->pools_as_tuple() : return_type{};
-    }
+} // namespace entt
 
-    auto filter() const noexcept {
-        using return_type = std::tuple<Exclude *...>;
-        return descriptor ? descriptor->filter_as_tuple() : return_type{};
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Converts a registry to a view.
+ * @tparam Registry Basic registry type.
+ */
+template<typename Registry>
+class as_view {
+    template<typename... Get, typename... Exclude>
+    [[nodiscard]] auto dispatch(get_t<Get...>, exclude_t<Exclude...>) const {
+        return reg.template view<constness_as_t<typename Get::element_type, Get>...>(exclude_t<constness_as_t<typename Exclude::element_type, Exclude>...>{});
     }
 
 public:
+    /*! @brief Type of registry to convert. */
+    using registry_type = Registry;
     /*! @brief Underlying entity identifier. */
-    using entity_type = underlying_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Common type among all storage types. */
-    using common_type = base_type;
-    /*! @brief Random access iterator type. */
-    using iterator = typename common_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename common_type::reverse_iterator;
-    /*! @brief Iterable group type. */
-    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<Owned...>, get_t<Get...>>>;
-    /*! @brief Group handler type. */
-    using handler = internal::group_handler<owned_t<std::remove_const_t<Owned>...>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>;
-
-    /*! @brief Default constructor to use to create empty, invalid groups. */
-    basic_group() noexcept
-        : descriptor{} {}
-
-    /**
-     * @brief Constructs a group from a set of storage classes.
-     * @param ref A reference to a group handler.
-     */
-    basic_group(handler &ref) noexcept
-        : descriptor{&ref} {}
+    using entity_type = typename registry_type::entity_type;
 
     /**
-     * @brief Returns the leading storage of a group.
-     * @return The leading storage of the group.
+     * @brief Constructs a converter for a given registry.
+     * @param source A valid reference to a registry.
      */
-    [[nodiscard]] const common_type &handle() const noexcept {
-        return *storage<0>();
-    }
+    as_view(registry_type &source) noexcept
+        : reg{source} {}
 
     /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
+     * @brief Conversion function from a registry to a view.
+     * @tparam Get Type of storage used to construct the view.
+     * @tparam Exclude Types of storage used to filter the view.
+     * @return A newly created view.
      */
-    template<typename Type>
-    [[nodiscard]] auto *storage() const noexcept {
-        return storage<index_of<Type>>();
+    template<typename Get, typename Exclude>
+    operator basic_view<Get, Exclude>() const {
+        return dispatch(Get{}, Exclude{});
     }
 
-    /**
-     * @brief Returns the storage for a given index, if any.
-     * @tparam Index Index of the storage to return.
-     * @return The storage for the given index.
-     */
-    template<std::size_t Index>
-    [[nodiscard]] auto *storage() const noexcept {
-        constexpr auto offset = sizeof...(Owned) + sizeof...(Get);
+private:
+    registry_type &reg;
+};
 
-        if constexpr(Index < offset) {
-            return std::get<Index>(pools());
+/**
+ * @brief Converts a registry to a group.
+ * @tparam Registry Basic registry type.
+ */
+template<typename Registry>
+class as_group {
+    template<typename... Owned, typename... Get, typename... Exclude>
+    [[nodiscard]] auto dispatch(owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>) const {
+        if constexpr(std::is_const_v<registry_type>) {
+            return reg.template group_if_exists<typename Owned::element_type...>(get_t<typename Get::element_type...>{}, exclude_t<typename Exclude::element_type...>{});
         } else {
-            return std::get<Index - offset>(filter());
+            return reg.template group<constness_as_t<typename Owned::element_type, Owned>...>(get_t<constness_as_t<typename Get::element_type, Get>...>{}, exclude_t<constness_as_t<typename Exclude::element_type, Exclude>...>{});
         }
     }
 
+public:
+    /*! @brief Type of registry to convert. */
+    using registry_type = Registry;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename registry_type::entity_type;
+
     /**
-     * @brief Returns the number of entities that that are part of the group.
-     * @return Number of entities that that are part of the group.
+     * @brief Constructs a converter for a given registry.
+     * @param source A valid reference to a registry.
      */
-    [[nodiscard]] size_type size() const noexcept {
-        return *this ? descriptor->length() : size_type{};
-    }
+    as_group(registry_type &source) noexcept
+        : reg{source} {}
 
     /**
-     * @brief Checks whether a group is empty.
-     * @return True if the group is empty, false otherwise.
+     * @brief Conversion function from a registry to a group.
+     * @tparam Owned Types of _owned_ by the group.
+     * @tparam Get Types of storage _observed_ by the group.
+     * @tparam Exclude Types of storage used to filter the group.
+     * @return A newly created group.
      */
-    [[nodiscard]] bool empty() const noexcept {
-        return !*this || !descriptor->length();
+    template<typename Owned, typename Get, typename Exclude>
+    operator basic_group<Owned, Get, Exclude>() const {
+        return dispatch(Owned{}, Get{}, Exclude{});
     }
 
-    /**
-     * @brief Returns an iterator to the first entity of the group.
-     *
-     * If the group is empty, the returned iterator will be equal to `end()`.
-     *
-     * @return An iterator to the first entity of the group.
-     */
-    [[nodiscard]] iterator begin() const noexcept {
-        return *this ? (handle().end() - descriptor->length()) : iterator{};
+private:
+    registry_type &reg;
+};
+
+/**
+ * @brief Helper to create a listener that directly invokes a member function.
+ * @tparam Member Member function to invoke on an element of the given type.
+ * @tparam Registry Basic registry type.
+ * @param reg A registry that contains the given entity and its elements.
+ * @param entt Entity from which to get the element.
+ */
+template<auto Member, typename Registry = std::decay_t<nth_argument_t<0u, decltype(Member)>>>
+void invoke(Registry &reg, const typename Registry::entity_type entt) {
+    static_assert(std::is_member_function_pointer_v<decltype(Member)>, "Invalid pointer to non-static member function");
+    (reg.template get<member_class_t<decltype(Member)>>(entt).*Member)(reg, entt);
+}
+
+/**
+ * @brief Returns the entity associated with a given element.
+ *
+ * @warning
+ * Currently, this function only works correctly with the default storage as it
+ * makes assumptions about how the elements are laid out.
+ *
+ * @tparam Args Storage type template parameters.
+ * @param storage A storage that contains the given element.
+ * @param instance A valid element instance.
+ * @return The entity associated with the given element.
+ */
+template<typename... Args>
+typename basic_storage<Args...>::entity_type to_entity(const basic_storage<Args...> &storage, const typename basic_storage<Args...>::value_type &instance) {
+    using traits_type = component_traits<typename basic_storage<Args...>::value_type>;
+    static_assert(traits_type::page_size != 0u, "Unexpected page size");
+    const typename basic_storage<Args...>::base_type &base = storage;
+    const auto *addr = std::addressof(instance);
+
+    for(auto it = base.rbegin(), last = base.rend(); it < last; it += traits_type::page_size) {
+        if(const auto dist = (addr - std::addressof(storage.get(*it))); dist >= 0 && dist < static_cast<decltype(dist)>(traits_type::page_size)) {
+            return *(it + dist);
+        }
     }
 
+    return null;
+}
+
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct sigh_helper;
+
+/**
+ * @brief Signal connection helper for registries.
+ * @tparam Registry Basic registry type.
+ */
+template<typename Registry>
+struct sigh_helper<Registry> {
+    /*! @brief Registry type. */
+    using registry_type = Registry;
+
     /**
-     * @brief Returns an iterator that is past the last entity of the group.
-     * @return An iterator to the entity following the last entity of the
-     * group.
+     * @brief Constructs a helper for a given registry.
+     * @param ref A valid reference to a registry.
      */
-    [[nodiscard]] iterator end() const noexcept {
-        return *this ? handle().end() : iterator{};
-    }
+    sigh_helper(registry_type &ref)
+        : bucket{&ref} {}
 
     /**
-     * @brief Returns an iterator to the first entity of the reversed group.
-     *
-     * If the group is empty, the returned iterator will be equal to `rend()`.
-     *
-     * @return An iterator to the first entity of the reversed group.
+     * @brief Binds a properly initialized helper to a given signal type.
+     * @tparam Type Type of signal to bind the helper to.
+     * @param id Optional name for the underlying storage to use.
+     * @return A helper for a given registry and signal type.
      */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
-        return *this ? handle().rbegin() : reverse_iterator{};
+    template<typename Type>
+    auto with(const id_type id = type_hash<Type>::value()) noexcept {
+        return sigh_helper<registry_type, Type>{*bucket, id};
     }
 
     /**
-     * @brief Returns an iterator that is past the last entity of the reversed
-     * group.
-     * @return An iterator to the entity following the last entity of the
-     * reversed group.
+     * @brief Returns a reference to the underlying registry.
+     * @return A reference to the underlying registry.
      */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return *this ? (handle().rbegin() + descriptor->length()) : reverse_iterator{};
+    [[nodiscard]] registry_type &registry() noexcept {
+        return *bucket;
     }
 
+private:
+    registry_type *bucket;
+};
+
+/**
+ * @brief Signal connection helper for registries.
+ * @tparam Registry Basic registry type.
+ * @tparam Type Type of signal to connect listeners to.
+ */
+template<typename Registry, typename Type>
+struct sigh_helper<Registry, Type> final: sigh_helper<Registry> {
+    /*! @brief Registry type. */
+    using registry_type = Registry;
+
     /**
-     * @brief Returns the first entity of the group, if any.
-     * @return The first entity of the group if one exists, the null entity
-     * otherwise.
+     * @brief Constructs a helper for a given registry.
+     * @param ref A valid reference to a registry.
+     * @param id Optional name for the underlying storage to use.
      */
-    [[nodiscard]] entity_type front() const noexcept {
-        const auto it = begin();
-        return it != end() ? *it : null;
-    }
+    sigh_helper(registry_type &ref, const id_type id = type_hash<Type>::value())
+        : sigh_helper<Registry>{ref},
+          name{id} {}
 
     /**
-     * @brief Returns the last entity of the group, if any.
-     * @return The last entity of the group if one exists, the null entity
-     * otherwise.
+     * @brief Forwards the call to `on_construct` on the underlying storage.
+     * @tparam Candidate Function or member to connect.
+     * @tparam Args Type of class or type of payload, if any.
+     * @param args A valid object that fits the purpose, if any.
+     * @return This helper.
      */
-    [[nodiscard]] entity_type back() const noexcept {
-        const auto it = rbegin();
-        return it != rend() ? *it : null;
+    template<auto Candidate, typename... Args>
+    auto on_construct(Args &&...args) {
+        this->registry().template on_construct<Type>(name).template connect<Candidate>(std::forward<Args>(args)...);
+        return *this;
     }
 
     /**
-     * @brief Finds an entity.
-     * @param entt A valid identifier.
-     * @return An iterator to the given entity if it's found, past the end
-     * iterator otherwise.
+     * @brief Forwards the call to `on_update` on the underlying storage.
+     * @tparam Candidate Function or member to connect.
+     * @tparam Args Type of class or type of payload, if any.
+     * @param args A valid object that fits the purpose, if any.
+     * @return This helper.
      */
-    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        const auto it = *this ? handle().find(entt) : iterator{};
-        return it >= begin() ? it : iterator{};
+    template<auto Candidate, typename... Args>
+    auto on_update(Args &&...args) {
+        this->registry().template on_update<Type>(name).template connect<Candidate>(std::forward<Args>(args)...);
+        return *this;
     }
 
     /**
-     * @brief Returns the identifier that occupies the given position.
-     * @param pos Position of the element to return.
-     * @return The identifier that occupies the given position.
+     * @brief Forwards the call to `on_destroy` on the underlying storage.
+     * @tparam Candidate Function or member to connect.
+     * @tparam Args Type of class or type of payload, if any.
+     * @param args A valid object that fits the purpose, if any.
+     * @return This helper.
      */
-    [[nodiscard]] entity_type operator[](const size_type pos) const {
-        return begin()[pos];
+    template<auto Candidate, typename... Args>
+    auto on_destroy(Args &&...args) {
+        this->registry().template on_destroy<Type>(name).template connect<Candidate>(std::forward<Args>(args)...);
+        return *this;
     }
 
-    /**
-     * @brief Checks if a group is properly initialized.
-     * @return True if the group is properly initialized, false otherwise.
-     */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return descriptor != nullptr;
-    }
+private:
+    id_type name;
+};
+
+/**
+ * @brief Deduction guide.
+ * @tparam Registry Basic registry type.
+ */
+template<typename Registry>
+sigh_helper(Registry &) -> sigh_helper<Registry>;
+
+} // namespace entt
+
+#endif
+
+// #include "entity/mixin.hpp"
+#ifndef ENTT_ENTITY_MIXIN_HPP
+#define ENTT_ENTITY_MIXIN_HPP
+
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "../core/any.hpp"
+
+// #include "../core/type_info.hpp"
+
+// #include "../signal/sigh.hpp"
+#ifndef ENTT_SIGNAL_SIGH_HPP
+#define ENTT_SIGNAL_SIGH_HPP
+
+#include <cstddef>
+#include <memory>
+#include <type_traits>
+#include <utility>
+#include <vector>
+// #include "delegate.hpp"
+#ifndef ENTT_SIGNAL_DELEGATE_HPP
+#define ENTT_SIGNAL_DELEGATE_HPP
+
+#include <cstddef>
+#include <functional>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+#ifndef ENTT_CONFIG_CONFIG_H
+#define ENTT_CONFIG_CONFIG_H
+
+// #include "version.h"
+#ifndef ENTT_CONFIG_VERSION_H
+#define ENTT_CONFIG_VERSION_H
+
+// #include "macro.h"
+#ifndef ENTT_CONFIG_MACRO_H
+#define ENTT_CONFIG_MACRO_H
+
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
+#define ENTT_STR(arg) #arg
+#define ENTT_XSTR(arg) ENTT_STR(arg)
+
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
 
-    /**
-     * @brief Checks if a group contains an entity.
-     * @param entt A valid identifier.
-     * @return True if the group contains the given entity, false otherwise.
-     */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        return *this && handle().contains(entt) && (handle().index(entt) < (descriptor->length()));
-    }
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Type Type of the component to get.
-     * @tparam Other Other types of components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<typename Type, typename... Other>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        return get<index_of<Type>, index_of<Other>...>(entt);
-    }
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Index Indexes of the components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<std::size_t... Index>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        const auto cpools = pools();
+#define ENTT_VERSION_MAJOR 3
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
-        if constexpr(sizeof...(Index) == 0) {
-            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
-        } else if constexpr(sizeof...(Index) == 1) {
-            return (std::get<Index>(cpools)->get(entt), ...);
-        } else {
-            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
-        }
-    }
+#define ENTT_VERSION \
+    ENTT_XSTR(ENTT_VERSION_MAJOR) \
+    "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
-    /**
-     * @brief Iterates entities and components and applies the given function
-     * object to them.
-     *
-     * The function object is invoked for each entity. It is provided with the
-     * entity itself and a set of references to non-empty components. The
-     * _constness_ of the components is as requested.<br/>
-     * The signature of the function must be equivalent to one of the following
-     * forms:
-     *
-     * @code{.cpp}
-     * void(const entity_type, Type &...);
-     * void(Type &...);
-     * @endcode
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @tparam Func Type of the function object to invoke.
-     * @param func A valid function object.
-     */
-    template<typename Func>
-    void each(Func func) const {
-        for(auto args: each()) {
-            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
-                std::apply(func, args);
-            } else {
-                std::apply([&func](auto, auto &&...less) { func(std::forward<decltype(less)>(less)...); }, args);
-            }
-        }
-    }
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-    /**
-     * @brief Returns an iterable object to use to _visit_ a group.
-     *
-     * The iterable object returns tuples that contain the current entity and a
-     * set of references to its non-empty components. The _constness_ of the
-     * components is as requested.
-     *
-     * @note
-     * Empty types aren't explicitly instantiated and therefore they are never
-     * returned during iterations.
-     *
-     * @return An iterable object to use to _visit_ the group.
-     */
-    [[nodiscard]] iterable each() const noexcept {
-        const auto cpools = pools();
-        return {{begin(), cpools}, {end(), cpools}};
-    }
+#endif
 
-    /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * The comparison function object must return `true` if the first element
-     * is _less_ than the second one, `false` otherwise. The signature of the
-     * comparison function should be equivalent to one of the following:
-     *
-     * @code{.cpp}
-     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
-     * bool(const Type &, const Type &);
-     * bool(const Entity, const Entity);
-     * @endcode
-     *
-     * Where `Type` are either owned types or not but still such that they are
-     * iterated by the group.<br/>
-     * Moreover, the comparison function object shall induce a
-     * _strict weak ordering_ on the values.
-     *
-     * The sort function object must offer a member function template
-     * `operator()` that accepts three arguments:
-     *
-     * * An iterator to the first element of the range to sort.
-     * * An iterator past the last element of the range to sort.
-     * * A comparison function to use to compare the elements.
-     *
-     * @tparam Type Optional type of component to compare.
-     * @tparam Other Other optional types of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
-        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
-    }
 
-    /**
-     * @brief Sort a group according to the given comparison function.
-     *
-     * @sa sort
-     *
-     * @tparam Index Optional indexes of components to compare.
-     * @tparam Compare Type of comparison function object.
-     * @tparam Sort Type of sort function object.
-     * @tparam Args Types of arguments to forward to the sort function object.
-     * @param compare A valid comparison function object.
-     * @param algo A valid sort function object.
-     * @param args Arguments to forward to the sort function object, if any.
-     */
-    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
-    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
-        const auto cpools = pools();
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
 
-        if constexpr(sizeof...(Index) == 0) {
-            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
-            storage<0>()->sort_n(descriptor->length(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
-        } else {
-            auto comp = [&compare, &cpools](const entity_type lhs, const entity_type rhs) {
-                if constexpr(sizeof...(Index) == 1) {
-                    return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
-                } else {
-                    return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
-                }
-            };
+#if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
+#    define ENTT_CONSTEXPR
+#    define ENTT_THROW throw
+#    define ENTT_TRY try
+#    define ENTT_CATCH catch(...)
+#else
+#    define ENTT_CONSTEXPR constexpr // use only with throwing functions (waiting for C++20)
+#    define ENTT_THROW
+#    define ENTT_TRY if(true)
+#    define ENTT_CATCH if(false)
+#endif
 
-            storage<0>()->sort_n(descriptor->length(), std::move(comp), std::move(algo), std::forward<Args>(args)...);
-        }
+#ifdef ENTT_USE_ATOMIC
+#    include <atomic>
+#    define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
+#else
+#    define ENTT_MAYBE_ATOMIC(Type) Type
+#endif
 
-        auto cb = [this](auto *head, auto *...other) {
-            for(auto next = descriptor->length(); next; --next) {
-                const auto pos = next - 1;
-                [[maybe_unused]] const auto entt = head->data()[pos];
-                (other->swap_elements(other->data()[pos], entt), ...);
-            }
-        };
+#ifndef ENTT_ID_TYPE
+#    include <cstdint>
+#    define ENTT_ID_TYPE std::uint32_t
+#else
+#    include <cstdint> // provides coverage for types in the std namespace
+#endif
 
-        std::apply(cb, cpools);
-    }
+#ifndef ENTT_SPARSE_PAGE
+#    define ENTT_SPARSE_PAGE 4096
+#endif
 
-private:
-    handler *descriptor;
-};
+#ifndef ENTT_PACKED_PAGE
+#    define ENTT_PACKED_PAGE 1024
+#endif
 
-} // namespace entt
+#ifdef ENTT_DISABLE_ASSERT
+#    undef ENTT_ASSERT
+#    define ENTT_ASSERT(condition, msg) (void(0))
+#elif !defined ENTT_ASSERT
+#    include <cassert>
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
+#endif
 
+#ifdef ENTT_DISABLE_ASSERT
+#    undef ENTT_ASSERT_CONSTEXPR
+#    define ENTT_ASSERT_CONSTEXPR(condition, msg) (void(0))
+#elif !defined ENTT_ASSERT_CONSTEXPR
+#    define ENTT_ASSERT_CONSTEXPR(condition, msg) ENTT_ASSERT(condition, msg)
 #endif
 
-// #include "storage.hpp"
+#define ENTT_FAIL(msg) ENTT_ASSERT(false, msg);
 
-// #include "view.hpp"
-#ifndef ENTT_ENTITY_VIEW_HPP
-#define ENTT_ENTITY_VIEW_HPP
+#ifdef ENTT_NO_ETO
+#    define ENTT_ETO_TYPE(Type) void
+#else
+#    define ENTT_ETO_TYPE(Type) Type
+#endif
 
-#include <array>
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
+#ifdef ENTT_STANDARD_CPP
+#    define ENTT_NONSTD false
+#else
+#    define ENTT_NONSTD true
+#    if defined __clang__ || defined __GNUC__
+#        define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
+#        define ENTT_PRETTY_FUNCTION_PREFIX '='
+#        define ENTT_PRETTY_FUNCTION_SUFFIX ']'
+#    elif defined _MSC_VER
+#        define ENTT_PRETTY_FUNCTION __FUNCSIG__
+#        define ENTT_PRETTY_FUNCTION_PREFIX '<'
+#        define ENTT_PRETTY_FUNCTION_SUFFIX '>'
+#    endif
+#endif
+
+#if defined _MSC_VER
+#    pragma detect_mismatch("entt.version", ENTT_VERSION)
+#    pragma detect_mismatch("entt.noexcept", ENTT_XSTR(ENTT_TRY))
+#    pragma detect_mismatch("entt.id", ENTT_XSTR(ENTT_ID_TYPE))
+#    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
+#endif
+
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+// #include "../core/type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
 #include <iterator>
 #include <tuple>
 #include <type_traits>
 #include <utility>
 // #include "../config/config.h"
+#ifndef ENTT_CONFIG_CONFIG_H
+#define ENTT_CONFIG_CONFIG_H
 
-// #include "../core/iterator.hpp"
+// #include "version.h"
+#ifndef ENTT_CONFIG_VERSION_H
+#define ENTT_CONFIG_VERSION_H
 
-// #include "../core/type_traits.hpp"
+// #include "macro.h"
+#ifndef ENTT_CONFIG_MACRO_H
+#define ENTT_CONFIG_MACRO_H
 
-// #include "entity.hpp"
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
 
-// #include "fwd.hpp"
+#define ENTT_STR(arg) #arg
+#define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-namespace entt {
+#endif
 
-/*! @cond TURN_OFF_DOXYGEN */
-namespace internal {
 
-template<typename Type, typename Entity>
-[[nodiscard]] bool all_of_but(const std::size_t index, const Type *const *it, const std::size_t len, const Entity entt) noexcept {
-    std::size_t pos{};
-    for(; (pos != index) && it[pos]->contains(entt); ++pos) {}
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
 
-    if(pos == index) {
-        for(++pos; (pos != len) && it[pos]->contains(entt); ++pos) {}
-    }
+#define ENTT_VERSION_MAJOR 3
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
-    return pos == len;
-}
+#define ENTT_VERSION \
+    ENTT_XSTR(ENTT_VERSION_MAJOR) \
+    "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
-template<typename Type, typename Entity>
-[[nodiscard]] bool none_of(const Type *const *it, const std::size_t len, const Entity entt) noexcept {
-    std::size_t pos{};
-    for(; (pos != len) && !(it[pos] && it[pos]->contains(entt)); ++pos) {}
-    return pos == len;
-}
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-template<typename Type>
-[[nodiscard]] bool fully_initialized(const Type *const *it, const std::size_t len) noexcept {
-    std::size_t pos{};
-    for(; (pos != len) && it[pos]; ++pos) {}
-    return pos == len;
-}
+#endif
 
-template<typename Result, typename View, typename Other, std::size_t... VGet, std::size_t... VExclude, std::size_t... OGet, std::size_t... OExclude>
-[[nodiscard]] Result view_pack(const View &view, const Other &other, std::index_sequence<VGet...>, std::index_sequence<VExclude...>, std::index_sequence<OGet...>, std::index_sequence<OExclude...>) {
-    Result elem{};
-    // friend-initialization, avoid multiple calls to refresh
-    elem.pools = {view.template storage<VGet>()..., other.template storage<OGet>()...};
-    elem.filter = {view.template storage<sizeof...(VGet) + VExclude>()..., other.template storage<sizeof...(OGet) + OExclude>()...};
-    elem.refresh();
-    return elem;
-}
 
-template<typename Type, std::size_t Get, std::size_t Exclude>
-class view_iterator final {
-    using iterator_type = typename Type::const_iterator;
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
 
-    [[nodiscard]] bool valid(const typename iterator_type::value_type entt) const noexcept {
-        return ((Get != 1u) || (entt != tombstone)) && all_of_but(index, pools.data(), Get, entt) && none_of(filter.data(), Exclude, entt);
-    }
+#if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
+#    define ENTT_CONSTEXPR
+#    define ENTT_THROW throw
+#    define ENTT_TRY try
+#    define ENTT_CATCH catch(...)
+#else
+#    define ENTT_CONSTEXPR constexpr // use only with throwing functions (waiting for C++20)
+#    define ENTT_THROW
+#    define ENTT_TRY if(true)
+#    define ENTT_CATCH if(false)
+#endif
 
-public:
-    using value_type = typename iterator_type::value_type;
-    using pointer = typename iterator_type::pointer;
-    using reference = typename iterator_type::reference;
-    using difference_type = typename iterator_type::difference_type;
-    using iterator_category = std::forward_iterator_tag;
+#ifdef ENTT_USE_ATOMIC
+#    include <atomic>
+#    define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
+#else
+#    define ENTT_MAYBE_ATOMIC(Type) Type
+#endif
 
-    constexpr view_iterator() noexcept
-        : it{},
-          last{},
-          pools{},
-          filter{},
-          index{} {}
+#ifndef ENTT_ID_TYPE
+#    include <cstdint>
+#    define ENTT_ID_TYPE std::uint32_t
+#else
+#    include <cstdint> // provides coverage for types in the std namespace
+#endif
 
-    view_iterator(iterator_type curr, iterator_type to, std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl, const std::size_t idx) noexcept
-        : it{curr},
-          last{to},
-          pools{value},
-          filter{excl},
-          index{idx} {
-        while(it != last && !valid(*it)) {
-            ++it;
-        }
-    }
+#ifndef ENTT_SPARSE_PAGE
+#    define ENTT_SPARSE_PAGE 4096
+#endif
 
-    view_iterator &operator++() noexcept {
-        while(++it != last && !valid(*it)) {}
-        return *this;
-    }
+#ifndef ENTT_PACKED_PAGE
+#    define ENTT_PACKED_PAGE 1024
+#endif
 
-    view_iterator operator++(int) noexcept {
-        view_iterator orig = *this;
-        return ++(*this), orig;
-    }
+#ifdef ENTT_DISABLE_ASSERT
+#    undef ENTT_ASSERT
+#    define ENTT_ASSERT(condition, msg) (void(0))
+#elif !defined ENTT_ASSERT
+#    include <cassert>
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
+#endif
 
-    [[nodiscard]] pointer operator->() const noexcept {
-        return &*it;
-    }
+#ifdef ENTT_DISABLE_ASSERT
+#    undef ENTT_ASSERT_CONSTEXPR
+#    define ENTT_ASSERT_CONSTEXPR(condition, msg) (void(0))
+#elif !defined ENTT_ASSERT_CONSTEXPR
+#    define ENTT_ASSERT_CONSTEXPR(condition, msg) ENTT_ASSERT(condition, msg)
+#endif
 
-    [[nodiscard]] reference operator*() const noexcept {
-        return *operator->();
-    }
+#define ENTT_FAIL(msg) ENTT_ASSERT(false, msg);
 
-    template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
-    friend constexpr bool operator==(const view_iterator<LhsType, LhsArgs...> &, const view_iterator<RhsType, RhsArgs...> &) noexcept;
+#ifdef ENTT_NO_ETO
+#    define ENTT_ETO_TYPE(Type) void
+#else
+#    define ENTT_ETO_TYPE(Type) Type
+#endif
 
-private:
-    iterator_type it;
-    iterator_type last;
-    std::array<const Type *, Get> pools;
-    std::array<const Type *, Exclude> filter;
-    std::size_t index;
-};
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
 
-template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
-[[nodiscard]] constexpr bool operator==(const view_iterator<LhsType, LhsArgs...> &lhs, const view_iterator<RhsType, RhsArgs...> &rhs) noexcept {
-    return lhs.it == rhs.it;
-}
+#ifdef ENTT_STANDARD_CPP
+#    define ENTT_NONSTD false
+#else
+#    define ENTT_NONSTD true
+#    if defined __clang__ || defined __GNUC__
+#        define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
+#        define ENTT_PRETTY_FUNCTION_PREFIX '='
+#        define ENTT_PRETTY_FUNCTION_SUFFIX ']'
+#    elif defined _MSC_VER
+#        define ENTT_PRETTY_FUNCTION __FUNCSIG__
+#        define ENTT_PRETTY_FUNCTION_PREFIX '<'
+#        define ENTT_PRETTY_FUNCTION_SUFFIX '>'
+#    endif
+#endif
 
-template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
-[[nodiscard]] constexpr bool operator!=(const view_iterator<LhsType, LhsArgs...> &lhs, const view_iterator<RhsType, RhsArgs...> &rhs) noexcept {
-    return !(lhs == rhs);
-}
+#if defined _MSC_VER
+#    pragma detect_mismatch("entt.version", ENTT_VERSION)
+#    pragma detect_mismatch("entt.noexcept", ENTT_XSTR(ENTT_TRY))
+#    pragma detect_mismatch("entt.id", ENTT_XSTR(ENTT_ID_TYPE))
+#    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
+#endif
 
-template<typename It, typename... Type>
-struct extended_view_iterator final {
-    using iterator_type = It;
-    using difference_type = std::ptrdiff_t;
-    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Type>().get_as_tuple({})...));
-    using pointer = input_iterator_pointer<value_type>;
-    using reference = value_type;
-    using iterator_category = std::input_iterator_tag;
-    using iterator_concept = std::forward_iterator_tag;
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-    constexpr extended_view_iterator()
-        : it{},
-          pools{} {}
+#endif
 
-    extended_view_iterator(iterator_type from, std::tuple<Type *...> value)
-        : it{from},
-          pools{value} {}
+// #include "fwd.hpp"
+#ifndef ENTT_CORE_FWD_HPP
+#define ENTT_CORE_FWD_HPP
 
-    extended_view_iterator &operator++() noexcept {
-        return ++it, *this;
-    }
+#include <cstddef>
+// #include "../config/config.h"
 
-    extended_view_iterator operator++(int) noexcept {
-        extended_view_iterator orig = *this;
-        return ++(*this), orig;
-    }
 
-    [[nodiscard]] reference operator*() const noexcept {
-        return std::apply([entt = *it](auto *...curr) { return std::tuple_cat(std::make_tuple(entt), curr->get_as_tuple(entt)...); }, pools);
-    }
+namespace entt {
 
-    [[nodiscard]] pointer operator->() const noexcept {
-        return operator*();
-    }
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
+class basic_any;
 
-    [[nodiscard]] constexpr iterator_type base() const noexcept {
-        return it;
-    }
+/*! @brief Alias declaration for type identifiers. */
+using id_type = ENTT_ID_TYPE;
 
-    template<typename... Lhs, typename... Rhs>
-    friend bool constexpr operator==(const extended_view_iterator<Lhs...> &, const extended_view_iterator<Rhs...> &) noexcept;
+/*! @brief Alias declaration for the most common use case. */
+using any = basic_any<>;
 
-private:
-    It it;
-    std::tuple<Type *...> pools;
-};
+template<typename, typename>
+class compressed_pair;
 
-template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator==(const extended_view_iterator<Lhs...> &lhs, const extended_view_iterator<Rhs...> &rhs) noexcept {
-    return lhs.it == rhs.it;
-}
+template<typename>
+class basic_hashed_string;
 
-template<typename... Lhs, typename... Rhs>
-[[nodiscard]] constexpr bool operator!=(const extended_view_iterator<Lhs...> &lhs, const extended_view_iterator<Rhs...> &rhs) noexcept {
-    return !(lhs == rhs);
-}
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
 
-} // namespace internal
-/*! @endcond */
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
 
-/**
- * @brief View implementation.
- *
- * Primary template isn't defined on purpose. All the specializations give a
- * compile-time error, but for a few reasonable cases.
- *
- * @b Important
- *
- * View iterators aren't invalidated if:
- *
- * * New elements are added to the storage iterated by the view.
- * * The entity currently returned is modified (for example, components are
- *   added or removed from it).
- * * The entity currently returned is destroyed.
- *
- * In all other cases, modifying the storage iterated by a view in any way can
- * invalidate all iterators.
- */
-template<typename, typename, typename>
-class basic_view;
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
 
-/**
- * @brief Basic storage view implementation.
- * @warning For internal use only, backward compatibility not guaranteed.
- * @tparam Type Common type among all storage types.
- * @tparam Get Number of storage iterated by the view.
- * @tparam Exclude Number of storage used to filter the view.
- */
-template<typename Type, std::size_t Get, std::size_t Exclude>
-class basic_common_view {
-    template<typename Return, typename View, typename Other, std::size_t... VGet, std::size_t... VExclude, std::size_t... OGet, std::size_t... OExclude>
-    friend Return internal::view_pack(const View &, const Other &, std::index_sequence<VGet...>, std::index_sequence<VExclude...>, std::index_sequence<OGet...>, std::index_sequence<OExclude...>);
+} // namespace entt
 
-protected:
-    /*! @cond TURN_OFF_DOXYGEN */
-    basic_common_view() noexcept = default;
+#endif
 
-    basic_common_view(std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl) noexcept
-        : pools{value},
-          filter{excl},
-          leading{},
-          index{Get} {
-        unchecked_refresh();
-    }
 
-    void use(const std::size_t pos) noexcept {
-        if(leading) {
-            index = pos;
-            leading = pools[index];
-        }
-    }
+namespace entt {
 
-    void unchecked_refresh() noexcept {
-        index = 0u;
+/**
+ * @brief Utility class to disambiguate overloaded functions.
+ * @tparam N Number of choices available.
+ */
+template<std::size_t N>
+struct choice_t
+    // unfortunately, doxygen cannot parse such a construct
+    : /*! @cond TURN_OFF_DOXYGEN */ choice_t<N - 1> /*! @endcond */
+{};
 
-        for(size_type pos{1u}; pos < Get; ++pos) {
-            if(pools[pos]->size() < pools[index]->size()) {
-                index = pos;
-            }
-        }
+/*! @copybrief choice_t */
+template<>
+struct choice_t<0> {};
+
+/**
+ * @brief Variable template for the choice trick.
+ * @tparam N Number of choices available.
+ */
+template<std::size_t N>
+inline constexpr choice_t<N> choice{};
 
-        leading = pools[index];
-    }
-    /*! @endcond */
+/**
+ * @brief Identity type trait.
+ *
+ * Useful to establish non-deduced contexts in template argument deduction
+ * (waiting for C++20) or to provide types through function arguments.
+ *
+ * @tparam Type A type.
+ */
+template<typename Type>
+struct type_identity {
+    /*! @brief Identity type. */
+    using type = Type;
+};
 
-public:
-    /*! @brief Common type among all storage types. */
-    using common_type = Type;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename Type::entity_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Bidirectional iterator type. */
-    using iterator = internal::view_iterator<common_type, Get, Exclude>;
+/**
+ * @brief Helper type.
+ * @tparam Type A type.
+ */
+template<typename Type>
+using type_identity_t = typename type_identity<Type>::type;
 
-    /*! @brief Updates the internal leading view if required. */
-    void refresh() noexcept {
-        size_type pos = (leading != nullptr) * Get;
-        for(; pos < Get && pools[pos] != nullptr; ++pos) {}
+/**
+ * @brief A type-only `sizeof` wrapper that returns 0 where `sizeof` complains.
+ * @tparam Type The type of which to return the size.
+ */
+template<typename Type, typename = void>
+struct size_of: std::integral_constant<std::size_t, 0u> {};
 
-        if(pos == Get) {
-            unchecked_refresh();
-        }
-    }
+/*! @copydoc size_of */
+template<typename Type>
+struct size_of<Type, std::void_t<decltype(sizeof(Type))>>
+    : std::integral_constant<std::size_t, sizeof(Type)> {};
 
-    /**
-     * @brief Returns the leading storage of a view, if any.
-     * @return The leading storage of the view.
-     */
-    [[nodiscard]] const common_type *handle() const noexcept {
-        return leading;
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type of which to return the size.
+ */
+template<typename Type>
+inline constexpr std::size_t size_of_v = size_of<Type>::value;
 
-    /**
-     * @brief Estimates the number of entities iterated by the view.
-     * @return Estimated number of entities iterated by the view.
-     */
-    [[nodiscard]] size_type size_hint() const noexcept {
-        return leading ? leading->size() : size_type{};
-    }
+/**
+ * @brief Using declaration to be used to _repeat_ the same type a number of
+ * times equal to the size of a given parameter pack.
+ * @tparam Type A type to repeat.
+ */
+template<typename Type, typename>
+using unpack_as_type = Type;
 
-    /**
-     * @brief Returns an iterator to the first entity of the view.
-     *
-     * If the view is empty, the returned iterator will be equal to `end()`.
-     *
-     * @return An iterator to the first entity of the view.
-     */
-    [[nodiscard]] iterator begin() const noexcept {
-        return leading ? iterator{leading->begin(0), leading->end(0), pools, filter, index} : iterator{};
-    }
+/**
+ * @brief Helper variable template to be used to _repeat_ the same value a
+ * number of times equal to the size of a given parameter pack.
+ * @tparam Value A value to repeat.
+ */
+template<auto Value, typename>
+inline constexpr auto unpack_as_value = Value;
 
-    /**
-     * @brief Returns an iterator that is past the last entity of the view.
-     * @return An iterator to the entity following the last entity of the view.
-     */
-    [[nodiscard]] iterator end() const noexcept {
-        return leading ? iterator{leading->end(0), leading->end(0), pools, filter, index} : iterator{};
-    }
+/**
+ * @brief Wraps a static constant.
+ * @tparam Value A static constant.
+ */
+template<auto Value>
+using integral_constant = std::integral_constant<decltype(Value), Value>;
 
-    /**
-     * @brief Returns the first entity of the view, if any.
-     * @return The first entity of the view if one exists, the null entity
-     * otherwise.
-     */
-    [[nodiscard]] entity_type front() const noexcept {
-        const auto it = begin();
-        return it != end() ? *it : null;
-    }
+/**
+ * @brief Alias template to facilitate the creation of named values.
+ * @tparam Value A constant value at least convertible to `id_type`.
+ */
+template<id_type Value>
+using tag = integral_constant<Value>;
 
-    /**
-     * @brief Returns the last entity of the view, if any.
-     * @return The last entity of the view if one exists, the null entity
-     * otherwise.
-     */
-    [[nodiscard]] entity_type back() const noexcept {
-        if(leading) {
-            auto it = leading->rbegin(0);
-            const auto last = leading->rend(0);
-            for(; it != last && !contains(*it); ++it) {}
-            return it == last ? null : *it;
-        }
+/**
+ * @brief A class to use to push around lists of types, nothing more.
+ * @tparam Type Types provided by the type list.
+ */
+template<typename... Type>
+struct type_list {
+    /*! @brief Type list type. */
+    using type = type_list;
+    /*! @brief Compile-time number of elements in the type list. */
+    static constexpr auto size = sizeof...(Type);
+};
 
-        return null;
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<std::size_t, typename>
+struct type_list_element;
 
-    /**
-     * @brief Finds an entity.
-     * @param entt A valid identifier.
-     * @return An iterator to the given entity if it's found, past the end
-     * iterator otherwise.
-     */
-    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        return contains(entt) ? iterator{leading->find(entt), leading->end(), pools, filter, index} : end();
-    }
+/**
+ * @brief Provides compile-time indexed access to the types of a type list.
+ * @tparam Index Index of the type to return.
+ * @tparam First First type provided by the type list.
+ * @tparam Other Other types provided by the type list.
+ */
+template<std::size_t Index, typename First, typename... Other>
+struct type_list_element<Index, type_list<First, Other...>>
+    : type_list_element<Index - 1u, type_list<Other...>> {};
 
-    /**
-     * @brief Checks if a view is fully initialized.
-     * @return True if the view is fully initialized, false otherwise.
-     */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return leading && internal::fully_initialized(filter.data(), Exclude);
-    }
+/**
+ * @brief Provides compile-time indexed access to the types of a type list.
+ * @tparam First First type provided by the type list.
+ * @tparam Other Other types provided by the type list.
+ */
+template<typename First, typename... Other>
+struct type_list_element<0u, type_list<First, Other...>> {
+    /*! @brief Searched type. */
+    using type = First;
+};
 
-    /**
-     * @brief Checks if a view contains an entity.
-     * @param entt A valid identifier.
-     * @return True if the view contains the given entity, false otherwise.
-     */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        if(leading) {
-            const auto idx = leading->find(entt).index();
-            return (!(idx < 0 || idx > leading->begin(0).index())) && internal::all_of_but(index, pools.data(), Get, entt) && internal::none_of(filter.data(), Exclude, entt);
-        }
+/**
+ * @brief Helper type.
+ * @tparam Index Index of the type to return.
+ * @tparam List Type list to search into.
+ */
+template<std::size_t Index, typename List>
+using type_list_element_t = typename type_list_element<Index, List>::type;
 
-        return false;
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename, typename>
+struct type_list_index;
 
-protected:
-    /*! @cond TURN_OFF_DOXYGEN */
-    std::array<const common_type *, Get> pools{};
-    std::array<const common_type *, Exclude> filter{};
-    const common_type *leading{};
-    size_type index{Get};
-    /*! @endcond */
+/**
+ * @brief Provides compile-time type access to the types of a type list.
+ * @tparam Type Type to look for and for which to return the index.
+ * @tparam First First type provided by the type list.
+ * @tparam Other Other types provided by the type list.
+ */
+template<typename Type, typename First, typename... Other>
+struct type_list_index<Type, type_list<First, Other...>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 1u + type_list_index<Type, type_list<Other...>>::value;
 };
 
 /**
- * @brief General purpose view.
- *
- * This view visits all entities that are at least in the given storage. During
- * initialization, it also looks at the number of elements available for each
- * storage and uses the smallest set in order to get a performance boost.
- *
- * @sa basic_view
- *
- * @tparam Get Types of storage iterated by the view.
- * @tparam Exclude Types of storage used to filter the view.
+ * @brief Provides compile-time type access to the types of a type list.
+ * @tparam Type Type to look for and for which to return the index.
+ * @tparam Other Other types provided by the type list.
  */
-template<typename... Get, typename... Exclude>
-class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)> {
-    using base_type = basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)>;
+template<typename Type, typename... Other>
+struct type_list_index<Type, type_list<Type, Other...>> {
+    static_assert(type_list_index<Type, type_list<Other...>>::value == sizeof...(Other), "Non-unique type");
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    template<typename Type>
-    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::value_type..., typename Exclude::value_type...>>;
+/**
+ * @brief Provides compile-time type access to the types of a type list.
+ * @tparam Type Type to look for and for which to return the index.
+ */
+template<typename Type>
+struct type_list_index<Type, type_list<>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    template<std::size_t... Index>
-    auto storage(std::index_sequence<Index...>) const noexcept {
-        return std::make_tuple(storage<Index>()...);
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam List Type list.
+ * @tparam Type Type to look for and for which to return the index.
+ */
+template<typename Type, typename List>
+inline constexpr std::size_t type_list_index_v = type_list_index<Type, List>::value;
 
-    template<std::size_t Curr, std::size_t Other, typename... Args>
-    [[nodiscard]] auto dispatch_get(const std::tuple<typename base_type::entity_type, Args...> &curr) const {
-        if constexpr(Curr == Other) {
-            return std::forward_as_tuple(std::get<Args>(curr)...);
-        } else {
-            return storage<Other>()->get_as_tuple(std::get<0>(curr));
-        }
-    }
+/**
+ * @brief Concatenates multiple type lists.
+ * @tparam Type Types provided by the first type list.
+ * @tparam Other Types provided by the second type list.
+ * @return A type list composed by the types of both the type lists.
+ */
+template<typename... Type, typename... Other>
+constexpr type_list<Type..., Other...> operator+(type_list<Type...>, type_list<Other...>) {
+    return {};
+}
 
-    template<std::size_t Curr, typename Func, std::size_t... Index>
-    void each(Func &func, std::index_sequence<Index...>) const {
-        for(const auto curr: storage<Curr>()->each()) {
-            if(const auto entt = std::get<0>(curr); ((sizeof...(Get) != 1u) || (entt != tombstone)) && internal::all_of_but(this->index, this->pools.data(), sizeof...(Get), entt) && internal::none_of(this->filter.data(), sizeof...(Exclude), entt)) {
-                if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_view>().get({})))>) {
-                    std::apply(func, std::tuple_cat(std::make_tuple(entt), dispatch_get<Curr, Index>(curr)...));
-                } else {
-                    std::apply(func, std::tuple_cat(dispatch_get<Curr, Index>(curr)...));
-                }
-            }
-        }
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct type_list_cat;
 
-    template<typename Func, std::size_t... Index>
-    void pick_and_each(Func &func, std::index_sequence<Index...> seq) const {
-        ((storage<Index>() == base_type::handle() ? each<Index>(func, seq) : void()), ...);
-    }
+/*! @brief Concatenates multiple type lists. */
+template<>
+struct type_list_cat<> {
+    /*! @brief A type list composed by the types of all the type lists. */
+    using type = type_list<>;
+};
 
-public:
-    /*! @brief Common type among all storage types. */
-    using common_type = typename base_type::common_type;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename base_type::entity_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = typename base_type::size_type;
-    /*! @brief Bidirectional iterator type. */
-    using iterator = typename base_type::iterator;
-    /*! @brief Iterable view type. */
-    using iterable = iterable_adaptor<internal::extended_view_iterator<iterator, Get...>>;
+/**
+ * @brief Concatenates multiple type lists.
+ * @tparam Type Types provided by the first type list.
+ * @tparam Other Types provided by the second type list.
+ * @tparam List Other type lists, if any.
+ */
+template<typename... Type, typename... Other, typename... List>
+struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
+    /*! @brief A type list composed by the types of all the type lists. */
+    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
+};
 
-    /*! @brief Default constructor to use to create empty, invalid views. */
-    basic_view() noexcept
-        : base_type{} {}
+/**
+ * @brief Concatenates multiple type lists.
+ * @tparam Type Types provided by the type list.
+ */
+template<typename... Type>
+struct type_list_cat<type_list<Type...>> {
+    /*! @brief A type list composed by the types of all the type lists. */
+    using type = type_list<Type...>;
+};
 
-    /**
-     * @brief Constructs a view from a set of storage classes.
-     * @param value The storage for the types to iterate.
-     * @param excl The storage for the types used to filter the view.
-     */
-    basic_view(Get &...value, Exclude &...excl) noexcept
-        : base_type{{&value...}, {&excl...}} {
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Type lists to concatenate.
+ */
+template<typename... List>
+using type_list_cat_t = typename type_list_cat<List...>::type;
 
-    /**
-     * @brief Constructs a view from a set of storage classes.
-     * @param value The storage for the types to iterate.
-     * @param excl The storage for the types used to filter the view.
-     */
-    basic_view(std::tuple<Get &...> value, std::tuple<Exclude &...> excl = {}) noexcept
-        : basic_view{std::make_from_tuple<basic_view>(std::tuple_cat(value, excl))} {}
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-    /**
-     * @brief Forces a view to use a given component to drive iterations
-     * @tparam Type Type of component to use to drive iterations.
-     */
-    template<typename Type>
-    void use() noexcept {
-        use<index_of<Type>>();
-    }
+template<typename...>
+struct type_list_unique;
 
-    /**
-     * @brief Forces a view to use a given component to drive iterations
-     * @tparam Index Index of the component to use to drive iterations.
-     */
-    template<std::size_t Index>
-    void use() noexcept {
-        base_type::use(Index);
-    }
+template<typename First, typename... Other, typename... Type>
+struct type_list_unique<type_list<First, Other...>, Type...>
+    : std::conditional_t<(std::is_same_v<First, Type> || ...), type_list_unique<type_list<Other...>, Type...>, type_list_unique<type_list<Other...>, Type..., First>> {};
 
-    /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
-     */
-    template<typename Type>
-    [[nodiscard]] auto *storage() const noexcept {
-        return storage<index_of<Type>>();
-    }
+template<typename... Type>
+struct type_list_unique<type_list<>, Type...> {
+    using type = type_list<Type...>;
+};
 
-    /**
-     * @brief Returns the storage for a given index, if any.
-     * @tparam Index Index of the storage to return.
-     * @return The storage for the given index.
-     */
-    template<std::size_t Index>
-    [[nodiscard]] auto *storage() const noexcept {
-        using type = type_list_element_t<Index, type_list<Get..., Exclude...>>;
+} // namespace internal
+/*! @endcond */
 
-        if constexpr(Index < sizeof...(Get)) {
-            return static_cast<type *>(const_cast<constness_as_t<common_type, type> *>(this->pools[Index]));
-        } else {
-            return static_cast<type *>(const_cast<constness_as_t<common_type, type> *>(this->filter[Index - sizeof...(Get)]));
-        }
-    }
+/**
+ * @brief Removes duplicates types from a type list.
+ * @tparam List Type list.
+ */
+template<typename List>
+struct type_list_unique {
+    /*! @brief A type list without duplicate types. */
+    using type = typename internal::type_list_unique<List>::type;
+};
 
-    /**
-     * @brief Assigns a storage to a view.
-     * @tparam Type Type of storage to assign to the view.
-     * @param elem A storage to assign to the view.
-     */
-    template<typename Type>
-    void storage(Type &elem) noexcept {
-        storage<index_of<typename Type::value_type>>(elem);
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Type list.
+ */
+template<typename List>
+using type_list_unique_t = typename type_list_unique<List>::type;
 
-    /**
-     * @brief Assigns a storage to a view.
-     * @tparam Index Index of the storage to assign to the view.
-     * @tparam Type Type of storage to assign to the view.
-     * @param elem A storage to assign to the view.
-     */
-    template<std::size_t Index, typename Type>
-    void storage(Type &elem) noexcept {
-        static_assert(std::is_convertible_v<Type &, type_list_element_t<Index, type_list<Get..., Exclude...>> &>, "Unexpected type");
+/**
+ * @brief Provides the member constant `value` to true if a type list contains a
+ * given type, false otherwise.
+ * @tparam List Type list.
+ * @tparam Type Type to look for.
+ */
+template<typename List, typename Type>
+struct type_list_contains;
 
-        if constexpr(Index < sizeof...(Get)) {
-            this->pools[Index] = &elem;
-            base_type::refresh();
-        } else {
-            this->filter[Index - sizeof...(Get)] = &elem;
-        }
-    }
+/**
+ * @copybrief type_list_contains
+ * @tparam Type Types provided by the type list.
+ * @tparam Other Type to look for.
+ */
+template<typename... Type, typename Other>
+struct type_list_contains<type_list<Type...>, Other>
+    : std::bool_constant<(std::is_same_v<Type, Other> || ...)> {};
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @param entt A valid identifier.
-     * @return The components assigned to the given entity.
-     */
-    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
-        return get(entt);
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam List Type list.
+ * @tparam Type Type to look for.
+ */
+template<typename List, typename Type>
+inline constexpr bool type_list_contains_v = type_list_contains<List, Type>::value;
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Type Type of the component to get.
-     * @tparam Other Other types of components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<typename Type, typename... Other>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        return get<index_of<Type>, index_of<Other>...>(entt);
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct type_list_diff;
 
-    /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Index Indexes of the components to get.
-     * @param entt A valid identifier.
-     * @return The components assigned to the entity.
-     */
-    template<std::size_t... Index>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        if constexpr(sizeof...(Index) == 0) {
-            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, storage(std::index_sequence_for<Get...>{}));
-        } else if constexpr(sizeof...(Index) == 1) {
-            return (storage<Index>()->get(entt), ...);
-        } else {
-            return std::tuple_cat(storage<Index>()->get_as_tuple(entt)...);
-        }
-    }
+/**
+ * @brief Computes the difference between two type lists.
+ * @tparam Type Types provided by the first type list.
+ * @tparam Other Types provided by the second type list.
+ */
+template<typename... Type, typename... Other>
+struct type_list_diff<type_list<Type...>, type_list<Other...>> {
+    /*! @brief A type list that is the difference between the two type lists. */
+    using type = type_list_cat_t<std::conditional_t<type_list_contains_v<type_list<Other...>, Type>, type_list<>, type_list<Type>>...>;
+};
 
-    /**
-     * @brief Iterates entities and components and applies the given function
-     * object to them.
-     *
-     * The signature of the function must be equivalent to one of the following
-     * (non-empty types only, constness as requested):
-     *
-     * @code{.cpp}
-     * void(const entity_type, Type &...);
-     * void(Type &...);
-     * @endcode
-     *
-     * @tparam Func Type of the function object to invoke.
-     * @param func A valid function object.
-     */
-    template<typename Func>
-    void each(Func func) const {
-        if(base_type::handle() != nullptr) {
-            pick_and_each(func, std::index_sequence_for<Get...>{});
-        }
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Type lists between which to compute the difference.
+ */
+template<typename... List>
+using type_list_diff_t = typename type_list_diff<List...>::type;
 
-    /**
-     * @brief Returns an iterable object to use to _visit_ a view.
-     *
-     * The iterable object returns a tuple that contains the current entity and
-     * a set of references to its non-empty components. The _constness_ of the
-     * components is as requested.
-     *
-     * @return An iterable object to use to _visit_ the view.
-     */
-    [[nodiscard]] iterable each() const noexcept {
-        const auto as_pools = storage(std::index_sequence_for<Get...>{});
-        return {internal::extended_view_iterator{base_type::begin(), as_pools}, internal::extended_view_iterator{base_type::end(), as_pools}};
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename, template<typename...> class>
+struct type_list_transform;
 
-    /**
-     * @brief Combines two views in a _more specific_ one.
-     * @tparam OGet Component list of the view to combine with.
-     * @tparam OExclude Filter list of the view to combine with.
-     * @param other The view to combine with.
-     * @return A more specific view.
-     */
-    template<typename... OGet, typename... OExclude>
-    [[nodiscard]] auto operator|(const basic_view<get_t<OGet...>, exclude_t<OExclude...>> &other) const noexcept {
-        return internal::view_pack<basic_view<get_t<Get..., OGet...>, exclude_t<Exclude..., OExclude...>>>(
-            *this, other, std::index_sequence_for<Get...>{}, std::index_sequence_for<Exclude...>{}, std::index_sequence_for<OGet...>{}, std::index_sequence_for<OExclude...>{});
-    }
+/**
+ * @brief Applies a given _function_ to a type list and generate a new list.
+ * @tparam Type Types provided by the type list.
+ * @tparam Op Unary operation as template class with a type member named `type`.
+ */
+template<typename... Type, template<typename...> class Op>
+struct type_list_transform<type_list<Type...>, Op> {
+    /*! @brief Resulting type list after applying the transform function. */
+    using type = type_list<typename Op<Type>::type...>;
 };
 
 /**
- * @brief Basic storage view implementation.
- * @warning For internal use only, backward compatibility not guaranteed.
- * @tparam Type Common type among all storage types.
+ * @brief Helper type.
+ * @tparam List Type list.
+ * @tparam Op Unary operation as template class with a type member named `type`.
  */
-template<typename Type>
-class basic_storage_view {
-protected:
-    /*! @cond TURN_OFF_DOXYGEN */
-    basic_storage_view() noexcept = default;
-
-    basic_storage_view(const Type *value) noexcept
-        : leading{value} {}
-    /*! @endcond */
+template<typename List, template<typename...> class Op>
+using type_list_transform_t = typename type_list_transform<List, Op>::type;
 
-public:
-    /*! @brief Common type among all storage types. */
-    using common_type = Type;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename common_type::entity_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = std::size_t;
-    /*! @brief Random access iterator type. */
-    using iterator = typename common_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename common_type::reverse_iterator;
+/**
+ * @brief A class to use to push around lists of constant values, nothing more.
+ * @tparam Value Values provided by the value list.
+ */
+template<auto... Value>
+struct value_list {
+    /*! @brief Value list type. */
+    using type = value_list;
+    /*! @brief Compile-time number of elements in the value list. */
+    static constexpr auto size = sizeof...(Value);
+};
 
-    /**
-     * @brief Returns the leading storage of a view, if any.
-     * @return The leading storage of the view.
-     */
-    [[nodiscard]] const common_type *handle() const noexcept {
-        return leading;
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<std::size_t, typename>
+struct value_list_element;
 
-    /**
-     * @brief Returns the number of entities that have the given component.
-     * @return Number of entities that have the given component.
-     */
-    [[nodiscard]] size_type size() const noexcept {
-        return leading ? leading->size() : size_type{};
-    }
+/**
+ * @brief Provides compile-time indexed access to the values of a value list.
+ * @tparam Index Index of the value to return.
+ * @tparam Value First value provided by the value list.
+ * @tparam Other Other values provided by the value list.
+ */
+template<std::size_t Index, auto Value, auto... Other>
+struct value_list_element<Index, value_list<Value, Other...>>
+    : value_list_element<Index - 1u, value_list<Other...>> {};
 
-    /**
-     * @brief Checks whether a view is empty.
-     * @return True if the view is empty, false otherwise.
-     */
-    [[nodiscard]] bool empty() const noexcept {
-        return !leading || leading->empty();
-    }
+/**
+ * @brief Provides compile-time indexed access to the types of a type list.
+ * @tparam Value First value provided by the value list.
+ * @tparam Other Other values provided by the value list.
+ */
+template<auto Value, auto... Other>
+struct value_list_element<0u, value_list<Value, Other...>> {
+    /*! @brief Searched type. */
+    using type = decltype(Value);
+    /*! @brief Searched value. */
+    static constexpr auto value = Value;
+};
 
-    /**
-     * @brief Returns an iterator to the first entity of the view.
-     *
-     * If the view is empty, the returned iterator will be equal to `end()`.
-     *
-     * @return An iterator to the first entity of the view.
-     */
-    [[nodiscard]] iterator begin() const noexcept {
-        return leading ? leading->begin() : iterator{};
-    }
+/**
+ * @brief Helper type.
+ * @tparam Index Index of the type to return.
+ * @tparam List Value list to search into.
+ */
+template<std::size_t Index, typename List>
+using value_list_element_t = typename value_list_element<Index, List>::type;
 
-    /**
-     * @brief Returns an iterator that is past the last entity of the view.
-     * @return An iterator to the entity following the last entity of the view.
-     */
-    [[nodiscard]] iterator end() const noexcept {
-        return leading ? leading->end() : iterator{};
-    }
+/**
+ * @brief Helper type.
+ * @tparam Index Index of the value to return.
+ * @tparam List Value list to search into.
+ */
+template<std::size_t Index, typename List>
+inline constexpr auto value_list_element_v = value_list_element<Index, List>::value;
 
-    /**
-     * @brief Returns an iterator to the first entity of the reversed view.
-     *
-     * If the view is empty, the returned iterator will be equal to `rend()`.
-     *
-     * @return An iterator to the first entity of the reversed view.
-     */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
-        return leading ? leading->rbegin() : reverse_iterator{};
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<auto, typename>
+struct value_list_index;
 
-    /**
-     * @brief Returns an iterator that is past the last entity of the reversed
-     * view.
-     * @return An iterator to the entity following the last entity of the
-     * reversed view.
-     */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return leading ? leading->rend() : reverse_iterator{};
-    }
+/**
+ * @brief Provides compile-time type access to the values of a value list.
+ * @tparam Value Value to look for and for which to return the index.
+ * @tparam First First value provided by the value list.
+ * @tparam Other Other values provided by the value list.
+ */
+template<auto Value, auto First, auto... Other>
+struct value_list_index<Value, value_list<First, Other...>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given value in the sublist. */
+    static constexpr value_type value = 1u + value_list_index<Value, value_list<Other...>>::value;
+};
 
-    /**
-     * @brief Returns the first entity of the view, if any.
-     * @return The first entity of the view if one exists, the null entity
-     * otherwise.
-     */
-    [[nodiscard]] entity_type front() const noexcept {
-        return empty() ? null : *leading->begin();
-    }
+/**
+ * @brief Provides compile-time type access to the values of a value list.
+ * @tparam Value Value to look for and for which to return the index.
+ * @tparam Other Other values provided by the value list.
+ */
+template<auto Value, auto... Other>
+struct value_list_index<Value, value_list<Value, Other...>> {
+    static_assert(value_list_index<Value, value_list<Other...>>::value == sizeof...(Other), "Non-unique type");
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given value in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    /**
-     * @brief Returns the last entity of the view, if any.
-     * @return The last entity of the view if one exists, the null entity
-     * otherwise.
-     */
-    [[nodiscard]] entity_type back() const noexcept {
-        return empty() ? null : *leading->rbegin();
-    }
+/**
+ * @brief Provides compile-time type access to the values of a value list.
+ * @tparam Value Value to look for and for which to return the index.
+ */
+template<auto Value>
+struct value_list_index<Value, value_list<>> {
+    /*! @brief Unsigned integer type. */
+    using value_type = std::size_t;
+    /*! @brief Compile-time position of the given type in the sublist. */
+    static constexpr value_type value = 0u;
+};
 
-    /**
-     * @brief Finds an entity.
-     * @param entt A valid identifier.
-     * @return An iterator to the given entity if it's found, past the end
-     * iterator otherwise.
-     */
-    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        return leading ? leading->find(entt) : iterator{};
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam List Value list.
+ * @tparam Value Value to look for and for which to return the index.
+ */
+template<auto Value, typename List>
+inline constexpr std::size_t value_list_index_v = value_list_index<Value, List>::value;
 
-    /**
-     * @brief Checks if a view is fully initialized.
-     * @return True if the view is fully initialized, false otherwise.
-     */
-    [[nodiscard]] explicit operator bool() const noexcept {
-        return (leading != nullptr);
-    }
+/**
+ * @brief Concatenates multiple value lists.
+ * @tparam Value Values provided by the first value list.
+ * @tparam Other Values provided by the second value list.
+ * @return A value list composed by the values of both the value lists.
+ */
+template<auto... Value, auto... Other>
+constexpr value_list<Value..., Other...> operator+(value_list<Value...>, value_list<Other...>) {
+    return {};
+}
 
-    /**
-     * @brief Checks if a view contains an entity.
-     * @param entt A valid identifier.
-     * @return True if the view contains the given entity, false otherwise.
-     */
-    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        return leading && leading->contains(entt);
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct value_list_cat;
 
-protected:
-    /*! @cond TURN_OFF_DOXYGEN */
-    const common_type *leading{};
-    /*! @endcond */
+/*! @brief Concatenates multiple value lists. */
+template<>
+struct value_list_cat<> {
+    /*! @brief A value list composed by the values of all the value lists. */
+    using type = value_list<>;
 };
 
 /**
- * @brief Storage view specialization.
- *
- * This specialization offers a boost in terms of performance. It can access the
- * underlying data structure directly and avoid superfluous checks.
- *
- * @sa basic_view
- *
- * @tparam Get Type of storage iterated by the view.
+ * @brief Concatenates multiple value lists.
+ * @tparam Value Values provided by the first value list.
+ * @tparam Other Values provided by the second value list.
+ * @tparam List Other value lists, if any.
  */
-template<typename Get>
-class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::traits_type::in_place_delete>>>: public basic_storage_view<typename Get::base_type> {
-    using base_type = basic_storage_view<typename Get::base_type>;
-
-public:
-    /*! @brief Common type among all storage types. */
-    using common_type = typename base_type::common_type;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename base_type::entity_type;
-    /*! @brief Unsigned integer type. */
-    using size_type = typename base_type::size_type;
-    /*! @brief Random access iterator type. */
-    using iterator = typename base_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename base_type::reverse_iterator;
-    /*! @brief Iterable view type. */
-    using iterable = decltype(std::declval<Get>().each());
+template<auto... Value, auto... Other, typename... List>
+struct value_list_cat<value_list<Value...>, value_list<Other...>, List...> {
+    /*! @brief A value list composed by the values of all the value lists. */
+    using type = typename value_list_cat<value_list<Value..., Other...>, List...>::type;
+};
 
-    /*! @brief Default constructor to use to create empty, invalid views. */
-    basic_view() noexcept
-        : base_type{} {}
+/**
+ * @brief Concatenates multiple value lists.
+ * @tparam Value Values provided by the value list.
+ */
+template<auto... Value>
+struct value_list_cat<value_list<Value...>> {
+    /*! @brief A value list composed by the values of all the value lists. */
+    using type = value_list<Value...>;
+};
 
-    /**
-     * @brief Constructs a view from a storage class.
-     * @param value The storage for the type to iterate.
-     */
-    basic_view(Get &value) noexcept
-        : base_type{&value} {
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Value lists to concatenate.
+ */
+template<typename... List>
+using value_list_cat_t = typename value_list_cat<List...>::type;
 
-    /**
-     * @brief Constructs a view from a storage class.
-     * @param value The storage for the type to iterate.
-     */
-    basic_view(std::tuple<Get &> value, std::tuple<> = {}) noexcept
-        : basic_view{std::get<0>(value)} {}
+/*! @brief Primary template isn't defined on purpose. */
+template<typename>
+struct value_list_unique;
 
-    /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
-     */
-    template<typename Type = typename Get::value_type>
-    [[nodiscard]] auto *storage() const noexcept {
-        static_assert(std::is_same_v<std::remove_const_t<Type>, typename Get::value_type>, "Invalid component type");
-        return storage<0>();
-    }
+/**
+ * @brief Removes duplicates values from a value list.
+ * @tparam Value One of the values provided by the given value list.
+ * @tparam Other The other values provided by the given value list.
+ */
+template<auto Value, auto... Other>
+struct value_list_unique<value_list<Value, Other...>> {
+    /*! @brief A value list without duplicate types. */
+    using type = std::conditional_t<
+        ((Value == Other) || ...),
+        typename value_list_unique<value_list<Other...>>::type,
+        value_list_cat_t<value_list<Value>, typename value_list_unique<value_list<Other...>>::type>>;
+};
 
-    /**
-     * @brief Returns the storage for a given index, if any.
-     * @tparam Index Index of the storage to return.
-     * @return The storage for the given index.
-     */
-    template<std::size_t Index>
-    [[nodiscard]] auto *storage() const noexcept {
-        static_assert(Index == 0u, "Index out of bounds");
-        return static_cast<Get *>(const_cast<constness_as_t<common_type, Get> *>(this->leading));
-    }
+/*! @brief Removes duplicates values from a value list. */
+template<>
+struct value_list_unique<value_list<>> {
+    /*! @brief A value list without duplicate types. */
+    using type = value_list<>;
+};
 
-    /**
-     * @brief Assigns a storage to a view.
-     * @param elem A storage to assign to the view.
-     */
-    void storage(Get &elem) noexcept {
-        storage<0>(elem);
-    }
+/**
+ * @brief Helper type.
+ * @tparam Type A value list.
+ */
+template<typename Type>
+using value_list_unique_t = typename value_list_unique<Type>::type;
 
-    /**
-     * @brief Assigns a storage to a view.
-     * @tparam Index Index of the storage to assign to the view.
-     * @param elem A storage to assign to the view.
-     */
-    template<std::size_t Index>
-    void storage(Get &elem) noexcept {
-        static_assert(Index == 0u, "Index out of bounds");
-        this->leading = &elem;
-    }
+/**
+ * @brief Provides the member constant `value` to true if a value list contains
+ * a given value, false otherwise.
+ * @tparam List Value list.
+ * @tparam Value Value to look for.
+ */
+template<typename List, auto Value>
+struct value_list_contains;
 
-    /**
-     * @brief Returns the component assigned to the given entity.
-     * @param entt A valid identifier.
-     * @return The component assigned to the given entity.
-     */
-    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
-        return storage()->get(entt);
-    }
+/**
+ * @copybrief value_list_contains
+ * @tparam Value Values provided by the value list.
+ * @tparam Other Value to look for.
+ */
+template<auto... Value, auto Other>
+struct value_list_contains<value_list<Value...>, Other>
+    : std::bool_constant<((Value == Other) || ...)> {};
 
-    /**
-     * @brief Returns the identifier that occupies the given position.
-     * @param pos Position of the element to return.
-     * @return The identifier that occupies the given position.
-     */
-    [[deprecated("use .begin()[pos] instead")]] [[nodiscard]] entity_type operator[](const size_type pos) const {
-        return base_type::begin()[pos];
-    }
+/**
+ * @brief Helper variable template.
+ * @tparam List Value list.
+ * @tparam Value Value to look for.
+ */
+template<typename List, auto Value>
+inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::value;
 
-    /**
-     * @brief Returns the component assigned to the given entity.
-     * @tparam Elem Type of the component to get.
-     * @param entt A valid identifier.
-     * @return The component assigned to the entity.
-     */
-    template<typename Elem>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        static_assert(std::is_same_v<std::remove_const_t<Elem>, typename Get::value_type>, "Invalid component type");
-        return get<0>(entt);
-    }
+/*! @brief Primary template isn't defined on purpose. */
+template<typename...>
+struct value_list_diff;
 
-    /**
-     * @brief Returns the component assigned to the given entity.
-     * @tparam Index Index of the component to get.
-     * @param entt A valid identifier.
-     * @return The component assigned to the entity.
-     */
-    template<std::size_t... Index>
-    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        if constexpr(sizeof...(Index) == 0) {
-            return storage()->get_as_tuple(entt);
-        } else {
-            return storage<Index...>()->get(entt);
-        }
-    }
+/**
+ * @brief Computes the difference between two value lists.
+ * @tparam Value Values provided by the first value list.
+ * @tparam Other Values provided by the second value list.
+ */
+template<auto... Value, auto... Other>
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
+    /*! @brief A value list that is the difference between the two value lists. */
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
+};
 
-    /**
-     * @brief Iterates entities and components and applies the given function
-     * object to them.
-     *
-     * The signature of the function must be equivalent to one of the following
-     * (non-empty types only, constness as requested):
-     *
-     * @code{.cpp}
-     * void(const entity_type, Type &);
-     * void(typename Type &);
-     * @endcode
-     *
-     * @tparam Func Type of the function object to invoke.
-     * @param func A valid function object.
-     */
-    template<typename Func>
-    void each(Func func) const {
-        if(auto *elem = storage(); elem) {
-            if constexpr(is_applicable_v<Func, decltype(*elem->each().begin())>) {
-                for(const auto pack: elem->each()) {
-                    std::apply(func, pack);
-                }
-            } else if constexpr(std::is_invocable_v<Func, decltype(*elem->begin())>) {
-                for(auto &&component: *elem) {
-                    func(component);
-                }
-            } else {
-                for(size_type pos = elem->size(); pos; --pos) {
-                    func();
-                }
-            }
-        }
-    }
+/**
+ * @brief Helper type.
+ * @tparam List Value lists between which to compute the difference.
+ */
+template<typename... List>
+using value_list_diff_t = typename value_list_diff<List...>::type;
 
-    /**
-     * @brief Returns an iterable object to use to _visit_ a view.
-     *
-     * The iterable object returns a tuple that contains the current entity and
-     * a reference to its component if it's a non-empty one. The _constness_ of
-     * the component is as requested.
-     *
-     * @return An iterable object to use to _visit_ the view.
-     */
-    [[nodiscard]] iterable each() const noexcept {
-        auto *elem = storage();
-        return elem ? elem->each() : iterable{};
-    }
+/*! @brief Same as std::is_invocable, but with tuples. */
+template<typename, typename>
+struct is_applicable: std::false_type {};
 
-    /**
-     * @brief Combines two views in a _more specific_ one.
-     * @tparam OGet Component list of the view to combine with.
-     * @tparam OExclude Filter list of the view to combine with.
-     * @param other The view to combine with.
-     * @return A more specific view.
-     */
-    template<typename... OGet, typename... OExclude>
-    [[nodiscard]] auto operator|(const basic_view<get_t<OGet...>, exclude_t<OExclude...>> &other) const noexcept {
-        return internal::view_pack<basic_view<get_t<Get, OGet...>, exclude_t<OExclude...>>>(
-            *this, other, std::index_sequence_for<Get>{}, std::index_sequence_for<>{}, std::index_sequence_for<OGet...>{}, std::index_sequence_for<OExclude...>{});
-    }
-};
+/**
+ * @copybrief is_applicable
+ * @tparam Func A valid function type.
+ * @tparam Tuple Tuple-like type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Func, template<typename...> class Tuple, typename... Args>
+struct is_applicable<Func, Tuple<Args...>>: std::is_invocable<Func, Args...> {};
 
 /**
- * @brief Deduction guide.
- * @tparam Type Type of storage classes used to create the view.
- * @param storage The storage for the types to iterate.
+ * @copybrief is_applicable
+ * @tparam Func A valid function type.
+ * @tparam Tuple Tuple-like type.
+ * @tparam Args The list of arguments to use to probe the function type.
  */
-template<typename... Type>
-basic_view(Type &...storage) -> basic_view<get_t<Type...>, exclude_t<>>;
+template<typename Func, template<typename...> class Tuple, typename... Args>
+struct is_applicable<Func, const Tuple<Args...>>: std::is_invocable<Func, Args...> {};
 
 /**
- * @brief Deduction guide.
- * @tparam Get Types of components iterated by the view.
- * @tparam Exclude Types of components used to filter the view.
+ * @brief Helper variable template.
+ * @tparam Func A valid function type.
+ * @tparam Args The list of arguments to use to probe the function type.
  */
-template<typename... Get, typename... Exclude>
-basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<get_t<Get...>, exclude_t<Exclude...>>;
+template<typename Func, typename Args>
+inline constexpr bool is_applicable_v = is_applicable<Func, Args>::value;
 
-} // namespace entt
+/*! @brief Same as std::is_invocable_r, but with tuples for arguments. */
+template<typename, typename, typename>
+struct is_applicable_r: std::false_type {};
 
-#endif
+/**
+ * @copybrief is_applicable_r
+ * @tparam Ret The type to which the return type of the function should be
+ * convertible.
+ * @tparam Func A valid function type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Ret, typename Func, typename... Args>
+struct is_applicable_r<Ret, Func, std::tuple<Args...>>: std::is_invocable_r<Ret, Func, Args...> {};
 
+/**
+ * @brief Helper variable template.
+ * @tparam Ret The type to which the return type of the function should be
+ * convertible.
+ * @tparam Func A valid function type.
+ * @tparam Args The list of arguments to use to probe the function type.
+ */
+template<typename Ret, typename Func, typename Args>
+inline constexpr bool is_applicable_r_v = is_applicable_r<Ret, Func, Args>::value;
 
-namespace entt {
+/**
+ * @brief Provides the member constant `value` to true if a given type is
+ * complete, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type, typename = void>
+struct is_complete: std::false_type {};
+
+/*! @copydoc is_complete */
+template<typename Type>
+struct is_complete<Type, std::void_t<decltype(sizeof(Type))>>: std::true_type {};
 
 /**
- * @brief Converts a registry to a view.
- * @tparam Registry Basic registry type.
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
  */
-template<typename Registry>
-class as_view {
-    template<typename... Get, typename... Exclude>
-    auto dispatch(get_t<Get...>, exclude_t<Exclude...>) const {
-        return reg.template view<constness_as_t<typename Get::value_type, Get>...>(exclude_t<constness_as_t<typename Exclude::value_type, Exclude>...>{});
-    }
+template<typename Type>
+inline constexpr bool is_complete_v = is_complete<Type>::value;
 
-public:
-    /*! @brief Type of registry to convert. */
-    using registry_type = Registry;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename registry_type::entity_type;
+/**
+ * @brief Provides the member constant `value` to true if a given type is an
+ * iterator, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type, typename = void>
+struct is_iterator: std::false_type {};
 
-    /**
-     * @brief Constructs a converter for a given registry.
-     * @param source A valid reference to a registry.
-     */
-    as_view(registry_type &source) noexcept
-        : reg{source} {}
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
 
-    /**
-     * @brief Conversion function from a registry to a view.
-     * @tparam Get Type of storage used to construct the view.
-     * @tparam Exclude Types of storage used to filter the view.
-     * @return A newly created view.
-     */
-    template<typename Get, typename Exclude>
-    operator basic_view<Get, Exclude>() const {
-        return dispatch(Get{}, Exclude{});
-    }
+template<typename, typename = void>
+struct has_iterator_category: std::false_type {};
 
-private:
-    registry_type &reg;
-};
+template<typename Type>
+struct has_iterator_category<Type, std::void_t<typename std::iterator_traits<Type>::iterator_category>>: std::true_type {};
+
+} // namespace internal
+/*! @endcond */
+
+/*! @copydoc is_iterator */
+template<typename Type>
+struct is_iterator<Type, std::enable_if_t<!std::is_void_v<std::remove_cv_t<std::remove_pointer_t<Type>>>>>
+    : internal::has_iterator_category<Type> {};
 
 /**
- * @brief Converts a registry to a group.
- * @tparam Registry Basic registry type.
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
  */
-template<typename Registry>
-class as_group {
-    template<typename... Owned, typename... Get, typename... Exclude>
-    auto dispatch(owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>) const {
-        if constexpr(std::is_const_v<registry_type>) {
-            return reg.template group_if_exists<typename Owned::value_type...>(get_t<typename Get::value_type...>{}, exclude_t<typename Exclude::value_type...>{});
-        } else {
-            return reg.template group<constness_as_t<typename Owned::value_type, Owned>...>(get_t<constness_as_t<typename Get::value_type, Get>...>{}, exclude_t<constness_as_t<typename Exclude::value_type, Exclude>...>{});
-        }
-    }
+template<typename Type>
+inline constexpr bool is_iterator_v = is_iterator<Type>::value;
 
-public:
-    /*! @brief Type of registry to convert. */
-    using registry_type = Registry;
-    /*! @brief Underlying entity identifier. */
-    using entity_type = typename registry_type::entity_type;
+/**
+ * @brief Provides the member constant `value` to true if a given type is both
+ * an empty and non-final class, false otherwise.
+ * @tparam Type The type to test
+ */
+template<typename Type>
+struct is_ebco_eligible
+    : std::bool_constant<std::is_empty_v<Type> && !std::is_final_v<Type>> {};
 
-    /**
-     * @brief Constructs a converter for a given registry.
-     * @param source A valid reference to a registry.
-     */
-    as_group(registry_type &source) noexcept
-        : reg{source} {}
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_ebco_eligible_v = is_ebco_eligible<Type>::value;
 
-    /**
-     * @brief Conversion function from a registry to a group.
-     * @tparam Owned Types of _owned_ by the group.
-     * @tparam Get Types of storage _observed_ by the group.
-     * @tparam Exclude Types of storage used to filter the group.
-     * @return A newly created group.
-     */
-    template<typename Owned, typename Get, typename Exclude>
-    operator basic_group<Owned, Get, Exclude>() const {
-        return dispatch(Owned{}, Get{}, Exclude{});
-    }
+/**
+ * @brief Provides the member constant `value` to true if `Type::is_transparent`
+ * is valid and denotes a type, false otherwise.
+ * @tparam Type The type to test.
+ */
+template<typename Type, typename = void>
+struct is_transparent: std::false_type {};
 
-private:
-    registry_type &reg;
-};
+/*! @copydoc is_transparent */
+template<typename Type>
+struct is_transparent<Type, std::void_t<typename Type::is_transparent>>: std::true_type {};
 
 /**
- * @brief Helper to create a listener that directly invokes a member function.
- * @tparam Member Member function to invoke on a component of the given type.
- * @tparam Registry Basic registry type.
- * @param reg A registry that contains the given entity and its components.
- * @param entt Entity from which to get the component.
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
  */
-template<auto Member, typename Registry = std::decay_t<nth_argument_t<0u, decltype(Member)>>>
-void invoke(Registry &reg, const typename Registry::entity_type entt) {
-    static_assert(std::is_member_function_pointer_v<decltype(Member)>, "Invalid pointer to non-static member function");
-    delegate<void(Registry &, const typename Registry::entity_type)> func;
-    func.template connect<Member>(reg.template get<member_class_t<decltype(Member)>>(entt));
-    func(reg, entt);
+template<typename Type>
+inline constexpr bool is_transparent_v = is_transparent<Type>::value;
+
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+template<typename, typename = void>
+struct has_tuple_size_value: std::false_type {};
+
+template<typename Type>
+struct has_tuple_size_value<Type, std::void_t<decltype(std::tuple_size<const Type>::value)>>: std::true_type {};
+
+template<typename, typename = void>
+struct has_value_type: std::false_type {};
+
+template<typename Type>
+struct has_value_type<Type, std::void_t<typename Type::value_type>>: std::true_type {};
+
+template<typename>
+[[nodiscard]] constexpr bool dispatch_is_equality_comparable();
+
+template<typename Type, std::size_t... Index>
+[[nodiscard]] constexpr bool unpack_maybe_equality_comparable(std::index_sequence<Index...>) {
+    return (dispatch_is_equality_comparable<std::tuple_element_t<Index, Type>>() && ...);
 }
 
-/**
- * @brief Returns the entity associated with a given component.
- *
- * @warning
- * Currently, this function only works correctly with the default storage as it
- * makes assumptions about how the components are laid out.
- *
- * @tparam Args Storage type template parameters.
- * @param storage A storage that contains the given component.
- * @param instance A valid component instance.
- * @return The entity associated with the given component.
- */
-template<typename... Args>
-auto to_entity(const basic_storage<Args...> &storage, const typename basic_storage<Args...>::value_type &instance) -> typename basic_storage<Args...>::entity_type {
-    constexpr auto page_size = basic_storage<Args...>::traits_type::page_size;
-    const typename basic_storage<Args...>::base_type &base = storage;
-    const auto *addr = std::addressof(instance);
+template<typename>
+[[nodiscard]] constexpr bool maybe_equality_comparable(char) {
+    return false;
+}
 
-    for(auto it = base.rbegin(), last = base.rend(); it < last; it += page_size) {
-        if(const auto dist = (addr - std::addressof(storage.get(*it))); dist >= 0 && dist < static_cast<decltype(dist)>(page_size)) {
-            return *(it + dist);
+template<typename Type>
+[[nodiscard]] constexpr auto maybe_equality_comparable(int) -> decltype(std::declval<Type>() == std::declval<Type>()) {
+    return true;
+}
+
+template<typename Type>
+[[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
+    if constexpr(std::is_array_v<Type>) {
+        return false;
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
+            return maybe_equality_comparable<Type>(0);
+        } else {
+            return false;
+        }
+    } else if constexpr(is_complete_v<std::tuple_size<std::remove_cv_t<Type>>>) {
+        if constexpr(has_tuple_size_value<Type>::value) {
+            return maybe_equality_comparable<Type>(0) && unpack_maybe_equality_comparable<Type>(std::make_index_sequence<std::tuple_size<Type>::value>{});
+        } else {
+            return maybe_equality_comparable<Type>(0);
         }
+    } else {
+        return maybe_equality_comparable<Type>(0);
     }
-
-    return null;
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
+} // namespace internal
+/*! @endcond */
+
 /**
- * @copybrief to_entity
- * @tparam Args Registry type template parameters.
- * @tparam Component Type of component.
- * @param reg A registry that contains the given entity and its components.
- * @param instance A valid component instance.
- * @return The entity associated with the given component.
+ * @brief Provides the member constant `value` to true if a given type is
+ * equality comparable, false otherwise.
+ * @tparam Type The type to test.
  */
-template<typename... Args, typename Component>
-[[deprecated("use storage based to_entity instead")]] typename basic_registry<Args...>::entity_type to_entity(const basic_registry<Args...> &reg, const Component &instance) {
-    if(const auto *storage = reg.template storage<Component>(); storage) {
-        return to_entity(*storage, instance);
-    }
+template<typename Type>
+struct is_equality_comparable: std::bool_constant<internal::dispatch_is_equality_comparable<Type>()> {};
 
-    return null;
-}
+/*! @copydoc is_equality_comparable */
+template<typename Type>
+struct is_equality_comparable<const Type>: is_equality_comparable<Type> {};
 
-/*! @brief Primary template isn't defined on purpose. */
-template<typename...>
-struct sigh_helper;
+/**
+ * @brief Helper variable template.
+ * @tparam Type The type to test.
+ */
+template<typename Type>
+inline constexpr bool is_equality_comparable_v = is_equality_comparable<Type>::value;
 
 /**
- * @brief Signal connection helper for registries.
- * @tparam Registry Basic registry type.
+ * @brief Transcribes the constness of a type to another type.
+ * @tparam To The type to which to transcribe the constness.
+ * @tparam From The type from which to transcribe the constness.
  */
-template<typename Registry>
-struct sigh_helper<Registry> {
-    /*! @brief Registry type. */
-    using registry_type = Registry;
+template<typename To, typename From>
+struct constness_as {
+    /*! @brief The type resulting from the transcription of the constness. */
+    using type = std::remove_const_t<To>;
+};
 
-    /**
-     * @brief Constructs a helper for a given registry.
-     * @param ref A valid reference to a registry.
-     */
-    sigh_helper(registry_type &ref)
-        : bucket{&ref} {}
+/*! @copydoc constness_as */
+template<typename To, typename From>
+struct constness_as<To, const From> {
+    /*! @brief The type resulting from the transcription of the constness. */
+    using type = const To;
+};
 
-    /**
-     * @brief Binds a properly initialized helper to a given signal type.
-     * @tparam Type Type of signal to bind the helper to.
-     * @param id Optional name for the underlying storage to use.
-     * @return A helper for a given registry and signal type.
-     */
-    template<typename Type>
-    auto with(const id_type id = type_hash<Type>::value()) noexcept {
-        return sigh_helper<registry_type, Type>{*bucket, id};
-    }
+/**
+ * @brief Alias template to facilitate the transcription of the constness.
+ * @tparam To The type to which to transcribe the constness.
+ * @tparam From The type from which to transcribe the constness.
+ */
+template<typename To, typename From>
+using constness_as_t = typename constness_as<To, From>::type;
 
-    /**
-     * @brief Returns a reference to the underlying registry.
-     * @return A reference to the underlying registry.
-     */
-    [[nodiscard]] registry_type &registry() noexcept {
-        return *bucket;
-    }
+/**
+ * @brief Extracts the class of a non-static member object or function.
+ * @tparam Member A pointer to a non-static member object or function.
+ */
+template<typename Member>
+class member_class {
+    static_assert(std::is_member_pointer_v<Member>, "Invalid pointer type to non-static member object or function");
 
-private:
-    registry_type *bucket;
+    template<typename Class, typename Ret, typename... Args>
+    static Class *clazz(Ret (Class::*)(Args...));
+
+    template<typename Class, typename Ret, typename... Args>
+    static Class *clazz(Ret (Class::*)(Args...) const);
+
+    template<typename Class, typename Type>
+    static Class *clazz(Type Class::*);
+
+public:
+    /*! @brief The class of the given non-static member object or function. */
+    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
 };
 
 /**
- * @brief Signal connection helper for registries.
- * @tparam Registry Basic registry type.
- * @tparam Type Type of signal to connect listeners to.
+ * @brief Helper type.
+ * @tparam Member A pointer to a non-static member object or function.
  */
-template<typename Registry, typename Type>
-struct sigh_helper<Registry, Type> final: sigh_helper<Registry> {
-    /*! @brief Registry type. */
-    using registry_type = Registry;
+template<typename Member>
+using member_class_t = typename member_class<Member>::type;
 
-    /**
-     * @brief Constructs a helper for a given registry.
-     * @param ref A valid reference to a registry.
-     * @param id Optional name for the underlying storage to use.
-     */
-    sigh_helper(registry_type &ref, const id_type id = type_hash<Type>::value())
-        : sigh_helper<Registry>{ref},
-          name{id} {}
+/**
+ * @brief Extracts the n-th argument of a _callable_ type.
+ * @tparam Index The index of the argument to extract.
+ * @tparam Candidate A valid _callable_ type.
+ */
+template<std::size_t Index, typename Candidate>
+class nth_argument {
+    template<typename Ret, typename... Args>
+    static constexpr type_list<Args...> pick_up(Ret (*)(Args...));
 
-    /**
-     * @brief Forwards the call to `on_construct` on the underlying storage.
-     * @tparam Candidate Function or member to connect.
-     * @tparam Args Type of class or type of payload, if any.
-     * @param args A valid object that fits the purpose, if any.
-     * @return This helper.
-     */
-    template<auto Candidate, typename... Args>
-    auto on_construct(Args &&...args) {
-        this->registry().template on_construct<Type>(name).template connect<Candidate>(std::forward<Args>(args)...);
-        return *this;
-    }
+    template<typename Ret, typename Class, typename... Args>
+    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...));
 
-    /**
-     * @brief Forwards the call to `on_update` on the underlying storage.
-     * @tparam Candidate Function or member to connect.
-     * @tparam Args Type of class or type of payload, if any.
-     * @param args A valid object that fits the purpose, if any.
-     * @return This helper.
-     */
-    template<auto Candidate, typename... Args>
-    auto on_update(Args &&...args) {
-        this->registry().template on_update<Type>(name).template connect<Candidate>(std::forward<Args>(args)...);
-        return *this;
-    }
+    template<typename Ret, typename Class, typename... Args>
+    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...) const);
 
-    /**
-     * @brief Forwards the call to `on_destroy` on the underlying storage.
-     * @tparam Candidate Function or member to connect.
-     * @tparam Args Type of class or type of payload, if any.
-     * @param args A valid object that fits the purpose, if any.
-     * @return This helper.
-     */
-    template<auto Candidate, typename... Args>
-    auto on_destroy(Args &&...args) {
-        this->registry().template on_destroy<Type>(name).template connect<Candidate>(std::forward<Args>(args)...);
-        return *this;
-    }
+    template<typename Type, typename Class>
+    static constexpr type_list<Type> pick_up(Type Class ::*);
 
-private:
-    id_type name;
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
+public:
+    /*! @brief N-th argument of the _callable_ type. */
+    using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
 /**
- * @brief Deduction guide.
- * @tparam Registry Basic registry type.
+ * @brief Helper type.
+ * @tparam Index The index of the argument to extract.
+ * @tparam Candidate A valid function, member function or data member type.
  */
-template<typename Registry>
-sigh_helper(Registry &) -> sigh_helper<Registry>;
+template<std::size_t Index, typename Candidate>
+using nth_argument_t = typename nth_argument<Index, Candidate>::type;
 
 } // namespace entt
 
-#endif
+template<typename... Type>
+struct std::tuple_size<entt::type_list<Type...>>: std::integral_constant<std::size_t, entt::type_list<Type...>::size> {};
 
-// #include "entity/mixin.hpp"
-#ifndef ENTT_ENTITY_MIXIN_HPP
-#define ENTT_ENTITY_MIXIN_HPP
+template<std::size_t Index, typename... Type>
+struct std::tuple_element<Index, entt::type_list<Type...>>: entt::type_list_element<Index, entt::type_list<Type...>> {};
 
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
+template<auto... Value>
+struct std::tuple_size<entt::value_list<Value...>>: std::integral_constant<std::size_t, entt::value_list<Value...>::size> {};
 
-// #include "../core/any.hpp"
+template<std::size_t Index, auto... Value>
+struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_element<Index, entt::value_list<Value...>> {};
 
-// #include "../signal/sigh.hpp"
-#ifndef ENTT_SIGNAL_SIGH_HPP
-#define ENTT_SIGNAL_SIGH_HPP
+#endif
+
+// #include "fwd.hpp"
+#ifndef ENTT_SIGNAL_FWD_HPP
+#define ENTT_SIGNAL_FWD_HPP
 
-#include <cstddef>
 #include <memory>
-#include <type_traits>
-#include <utility>
-#include <vector>
-// #include "delegate.hpp"
-#ifndef ENTT_SIGNAL_DELEGATE_HPP
-#define ENTT_SIGNAL_DELEGATE_HPP
 
-#include <cstddef>
-#include <functional>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
+namespace entt {
 
-// #include "../core/type_traits.hpp"
+template<typename>
+class delegate;
 
-// #include "fwd.hpp"
+template<typename = std::allocator<void>>
+class basic_dispatcher;
+
+template<typename, typename = std::allocator<void>>
+class emitter;
+
+class connection;
+
+struct scoped_connection;
+
+template<typename>
+class sink;
+
+template<typename Type, typename = std::allocator<void>>
+class sigh;
+
+/*! @brief Alias declaration for the most common use case. */
+using dispatcher = basic_dispatcher<>;
+
+/*! @brief Disambiguation tag for constructors and the like. */
+template<auto>
+struct connect_arg_t {
+    /*! @brief Default constructor. */
+    explicit connect_arg_t() = default;
+};
+
+/**
+ * @brief Constant of type connect_arg_t used to disambiguate calls.
+ * @tparam Candidate Element to connect (likely a free or member function).
+ */
+template<auto Candidate>
+inline constexpr connect_arg_t<Candidate> connect_arg{};
+
+} // namespace entt
+
+#endif
 
 
 namespace entt {
@@ -23462,7 +24314,7 @@ constexpr auto function_pointer(Ret (Class::*)(Args...), Other &&...) -> Ret (*)
 template<typename Class, typename Ret, typename... Args, typename... Other>
 constexpr auto function_pointer(Ret (Class::*)(Args...) const, Other &&...) -> Ret (*)(Args...);
 
-template<typename Class, typename Type, typename... Other>
+template<typename Class, typename Type, typename... Other, typename = std::enable_if_t<std::is_member_object_pointer_v<Type Class::*>>>
 constexpr auto function_pointer(Type Class::*, Other &&...) -> Type (*)();
 
 template<typename... Type>
@@ -23499,47 +24351,35 @@ class delegate;
  */
 template<typename Ret, typename... Args>
 class delegate<Ret(Args...)> {
+    using return_type = std::remove_const_t<Ret>;
+    using delegate_type = return_type(const void *, Args...);
+
     template<auto Candidate, std::size_t... Index>
     [[nodiscard]] auto wrap(std::index_sequence<Index...>) noexcept {
-        return [](const void *, Args... args) -> Ret {
+        return [](const void *, Args... args) -> return_type {
             [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
     template<auto Candidate, typename Type, std::size_t... Index>
     [[nodiscard]] auto wrap(Type &, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+        return [](const void *payload, Args... args) -> return_type {
             Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
     template<auto Candidate, typename Type, std::size_t... Index>
     [[nodiscard]] auto wrap(Type *, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+        return [](const void *payload, Args... args) -> return_type {
             Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
@@ -23552,9 +24392,7 @@ class delegate<Ret(Args...)> {
     using result_type = Ret;
 
     /*! @brief Default constructor. */
-    delegate() noexcept
-        : instance{nullptr},
-          fn{nullptr} {}
+    delegate() noexcept = default;
 
     /**
      * @brief Constructs a delegate with a given object or payload, if any.
@@ -23586,7 +24424,7 @@ class delegate<Ret(Args...)> {
         instance = nullptr;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
-            fn = [](const void *, Args... args) -> Ret {
+            fn = [](const void *, Args... args) -> return_type {
                 return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
             };
         } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
@@ -23616,7 +24454,7 @@ class delegate<Ret(Args...)> {
         instance = &value_or_instance;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
+            fn = [](const void *payload, Args... args) -> return_type {
                 Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                 return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
             };
@@ -23640,7 +24478,7 @@ class delegate<Ret(Args...)> {
         instance = value_or_instance;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
+            fn = [](const void *payload, Args... args) -> return_type {
                 Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                 return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
             };
@@ -23730,8 +24568,8 @@ class delegate<Ret(Args...)> {
     }
 
 private:
-    const void *instance;
-    function_type *fn;
+    const void *instance{};
+    delegate_type *fn{};
 };
 
 /**
@@ -23835,21 +24673,21 @@ class sigh<Ret(Args...), Allocator> {
     using sink_type = sink<sigh<Ret(Args...), Allocator>>;
 
     /*! @brief Default constructor. */
-    sigh() noexcept(std::is_nothrow_default_constructible_v<allocator_type> &&std::is_nothrow_constructible_v<container_type, const allocator_type &>)
+    sigh() noexcept(noexcept(allocator_type{}))
         : sigh{allocator_type{}} {}
 
     /**
      * @brief Constructs a signal handler with a given allocator.
      * @param allocator The allocator to use.
      */
-    explicit sigh(const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const allocator_type &>)
+    explicit sigh(const allocator_type &allocator) noexcept
         : calls{allocator} {}
 
     /**
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    sigh(const sigh &other) noexcept(std::is_nothrow_copy_constructible_v<container_type>)
+    sigh(const sigh &other)
         : calls{other.calls} {}
 
     /**
@@ -23857,14 +24695,14 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to copy from.
      * @param allocator The allocator to use.
      */
-    sigh(const sigh &other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const container_type &, const allocator_type &>)
+    sigh(const sigh &other, const allocator_type &allocator)
         : calls{other.calls, allocator} {}
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    sigh(sigh &&other) noexcept(std::is_nothrow_move_constructible_v<container_type>)
+    sigh(sigh &&other) noexcept
         : calls{std::move(other.calls)} {}
 
     /**
@@ -23872,15 +24710,18 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    sigh(sigh &&other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, container_type &&, const allocator_type &>)
+    sigh(sigh &&other, const allocator_type &allocator)
         : calls{std::move(other.calls), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~sigh() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This signal handler.
      */
-    sigh &operator=(const sigh &other) noexcept(std::is_nothrow_copy_assignable_v<container_type>) {
+    sigh &operator=(const sigh &other) {
         calls = other.calls;
         return *this;
     }
@@ -23890,8 +24731,8 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to move from.
      * @return This signal handler.
      */
-    sigh &operator=(sigh &&other) noexcept(std::is_nothrow_move_assignable_v<container_type>) {
-        calls = std::move(other.calls);
+    sigh &operator=(sigh &&other) noexcept {
+        swap(other);
         return *this;
     }
 
@@ -23899,7 +24740,7 @@ class sigh<Ret(Args...), Allocator> {
      * @brief Exchanges the contents with those of a given signal handler.
      * @param other Signal handler to exchange the content with.
      */
-    void swap(sigh &other) noexcept(std::is_nothrow_swappable_v<container_type>) {
+    void swap(sigh &other) noexcept {
         using std::swap;
         swap(calls, other.calls);
     }
@@ -24001,8 +24842,7 @@ class connection {
 public:
     /*! @brief Default constructor. */
     connection()
-        : disconnect{},
-          signal{} {}
+        : signal{} {}
 
     /**
      * @brief Checks whether a connection is properly initialized.
@@ -24082,7 +24922,7 @@ struct scoped_connection {
      * @return This scoped connection.
      */
     scoped_connection &operator=(connection other) {
-        conn = std::move(other);
+        conn = other;
         return *this;
     }
 
@@ -24182,7 +25022,7 @@ class sink<sigh<Ret(Args...), Allocator>> {
 
         delegate<void(void *)> conn{};
         conn.template connect<&release<Candidate, Type...>>(value_or_instance...);
-        return {std::move(conn), signal};
+        return {conn, signal};
     }
 
     /**
@@ -24205,9 +25045,8 @@ class sink<sigh<Ret(Args...), Allocator>> {
      * @param value_or_instance A valid object that fits the purpose.
      */
     void disconnect(const void *value_or_instance) {
-        if(value_or_instance) {
-            disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
-        }
+        ENTT_ASSERT(value_or_instance != nullptr, "Invalid value or instance");
+        disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
     }
 
     /*! @brief Disconnects all the listeners from a signal. */
@@ -24243,6 +25082,47 @@ sink(sigh<Ret(Args...), Allocator> &) -> sink<sigh<Ret(Args...), Allocator>>;
 
 namespace entt {
 
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+template<typename, typename, typename = void>
+struct has_on_construct final: std::false_type {};
+
+template<typename Type, typename Registry>
+struct has_on_construct<Type, Registry, std::void_t<decltype(Type::on_construct(std::declval<Registry &>(), std::declval<Registry>().create()))>>
+    : std::true_type {};
+
+template<typename, typename, typename = void>
+struct has_on_update final: std::false_type {};
+
+template<typename Type, typename Registry>
+struct has_on_update<Type, Registry, std::void_t<decltype(Type::on_update(std::declval<Registry &>(), std::declval<Registry>().create()))>>
+    : std::true_type {};
+
+template<typename, typename, typename = void>
+struct has_on_destroy final: std::false_type {};
+
+template<typename Type, typename Registry>
+struct has_on_destroy<Type, Registry, std::void_t<decltype(Type::on_destroy(std::declval<Registry &>(), std::declval<Registry>().create()))>>
+    : std::true_type {};
+
+template<typename Type>
+auto *any_to_owner(any &value) noexcept {
+    using base_type = basic_registry<typename Type::entity_type, typename Type::allocator_type>;
+    auto *reg = any_cast<base_type>(&value);
+
+    if constexpr(!std::is_same_v<Type, base_type>) {
+        if(!reg) {
+            reg = any_cast<Type>(&value);
+        }
+    }
+
+    return reg;
+}
+
+} // namespace internal
+/*! @endcond */
+
 /**
  * @brief Mixin type used to add signal support to storage types.
  *
@@ -24262,17 +25142,18 @@ class basic_sigh_mixin final: public Type {
     using underlying_type = Type;
     using owner_type = Registry;
 
-    using basic_registry_type = basic_registry<typename underlying_type::entity_type, typename underlying_type::base_type::allocator_type>;
+    using basic_registry_type = basic_registry<typename owner_type::entity_type, typename owner_type::allocator_type>;
     using sigh_type = sigh<void(owner_type &, const typename underlying_type::entity_type), typename underlying_type::allocator_type>;
     using underlying_iterator = typename underlying_type::base_type::basic_iterator;
 
     static_assert(std::is_base_of_v<basic_registry_type, owner_type>, "Invalid registry type");
 
-    owner_type &owner_or_assert() const noexcept {
+    [[nodiscard]] auto &owner_or_assert() const noexcept {
         ENTT_ASSERT(owner != nullptr, "Invalid pointer to registry");
         return static_cast<owner_type &>(*owner);
     }
 
+private:
     void pop(underlying_iterator first, underlying_iterator last) final {
         if(auto &reg = owner_or_assert(); destruction.empty()) {
             underlying_type::pop(first, last);
@@ -24288,16 +25169,18 @@ class basic_sigh_mixin final: public Type {
 
     void pop_all() final {
         if(auto &reg = owner_or_assert(); !destruction.empty()) {
-            for(auto it = underlying_type::base_type::begin(0), last = underlying_type::base_type::end(0); it != last; ++it) {
-                if constexpr(std::is_same_v<typename underlying_type::value_type, typename underlying_type::entity_type>) {
-                    destruction.publish(reg, *it);
-                } else {
-                    if constexpr(underlying_type::traits_type::in_place_delete) {
-                        if(const auto entt = *it; entt != tombstone) {
+            if constexpr(std::is_same_v<typename underlying_type::element_type, entity_type>) {
+                for(typename underlying_type::size_type pos{}, last = underlying_type::free_list(); pos < last; ++pos) {
+                    destruction.publish(reg, underlying_type::base_type::operator[](pos));
+                }
+            } else {
+                for(auto entt: static_cast<typename underlying_type::base_type &>(*this)) {
+                    if constexpr(underlying_type::storage_policy == deletion_policy::in_place) {
+                        if(entt != tombstone) {
                             destruction.publish(reg, entt);
                         }
                     } else {
-                        destruction.publish(reg, *it);
+                        destruction.publish(reg, entt);
                     }
                 }
             }
@@ -24316,6 +25199,11 @@ class basic_sigh_mixin final: public Type {
         return it;
     }
 
+    void bind_any(any value) noexcept final {
+        owner = internal::any_to_owner<registry_type>(value);
+        underlying_type::bind_any(std::move(value));
+    }
+
 public:
     /*! @brief Allocator type. */
     using allocator_type = typename underlying_type::allocator_type;
@@ -24337,7 +25225,22 @@ class basic_sigh_mixin final: public Type {
           owner{},
           construction{allocator},
           destruction{allocator},
-          update{allocator} {}
+          update{allocator} {
+        if constexpr(internal::has_on_construct<typename underlying_type::element_type, Registry>::value) {
+            entt::sink{construction}.template connect<&underlying_type::element_type::on_construct>();
+        }
+
+        if constexpr(internal::has_on_update<typename underlying_type::element_type, Registry>::value) {
+            entt::sink{update}.template connect<&underlying_type::element_type::on_update>();
+        }
+
+        if constexpr(internal::has_on_destroy<typename underlying_type::element_type, Registry>::value) {
+            entt::sink{destruction}.template connect<&underlying_type::element_type::on_destroy>();
+        }
+    }
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_sigh_mixin(const basic_sigh_mixin &) = delete;
 
     /**
      * @brief Move constructor.
@@ -24355,24 +25258,29 @@ class basic_sigh_mixin final: public Type {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_sigh_mixin(basic_sigh_mixin &&other, const allocator_type &allocator) noexcept
+    basic_sigh_mixin(basic_sigh_mixin &&other, const allocator_type &allocator)
         : underlying_type{std::move(other), allocator},
           owner{other.owner},
           construction{std::move(other.construction), allocator},
           destruction{std::move(other.destruction), allocator},
           update{std::move(other.update), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~basic_sigh_mixin() override = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This mixin.
+     */
+    basic_sigh_mixin &operator=(const basic_sigh_mixin &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
-     * @return This storage.
+     * @return This mixin.
      */
     basic_sigh_mixin &operator=(basic_sigh_mixin &&other) noexcept {
-        underlying_type::operator=(std::move(other));
-        owner = other.owner;
-        construction = std::move(other.construction);
-        destruction = std::move(other.destruction);
-        update = std::move(other.update);
+        swap(other);
         return *this;
     }
 
@@ -24380,13 +25288,13 @@ class basic_sigh_mixin final: public Type {
      * @brief Exchanges the contents with those of a given storage.
      * @param other Storage to exchange the content with.
      */
-    void swap(basic_sigh_mixin &other) {
+    void swap(basic_sigh_mixin &other) noexcept {
         using std::swap;
-        underlying_type::swap(other);
         swap(owner, other.owner);
         swap(construction, other.construction);
         swap(destruction, other.destruction);
         swap(update, other.update);
+        underlying_type::swap(other);
     }
 
     /**
@@ -24434,6 +25342,27 @@ class basic_sigh_mixin final: public Type {
         return sink{destruction};
     }
 
+    /**
+     * @brief Checks if a mixin refers to a valid registry.
+     * @return True if the mixin refers to a valid registry, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return (owner != nullptr);
+    }
+
+    /**
+     * @brief Returns a pointer to the underlying registry, if any.
+     * @return A pointer to the underlying registry, if any.
+     */
+    [[nodiscard]] const registry_type &registry() const noexcept {
+        return owner_or_assert();
+    }
+
+    /*! @copydoc registry */
+    [[nodiscard]] registry_type &registry() noexcept {
+        return owner_or_assert();
+    }
+
     /**
      * @brief Emplace elements into a storage.
      *
@@ -24441,7 +25370,7 @@ class basic_sigh_mixin final: public Type {
      * (for example, components vs entities).<br/>
      * Refer to the specific documentation for more details.
      *
-     * @return A return value as returned by the underlying storage.
+     * @return Whatever the underlying storage returns.
      */
     auto emplace() {
         const auto entt = underlying_type::emplace();
@@ -24459,11 +25388,12 @@ class basic_sigh_mixin final: public Type {
      * @tparam Args Types of arguments to forward to the underlying storage.
      * @param hint A valid identifier.
      * @param args Parameters to forward to the underlying storage.
-     * @return A return value as returned by the underlying storage.
+     * @return Whatever the underlying storage returns.
      */
     template<typename... Args>
-    decltype(auto) emplace(const entity_type hint, Args &&...args) {
-        if constexpr(std::is_same_v<typename underlying_type::value_type, typename underlying_type::entity_type>) {
+    std::conditional_t<std::is_same_v<typename underlying_type::element_type, entity_type>, entity_type, decltype(std::declval<underlying_type>().get({}))>
+    emplace(const entity_type hint, Args &&...args) {
+        if constexpr(std::is_same_v<typename underlying_type::element_type, entity_type>) {
             const auto entt = underlying_type::emplace(hint, std::forward<Args>(args)...);
             construction.publish(owner_or_assert(), entt);
             return entt;
@@ -24513,21 +25443,199 @@ class basic_sigh_mixin final: public Type {
         }
     }
 
+private:
+    basic_registry_type *owner;
+    sigh_type construction;
+    sigh_type destruction;
+    sigh_type update;
+};
+
+/**
+ * @brief Mixin type used to add _reactive_ support to storage types.
+ * @tparam Type Underlying storage type.
+ * @tparam Registry Basic registry type.
+ */
+template<typename Type, typename Registry>
+class basic_reactive_mixin final: public Type {
+    using underlying_type = Type;
+    using owner_type = Registry;
+
+    using basic_registry_type = basic_registry<typename owner_type::entity_type, typename owner_type::allocator_type>;
+
+    static_assert(std::is_base_of_v<basic_registry_type, owner_type>, "Invalid registry type");
+
+    [[nodiscard]] auto &owner_or_assert() const noexcept {
+        ENTT_ASSERT(owner != nullptr, "Invalid pointer to registry");
+        return static_cast<owner_type &>(*owner);
+    }
+
+    void emplace_element(const Registry &, typename underlying_type::entity_type entity) {
+        if(!underlying_type::contains(entity)) {
+            underlying_type::emplace(entity);
+        }
+    }
+
+private:
+    void bind_any(any value) noexcept final {
+        owner = internal::any_to_owner<registry_type>(value);
+        underlying_type::bind_any(std::move(value));
+    }
+
+public:
+    /*! @brief Allocator type. */
+    using allocator_type = typename underlying_type::allocator_type;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename underlying_type::entity_type;
+    /*! @brief Expected registry type. */
+    using registry_type = owner_type;
+
+    /*! @brief Default constructor. */
+    basic_reactive_mixin()
+        : basic_reactive_mixin{allocator_type{}} {}
+
     /**
-     * @brief Forwards variables to derived classes, if any.
-     * @param value A variable wrapped in an opaque container.
+     * @brief Constructs an empty storage with a given allocator.
+     * @param allocator The allocator to use.
+     */
+    explicit basic_reactive_mixin(const allocator_type &allocator)
+        : underlying_type{allocator},
+          owner{} {
+    }
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_reactive_mixin(const basic_reactive_mixin &) = delete;
+
+    /**
+     * @brief Move constructor.
+     * @param other The instance to move from.
+     */
+    basic_reactive_mixin(basic_reactive_mixin &&other) noexcept
+        : underlying_type{std::move(other)},
+          owner{other.owner} {}
+
+    /**
+     * @brief Allocator-extended move constructor.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
+     */
+    basic_reactive_mixin(basic_reactive_mixin &&other, const allocator_type &allocator)
+        : underlying_type{std::move(other), allocator},
+          owner{other.owner} {}
+
+    /*! @brief Default destructor. */
+    ~basic_reactive_mixin() override = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This mixin.
+     */
+    basic_reactive_mixin &operator=(const basic_reactive_mixin &) = delete;
+
+    /**
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This mixin.
+     */
+    basic_reactive_mixin &operator=(basic_reactive_mixin &&other) noexcept {
+        swap(other);
+        return *this;
+    }
+
+    /**
+     * @brief Exchanges the contents with those of a given storage.
+     * @param other Storage to exchange the content with.
      */
-    void bind(any value) noexcept final {
-        auto *reg = any_cast<basic_registry_type>(&value);
-        owner = reg ? reg : owner;
-        underlying_type::bind(std::move(value));
+    void swap(basic_reactive_mixin &other) noexcept {
+        using std::swap;
+        swap(owner, other.owner);
+        underlying_type::swap(other);
+    }
+
+    /**
+     * @brief Makes storage _react_ to creation of objects of the given type.
+     * @tparam Clazz Type of element to _react_ to.
+     * @tparam Candidate Function to use to _react_ to the event.
+     * @param id Optional name used to map the storage within the registry.
+     * @return This mixin.
+     */
+    template<typename Clazz, auto Candidate = &basic_reactive_mixin::emplace_element>
+    basic_reactive_mixin &on_construct(const id_type id = type_hash<Clazz>::value()) {
+        owner_or_assert().template storage<Clazz>(id).on_construct().template connect<Candidate>(*this);
+        return *this;
+    }
+
+    /**
+     * @brief Makes storage _react_ to update of objects of the given type.
+     * @tparam Clazz Type of element to _react_ to.
+     * @tparam Candidate Function to use to _react_ to the event.
+     * @param id Optional name used to map the storage within the registry.
+     * @return This mixin.
+     */
+    template<typename Clazz, auto Candidate = &basic_reactive_mixin::emplace_element>
+    basic_reactive_mixin &on_update(const id_type id = type_hash<Clazz>::value()) {
+        owner_or_assert().template storage<Clazz>(id).on_update().template connect<Candidate>(*this);
+        return *this;
+    }
+
+    /**
+     * @brief Makes storage _react_ to destruction of objects of the given type.
+     * @tparam Clazz Type of element to _react_ to.
+     * @tparam Candidate Function to use to _react_ to the event.
+     * @param id Optional name used to map the storage within the registry.
+     * @return This mixin.
+     */
+    template<typename Clazz, auto Candidate = &basic_reactive_mixin::emplace_element>
+    basic_reactive_mixin &on_destroy(const id_type id = type_hash<Clazz>::value()) {
+        owner_or_assert().template storage<Clazz>(id).on_destroy().template connect<Candidate>(*this);
+        return *this;
+    }
+
+    /**
+     * @brief Checks if a mixin refers to a valid registry.
+     * @return True if the mixin refers to a valid registry, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return (owner != nullptr);
+    }
+
+    /**
+     * @brief Returns a pointer to the underlying registry, if any.
+     * @return A pointer to the underlying registry, if any.
+     */
+    [[nodiscard]] const registry_type &registry() const noexcept {
+        return owner_or_assert();
+    }
+
+    /*! @copydoc registry */
+    [[nodiscard]] registry_type &registry() noexcept {
+        return owner_or_assert();
+    }
+
+    /**
+     * @brief Returns a view that is filtered by the underlying storage.
+     * @tparam Get Types of elements used to construct the view.
+     * @tparam Exclude Types of elements used to filter the view.
+     * @return A newly created view.
+     */
+    template<typename... Get, typename... Exclude>
+    [[nodiscard]] basic_view<get_t<const basic_reactive_mixin, typename basic_registry_type::template storage_for_type<const Get>...>, exclude_t<typename basic_registry_type::template storage_for_type<const Exclude>...>>
+    view(exclude_t<Exclude...> = exclude_t{}) const {
+        const owner_type &parent = owner_or_assert();
+        basic_view<get_t<const basic_reactive_mixin, typename basic_registry_type::template storage_for_type<const Get>...>, exclude_t<typename basic_registry_type::template storage_for_type<const Exclude>...>> elem{};
+        [&elem](const auto *...curr) { ((curr ? elem.storage(*curr) : void()), ...); }(parent.template storage<std::remove_const_t<Exclude>>()..., parent.template storage<std::remove_const_t<Get>>()..., this);
+        return elem;
+    }
+
+    /*! @copydoc view */
+    template<typename... Get, typename... Exclude>
+    [[nodiscard]] basic_view<get_t<const basic_reactive_mixin, typename basic_registry_type::template storage_for_type<Get>...>, exclude_t<typename basic_registry_type::template storage_for_type<Exclude>...>>
+    view(exclude_t<Exclude...> = exclude_t{}) {
+        owner_type &parent = owner_or_assert();
+        return {*this, parent.template storage<std::remove_const_t<Get>>()..., parent.template storage<std::remove_const_t<Exclude>>()...};
     }
 
 private:
     basic_registry_type *owner;
-    sigh_type construction;
-    sigh_type destruction;
-    sigh_type update;
 };
 
 } // namespace entt
@@ -24545,8 +25653,6 @@ class basic_sigh_mixin final: public Type {
 #include <utility>
 // #include "../core/type_traits.hpp"
 
-// #include "../signal/delegate.hpp"
-
 // #include "fwd.hpp"
 
 // #include "storage.hpp"
@@ -24579,8 +25685,8 @@ template<>
 struct basic_collector<> {
     /**
      * @brief Adds a grouping matcher to the collector.
-     * @tparam AllOf Types of components tracked by the matcher.
-     * @tparam NoneOf Types of components used to filter out entities.
+     * @tparam AllOf Types of elements tracked by the matcher.
+     * @tparam NoneOf Types of elements used to filter out entities.
      * @return The updated collector.
      */
     template<typename... AllOf, typename... NoneOf>
@@ -24590,7 +25696,7 @@ struct basic_collector<> {
 
     /**
      * @brief Adds an observing matcher to the collector.
-     * @tparam AnyOf Type of component for which changes should be detected.
+     * @tparam AnyOf Type of element for which changes should be detected.
      * @return The updated collector.
      */
     template<typename AnyOf>
@@ -24608,14 +25714,14 @@ struct basic_collector<> {
  * @tparam Other Other matchers.
  */
 template<typename... Reject, typename... Require, typename... Rule, typename... Other>
-struct basic_collector<matcher<type_list<Reject...>, type_list<Require...>, Rule...>, Other...> {
+struct [[deprecated("use reactive mixin instead")]] basic_collector<matcher<type_list<Reject...>, type_list<Require...>, Rule...>, Other...> {
     /*! @brief Current matcher. */
     using current_type = matcher<type_list<Reject...>, type_list<Require...>, Rule...>;
 
     /**
      * @brief Adds a grouping matcher to the collector.
-     * @tparam AllOf Types of components tracked by the matcher.
-     * @tparam NoneOf Types of components used to filter out entities.
+     * @tparam AllOf Types of elements tracked by the matcher.
+     * @tparam NoneOf Types of elements used to filter out entities.
      * @return The updated collector.
      */
     template<typename... AllOf, typename... NoneOf>
@@ -24625,7 +25731,7 @@ struct basic_collector<matcher<type_list<Reject...>, type_list<Require...>, Rule
 
     /**
      * @brief Adds an observing matcher to the collector.
-     * @tparam AnyOf Type of component for which changes should be detected.
+     * @tparam AnyOf Type of element for which changes should be detected.
      * @return The updated collector.
      */
     template<typename AnyOf>
@@ -24635,8 +25741,8 @@ struct basic_collector<matcher<type_list<Reject...>, type_list<Require...>, Rule
 
     /**
      * @brief Updates the filter of the last added matcher.
-     * @tparam AllOf Types of components required by the matcher.
-     * @tparam NoneOf Types of components used to filter out entities.
+     * @tparam AllOf Types of elements required by the matcher.
+     * @tparam NoneOf Types of elements used to filter out entities.
      * @return The updated collector.
      */
     template<typename... AllOf, typename... NoneOf>
@@ -24655,13 +25761,13 @@ inline constexpr basic_collector<> collector{};
  * An observer returns all the entities and only the entities that fit the
  * requirements of at least one matcher. Moreover, it's guaranteed that the
  * entity list is tightly packed in memory for fast iterations.<br/>
- * In general, observers don't stay true to the order of any set of components.
+ * In general, observers don't stay true to the order of any set of elements.
  *
  * Observers work mainly with two types of matchers, provided through a
  * collector:
  *
  * * Observing matcher: an observer will return at least all the living entities
- *   for which one or more of the given components have been updated and not yet
+ *   for which one or more of the given elements have been updated and not yet
  *   destroyed.
  * * Grouping matcher: an observer will return at least all the living entities
  *   that would have entered the given group if it existed and that would have
@@ -24681,13 +25787,13 @@ inline constexpr basic_collector<> collector{};
  *
  * Iterators aren't invalidated if:
  *
- * * New instances of the given components are created and assigned to entities.
+ * * New instances of the given elements are created and assigned to entities.
  * * The entity currently pointed is modified (as an example, if one of the
- *   given components is removed from the entity to which the iterator points).
+ *   given elements is removed from the entity to which the iterator points).
  * * The entity currently pointed is destroyed.
  *
- * In all the other cases, modifying the pools of the given components in any
- * way invalidates all the iterators.
+ * In all the other cases, modifying the pools of the given elements in any way
+ * invalidates all the iterators.
  *
  * @warning
  * Lifetime of an observer doesn't necessarily have to overcome that of the
@@ -24696,12 +25802,19 @@ inline constexpr basic_collector<> collector{};
  * pointers.
  *
  * @tparam Registry Basic registry type.
- * @tparam Mask Mask type.
  * @tparam Allocator Type of allocator used to manage memory and elements.
  */
-template<typename Registry, typename Mask, typename Allocator>
-class basic_observer: private basic_storage<Mask, typename Registry::entity_type, Allocator> {
-    using base_type = basic_storage<Mask, typename Registry::entity_type, Allocator>;
+template<typename Registry, typename Allocator>
+class basic_observer {
+    using mask_type = std::uint64_t;
+    using storage_type = basic_storage<mask_type, typename Registry::entity_type, typename std::allocator_traits<Allocator>::template rebind_alloc<mask_type>>;
+
+    template<std::size_t Index>
+    static void discard_if(storage_type &storage, Registry &, const typename Registry::entity_type entt) {
+        if(storage.contains(entt) && !(storage.get(entt) &= (~(1 << Index)))) {
+            storage.erase(entt);
+        }
+    }
 
     template<typename>
     struct matcher_handler;
@@ -24709,108 +25822,93 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
     template<typename... Reject, typename... Require, typename AnyOf>
     struct matcher_handler<matcher<type_list<Reject...>, type_list<Require...>, AnyOf>> {
         template<std::size_t Index>
-        static void maybe_valid_if(basic_observer &obs, Registry &reg, const typename Registry::entity_type entt) {
-            if(reg.template all_of<Require...>(entt) && !reg.template any_of<Reject...>(entt)) {
-                if(!obs.contains(entt)) {
-                    obs.emplace(entt);
+        static void maybe_valid_if(storage_type &storage, Registry &parent, const typename Registry::entity_type entt) {
+            if(parent.template all_of<Require...>(entt) && !parent.template any_of<Reject...>(entt)) {
+                if(!storage.contains(entt)) {
+                    storage.emplace(entt);
                 }
 
-                obs.get(entt) |= (1 << Index);
+                storage.get(entt) |= (1 << Index);
             }
         }
 
         template<std::size_t Index>
-        static void discard_if(basic_observer &obs, Registry &, const typename Registry::entity_type entt) {
-            if(obs.contains(entt) && !(obs.get(entt) &= (~(1 << Index)))) {
-                obs.erase(entt);
-            }
+        static void connect(storage_type &storage, Registry &parent) {
+            (parent.template on_destroy<Require>().template connect<&discard_if<Index>>(storage), ...);
+            (parent.template on_construct<Reject>().template connect<&discard_if<Index>>(storage), ...);
+            parent.template on_update<AnyOf>().template connect<&maybe_valid_if<Index>>(storage);
+            parent.template on_destroy<AnyOf>().template connect<&discard_if<Index>>(storage);
         }
 
-        template<std::size_t Index>
-        static void connect(basic_observer &obs, Registry &reg) {
-            (reg.template on_destroy<Require>().template connect<&discard_if<Index>>(obs), ...);
-            (reg.template on_construct<Reject>().template connect<&discard_if<Index>>(obs), ...);
-            reg.template on_update<AnyOf>().template connect<&maybe_valid_if<Index>>(obs);
-            reg.template on_destroy<AnyOf>().template connect<&discard_if<Index>>(obs);
-        }
-
-        static void disconnect(basic_observer &obs, Registry &reg) {
-            (reg.template on_destroy<Require>().disconnect(&obs), ...);
-            (reg.template on_construct<Reject>().disconnect(&obs), ...);
-            reg.template on_update<AnyOf>().disconnect(&obs);
-            reg.template on_destroy<AnyOf>().disconnect(&obs);
+        static void disconnect(storage_type &storage, Registry &parent) {
+            (parent.template on_destroy<Require>().disconnect(&storage), ...);
+            (parent.template on_construct<Reject>().disconnect(&storage), ...);
+            parent.template on_update<AnyOf>().disconnect(&storage);
+            parent.template on_destroy<AnyOf>().disconnect(&storage);
         }
     };
 
     template<typename... Reject, typename... Require, typename... NoneOf, typename... AllOf>
     struct matcher_handler<matcher<type_list<Reject...>, type_list<Require...>, type_list<NoneOf...>, AllOf...>> {
         template<std::size_t Index, typename... Ignore>
-        static void maybe_valid_if(basic_observer &obs, Registry &reg, const typename Registry::entity_type entt) {
-            auto condition = [&reg, entt]() {
-                if constexpr(sizeof...(Ignore) == 0) {
-                    return reg.template all_of<AllOf..., Require...>(entt) && !reg.template any_of<NoneOf..., Reject...>(entt);
-                } else {
-                    return reg.template all_of<AllOf..., Require...>(entt) && ((std::is_same_v<Ignore..., NoneOf> || !reg.template any_of<NoneOf>(entt)) && ...) && !reg.template any_of<Reject...>(entt);
-                }
-            };
-
-            if(condition()) {
-                if(!obs.contains(entt)) {
-                    obs.emplace(entt);
-                }
+        static void maybe_valid_if(storage_type &storage, Registry &parent, const typename Registry::entity_type entt) {
+            bool guard{};
 
-                obs.get(entt) |= (1 << Index);
+            if constexpr(sizeof...(Ignore) == 0) {
+                guard = parent.template all_of<AllOf..., Require...>(entt) && !parent.template any_of<NoneOf..., Reject...>(entt);
+            } else {
+                guard = parent.template all_of<AllOf..., Require...>(entt) && ((std::is_same_v<Ignore..., NoneOf> || !parent.template any_of<NoneOf>(entt)) && ...) && !parent.template any_of<Reject...>(entt);
             }
-        }
 
-        template<std::size_t Index>
-        static void discard_if(basic_observer &obs, Registry &, const typename Registry::entity_type entt) {
-            if(obs.contains(entt) && !(obs.get(entt) &= (~(1 << Index)))) {
-                obs.erase(entt);
+            if(guard) {
+                if(!storage.contains(entt)) {
+                    storage.emplace(entt);
+                }
+
+                storage.get(entt) |= (1 << Index);
             }
         }
 
         template<std::size_t Index>
-        static void connect(basic_observer &obs, Registry &reg) {
-            (reg.template on_destroy<Require>().template connect<&discard_if<Index>>(obs), ...);
-            (reg.template on_construct<Reject>().template connect<&discard_if<Index>>(obs), ...);
-            (reg.template on_construct<AllOf>().template connect<&maybe_valid_if<Index>>(obs), ...);
-            (reg.template on_destroy<NoneOf>().template connect<&maybe_valid_if<Index, NoneOf>>(obs), ...);
-            (reg.template on_destroy<AllOf>().template connect<&discard_if<Index>>(obs), ...);
-            (reg.template on_construct<NoneOf>().template connect<&discard_if<Index>>(obs), ...);
-        }
-
-        static void disconnect(basic_observer &obs, Registry &reg) {
-            (reg.template on_destroy<Require>().disconnect(&obs), ...);
-            (reg.template on_construct<Reject>().disconnect(&obs), ...);
-            (reg.template on_construct<AllOf>().disconnect(&obs), ...);
-            (reg.template on_destroy<NoneOf>().disconnect(&obs), ...);
-            (reg.template on_destroy<AllOf>().disconnect(&obs), ...);
-            (reg.template on_construct<NoneOf>().disconnect(&obs), ...);
+        static void connect(storage_type &storage, Registry &parent) {
+            (parent.template on_destroy<Require>().template connect<&discard_if<Index>>(storage), ...);
+            (parent.template on_construct<Reject>().template connect<&discard_if<Index>>(storage), ...);
+            (parent.template on_construct<AllOf>().template connect<&maybe_valid_if<Index>>(storage), ...);
+            (parent.template on_destroy<NoneOf>().template connect<&maybe_valid_if<Index, NoneOf>>(storage), ...);
+            (parent.template on_destroy<AllOf>().template connect<&discard_if<Index>>(storage), ...);
+            (parent.template on_construct<NoneOf>().template connect<&discard_if<Index>>(storage), ...);
+        }
+
+        static void disconnect(storage_type &storage, Registry &parent) {
+            (parent.template on_destroy<Require>().disconnect(&storage), ...);
+            (parent.template on_construct<Reject>().disconnect(&storage), ...);
+            (parent.template on_construct<AllOf>().disconnect(&storage), ...);
+            (parent.template on_destroy<NoneOf>().disconnect(&storage), ...);
+            (parent.template on_destroy<AllOf>().disconnect(&storage), ...);
+            (parent.template on_construct<NoneOf>().disconnect(&storage), ...);
         }
     };
 
     template<typename... Matcher>
-    static void disconnect(Registry &reg, basic_observer &obs) {
-        (matcher_handler<Matcher>::disconnect(obs, reg), ...);
+    static void disconnect(Registry &parent, storage_type &storage) {
+        (matcher_handler<Matcher>::disconnect(storage, parent), ...);
     }
 
     template<typename... Matcher, std::size_t... Index>
-    void connect(Registry &reg, std::index_sequence<Index...>) {
-        static_assert(sizeof...(Matcher) < std::numeric_limits<typename base_type::value_type>::digits, "Too many matchers");
-        (matcher_handler<Matcher>::template connect<Index>(*this, reg), ...);
-        release.template connect<&basic_observer::disconnect<Matcher...>>(reg);
+    static void connect(Registry &parent, storage_type &storage, std::index_sequence<Index...>) {
+        static_assert(sizeof...(Matcher) < std::numeric_limits<mask_type>::digits, "Too many matchers");
+        (matcher_handler<Matcher>::template connect<Index>(storage, parent), ...);
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! Basic registry type. */
     using registry_type = Registry;
     /*! @brief Underlying entity identifier. */
     using entity_type = typename registry_type::entity_type;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Random access iterator type. */
     using iterator = typename registry_type::common_type::iterator;
 
@@ -24823,8 +25921,9 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      * @param allocator The allocator to use.
      */
     explicit basic_observer(const allocator_type &allocator)
-        : base_type{allocator},
-          release{} {}
+        : release{},
+          parent{},
+          storage{allocator} {}
 
     /*! @brief Default copy constructor, deleted on purpose. */
     basic_observer(const basic_observer &) = delete;
@@ -24840,10 +25939,15 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      */
     template<typename... Matcher>
     basic_observer(registry_type &reg, basic_collector<Matcher...>, const allocator_type &allocator = allocator_type{})
-        : basic_observer{allocator} {
-        connect<Matcher...>(reg, std::index_sequence_for<Matcher...>{});
+        : release{&basic_observer::disconnect<Matcher...>},
+          parent{&reg},
+          storage{allocator} {
+        connect<Matcher...>(reg, storage, std::index_sequence_for<Matcher...>{});
     }
 
+    /*! @brief Default destructor. */
+    ~basic_observer() = default;
+
     /**
      * @brief Default copy assignment operator, deleted on purpose.
      * @return This observer.
@@ -24864,15 +25968,18 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
     template<typename... Matcher>
     void connect(registry_type &reg, basic_collector<Matcher...>) {
         disconnect();
-        connect<Matcher...>(reg, std::index_sequence_for<Matcher...>{});
-        base_type::clear();
+        storage.clear();
+
+        parent = &reg;
+        release = &basic_observer::disconnect<Matcher...>;
+        connect<Matcher...>(reg, storage, std::index_sequence_for<Matcher...>{});
     }
 
     /*! @brief Disconnects an observer from the registry it keeps track of. */
     void disconnect() {
         if(release) {
-            release(*this);
-            release.reset();
+            release(*parent, storage);
+            release = nullptr;
         }
     }
 
@@ -24881,7 +25988,7 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      * @return Number of elements.
      */
     [[nodiscard]] size_type size() const noexcept {
-        return base_type::size();
+        return storage.size();
     }
 
     /**
@@ -24889,7 +25996,7 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      * @return True if the observer is empty, false otherwise.
      */
     [[nodiscard]] bool empty() const noexcept {
-        return base_type::empty();
+        return storage.empty();
     }
 
     /**
@@ -24905,7 +26012,7 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      * @return A pointer to the array of entities.
      */
     [[nodiscard]] const entity_type *data() const noexcept {
-        return base_type::data();
+        return storage.data();
     }
 
     /**
@@ -24916,7 +26023,7 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      * @return An iterator to the first entity of the observer.
      */
     [[nodiscard]] iterator begin() const noexcept {
-        return base_type::base_type::begin();
+        return storage.storage_type::base_type::begin();
     }
 
     /**
@@ -24925,12 +26032,12 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
      * observer.
      */
     [[nodiscard]] iterator end() const noexcept {
-        return base_type::base_type::end();
+        return storage.storage_type::base_type::end();
     }
 
     /*! @brief Clears the underlying container. */
     void clear() noexcept {
-        base_type::clear();
+        storage.clear();
     }
 
     /**
@@ -24969,7 +26076,9 @@ class basic_observer: private basic_storage<Mask, typename Registry::entity_type
     }
 
 private:
-    delegate<void(basic_observer &)> release;
+    void (*release)(registry_type &, storage_type &);
+    registry_type *parent;
+    storage_type storage;
 };
 
 } // namespace entt
@@ -25113,23 +26222,33 @@ struct y_combinator {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -25169,7 +26288,7 @@ struct y_combinator {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -25187,6 +26306,12 @@ struct y_combinator {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -25209,6 +26334,8 @@ struct y_combinator {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/iterator.hpp"
@@ -25361,7 +26488,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -25370,7 +26497,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -25433,23 +26560,33 @@ struct iterable_adaptor final {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -25489,7 +26626,7 @@ struct iterable_adaptor final {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -25507,6 +26644,12 @@ struct iterable_adaptor final {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -25529,11 +26672,14 @@ struct iterable_adaptor final {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -25543,6 +26689,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -25587,13 +26748,9 @@ class edge_iterator {
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    constexpr edge_iterator() noexcept
-        : it{},
-          vert{},
-          pos{},
-          last{},
-          offset{} {}
+    constexpr edge_iterator() noexcept = default;
 
+    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
     constexpr edge_iterator(It base, const size_type vertices, const size_type from, const size_type to, const size_type step) noexcept
         : it{std::move(base)},
           vert{vertices},
@@ -25625,10 +26782,10 @@ class edge_iterator {
     friend constexpr bool operator==(const edge_iterator<Type> &, const edge_iterator<Type> &) noexcept;
 
 private:
-    It it;
-    size_type vert;
-    size_type pos;
-    size_type last;
+    It it{};
+    size_type vert{};
+    size_type pos{};
+    size_type last{};
     size_type offset{};
 };
 
@@ -25670,16 +26827,17 @@ class adjacency_matrix {
     using vertex_iterator = iota_iterator<vertex_type>;
     /*! @brief Edge iterator type. */
     using edge_iterator = internal::edge_iterator<typename container_type::const_iterator>;
-    /*! @brief Out edge iterator type. */
+    /*! @brief Out-edge iterator type. */
     using out_edge_iterator = edge_iterator;
-    /*! @brief In edge iterator type. */
+    /*! @brief In-edge iterator type. */
     using in_edge_iterator = edge_iterator;
     /*! @brief Graph category tag. */
     using graph_category = Category;
 
     /*! @brief Default constructor. */
     adjacency_matrix() noexcept(noexcept(allocator_type{}))
-        : adjacency_matrix{0u} {}
+        : adjacency_matrix{0u} {
+    }
 
     /**
      * @brief Constructs an empty container with a given allocator.
@@ -25698,12 +26856,8 @@ class adjacency_matrix {
         : matrix{vertices * vertices, allocator},
           vert{vertices} {}
 
-    /**
-     * @brief Copy constructor.
-     * @param other The instance to copy from.
-     */
-    adjacency_matrix(const adjacency_matrix &other)
-        : adjacency_matrix{other, other.get_allocator()} {}
+    /*! @brief Default copy constructor. */
+    adjacency_matrix(const adjacency_matrix &) = default;
 
     /**
      * @brief Allocator-extended copy constructor.
@@ -25714,12 +26868,8 @@ class adjacency_matrix {
         : matrix{other.matrix, allocator},
           vert{other.vert} {}
 
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    adjacency_matrix(adjacency_matrix &&other) noexcept
-        : adjacency_matrix{std::move(other), other.get_allocator()} {}
+    /*! @brief Default move constructor. */
+    adjacency_matrix(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -25728,29 +26878,22 @@ class adjacency_matrix {
      */
     adjacency_matrix(adjacency_matrix &&other, const allocator_type &allocator)
         : matrix{std::move(other.matrix), allocator},
-          vert{std::exchange(other.vert, 0u)} {}
+          vert{other.vert} {}
+
+    /*! @brief Default destructor. */
+    ~adjacency_matrix() = default;
 
     /**
      * @brief Default copy assignment operator.
-     * @param other The instance to copy from.
      * @return This container.
      */
-    adjacency_matrix &operator=(const adjacency_matrix &other) {
-        matrix = other.matrix;
-        vert = other.vert;
-        return *this;
-    }
+    adjacency_matrix &operator=(const adjacency_matrix &) = default;
 
     /**
      * @brief Default move assignment operator.
-     * @param other The instance to move from.
      * @return This container.
      */
-    adjacency_matrix &operator=(adjacency_matrix &&other) noexcept {
-        matrix = std::move(other.matrix);
-        vert = std::exchange(other.vert, 0u);
-        return *this;
-    }
+    adjacency_matrix &operator=(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -25770,12 +26913,25 @@ class adjacency_matrix {
      * @brief Exchanges the contents with those of a given adjacency matrix.
      * @param other Adjacency matrix to exchange the content with.
      */
-    void swap(adjacency_matrix &other) {
+    void swap(adjacency_matrix &other) noexcept {
         using std::swap;
         swap(matrix, other.matrix);
         swap(vert, other.vert);
     }
 
+    /**
+     * @brief Returns true if an adjacency matrix is empty, false otherwise.
+     *
+     * @warning
+     * Potentially expensive, try to avoid it on hot paths.
+     *
+     * @return True if the adjacency matrix is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        const auto iterable = edges();
+        return (iterable.begin() == iterable.end());
+    }
+
     /**
      * @brief Returns the number of vertices.
      * @return The number of vertices.
@@ -25803,9 +26959,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all out edges of a vertex.
-     * @param vertex The vertex of which to return all out edges.
-     * @return An iterable object to visit all out edges of a vertex.
+     * @brief Returns an iterable object to visit all out-edges of a vertex.
+     * @param vertex The vertex of which to return all out-edges.
+     * @return An iterable object to visit all out-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<out_edge_iterator> out_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -25815,9 +26971,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all in edges of a vertex.
-     * @param vertex The vertex of which to return all in edges.
-     * @return An iterable object to visit all in edges of a vertex.
+     * @brief Returns an iterable object to visit all in-edges of a vertex.
+     * @param vertex The vertex of which to return all in-edges.
+     * @return An iterable object to visit all in-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<in_edge_iterator> in_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -25939,23 +27095,33 @@ class adjacency_matrix {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -25995,7 +27161,7 @@ class adjacency_matrix {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -26013,6 +27179,12 @@ class adjacency_matrix {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -26035,25 +27207,17 @@ class adjacency_matrix {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -26066,23 +27230,33 @@ class adjacency_matrix {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -26122,7 +27296,7 @@ class adjacency_matrix {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -26140,6 +27314,12 @@ class adjacency_matrix {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -26162,8 +27342,81 @@ class adjacency_matrix {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
 #endif
 
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -26174,6 +27427,7 @@ class adjacency_matrix {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -26183,10 +27437,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -26753,7 +28035,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -26761,12 +28043,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -26951,14 +28230,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -26972,6 +28248,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -27052,9 +28329,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -27070,8 +28347,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -27110,9 +28390,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -27131,7 +28411,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -27140,7 +28420,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -27195,7 +28475,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -27203,13 +28483,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -27219,7 +28499,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -27231,23 +28511,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -27279,7 +28562,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -27292,7 +28575,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -27303,7 +28586,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -27335,8 +28618,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -27359,7 +28640,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -27513,7 +28793,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -27522,7 +28802,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -27567,7 +28847,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -27577,44 +28856,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -27841,7 +29082,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -28427,7 +29668,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -28435,12 +29676,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -28625,14 +29863,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -28646,6 +29881,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -28726,9 +29962,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -28744,8 +29980,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -28780,6 +30019,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -28787,17 +30027,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -28907,7 +30157,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -29052,6 +30302,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -29110,7 +30361,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -29126,6 +30377,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -29138,8 +30391,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -29189,8 +30440,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -29208,7 +30458,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -29220,6 +30470,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -29230,7 +30483,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -29462,7 +30715,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -29478,7 +30731,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -29807,7 +31060,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -29840,9 +31093,9 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #include <vector>
 // #include "../config/config.h"
 
-// #include "../core/compressed_pair.hpp"
+// #include "../core/bit.hpp"
 
-// #include "../core/memory.hpp"
+// #include "../core/compressed_pair.hpp"
 
 // #include "../core/type_traits.hpp"
 
@@ -29917,11 +31170,11 @@ class dense_set_iterator final {
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return std::addressof(it->second);
+        return std::addressof(operator[](0));
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -30103,7 +31356,7 @@ class dense_set {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + value_to_bucket(packed.first().back().second);
+            size_type *curr = &sparse.first()[value_to_bucket(packed.first().back().second)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].first) {}
             *curr = pos;
@@ -30119,6 +31372,8 @@ class dense_set {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Type;
     /*! @brief Value type of the container. */
@@ -30129,8 +31384,6 @@ class dense_set {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the elements for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Random access iterator type. */
     using iterator = internal::dense_set_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant random access iterator type. */
@@ -30184,8 +31437,7 @@ class dense_set {
      */
     explicit dense_set(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -30203,7 +31455,7 @@ class dense_set {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_set(dense_set &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set(dense_set &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -30215,6 +31467,9 @@ class dense_set {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_set() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -30225,7 +31480,7 @@ class dense_set {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_set &operator=(dense_set &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set &operator=(dense_set &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -30441,7 +31696,7 @@ class dense_set {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const value_type &value) {
-        for(size_type *curr = sparse.first().data() + value_to_bucket(value); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
+        for(size_type *curr = &sparse.first()[value_to_bucket(value)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
             if(packed.second()(packed.first()[*curr].second, value)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].first;
@@ -30457,7 +31712,7 @@ class dense_set {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_set &other) {
+    void swap(dense_set &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -30749,7 +32004,7 @@ class dense_set {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -30764,17 +32019,6 @@ class dense_set {
 #include <tuple>
 #include <type_traits>
 #include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
-
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -30785,6 +32029,7 @@ class dense_set {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -30794,10 +32039,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -31364,7 +32637,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -31372,12 +32645,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -31562,14 +32832,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -31583,6 +32850,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -31663,9 +32931,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -31681,8 +32949,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -31721,9 +32992,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -31742,7 +33013,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -31751,7 +33022,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -31806,7 +33077,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -31814,13 +33085,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -31830,7 +33101,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -31842,23 +33113,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -31890,7 +33164,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -31903,7 +33177,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -31914,7 +33188,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -31946,8 +33220,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -31970,7 +33242,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -32115,13 +33386,9 @@ class edge_iterator {
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    constexpr edge_iterator() noexcept
-        : it{},
-          vert{},
-          pos{},
-          last{},
-          offset{} {}
+    constexpr edge_iterator() noexcept = default;
 
+    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
     constexpr edge_iterator(It base, const size_type vertices, const size_type from, const size_type to, const size_type step) noexcept
         : it{std::move(base)},
           vert{vertices},
@@ -32153,10 +33420,10 @@ class edge_iterator {
     friend constexpr bool operator==(const edge_iterator<Type> &, const edge_iterator<Type> &) noexcept;
 
 private:
-    It it;
-    size_type vert;
-    size_type pos;
-    size_type last;
+    It it{};
+    size_type vert{};
+    size_type pos{};
+    size_type last{};
     size_type offset{};
 };
 
@@ -32198,16 +33465,17 @@ class adjacency_matrix {
     using vertex_iterator = iota_iterator<vertex_type>;
     /*! @brief Edge iterator type. */
     using edge_iterator = internal::edge_iterator<typename container_type::const_iterator>;
-    /*! @brief Out edge iterator type. */
+    /*! @brief Out-edge iterator type. */
     using out_edge_iterator = edge_iterator;
-    /*! @brief In edge iterator type. */
+    /*! @brief In-edge iterator type. */
     using in_edge_iterator = edge_iterator;
     /*! @brief Graph category tag. */
     using graph_category = Category;
 
     /*! @brief Default constructor. */
     adjacency_matrix() noexcept(noexcept(allocator_type{}))
-        : adjacency_matrix{0u} {}
+        : adjacency_matrix{0u} {
+    }
 
     /**
      * @brief Constructs an empty container with a given allocator.
@@ -32226,12 +33494,8 @@ class adjacency_matrix {
         : matrix{vertices * vertices, allocator},
           vert{vertices} {}
 
-    /**
-     * @brief Copy constructor.
-     * @param other The instance to copy from.
-     */
-    adjacency_matrix(const adjacency_matrix &other)
-        : adjacency_matrix{other, other.get_allocator()} {}
+    /*! @brief Default copy constructor. */
+    adjacency_matrix(const adjacency_matrix &) = default;
 
     /**
      * @brief Allocator-extended copy constructor.
@@ -32242,12 +33506,8 @@ class adjacency_matrix {
         : matrix{other.matrix, allocator},
           vert{other.vert} {}
 
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    adjacency_matrix(adjacency_matrix &&other) noexcept
-        : adjacency_matrix{std::move(other), other.get_allocator()} {}
+    /*! @brief Default move constructor. */
+    adjacency_matrix(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -32256,29 +33516,22 @@ class adjacency_matrix {
      */
     adjacency_matrix(adjacency_matrix &&other, const allocator_type &allocator)
         : matrix{std::move(other.matrix), allocator},
-          vert{std::exchange(other.vert, 0u)} {}
+          vert{other.vert} {}
+
+    /*! @brief Default destructor. */
+    ~adjacency_matrix() = default;
 
     /**
      * @brief Default copy assignment operator.
-     * @param other The instance to copy from.
      * @return This container.
      */
-    adjacency_matrix &operator=(const adjacency_matrix &other) {
-        matrix = other.matrix;
-        vert = other.vert;
-        return *this;
-    }
+    adjacency_matrix &operator=(const adjacency_matrix &) = default;
 
     /**
      * @brief Default move assignment operator.
-     * @param other The instance to move from.
      * @return This container.
      */
-    adjacency_matrix &operator=(adjacency_matrix &&other) noexcept {
-        matrix = std::move(other.matrix);
-        vert = std::exchange(other.vert, 0u);
-        return *this;
-    }
+    adjacency_matrix &operator=(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -32298,12 +33551,25 @@ class adjacency_matrix {
      * @brief Exchanges the contents with those of a given adjacency matrix.
      * @param other Adjacency matrix to exchange the content with.
      */
-    void swap(adjacency_matrix &other) {
+    void swap(adjacency_matrix &other) noexcept {
         using std::swap;
         swap(matrix, other.matrix);
         swap(vert, other.vert);
     }
 
+    /**
+     * @brief Returns true if an adjacency matrix is empty, false otherwise.
+     *
+     * @warning
+     * Potentially expensive, try to avoid it on hot paths.
+     *
+     * @return True if the adjacency matrix is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        const auto iterable = edges();
+        return (iterable.begin() == iterable.end());
+    }
+
     /**
      * @brief Returns the number of vertices.
      * @return The number of vertices.
@@ -32331,9 +33597,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all out edges of a vertex.
-     * @param vertex The vertex of which to return all out edges.
-     * @return An iterable object to visit all out edges of a vertex.
+     * @brief Returns an iterable object to visit all out-edges of a vertex.
+     * @param vertex The vertex of which to return all out-edges.
+     * @return An iterable object to visit all out-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<out_edge_iterator> out_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -32343,9 +33609,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all in edges of a vertex.
-     * @param vertex The vertex of which to return all in edges.
-     * @return An iterable object to visit all in edges of a vertex.
+     * @brief Returns an iterable object to visit all in-edges of a vertex.
+     * @param vertex The vertex of which to return all in-edges.
+     * @return An iterable object to visit all in-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<in_edge_iterator> in_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -32440,9 +33706,9 @@ template<typename Allocator>
 class basic_flow {
     using alloc_traits = std::allocator_traits<Allocator>;
     static_assert(std::is_same_v<typename alloc_traits::value_type, id_type>, "Invalid value type");
-    using task_container_type = dense_set<id_type, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<id_type>>;
+    using task_container_type = dense_set<id_type, identity, std::equal_to<>, typename alloc_traits::template rebind_alloc<id_type>>;
     using ro_rw_container_type = std::vector<std::pair<std::size_t, bool>, typename alloc_traits::template rebind_alloc<std::pair<std::size_t, bool>>>;
-    using deps_container_type = dense_map<id_type, ro_rw_container_type, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, ro_rw_container_type>>>;
+    using deps_container_type = dense_map<id_type, ro_rw_container_type, identity, std::equal_to<>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, ro_rw_container_type>>>;
     using adjacency_matrix_type = adjacency_matrix<directed_tag, typename alloc_traits::template rebind_alloc<std::size_t>>;
 
     void emplace(const id_type res, const bool is_rw) {
@@ -32546,8 +33812,7 @@ class basic_flow {
     explicit basic_flow(const allocator_type &allocator)
         : index{0u, allocator},
           vertices{allocator},
-          deps{allocator},
-          sync_on{} {}
+          deps{allocator} {}
 
     /*! @brief Default copy constructor. */
     basic_flow(const basic_flow &) = default;
@@ -32577,6 +33842,9 @@ class basic_flow {
           deps{std::move(other.deps), allocator},
           sync_on{other.sync_on} {}
 
+    /*! @brief Default destructor. */
+    ~basic_flow() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This flow builder.
@@ -32618,7 +33886,7 @@ class basic_flow {
      * @brief Exchanges the contents with those of a given flow builder.
      * @param other Flow builder to exchange the content with.
      */
-    void swap(basic_flow &other) {
+    void swap(basic_flow &other) noexcept {
         using std::swap;
         std::swap(index, other.index);
         std::swap(vertices, other.vertices);
@@ -32626,6 +33894,14 @@ class basic_flow {
         std::swap(sync_on, other.sync_on);
     }
 
+    /**
+     * @brief Returns true if a flow builder contains no tasks, false otherwise.
+     * @return True if the flow builder contains no tasks, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        return vertices.empty();
+    }
+
     /**
      * @brief Returns the number of tasks.
      * @return The number of tasks.
@@ -32744,7 +34020,7 @@ class basic_flow {
     compressed_pair<size_type, allocator_type> index;
     task_container_type vertices;
     deps_container_type deps;
-    size_type sync_on;
+    size_type sync_on{};
 };
 
 } // namespace entt
@@ -32764,7 +34040,7 @@ class basic_flow {
 
 // #include "../core/type_traits.hpp"
 
-// #include "../signal/delegate.hpp"
+// #include "component.hpp"
 
 // #include "fwd.hpp"
 
@@ -32784,8 +34060,8 @@ namespace entt {
 template<typename Registry>
 class as_view {
     template<typename... Get, typename... Exclude>
-    auto dispatch(get_t<Get...>, exclude_t<Exclude...>) const {
-        return reg.template view<constness_as_t<typename Get::value_type, Get>...>(exclude_t<constness_as_t<typename Exclude::value_type, Exclude>...>{});
+    [[nodiscard]] auto dispatch(get_t<Get...>, exclude_t<Exclude...>) const {
+        return reg.template view<constness_as_t<typename Get::element_type, Get>...>(exclude_t<constness_as_t<typename Exclude::element_type, Exclude>...>{});
     }
 
 public:
@@ -32823,11 +34099,11 @@ class as_view {
 template<typename Registry>
 class as_group {
     template<typename... Owned, typename... Get, typename... Exclude>
-    auto dispatch(owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>) const {
+    [[nodiscard]] auto dispatch(owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>) const {
         if constexpr(std::is_const_v<registry_type>) {
-            return reg.template group_if_exists<typename Owned::value_type...>(get_t<typename Get::value_type...>{}, exclude_t<typename Exclude::value_type...>{});
+            return reg.template group_if_exists<typename Owned::element_type...>(get_t<typename Get::element_type...>{}, exclude_t<typename Exclude::element_type...>{});
         } else {
-            return reg.template group<constness_as_t<typename Owned::value_type, Owned>...>(get_t<constness_as_t<typename Get::value_type, Get>...>{}, exclude_t<constness_as_t<typename Exclude::value_type, Exclude>...>{});
+            return reg.template group<constness_as_t<typename Owned::element_type, Owned>...>(get_t<constness_as_t<typename Get::element_type, Get>...>{}, exclude_t<constness_as_t<typename Exclude::element_type, Exclude>...>{});
         }
     }
 
@@ -32862,39 +34138,38 @@ class as_group {
 
 /**
  * @brief Helper to create a listener that directly invokes a member function.
- * @tparam Member Member function to invoke on a component of the given type.
+ * @tparam Member Member function to invoke on an element of the given type.
  * @tparam Registry Basic registry type.
- * @param reg A registry that contains the given entity and its components.
- * @param entt Entity from which to get the component.
+ * @param reg A registry that contains the given entity and its elements.
+ * @param entt Entity from which to get the element.
  */
 template<auto Member, typename Registry = std::decay_t<nth_argument_t<0u, decltype(Member)>>>
 void invoke(Registry &reg, const typename Registry::entity_type entt) {
     static_assert(std::is_member_function_pointer_v<decltype(Member)>, "Invalid pointer to non-static member function");
-    delegate<void(Registry &, const typename Registry::entity_type)> func;
-    func.template connect<Member>(reg.template get<member_class_t<decltype(Member)>>(entt));
-    func(reg, entt);
+    (reg.template get<member_class_t<decltype(Member)>>(entt).*Member)(reg, entt);
 }
 
 /**
- * @brief Returns the entity associated with a given component.
+ * @brief Returns the entity associated with a given element.
  *
  * @warning
  * Currently, this function only works correctly with the default storage as it
- * makes assumptions about how the components are laid out.
+ * makes assumptions about how the elements are laid out.
  *
  * @tparam Args Storage type template parameters.
- * @param storage A storage that contains the given component.
- * @param instance A valid component instance.
- * @return The entity associated with the given component.
+ * @param storage A storage that contains the given element.
+ * @param instance A valid element instance.
+ * @return The entity associated with the given element.
  */
 template<typename... Args>
-auto to_entity(const basic_storage<Args...> &storage, const typename basic_storage<Args...>::value_type &instance) -> typename basic_storage<Args...>::entity_type {
-    constexpr auto page_size = basic_storage<Args...>::traits_type::page_size;
+typename basic_storage<Args...>::entity_type to_entity(const basic_storage<Args...> &storage, const typename basic_storage<Args...>::value_type &instance) {
+    using traits_type = component_traits<typename basic_storage<Args...>::value_type>;
+    static_assert(traits_type::page_size != 0u, "Unexpected page size");
     const typename basic_storage<Args...>::base_type &base = storage;
     const auto *addr = std::addressof(instance);
 
-    for(auto it = base.rbegin(), last = base.rend(); it < last; it += page_size) {
-        if(const auto dist = (addr - std::addressof(storage.get(*it))); dist >= 0 && dist < static_cast<decltype(dist)>(page_size)) {
+    for(auto it = base.rbegin(), last = base.rend(); it < last; it += traits_type::page_size) {
+        if(const auto dist = (addr - std::addressof(storage.get(*it))); dist >= 0 && dist < static_cast<decltype(dist)>(traits_type::page_size)) {
             return *(it + dist);
         }
     }
@@ -32902,23 +34177,6 @@ auto to_entity(const basic_storage<Args...> &storage, const typename basic_stora
     return null;
 }
 
-/**
- * @copybrief to_entity
- * @tparam Args Registry type template parameters.
- * @tparam Component Type of component.
- * @param reg A registry that contains the given entity and its components.
- * @param instance A valid component instance.
- * @return The entity associated with the given component.
- */
-template<typename... Args, typename Component>
-[[deprecated("use storage based to_entity instead")]] typename basic_registry<Args...>::entity_type to_entity(const basic_registry<Args...> &reg, const Component &instance) {
-    if(const auto *storage = reg.template storage<Component>(); storage) {
-        return to_entity(*storage, instance);
-    }
-
-    return null;
-}
-
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
 struct sigh_helper;
@@ -33075,8 +34333,8 @@ struct unpack_type<const basic_registry<Args...>, type_list<Override...>>
 
 template<typename... Get, typename... Exclude, typename... Override>
 struct unpack_type<basic_view<get_t<Get...>, exclude_t<Exclude...>>, type_list<Override...>> {
-    using ro = type_list_cat_t<type_list<typename Exclude::value_type...>, typename unpack_type<constness_as_t<typename Get::value_type, Get>, type_list<Override...>>::ro...>;
-    using rw = type_list_cat_t<typename unpack_type<constness_as_t<typename Get::value_type, Get>, type_list<Override...>>::rw...>;
+    using ro = type_list_cat_t<type_list<typename Exclude::element_type...>, typename unpack_type<constness_as_t<typename Get::element_type, Get>, type_list<Override...>>::ro...>;
+    using rw = type_list_cat_t<typename unpack_type<constness_as_t<typename Get::element_type, Get>, type_list<Override...>>::rw...>;
 };
 
 template<typename... Get, typename... Exclude, typename... Override>
@@ -33131,7 +34389,7 @@ class basic_organizer final {
         const char *name{};
         const void *payload{};
         callback_type *callback{};
-        dependency_type *dependency;
+        dependency_type *dependency{};
         prepare_type *prepare{};
         const type_info *info{};
     };
@@ -33153,14 +34411,16 @@ class basic_organizer final {
     }
 
     template<typename... Type>
-    static std::size_t fill_dependencies(type_list<Type...>, [[maybe_unused]] const type_info **buffer, [[maybe_unused]] const std::size_t count) {
+    [[nodiscard]] static std::size_t fill_dependencies(type_list<Type...>, [[maybe_unused]] const type_info **buffer, [[maybe_unused]] const std::size_t count) {
         if constexpr(sizeof...(Type) == 0u) {
             return {};
         } else {
-            const type_info *info[sizeof...(Type)]{&type_id<Type>()...};
+            // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+            const type_info *info[]{&type_id<Type>()...};
             const auto length = count < sizeof...(Type) ? count : sizeof...(Type);
 
             for(std::size_t pos{}; pos < length; ++pos) {
+                // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)
                 buffer[pos] = info[pos];
             }
 
@@ -33190,14 +34450,14 @@ class basic_organizer final {
     struct vertex {
         /**
          * @brief Constructs a vertex of the task graph.
-         * @param vtype True if the vertex is a top-level one, false otherwise.
          * @param data The data associated with the vertex.
-         * @param edges The indices of the children in the adjacency list.
+         * @param from List of in-edges of the vertex.
+         * @param to List of out-edges of the vertex.
          */
-        vertex(const bool vtype, vertex_data data, std::vector<std::size_t> edges)
-            : is_top_level{vtype},
-              node{std::move(data)},
-              reachable{std::move(edges)} {}
+        vertex(vertex_data data, std::vector<std::size_t> from, std::vector<std::size_t> to)
+            : node{std::move(data)},
+              in{std::move(from)},
+              out{std::move(to)} {}
 
         /**
          * @brief Fills a buffer with the type info objects for the writable
@@ -33206,7 +34466,7 @@ class basic_organizer final {
          * @param length The length of the user-supplied buffer.
          * @return The number of type info objects written to the buffer.
          */
-        size_type ro_dependency(const type_info **buffer, const std::size_t length) const noexcept {
+        [[nodiscard]] size_type ro_dependency(const type_info **buffer, const std::size_t length) const noexcept {
             return node.dependency(false, buffer, length);
         }
 
@@ -33217,7 +34477,7 @@ class basic_organizer final {
          * @param length The length of the user-supplied buffer.
          * @return The number of type info objects written to the buffer.
          */
-        size_type rw_dependency(const type_info **buffer, const std::size_t length) const noexcept {
+        [[nodiscard]] size_type rw_dependency(const type_info **buffer, const std::size_t length) const noexcept {
             return node.dependency(true, buffer, length);
         }
 
@@ -33225,7 +34485,7 @@ class basic_organizer final {
          * @brief Returns the number of read-only resources of a vertex.
          * @return The number of read-only resources of the vertex.
          */
-        size_type ro_count() const noexcept {
+        [[nodiscard]] size_type ro_count() const noexcept {
             return node.ro_count;
         }
 
@@ -33233,7 +34493,7 @@ class basic_organizer final {
          * @brief Returns the number of writable resources of a vertex.
          * @return The number of writable resources of the vertex.
          */
-        size_type rw_count() const noexcept {
+        [[nodiscard]] size_type rw_count() const noexcept {
             return node.rw_count;
         }
 
@@ -33241,15 +34501,15 @@ class basic_organizer final {
          * @brief Checks if a vertex is also a top-level one.
          * @return True if the vertex is a top-level one, false otherwise.
          */
-        bool top_level() const noexcept {
-            return is_top_level;
+        [[nodiscard]] bool top_level() const noexcept {
+            return in.empty();
         }
 
         /**
          * @brief Returns a type info object associated with a vertex.
          * @return A properly initialized type info object.
          */
-        const type_info &info() const noexcept {
+        [[nodiscard]] const type_info &info() const noexcept {
             return *node.info;
         }
 
@@ -33257,7 +34517,7 @@ class basic_organizer final {
          * @brief Returns a user defined name associated with a vertex, if any.
          * @return The user defined name associated with the vertex, if any.
          */
-        const char *name() const noexcept {
+        [[nodiscard]] const char *name() const noexcept {
             return node.name;
         }
 
@@ -33265,7 +34525,7 @@ class basic_organizer final {
          * @brief Returns the function associated with a vertex.
          * @return The function associated with the vertex.
          */
-        function_type *callback() const noexcept {
+        [[nodiscard]] function_type *callback() const noexcept {
             return node.callback;
         }
 
@@ -33273,16 +34533,32 @@ class basic_organizer final {
          * @brief Returns the payload associated with a vertex, if any.
          * @return The payload associated with the vertex, if any.
          */
-        const void *data() const noexcept {
+        [[nodiscard]] const void *data() const noexcept {
             return node.payload;
         }
 
+        /**
+         * @brief Returns the list of in-edges of a vertex.
+         * @return The list of in-edges of a vertex.
+         */
+        [[nodiscard]] const std::vector<std::size_t> &in_edges() const noexcept {
+            return in;
+        }
+
+        /**
+         * @brief Returns the list of out-edges of a vertex.
+         * @return The list of out-edges of a vertex.
+         */
+        [[nodiscard]] const std::vector<std::size_t> &out_edges() const noexcept {
+            return out;
+        }
+
         /**
          * @brief Returns the list of nodes reachable from a given vertex.
          * @return The list of nodes reachable from the vertex.
          */
-        const std::vector<std::size_t> &children() const noexcept {
-            return reachable;
+        [[deprecated("use ::out_edges")]] [[nodiscard]] const std::vector<std::size_t> &children() const noexcept {
+            return out_edges();
         }
 
         /**
@@ -33295,9 +34571,9 @@ class basic_organizer final {
         }
 
     private:
-        bool is_top_level;
         vertex_data node;
-        std::vector<std::size_t> reachable;
+        std::vector<std::size_t> in;
+        std::vector<std::size_t> out;
     };
 
     /**
@@ -33392,20 +34668,24 @@ class basic_organizer final {
      * @brief Generates a task graph for the current content.
      * @return The adjacency list of the task graph.
      */
-    std::vector<vertex> graph() {
+    [[nodiscard]] std::vector<vertex> graph() {
         std::vector<vertex> adjacency_list{};
         adjacency_list.reserve(vertices.size());
         auto adjacency_matrix = builder.graph();
 
         for(auto curr: adjacency_matrix.vertices()) {
-            const auto iterable = adjacency_matrix.in_edges(curr);
-            std::vector<std::size_t> reachable{};
+            std::vector<std::size_t> in{};
+            std::vector<std::size_t> out{};
+
+            for(auto &&edge: adjacency_matrix.in_edges(curr)) {
+                in.push_back(edge.first);
+            }
 
             for(auto &&edge: adjacency_matrix.out_edges(curr)) {
-                reachable.push_back(edge.second);
+                out.push_back(edge.second);
             }
 
-            adjacency_list.emplace_back(iterable.cbegin() == iterable.cend(), vertices[curr], std::move(reachable));
+            adjacency_list.emplace_back(vertices[curr], std::move(in), std::move(out));
         }
 
         return adjacency_list;
@@ -33426,11 +34706,40 @@ class basic_organizer final {
 
 #endif
 
+// #include "entity/ranges.hpp"
+#ifndef ENTT_ENTITY_RANGES_HPP
+#define ENTT_ENTITY_RANGES_HPP
+
+#if __has_include(<version>)
+#    include <version>
+#
+#    if defined(__cpp_lib_ranges)
+#        include <ranges>
+// #        include "fwd.hpp"
+
+
+template<class... Args>
+inline constexpr bool std::ranges::enable_borrowed_range<entt::basic_view<Args...>>{true};
+
+template<class... Args>
+inline constexpr bool std::ranges::enable_borrowed_range<entt::basic_group<Args...>>{true};
+
+template<class... Args>
+inline constexpr bool std::ranges::enable_view<entt::basic_view<Args...>>{true};
+
+template<class... Args>
+inline constexpr bool std::ranges::enable_view<entt::basic_group<Args...>>{true};
+
+#    endif
+#endif
+
+#endif
 // #include "entity/registry.hpp"
 #ifndef ENTT_ENTITY_REGISTRY_HPP
 #define ENTT_ENTITY_REGISTRY_HPP
 
 #include <algorithm>
+#include <array>
 #include <cstddef>
 #include <functional>
 #include <iterator>
@@ -33467,23 +34776,33 @@ class basic_organizer final {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -33523,7 +34842,7 @@ class basic_organizer final {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -33541,6 +34860,12 @@ class basic_organizer final {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -33563,25 +34888,17 @@ class basic_organizer final {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+#endif
 
-#include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -33594,23 +34911,33 @@ class basic_organizer final {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -33650,7 +34977,7 @@ class basic_organizer final {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -33668,6 +34995,12 @@ class basic_organizer final {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -33690,8 +35023,81 @@ class basic_organizer final {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
 #endif
 
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -33702,6 +35108,7 @@ class basic_organizer final {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -33711,10 +35118,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -34281,7 +35716,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -34289,12 +35724,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -34479,14 +35911,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -34500,6 +35929,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -34580,9 +36010,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -34598,8 +36028,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -34638,9 +36071,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -34659,7 +36092,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -34668,7 +36101,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -34723,7 +36156,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -34731,13 +36164,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -34747,7 +36180,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -34759,23 +36192,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -34807,7 +36243,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -34820,7 +36256,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -34831,7 +36267,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -34863,8 +36299,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -34887,7 +36321,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -35041,7 +36474,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -35050,7 +36483,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -35095,7 +36528,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -35105,44 +36537,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -35369,7 +36763,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -35955,7 +37349,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -35963,12 +37357,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -36153,14 +37544,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -36174,6 +37562,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -36254,9 +37643,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -36272,8 +37661,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -36308,6 +37700,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -36315,17 +37708,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -36435,7 +37838,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -36580,6 +37983,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -36638,7 +38042,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -36654,6 +38058,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -36666,8 +38072,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -36717,8 +38121,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -36736,7 +38139,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -36748,6 +38151,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -36758,7 +38164,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -36990,7 +38396,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -37006,7 +38412,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -37335,7 +38741,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -37384,6 +38790,8 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 
 // #include "../core/any.hpp"
 
+// #include "../core/type_info.hpp"
+
 // #include "../signal/sigh.hpp"
 
 // #include "entity.hpp"
@@ -37393,6 +38801,47 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 
 namespace entt {
 
+/*! @cond TURN_OFF_DOXYGEN */
+namespace internal {
+
+template<typename, typename, typename = void>
+struct has_on_construct final: std::false_type {};
+
+template<typename Type, typename Registry>
+struct has_on_construct<Type, Registry, std::void_t<decltype(Type::on_construct(std::declval<Registry &>(), std::declval<Registry>().create()))>>
+    : std::true_type {};
+
+template<typename, typename, typename = void>
+struct has_on_update final: std::false_type {};
+
+template<typename Type, typename Registry>
+struct has_on_update<Type, Registry, std::void_t<decltype(Type::on_update(std::declval<Registry &>(), std::declval<Registry>().create()))>>
+    : std::true_type {};
+
+template<typename, typename, typename = void>
+struct has_on_destroy final: std::false_type {};
+
+template<typename Type, typename Registry>
+struct has_on_destroy<Type, Registry, std::void_t<decltype(Type::on_destroy(std::declval<Registry &>(), std::declval<Registry>().create()))>>
+    : std::true_type {};
+
+template<typename Type>
+auto *any_to_owner(any &value) noexcept {
+    using base_type = basic_registry<typename Type::entity_type, typename Type::allocator_type>;
+    auto *reg = any_cast<base_type>(&value);
+
+    if constexpr(!std::is_same_v<Type, base_type>) {
+        if(!reg) {
+            reg = any_cast<Type>(&value);
+        }
+    }
+
+    return reg;
+}
+
+} // namespace internal
+/*! @endcond */
+
 /**
  * @brief Mixin type used to add signal support to storage types.
  *
@@ -37412,17 +38861,18 @@ class basic_sigh_mixin final: public Type {
     using underlying_type = Type;
     using owner_type = Registry;
 
-    using basic_registry_type = basic_registry<typename underlying_type::entity_type, typename underlying_type::base_type::allocator_type>;
+    using basic_registry_type = basic_registry<typename owner_type::entity_type, typename owner_type::allocator_type>;
     using sigh_type = sigh<void(owner_type &, const typename underlying_type::entity_type), typename underlying_type::allocator_type>;
     using underlying_iterator = typename underlying_type::base_type::basic_iterator;
 
     static_assert(std::is_base_of_v<basic_registry_type, owner_type>, "Invalid registry type");
 
-    owner_type &owner_or_assert() const noexcept {
+    [[nodiscard]] auto &owner_or_assert() const noexcept {
         ENTT_ASSERT(owner != nullptr, "Invalid pointer to registry");
         return static_cast<owner_type &>(*owner);
     }
 
+private:
     void pop(underlying_iterator first, underlying_iterator last) final {
         if(auto &reg = owner_or_assert(); destruction.empty()) {
             underlying_type::pop(first, last);
@@ -37438,16 +38888,18 @@ class basic_sigh_mixin final: public Type {
 
     void pop_all() final {
         if(auto &reg = owner_or_assert(); !destruction.empty()) {
-            for(auto it = underlying_type::base_type::begin(0), last = underlying_type::base_type::end(0); it != last; ++it) {
-                if constexpr(std::is_same_v<typename underlying_type::value_type, typename underlying_type::entity_type>) {
-                    destruction.publish(reg, *it);
-                } else {
-                    if constexpr(underlying_type::traits_type::in_place_delete) {
-                        if(const auto entt = *it; entt != tombstone) {
+            if constexpr(std::is_same_v<typename underlying_type::element_type, entity_type>) {
+                for(typename underlying_type::size_type pos{}, last = underlying_type::free_list(); pos < last; ++pos) {
+                    destruction.publish(reg, underlying_type::base_type::operator[](pos));
+                }
+            } else {
+                for(auto entt: static_cast<typename underlying_type::base_type &>(*this)) {
+                    if constexpr(underlying_type::storage_policy == deletion_policy::in_place) {
+                        if(entt != tombstone) {
                             destruction.publish(reg, entt);
                         }
                     } else {
-                        destruction.publish(reg, *it);
+                        destruction.publish(reg, entt);
                     }
                 }
             }
@@ -37466,6 +38918,11 @@ class basic_sigh_mixin final: public Type {
         return it;
     }
 
+    void bind_any(any value) noexcept final {
+        owner = internal::any_to_owner<registry_type>(value);
+        underlying_type::bind_any(std::move(value));
+    }
+
 public:
     /*! @brief Allocator type. */
     using allocator_type = typename underlying_type::allocator_type;
@@ -37487,7 +38944,22 @@ class basic_sigh_mixin final: public Type {
           owner{},
           construction{allocator},
           destruction{allocator},
-          update{allocator} {}
+          update{allocator} {
+        if constexpr(internal::has_on_construct<typename underlying_type::element_type, Registry>::value) {
+            entt::sink{construction}.template connect<&underlying_type::element_type::on_construct>();
+        }
+
+        if constexpr(internal::has_on_update<typename underlying_type::element_type, Registry>::value) {
+            entt::sink{update}.template connect<&underlying_type::element_type::on_update>();
+        }
+
+        if constexpr(internal::has_on_destroy<typename underlying_type::element_type, Registry>::value) {
+            entt::sink{destruction}.template connect<&underlying_type::element_type::on_destroy>();
+        }
+    }
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_sigh_mixin(const basic_sigh_mixin &) = delete;
 
     /**
      * @brief Move constructor.
@@ -37505,24 +38977,29 @@ class basic_sigh_mixin final: public Type {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_sigh_mixin(basic_sigh_mixin &&other, const allocator_type &allocator) noexcept
+    basic_sigh_mixin(basic_sigh_mixin &&other, const allocator_type &allocator)
         : underlying_type{std::move(other), allocator},
           owner{other.owner},
           construction{std::move(other.construction), allocator},
           destruction{std::move(other.destruction), allocator},
           update{std::move(other.update), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~basic_sigh_mixin() override = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This mixin.
+     */
+    basic_sigh_mixin &operator=(const basic_sigh_mixin &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
-     * @return This storage.
+     * @return This mixin.
      */
     basic_sigh_mixin &operator=(basic_sigh_mixin &&other) noexcept {
-        underlying_type::operator=(std::move(other));
-        owner = other.owner;
-        construction = std::move(other.construction);
-        destruction = std::move(other.destruction);
-        update = std::move(other.update);
+        swap(other);
         return *this;
     }
 
@@ -37530,13 +39007,13 @@ class basic_sigh_mixin final: public Type {
      * @brief Exchanges the contents with those of a given storage.
      * @param other Storage to exchange the content with.
      */
-    void swap(basic_sigh_mixin &other) {
+    void swap(basic_sigh_mixin &other) noexcept {
         using std::swap;
-        underlying_type::swap(other);
         swap(owner, other.owner);
         swap(construction, other.construction);
         swap(destruction, other.destruction);
         swap(update, other.update);
+        underlying_type::swap(other);
     }
 
     /**
@@ -37584,6 +39061,27 @@ class basic_sigh_mixin final: public Type {
         return sink{destruction};
     }
 
+    /**
+     * @brief Checks if a mixin refers to a valid registry.
+     * @return True if the mixin refers to a valid registry, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return (owner != nullptr);
+    }
+
+    /**
+     * @brief Returns a pointer to the underlying registry, if any.
+     * @return A pointer to the underlying registry, if any.
+     */
+    [[nodiscard]] const registry_type &registry() const noexcept {
+        return owner_or_assert();
+    }
+
+    /*! @copydoc registry */
+    [[nodiscard]] registry_type &registry() noexcept {
+        return owner_or_assert();
+    }
+
     /**
      * @brief Emplace elements into a storage.
      *
@@ -37591,7 +39089,7 @@ class basic_sigh_mixin final: public Type {
      * (for example, components vs entities).<br/>
      * Refer to the specific documentation for more details.
      *
-     * @return A return value as returned by the underlying storage.
+     * @return Whatever the underlying storage returns.
      */
     auto emplace() {
         const auto entt = underlying_type::emplace();
@@ -37609,11 +39107,12 @@ class basic_sigh_mixin final: public Type {
      * @tparam Args Types of arguments to forward to the underlying storage.
      * @param hint A valid identifier.
      * @param args Parameters to forward to the underlying storage.
-     * @return A return value as returned by the underlying storage.
+     * @return Whatever the underlying storage returns.
      */
     template<typename... Args>
-    decltype(auto) emplace(const entity_type hint, Args &&...args) {
-        if constexpr(std::is_same_v<typename underlying_type::value_type, typename underlying_type::entity_type>) {
+    std::conditional_t<std::is_same_v<typename underlying_type::element_type, entity_type>, entity_type, decltype(std::declval<underlying_type>().get({}))>
+    emplace(const entity_type hint, Args &&...args) {
+        if constexpr(std::is_same_v<typename underlying_type::element_type, entity_type>) {
             const auto entt = underlying_type::emplace(hint, std::forward<Args>(args)...);
             construction.publish(owner_or_assert(), entt);
             return entt;
@@ -37663,21 +39162,199 @@ class basic_sigh_mixin final: public Type {
         }
     }
 
+private:
+    basic_registry_type *owner;
+    sigh_type construction;
+    sigh_type destruction;
+    sigh_type update;
+};
+
+/**
+ * @brief Mixin type used to add _reactive_ support to storage types.
+ * @tparam Type Underlying storage type.
+ * @tparam Registry Basic registry type.
+ */
+template<typename Type, typename Registry>
+class basic_reactive_mixin final: public Type {
+    using underlying_type = Type;
+    using owner_type = Registry;
+
+    using basic_registry_type = basic_registry<typename owner_type::entity_type, typename owner_type::allocator_type>;
+
+    static_assert(std::is_base_of_v<basic_registry_type, owner_type>, "Invalid registry type");
+
+    [[nodiscard]] auto &owner_or_assert() const noexcept {
+        ENTT_ASSERT(owner != nullptr, "Invalid pointer to registry");
+        return static_cast<owner_type &>(*owner);
+    }
+
+    void emplace_element(const Registry &, typename underlying_type::entity_type entity) {
+        if(!underlying_type::contains(entity)) {
+            underlying_type::emplace(entity);
+        }
+    }
+
+private:
+    void bind_any(any value) noexcept final {
+        owner = internal::any_to_owner<registry_type>(value);
+        underlying_type::bind_any(std::move(value));
+    }
+
+public:
+    /*! @brief Allocator type. */
+    using allocator_type = typename underlying_type::allocator_type;
+    /*! @brief Underlying entity identifier. */
+    using entity_type = typename underlying_type::entity_type;
+    /*! @brief Expected registry type. */
+    using registry_type = owner_type;
+
+    /*! @brief Default constructor. */
+    basic_reactive_mixin()
+        : basic_reactive_mixin{allocator_type{}} {}
+
     /**
-     * @brief Forwards variables to derived classes, if any.
-     * @param value A variable wrapped in an opaque container.
+     * @brief Constructs an empty storage with a given allocator.
+     * @param allocator The allocator to use.
+     */
+    explicit basic_reactive_mixin(const allocator_type &allocator)
+        : underlying_type{allocator},
+          owner{} {
+    }
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_reactive_mixin(const basic_reactive_mixin &) = delete;
+
+    /**
+     * @brief Move constructor.
+     * @param other The instance to move from.
+     */
+    basic_reactive_mixin(basic_reactive_mixin &&other) noexcept
+        : underlying_type{std::move(other)},
+          owner{other.owner} {}
+
+    /**
+     * @brief Allocator-extended move constructor.
+     * @param other The instance to move from.
+     * @param allocator The allocator to use.
+     */
+    basic_reactive_mixin(basic_reactive_mixin &&other, const allocator_type &allocator)
+        : underlying_type{std::move(other), allocator},
+          owner{other.owner} {}
+
+    /*! @brief Default destructor. */
+    ~basic_reactive_mixin() override = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This mixin.
+     */
+    basic_reactive_mixin &operator=(const basic_reactive_mixin &) = delete;
+
+    /**
+     * @brief Move assignment operator.
+     * @param other The instance to move from.
+     * @return This mixin.
+     */
+    basic_reactive_mixin &operator=(basic_reactive_mixin &&other) noexcept {
+        swap(other);
+        return *this;
+    }
+
+    /**
+     * @brief Exchanges the contents with those of a given storage.
+     * @param other Storage to exchange the content with.
+     */
+    void swap(basic_reactive_mixin &other) noexcept {
+        using std::swap;
+        swap(owner, other.owner);
+        underlying_type::swap(other);
+    }
+
+    /**
+     * @brief Makes storage _react_ to creation of objects of the given type.
+     * @tparam Clazz Type of element to _react_ to.
+     * @tparam Candidate Function to use to _react_ to the event.
+     * @param id Optional name used to map the storage within the registry.
+     * @return This mixin.
+     */
+    template<typename Clazz, auto Candidate = &basic_reactive_mixin::emplace_element>
+    basic_reactive_mixin &on_construct(const id_type id = type_hash<Clazz>::value()) {
+        owner_or_assert().template storage<Clazz>(id).on_construct().template connect<Candidate>(*this);
+        return *this;
+    }
+
+    /**
+     * @brief Makes storage _react_ to update of objects of the given type.
+     * @tparam Clazz Type of element to _react_ to.
+     * @tparam Candidate Function to use to _react_ to the event.
+     * @param id Optional name used to map the storage within the registry.
+     * @return This mixin.
      */
-    void bind(any value) noexcept final {
-        auto *reg = any_cast<basic_registry_type>(&value);
-        owner = reg ? reg : owner;
-        underlying_type::bind(std::move(value));
+    template<typename Clazz, auto Candidate = &basic_reactive_mixin::emplace_element>
+    basic_reactive_mixin &on_update(const id_type id = type_hash<Clazz>::value()) {
+        owner_or_assert().template storage<Clazz>(id).on_update().template connect<Candidate>(*this);
+        return *this;
+    }
+
+    /**
+     * @brief Makes storage _react_ to destruction of objects of the given type.
+     * @tparam Clazz Type of element to _react_ to.
+     * @tparam Candidate Function to use to _react_ to the event.
+     * @param id Optional name used to map the storage within the registry.
+     * @return This mixin.
+     */
+    template<typename Clazz, auto Candidate = &basic_reactive_mixin::emplace_element>
+    basic_reactive_mixin &on_destroy(const id_type id = type_hash<Clazz>::value()) {
+        owner_or_assert().template storage<Clazz>(id).on_destroy().template connect<Candidate>(*this);
+        return *this;
+    }
+
+    /**
+     * @brief Checks if a mixin refers to a valid registry.
+     * @return True if the mixin refers to a valid registry, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return (owner != nullptr);
+    }
+
+    /**
+     * @brief Returns a pointer to the underlying registry, if any.
+     * @return A pointer to the underlying registry, if any.
+     */
+    [[nodiscard]] const registry_type &registry() const noexcept {
+        return owner_or_assert();
+    }
+
+    /*! @copydoc registry */
+    [[nodiscard]] registry_type &registry() noexcept {
+        return owner_or_assert();
+    }
+
+    /**
+     * @brief Returns a view that is filtered by the underlying storage.
+     * @tparam Get Types of elements used to construct the view.
+     * @tparam Exclude Types of elements used to filter the view.
+     * @return A newly created view.
+     */
+    template<typename... Get, typename... Exclude>
+    [[nodiscard]] basic_view<get_t<const basic_reactive_mixin, typename basic_registry_type::template storage_for_type<const Get>...>, exclude_t<typename basic_registry_type::template storage_for_type<const Exclude>...>>
+    view(exclude_t<Exclude...> = exclude_t{}) const {
+        const owner_type &parent = owner_or_assert();
+        basic_view<get_t<const basic_reactive_mixin, typename basic_registry_type::template storage_for_type<const Get>...>, exclude_t<typename basic_registry_type::template storage_for_type<const Exclude>...>> elem{};
+        [&elem](const auto *...curr) { ((curr ? elem.storage(*curr) : void()), ...); }(parent.template storage<std::remove_const_t<Exclude>>()..., parent.template storage<std::remove_const_t<Get>>()..., this);
+        return elem;
+    }
+
+    /*! @copydoc view */
+    template<typename... Get, typename... Exclude>
+    [[nodiscard]] basic_view<get_t<const basic_reactive_mixin, typename basic_registry_type::template storage_for_type<Get>...>, exclude_t<typename basic_registry_type::template storage_for_type<Exclude>...>>
+    view(exclude_t<Exclude...> = exclude_t{}) {
+        owner_type &parent = owner_or_assert();
+        return {*this, parent.template storage<std::remove_const_t<Get>>()..., parent.template storage<std::remove_const_t<Exclude>>()...};
     }
 
 private:
     basic_registry_type *owner;
-    sigh_type construction;
-    sigh_type destruction;
-    sigh_type update;
 };
 
 } // namespace entt
@@ -37762,7 +39439,7 @@ class registry_storage_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->first, *it->second};
+        return operator[](0);
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
@@ -37881,7 +39558,7 @@ class registry_context {
     }
 
 private:
-    dense_map<id_type, basic_any<0u>, identity, std::equal_to<id_type>, allocator_type> ctx;
+    dense_map<id_type, basic_any<0u>, identity, std::equal_to<>, allocator_type> ctx;
 };
 
 } // namespace internal
@@ -37895,39 +39572,42 @@ class registry_context {
 template<typename Entity, typename Allocator>
 class basic_registry {
     using base_type = basic_sparse_set<Entity, Allocator>;
-
     using alloc_traits = std::allocator_traits<Allocator>;
     static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
-
     // std::shared_ptr because of its type erased allocator which is useful here
-    using pool_container_type = dense_map<id_type, std::shared_ptr<base_type>, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, std::shared_ptr<base_type>>>>;
-    using group_container_type = dense_map<id_type, std::shared_ptr<internal::group_descriptor>, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, std::shared_ptr<internal::group_descriptor>>>>;
+    using pool_container_type = dense_map<id_type, std::shared_ptr<base_type>, identity, std::equal_to<>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, std::shared_ptr<base_type>>>>;
+    using group_container_type = dense_map<id_type, std::shared_ptr<internal::group_descriptor>, identity, std::equal_to<>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, std::shared_ptr<internal::group_descriptor>>>>;
+    using traits_type = entt_traits<Entity>;
 
     template<typename Type>
     [[nodiscard]] auto &assure([[maybe_unused]] const id_type id = type_hash<Type>::value()) {
         static_assert(std::is_same_v<Type, std::decay_t<Type>>, "Non-decayed types not allowed");
 
         if constexpr(std::is_same_v<Type, entity_type>) {
+            ENTT_ASSERT(id == type_hash<Type>::value(), "User entity storage not allowed");
             return entities;
         } else {
-            auto &cpool = pools[id];
+            using storage_type = storage_for_type<Type>;
 
-            if(!cpool) {
-                using storage_type = storage_for_type<Type>;
-                using alloc_type = typename storage_type::allocator_type;
+            if(auto it = pools.find(id); it != pools.cend()) {
+                ENTT_ASSERT(it->second->type() == type_id<Type>(), "Unexpected type");
+                return static_cast<storage_type &>(*it->second);
+            }
 
-                if constexpr(std::is_void_v<Type> && !std::is_constructible_v<alloc_type, allocator_type>) {
-                    // std::allocator<void> has no cross constructors (waiting for C++20)
-                    cpool = std::allocate_shared<storage_type>(get_allocator(), alloc_type{});
-                } else {
-                    cpool = std::allocate_shared<storage_type>(get_allocator(), get_allocator());
-                }
+            using alloc_type = typename storage_type::allocator_type;
+            typename pool_container_type::mapped_type cpool{};
 
-                cpool->bind(forward_as_any(*this));
+            if constexpr(std::is_void_v<Type> && !std::is_constructible_v<alloc_type, allocator_type>) {
+                // std::allocator<void> has no cross constructors (waiting for C++20)
+                cpool = std::allocate_shared<storage_type>(get_allocator(), alloc_type{});
+            } else {
+                cpool = std::allocate_shared<storage_type>(get_allocator(), get_allocator());
             }
 
-            ENTT_ASSERT(cpool->type() == type_id<Type>(), "Unexpected type");
-            return static_cast<storage_for_type<Type> &>(*cpool);
+            pools.emplace(id, cpool);
+            cpool->bind(*this);
+
+            return static_cast<storage_type &>(*cpool);
         }
     }
 
@@ -37936,6 +39616,7 @@ class basic_registry {
         static_assert(std::is_same_v<Type, std::decay_t<Type>>, "Non-decayed types not allowed");
 
         if constexpr(std::is_same_v<Type, entity_type>) {
+            ENTT_ASSERT(id == type_hash<Type>::value(), "User entity storage not allowed");
             return &entities;
         } else {
             if(const auto it = pools.find(id); it != pools.cend()) {
@@ -37948,16 +39629,14 @@ class basic_registry {
     }
 
     void rebind() {
-        entities.bind(forward_as_any(*this));
+        entities.bind(*this);
 
         for(auto &&curr: pools) {
-            curr.second->bind(forward_as_any(*this));
+            curr.second->bind(*this);
         }
     }
 
 public:
-    /*! @brief Entity traits. */
-    using traits_type = typename base_type::traits_type;
     /*! @brief Allocator type. */
     using allocator_type = Allocator;
     /*! @brief Underlying entity identifier. */
@@ -38007,6 +39686,9 @@ class basic_registry {
         rebind();
     }
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_registry(const basic_registry &) = delete;
+
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
@@ -38019,19 +39701,22 @@ class basic_registry {
         rebind();
     }
 
+    /*! @brief Default destructor. */
+    ~basic_registry() = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This mixin.
+     */
+    basic_registry &operator=(const basic_registry &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This registry.
      */
     basic_registry &operator=(basic_registry &&other) noexcept {
-        vars = std::move(other.vars);
-        pools = std::move(other.pools);
-        groups = std::move(other.groups);
-        entities = std::move(other.entities);
-
-        rebind();
-
+        swap(other);
         return *this;
     }
 
@@ -38039,7 +39724,7 @@ class basic_registry {
      * @brief Exchanges the contents with those of a given registry.
      * @param other Registry to exchange the content with.
      */
-    void swap(basic_registry &other) {
+    void swap(basic_registry &other) noexcept {
         using std::swap;
 
         swap(vars, other.vars);
@@ -38068,12 +39753,12 @@ class basic_registry {
      * @return An iterable object to use to _visit_ the registry.
      */
     [[nodiscard]] iterable storage() noexcept {
-        return iterable_adaptor{internal::registry_storage_iterator{pools.begin()}, internal::registry_storage_iterator{pools.end()}};
+        return iterable{pools.begin(), pools.end()};
     }
 
     /*! @copydoc storage */
     [[nodiscard]] const_iterable storage() const noexcept {
-        return iterable_adaptor{internal::registry_storage_iterator{pools.cbegin()}, internal::registry_storage_iterator{pools.cend()}};
+        return const_iterable{pools.cbegin(), pools.cend()};
     }
 
     /**
@@ -38096,10 +39781,10 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns the storage for a given component type.
-     * @tparam Type Type of component of which to return the storage.
+     * @brief Returns the storage for a given element type.
+     * @tparam Type Type of element of which to return the storage.
      * @param id Optional name used to map the storage within the registry.
-     * @return The storage for the given component type.
+     * @return The storage for the given element type.
      */
     template<typename Type>
     storage_for_type<Type> &storage(const id_type id = type_hash<Type>::value()) {
@@ -38107,23 +39792,33 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
      * @param id Optional name used to map the storage within the registry.
-     * @return The storage for the given component type.
+     * @return The storage for the given element type.
      */
     template<typename Type>
-    const storage_for_type<Type> *storage(const id_type id = type_hash<Type>::value()) const {
+    [[nodiscard]] const storage_for_type<Type> *storage(const id_type id = type_hash<Type>::value()) const {
         return assure<Type>(id);
     }
 
+    /**
+     * @brief Discards the storage associated with a given name, if any.
+     * @param id Name used to map the storage within the registry.
+     * @return True in case of success, false otherwise.
+     */
+    bool reset(const id_type id) {
+        ENTT_ASSERT(id != type_hash<entity_type>::value(), "Cannot reset entity storage");
+        return !(pools.erase(id) == 0u);
+    }
+
     /**
      * @brief Checks if an identifier refers to a valid entity.
      * @param entt An identifier, either valid or not.
      * @return True if the identifier is valid, false otherwise.
      */
     [[nodiscard]] bool valid(const entity_type entt) const {
-        return entities.contains(entt) && (entities.index(entt) < entities.free_list());
+        return static_cast<size_type>(entities.find(entt).index()) < entities.free_list();
     }
 
     /**
@@ -38175,14 +39870,14 @@ class basic_registry {
      * @brief Destroys an entity and releases its identifier.
      *
      * @warning
-     * Adding or removing components to an entity that is being destroyed can
+     * Adding or removing elements to an entity that is being destroyed can
      * result in undefined behavior.
      *
      * @param entt A valid identifier.
      * @return The version of the recycled entity.
      */
     version_type destroy(const entity_type entt) {
-        for(size_type pos = pools.size(); pos; --pos) {
+        for(size_type pos = pools.size(); pos != 0u; --pos) {
             pools.begin()[pos - 1u].second->remove(entt);
         }
 
@@ -38219,10 +39914,8 @@ class basic_registry {
      */
     template<typename It>
     void destroy(It first, It last) {
-        entities.sort_as(first, last);
-
-        const auto from = entities.cbegin(0);
-        const auto to = from + std::distance(first, last);
+        const auto to = entities.sort_as(first, last);
+        const auto from = entities.cend() - entities.free_list();
 
         for(auto &&curr: pools) {
             curr.second->remove(from, to);
@@ -38232,81 +39925,82 @@ class basic_registry {
     }
 
     /**
-     * @brief Assigns the given component to an entity.
+     * @brief Assigns the given element to an entity.
      *
-     * The component must have a proper constructor or be of aggregate type.
+     * The element must have a proper constructor or be of aggregate type.
      *
      * @warning
-     * Attempting to assign a component to an entity that already owns it
-     * results in undefined behavior.
+     * Attempting to assign an element to an entity that already owns it results
+     * in undefined behavior.
      *
-     * @tparam Type Type of component to create.
-     * @tparam Args Types of arguments to use to construct the component.
+     * @tparam Type Type of element to create.
+     * @tparam Args Types of arguments to use to construct the element.
      * @param entt A valid identifier.
-     * @param args Parameters to use to initialize the component.
-     * @return A reference to the newly created component.
+     * @param args Parameters to use to initialize the element.
+     * @return A reference to the newly created element.
      */
     template<typename Type, typename... Args>
     decltype(auto) emplace(const entity_type entt, Args &&...args) {
+        ENTT_ASSERT(valid(entt), "Invalid entity");
         return assure<Type>().emplace(entt, std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Assigns each entity in a range the given component.
+     * @brief Assigns each entity in a range the given element.
      *
      * @sa emplace
      *
-     * @tparam Type Type of component to create.
+     * @tparam Type Type of element to create.
      * @tparam It Type of input iterator.
      * @param first An iterator to the first element of the range of entities.
      * @param last An iterator past the last element of the range of entities.
-     * @param value An instance of the component to assign.
+     * @param value An instance of the element to assign.
      */
     template<typename Type, typename It>
     void insert(It first, It last, const Type &value = {}) {
+        ENTT_ASSERT(std::all_of(first, last, [this](const auto entt) { return valid(entt); }), "Invalid entity");
         assure<Type>().insert(std::move(first), std::move(last), value);
     }
 
     /**
-     * @brief Assigns each entity in a range the given components.
+     * @brief Assigns each entity in a range the given elements.
      *
      * @sa emplace
      *
-     * @tparam Type Type of component to create.
+     * @tparam Type Type of element to create.
      * @tparam EIt Type of input iterator.
      * @tparam CIt Type of input iterator.
      * @param first An iterator to the first element of the range of entities.
      * @param last An iterator past the last element of the range of entities.
-     * @param from An iterator to the first element of the range of components.
+     * @param from An iterator to the first element of the range of elements.
      */
     template<typename Type, typename EIt, typename CIt, typename = std::enable_if_t<std::is_same_v<typename std::iterator_traits<CIt>::value_type, Type>>>
     void insert(EIt first, EIt last, CIt from) {
+        ENTT_ASSERT(std::all_of(first, last, [this](const auto entt) { return valid(entt); }), "Invalid entity");
         assure<Type>().insert(first, last, from);
     }
 
     /**
-     * @brief Assigns or replaces the given component for an entity.
+     * @brief Assigns or replaces the given element for an entity.
      *
      * @sa emplace
      * @sa replace
      *
-     * @tparam Type Type of component to assign or replace.
-     * @tparam Args Types of arguments to use to construct the component.
+     * @tparam Type Type of element to assign or replace.
+     * @tparam Args Types of arguments to use to construct the element.
      * @param entt A valid identifier.
-     * @param args Parameters to use to initialize the component.
-     * @return A reference to the newly created component.
+     * @param args Parameters to use to initialize the element.
+     * @return A reference to the newly created element.
      */
     template<typename Type, typename... Args>
     decltype(auto) emplace_or_replace(const entity_type entt, Args &&...args) {
-        if(auto &cpool = assure<Type>(); cpool.contains(entt)) {
-            return cpool.patch(entt, [&args...](auto &...curr) { ((curr = Type{std::forward<Args>(args)...}), ...); });
-        } else {
-            return cpool.emplace(entt, std::forward<Args>(args)...);
-        }
+        auto &cpool = assure<Type>();
+        ENTT_ASSERT(valid(entt), "Invalid entity");
+        return cpool.contains(entt) ? cpool.patch(entt, [&args...](auto &...curr) { ((curr = Type{std::forward<Args>(args)...}), ...); }) : cpool.emplace(entt, std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Patches the given component for an entity.
+     * @brief Patches the given element for an entity.
      *
      * The signature of the function should be equivalent to the following:
      *
@@ -38315,14 +40009,14 @@ class basic_registry {
      * @endcode
      *
      * @warning
-     * Attempting to patch a component of an entity that doesn't own it
-     * results in undefined behavior.
+     * Attempting to patch an element of an entity that doesn't own it results
+     * in undefined behavior.
      *
-     * @tparam Type Type of component to patch.
+     * @tparam Type Type of element to patch.
      * @tparam Func Types of the function objects to invoke.
      * @param entt A valid identifier.
      * @param func Valid function objects.
-     * @return A reference to the patched component.
+     * @return A reference to the patched element.
      */
     template<typename Type, typename... Func>
     decltype(auto) patch(const entity_type entt, Func &&...func) {
@@ -38330,19 +40024,19 @@ class basic_registry {
     }
 
     /**
-     * @brief Replaces the given component for an entity.
+     * @brief Replaces the given element for an entity.
      *
-     * The component must have a proper constructor or be of aggregate type.
+     * The element must have a proper constructor or be of aggregate type.
      *
      * @warning
-     * Attempting to replace a component of an entity that doesn't own it
-     * results in undefined behavior.
+     * Attempting to replace an element of an entity that doesn't own it results
+     * in undefined behavior.
      *
-     * @tparam Type Type of component to replace.
-     * @tparam Args Types of arguments to use to construct the component.
+     * @tparam Type Type of element to replace.
+     * @tparam Args Types of arguments to use to construct the element.
      * @param entt A valid identifier.
-     * @param args Parameters to use to initialize the component.
-     * @return A reference to the component being replaced.
+     * @param args Parameters to use to initialize the element.
+     * @return A reference to the element being replaced.
      */
     template<typename Type, typename... Args>
     decltype(auto) replace(const entity_type entt, Args &&...args) {
@@ -38350,11 +40044,11 @@ class basic_registry {
     }
 
     /**
-     * @brief Removes the given components from an entity.
-     * @tparam Type Type of component to remove.
-     * @tparam Other Other types of components to remove.
+     * @brief Removes the given elements from an entity.
+     * @tparam Type Type of element to remove.
+     * @tparam Other Other types of elements to remove.
      * @param entt A valid identifier.
-     * @return The number of components actually removed.
+     * @return The number of elements actually removed.
      */
     template<typename Type, typename... Other>
     size_type remove(const entity_type entt) {
@@ -38362,33 +40056,34 @@ class basic_registry {
     }
 
     /**
-     * @brief Removes the given components from all the entities in a range.
+     * @brief Removes the given elements from all the entities in a range.
      *
      * @sa remove
      *
-     * @tparam Type Type of component to remove.
-     * @tparam Other Other types of components to remove.
+     * @tparam Type Type of element to remove.
+     * @tparam Other Other types of elements to remove.
      * @tparam It Type of input iterator.
      * @param first An iterator to the first element of the range of entities.
      * @param last An iterator past the last element of the range of entities.
-     * @return The number of components actually removed.
+     * @return The number of elements actually removed.
      */
     template<typename Type, typename... Other, typename It>
     size_type remove(It first, It last) {
         size_type count{};
 
         if constexpr(std::is_same_v<It, typename common_type::iterator>) {
-            common_type *cpools[sizeof...(Other) + 1u]{&assure<Type>(), &assure<Other>()...};
+            std::array cpools{static_cast<common_type *>(&assure<Type>()), static_cast<common_type *>(&assure<Other>())...};
 
-            for(size_type pos{}, len = sizeof...(Other) + 1u; pos < len; ++pos) {
+            for(auto from = cpools.begin(), to = cpools.end(); from != to; ++from) {
                 if constexpr(sizeof...(Other) != 0u) {
-                    if(cpools[pos]->data() == first.data()) {
-                        std::swap(cpools[pos], cpools[sizeof...(Other)]);
+                    if((*from)->data() == first.data()) {
+                        std::swap((*from), cpools.back());
                     }
                 }
 
-                count += cpools[pos]->remove(first, last);
+                count += (*from)->remove(first, last);
             }
+
         } else {
             for(auto cpools = std::forward_as_tuple(assure<Type>(), assure<Other>()...); first != last; ++first) {
                 count += std::apply([entt = *first](auto &...curr) { return (curr.remove(entt) + ... + 0u); }, cpools);
@@ -38399,14 +40094,14 @@ class basic_registry {
     }
 
     /**
-     * @brief Erases the given components from an entity.
+     * @brief Erases the given elements from an entity.
      *
      * @warning
-     * Attempting to erase a component from an entity that doesn't own it
-     * results in undefined behavior.
+     * Attempting to erase an element from an entity that doesn't own it results
+     * in undefined behavior.
      *
-     * @tparam Type Types of components to erase.
-     * @tparam Other Other types of components to erase.
+     * @tparam Type Types of elements to erase.
+     * @tparam Other Other types of elements to erase.
      * @param entt A valid identifier.
      */
     template<typename Type, typename... Other>
@@ -38415,12 +40110,12 @@ class basic_registry {
     }
 
     /**
-     * @brief Erases the given components from all the entities in a range.
+     * @brief Erases the given elements from all the entities in a range.
      *
      * @sa erase
      *
-     * @tparam Type Types of components to erase.
-     * @tparam Other Other types of components to erase.
+     * @tparam Type Types of elements to erase.
+     * @tparam Other Other types of elements to erase.
      * @tparam It Type of input iterator.
      * @param first An iterator to the first element of the range of entities.
      * @param last An iterator past the last element of the range of entities.
@@ -38428,16 +40123,16 @@ class basic_registry {
     template<typename Type, typename... Other, typename It>
     void erase(It first, It last) {
         if constexpr(std::is_same_v<It, typename common_type::iterator>) {
-            common_type *cpools[sizeof...(Other) + 1u]{&assure<Type>(), &assure<Other>()...};
+            std::array cpools{static_cast<common_type *>(&assure<Type>()), static_cast<common_type *>(&assure<Other>())...};
 
-            for(size_type pos{}, len = sizeof...(Other) + 1u; pos < len; ++pos) {
+            for(auto from = cpools.begin(), to = cpools.end(); from != to; ++from) {
                 if constexpr(sizeof...(Other) != 0u) {
-                    if(cpools[pos]->data() == first.data()) {
-                        std::swap(cpools[pos], cpools[sizeof...(Other)]);
+                    if((*from)->data() == first.data()) {
+                        std::swap(*from, cpools.back());
                     }
                 }
 
-                cpools[pos]->erase(first, last);
+                (*from)->erase(first, last);
             }
         } else {
             for(auto cpools = std::forward_as_tuple(assure<Type>(), assure<Other>()...); first != last; ++first) {
@@ -38447,12 +40142,12 @@ class basic_registry {
     }
 
     /**
-     * @brief Erases components satisfying specific criteria from an entity.
+     * @brief Erases elements satisfying specific criteria from an entity.
      *
      * The function type is equivalent to:
      *
      * @code{.cpp}
-     * void(const id_type, typename basic_registry<Entity>::base_type &);
+     * void(const id_type, typename basic_registry<Entity>::common_type &);
      * @endcode
      *
      * Only storage where the entity exists are passed to the function.
@@ -38472,8 +40167,8 @@ class basic_registry {
 
     /**
      * @brief Removes all tombstones from a registry or only the pools for the
-     * given components.
-     * @tparam Type Types of components for which to clear all tombstones.
+     * given elements.
+     * @tparam Type Types of elements for which to clear all tombstones.
      */
     template<typename... Type>
     void compact() {
@@ -38515,15 +40210,15 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns references to the given components for an entity.
+     * @brief Returns references to the given elements for an entity.
      *
      * @warning
-     * Attempting to get a component from an entity that doesn't own it results
+     * Attempting to get an element from an entity that doesn't own it results
      * in undefined behavior.
      *
-     * @tparam Type Types of components to get.
+     * @tparam Type Types of elements to get.
      * @param entt A valid identifier.
-     * @return References to the components owned by the entity.
+     * @return References to the elements owned by the entity.
      */
     template<typename... Type>
     [[nodiscard]] decltype(auto) get([[maybe_unused]] const entity_type entt) const {
@@ -38545,38 +40240,36 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns a reference to the given component for an entity.
+     * @brief Returns a reference to the given element for an entity.
      *
-     * In case the entity doesn't own the component, the parameters provided are
+     * In case the entity doesn't own the element, the parameters provided are
      * used to construct it.
      *
      * @sa get
      * @sa emplace
      *
-     * @tparam Type Type of component to get.
-     * @tparam Args Types of arguments to use to construct the component.
+     * @tparam Type Type of element to get.
+     * @tparam Args Types of arguments to use to construct the element.
      * @param entt A valid identifier.
-     * @param args Parameters to use to initialize the component.
-     * @return Reference to the component owned by the entity.
+     * @param args Parameters to use to initialize the element.
+     * @return Reference to the element owned by the entity.
      */
     template<typename Type, typename... Args>
     [[nodiscard]] decltype(auto) get_or_emplace(const entity_type entt, Args &&...args) {
-        if(auto &cpool = assure<Type>(); cpool.contains(entt)) {
-            return cpool.get(entt);
-        } else {
-            return cpool.emplace(entt, std::forward<Args>(args)...);
-        }
+        auto &cpool = assure<Type>();
+        ENTT_ASSERT(valid(entt), "Invalid entity");
+        return cpool.contains(entt) ? cpool.get(entt) : cpool.emplace(entt, std::forward<Args>(args)...);
     }
 
     /**
-     * @brief Returns pointers to the given components for an entity.
+     * @brief Returns pointers to the given elements for an entity.
      *
      * @note
-     * The registry retains ownership of the pointed-to components.
+     * The registry retains ownership of the pointed-to elements.
      *
-     * @tparam Type Types of components to get.
+     * @tparam Type Types of elements to get.
      * @param entt A valid identifier.
-     * @return Pointers to the components owned by the entity.
+     * @return Pointers to the elements owned by the entity.
      */
     template<typename... Type>
     [[nodiscard]] auto try_get([[maybe_unused]] const entity_type entt) const {
@@ -38599,8 +40292,8 @@ class basic_registry {
     }
 
     /**
-     * @brief Clears a whole registry or the pools for the given components.
-     * @tparam Type Types of components to remove from their entities.
+     * @brief Clears a whole registry or the pools for the given elements.
+     * @tparam Type Types of elements to remove from their entities.
      */
     template<typename... Type>
     void clear() {
@@ -38617,30 +40310,30 @@ class basic_registry {
     }
 
     /**
-     * @brief Checks if an entity has components assigned.
+     * @brief Checks if an entity has elements assigned.
      * @param entt A valid identifier.
-     * @return True if the entity has no components assigned, false otherwise.
+     * @return True if the entity has no elements assigned, false otherwise.
      */
     [[nodiscard]] bool orphan(const entity_type entt) const {
         return std::none_of(pools.cbegin(), pools.cend(), [entt](auto &&curr) { return curr.second->contains(entt); });
     }
 
     /**
-     * @brief Returns a sink object for the given component.
+     * @brief Returns a sink object for the given element.
      *
      * Use this function to receive notifications whenever a new instance of the
-     * given component is created and assigned to an entity.<br/>
+     * given element is created and assigned to an entity.<br/>
      * The function type for a listener is equivalent to:
      *
      * @code{.cpp}
      * void(basic_registry<Entity> &, Entity);
      * @endcode
      *
-     * Listeners are invoked **after** assigning the component to the entity.
+     * Listeners are invoked **after** assigning the element to the entity.
      *
      * @sa sink
      *
-     * @tparam Type Type of component of which to get the sink.
+     * @tparam Type Type of element of which to get the sink.
      * @param id Optional name used to map the storage within the registry.
      * @return A temporary sink object.
      */
@@ -38650,21 +40343,21 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns a sink object for the given component.
+     * @brief Returns a sink object for the given element.
      *
      * Use this function to receive notifications whenever an instance of the
-     * given component is explicitly updated.<br/>
+     * given element is explicitly updated.<br/>
      * The function type for a listener is equivalent to:
      *
      * @code{.cpp}
      * void(basic_registry<Entity> &, Entity);
      * @endcode
      *
-     * Listeners are invoked **after** updating the component.
+     * Listeners are invoked **after** updating the element.
      *
      * @sa sink
      *
-     * @tparam Type Type of component of which to get the sink.
+     * @tparam Type Type of element of which to get the sink.
      * @param id Optional name used to map the storage within the registry.
      * @return A temporary sink object.
      */
@@ -38674,21 +40367,21 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns a sink object for the given component.
+     * @brief Returns a sink object for the given element.
      *
      * Use this function to receive notifications whenever an instance of the
-     * given component is removed from an entity and thus destroyed.<br/>
+     * given element is removed from an entity and thus destroyed.<br/>
      * The function type for a listener is equivalent to:
      *
      * @code{.cpp}
      * void(basic_registry<Entity> &, Entity);
      * @endcode
      *
-     * Listeners are invoked **before** removing the component from the entity.
+     * Listeners are invoked **before** removing the element from the entity.
      *
      * @sa sink
      *
-     * @tparam Type Type of component of which to get the sink.
+     * @tparam Type Type of element of which to get the sink.
      * @param id Optional name used to map the storage within the registry.
      * @return A temporary sink object.
      */
@@ -38698,18 +40391,17 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns a view for the given components.
-     * @tparam Type Type of component used to construct the view.
-     * @tparam Other Other types of components used to construct the view.
-     * @tparam Exclude Types of components used to filter the view.
+     * @brief Returns a view for the given elements.
+     * @tparam Type Type of element used to construct the view.
+     * @tparam Other Other types of elements used to construct the view.
+     * @tparam Exclude Types of elements used to filter the view.
      * @return A newly created view.
      */
     template<typename Type, typename... Other, typename... Exclude>
     [[nodiscard]] basic_view<get_t<storage_for_type<const Type>, storage_for_type<const Other>...>, exclude_t<storage_for_type<const Exclude>...>>
     view(exclude_t<Exclude...> = exclude_t{}) const {
-        const auto cpools = std::make_tuple(assure<std::remove_const_t<Type>>(), assure<std::remove_const_t<Other>>()..., assure<std::remove_const_t<Exclude>>()...);
         basic_view<get_t<storage_for_type<const Type>, storage_for_type<const Other>...>, exclude_t<storage_for_type<const Exclude>...>> elem{};
-        std::apply([&elem](const auto *...curr) { ((curr ? elem.storage(*curr) : void()), ...); }, cpools);
+        [&elem](const auto *...curr) { ((curr ? elem.storage(*curr) : void()), ...); }(assure<std::remove_const_t<Exclude>>()..., assure<std::remove_const_t<Other>>()..., assure<std::remove_const_t<Type>>());
         return elem;
     }
 
@@ -38721,7 +40413,7 @@ class basic_registry {
     }
 
     /**
-     * @brief Returns a group for the given components.
+     * @brief Returns a group for the given elements.
      * @tparam Owned Types of storage _owned_ by the group.
      * @tparam Get Types of storage _observed_ by the group, if any.
      * @tparam Exclude Types of storage used to filter the group, if any.
@@ -38730,33 +40422,34 @@ class basic_registry {
     template<typename... Owned, typename... Get, typename... Exclude>
     basic_group<owned_t<storage_for_type<Owned>...>, get_t<storage_for_type<Get>...>, exclude_t<storage_for_type<Exclude>...>>
     group(get_t<Get...> = get_t{}, exclude_t<Exclude...> = exclude_t{}) {
-        using handler_type = typename basic_group<owned_t<storage_for_type<Owned>...>, get_t<storage_for_type<Get>...>, exclude_t<storage_for_type<Exclude>...>>::handler;
+        using group_type = basic_group<owned_t<storage_for_type<Owned>...>, get_t<storage_for_type<Get>...>, exclude_t<storage_for_type<Exclude>...>>;
+        using handler_type = typename group_type::handler;
 
-        if(auto it = groups.find(type_hash<handler_type>::value()); it != groups.cend()) {
+        if(auto it = groups.find(group_type::group_id()); it != groups.cend()) {
             return {*std::static_pointer_cast<handler_type>(it->second)};
         }
 
         std::shared_ptr<handler_type> handler{};
 
         if constexpr(sizeof...(Owned) == 0u) {
-            handler = std::allocate_shared<handler_type>(get_allocator(), get_allocator(), assure<std::remove_const_t<Get>>()..., assure<std::remove_const_t<Exclude>>()...);
+            handler = std::allocate_shared<handler_type>(get_allocator(), get_allocator(), std::forward_as_tuple(assure<std::remove_const_t<Get>>()...), std::forward_as_tuple(assure<std::remove_const_t<Exclude>>()...));
         } else {
-            handler = std::allocate_shared<handler_type>(get_allocator(), assure<std::remove_const_t<Owned>>()..., assure<std::remove_const_t<Get>>()..., assure<std::remove_const_t<Exclude>>()...);
-            [[maybe_unused]] const id_type elem[]{type_hash<std::remove_const_t<Owned>>::value()..., type_hash<std::remove_const_t<Get>>::value()..., type_hash<std::remove_const_t<Exclude>>::value()...};
-            ENTT_ASSERT(std::all_of(groups.cbegin(), groups.cend(), [&elem](const auto &data) { return data.second->owned(elem, sizeof...(Owned)) == 0u; }), "Conflicting groups");
+            handler = std::allocate_shared<handler_type>(get_allocator(), std::forward_as_tuple(assure<std::remove_const_t<Owned>>()..., assure<std::remove_const_t<Get>>()...), std::forward_as_tuple(assure<std::remove_const_t<Exclude>>()...));
+            ENTT_ASSERT(std::all_of(groups.cbegin(), groups.cend(), [](const auto &data) { return !(data.second->owned(type_id<Owned>().hash()) || ...); }), "Conflicting groups");
         }
 
-        groups.emplace(type_hash<handler_type>::value(), handler);
+        groups.emplace(group_type::group_id(), handler);
         return {*handler};
     }
 
     /*! @copydoc group */
     template<typename... Owned, typename... Get, typename... Exclude>
-    basic_group<owned_t<storage_for_type<const Owned>...>, get_t<storage_for_type<const Get>...>, exclude_t<storage_for_type<const Exclude>...>>
+    [[nodiscard]] basic_group<owned_t<storage_for_type<const Owned>...>, get_t<storage_for_type<const Get>...>, exclude_t<storage_for_type<const Exclude>...>>
     group_if_exists(get_t<Get...> = get_t{}, exclude_t<Exclude...> = exclude_t{}) const {
-        using handler_type = typename basic_group<owned_t<storage_for_type<const Owned>...>, get_t<storage_for_type<const Get>...>, exclude_t<storage_for_type<const Exclude>...>>::handler;
+        using group_type = basic_group<owned_t<storage_for_type<const Owned>...>, get_t<storage_for_type<const Get>...>, exclude_t<storage_for_type<const Exclude>...>>;
+        using handler_type = typename group_type::handler;
 
-        if(auto it = groups.find(type_hash<handler_type>::value()); it != groups.cend()) {
+        if(auto it = groups.find(group_type::group_id()); it != groups.cend()) {
             return {*std::static_pointer_cast<handler_type>(it->second)};
         }
 
@@ -38764,20 +40457,18 @@ class basic_registry {
     }
 
     /**
-     * @brief Checks whether the given components belong to any group.
-     * @tparam Type Type of component in which one is interested.
-     * @tparam Other Other types of components in which one is interested.
-     * @return True if the pools of the given components are _free_, false
+     * @brief Checks whether the given elements belong to any group.
+     * @tparam Type Types of elements in which one is interested.
+     * @return True if the pools of the given elements are _free_, false
      * otherwise.
      */
-    template<typename Type, typename... Other>
+    template<typename... Type>
     [[nodiscard]] bool owned() const {
-        const id_type elem[]{type_hash<std::remove_const_t<Type>>::value(), type_hash<std::remove_const_t<Other>>::value()...};
-        return std::any_of(groups.cbegin(), groups.cend(), [&elem](auto &&data) { return data.second->owned(elem, 1u + sizeof...(Other)); });
+        return std::any_of(groups.cbegin(), groups.cend(), [](auto &&data) { return (data.second->owned(type_id<Type>().hash()) || ...); });
     }
 
     /**
-     * @brief Sorts the elements of a given component.
+     * @brief Sorts the elements of a given element.
      *
      * The comparison function object returns `true` if the first element is
      * _less_ than the second one, `false` otherwise. Its signature is also
@@ -38799,9 +40490,9 @@ class basic_registry {
      * passed along with the other parameters to this member function.
      *
      * @warning
-     * Pools of components owned by a group cannot be sorted.
+     * Pools of elements owned by a group cannot be sorted.
      *
-     * @tparam Type Type of components to sort.
+     * @tparam Type Type of elements to sort.
      * @tparam Compare Type of comparison function object.
      * @tparam Sort Type of sort function object.
      * @tparam Args Types of arguments to forward to the sort function object.
@@ -38823,17 +40514,17 @@ class basic_registry {
     }
 
     /**
-     * @brief Sorts two pools of components in the same way.
+     * @brief Sorts two pools of elements in the same way.
      *
-     * Entities and components in `To` which are part of both storage are sorted
+     * Entities and elements in `To` which are part of both storage are sorted
      * internally with the order they have in `From`. The others follow in no
      * particular order.
      *
      * @warning
-     * Pools of components owned by a group cannot be sorted.
+     * Pools of elements owned by a group cannot be sorted.
      *
-     * @tparam To Type of components to sort.
-     * @tparam From Type of components to use to sort.
+     * @tparam To Type of elements to sort.
+     * @tparam From Type of elements to use to sort.
      */
     template<typename To, typename From>
     void sort() {
@@ -38846,12 +40537,12 @@ class basic_registry {
      * @brief Returns the context object, that is, a general purpose container.
      * @return The context object, that is, a general purpose container.
      */
-    context &ctx() noexcept {
+    [[nodiscard]] context &ctx() noexcept {
         return vars;
     }
 
     /*! @copydoc ctx */
-    const context &ctx() const noexcept {
+    [[nodiscard]] const context &ctx() const noexcept {
         return vars;
     }
 
@@ -38888,6 +40579,7 @@ namespace internal {
 template<typename Set>
 class runtime_view_iterator final {
     using iterator_type = typename Set::iterator;
+    using iterator_traits = std::iterator_traits<iterator_type>;
 
     [[nodiscard]] bool valid() const {
         return (!tombstone_check || *it != tombstone)
@@ -38896,10 +40588,10 @@ class runtime_view_iterator final {
     }
 
 public:
-    using difference_type = typename iterator_type::difference_type;
-    using value_type = typename iterator_type::value_type;
-    using pointer = typename iterator_type::pointer;
-    using reference = typename iterator_type::reference;
+    using value_type = typename iterator_traits::value_type;
+    using pointer = typename iterator_traits::pointer;
+    using reference = typename iterator_traits::reference;
+    using difference_type = typename iterator_traits::difference_type;
     using iterator_category = std::bidirectional_iterator_tag;
 
     constexpr runtime_view_iterator() noexcept
@@ -38908,6 +40600,7 @@ class runtime_view_iterator final {
           it{},
           tombstone_check{} {}
 
+    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
     runtime_view_iterator(const std::vector<Set *> &cpools, const std::vector<Set *> &ignore, iterator_type curr) noexcept
         : pools{&cpools},
           filter{&ignore},
@@ -38919,7 +40612,8 @@ class runtime_view_iterator final {
     }
 
     runtime_view_iterator &operator++() {
-        while(++it != (*pools)[0]->end() && !valid()) {}
+        ++it;
+        for(const auto last = (*pools)[0]->end(); it != last && !valid(); ++it) {}
         return *this;
     }
 
@@ -38929,7 +40623,8 @@ class runtime_view_iterator final {
     }
 
     runtime_view_iterator &operator--() {
-        while(--it != (*pools)[0]->begin() && !valid()) {}
+        --it;
+        for(const auto first = (*pools)[0]->begin(); it != first && !valid(); --it) {}
         return *this;
     }
 
@@ -38969,15 +40664,15 @@ class runtime_view_iterator final {
  *
  * Runtime views iterate over those entities that are at least in the given
  * storage. During initialization, a runtime view looks at the number of
- * entities available for each component and uses the smallest set in order to
- * get a performance boost when iterating.
+ * entities available for each element and uses the smallest set in order to get
+ * a performance boost when iterating.
  *
  * @b Important
  *
  * Iterators aren't invalidated if:
  *
  * * New elements are added to the storage.
- * * The entity currently pointed is modified (for example, components are added
+ * * The entity currently pointed is modified (for example, elements are added
  *   or removed from it).
  * * The entity currently pointed is destroyed.
  *
@@ -39030,7 +40725,7 @@ class basic_runtime_view {
           filter{other.filter, allocator} {}
 
     /*! @brief Default move constructor. */
-    basic_runtime_view(basic_runtime_view &&) noexcept(std::is_nothrow_move_constructible_v<container_type>) = default;
+    basic_runtime_view(basic_runtime_view &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -39041,23 +40736,26 @@ class basic_runtime_view {
         : pools{std::move(other.pools), allocator},
           filter{std::move(other.filter), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~basic_runtime_view() = default;
+
     /**
      * @brief Default copy assignment operator.
-     * @return This container.
+     * @return This runtime view.
      */
     basic_runtime_view &operator=(const basic_runtime_view &) = default;
 
     /**
      * @brief Default move assignment operator.
-     * @return This container.
+     * @return This runtime view.
      */
-    basic_runtime_view &operator=(basic_runtime_view &&) noexcept(std::is_nothrow_move_assignable_v<container_type>) = default;
+    basic_runtime_view &operator=(basic_runtime_view &&) noexcept = default;
 
     /**
      * @brief Exchanges the contents with those of a given view.
      * @param other View to exchange the content with.
      */
-    void swap(basic_runtime_view &other) {
+    void swap(basic_runtime_view &other) noexcept {
         using std::swap;
         swap(pools, other.pools);
         swap(filter, other.filter);
@@ -39112,11 +40810,11 @@ class basic_runtime_view {
 
     /**
      * @brief Returns an iterator to the first entity that has the given
-     * components.
+     * elements.
      *
      * If the view is empty, the returned iterator will be equal to `end()`.
      *
-     * @return An iterator to the first entity that has the given components.
+     * @return An iterator to the first entity that has the given elements.
      */
     [[nodiscard]] iterator begin() const {
         return pools.empty() ? iterator{} : iterator{pools, filter, pools[0]->begin()};
@@ -39124,14 +40822,22 @@ class basic_runtime_view {
 
     /**
      * @brief Returns an iterator that is past the last entity that has the
-     * given components.
+     * given elements.
      * @return An iterator to the entity following the last entity that has the
-     * given components.
+     * given elements.
      */
     [[nodiscard]] iterator end() const {
         return pools.empty() ? iterator{} : iterator{pools, filter, pools[0]->end()};
     }
 
+    /**
+     * @brief Checks whether a view is initialized or not.
+     * @return True if the view is initialized, false otherwise.
+     */
+    [[nodiscard]] explicit operator bool() const noexcept {
+        return !(pools.empty() && filter.empty());
+    }
+
     /**
      * @brief Checks if a view contains an entity.
      * @param entt A valid identifier.
@@ -39219,7 +40925,7 @@ void orphans(Registry &registry) {
  * @brief Utility class to create snapshots from a registry.
  *
  * A _snapshot_ can be either a dump of the entire registry or a narrower
- * selection of components of interest.<br/>
+ * selection of elements of interest.<br/>
  * This type can be used in both cases if provided with a correctly configured
  * output archive.
  *
@@ -39228,7 +40934,7 @@ void orphans(Registry &registry) {
 template<typename Registry>
 class basic_snapshot {
     static_assert(!std::is_const_v<Registry>, "Non-const registry type required");
-    using traits_type = typename Registry::traits_type;
+    using traits_type = entt_traits<typename Registry::entity_type>;
 
 public:
     /*! Basic registry type. */
@@ -39243,10 +40949,25 @@ class basic_snapshot {
     basic_snapshot(const registry_type &source) noexcept
         : reg{&source} {}
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_snapshot(const basic_snapshot &) = delete;
+
     /*! @brief Default move constructor. */
     basic_snapshot(basic_snapshot &&) noexcept = default;
 
-    /*! @brief Default move assignment operator. @return This snapshot. */
+    /*! @brief Default destructor. */
+    ~basic_snapshot() = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This snapshot.
+     */
+    basic_snapshot &operator=(const basic_snapshot &) = delete;
+
+    /**
+     * @brief Default move assignment operator.
+     * @return This snapshot.
+     */
     basic_snapshot &operator=(basic_snapshot &&) noexcept = default;
 
     /**
@@ -39260,17 +40981,17 @@ class basic_snapshot {
     template<typename Type, typename Archive>
     const basic_snapshot &get(Archive &archive, const id_type id = type_hash<Type>::value()) const {
         if(const auto *storage = reg->template storage<Type>(id); storage) {
+            const typename registry_type::common_type &base = *storage;
+
             archive(static_cast<typename traits_type::entity_type>(storage->size()));
 
             if constexpr(std::is_same_v<Type, entity_type>) {
                 archive(static_cast<typename traits_type::entity_type>(storage->free_list()));
 
-                for(auto first = storage->data(), last = first + storage->size(); first != last; ++first) {
+                for(auto first = base.rbegin(), last = base.rend(); first != last; ++first) {
                     archive(*first);
                 }
-            } else if constexpr(component_traits<Type>::in_place_delete) {
-                const typename registry_type::common_type &base = *storage;
-
+            } else if constexpr(registry_type::template storage_for_type<Type>::storage_policy == deletion_policy::in_place) {
                 for(auto it = base.rbegin(), last = base.rend(); it != last; ++it) {
                     if(const auto entt = *it; entt == tombstone) {
                         archive(static_cast<entity_type>(null));
@@ -39342,7 +41063,7 @@ class basic_snapshot {
 template<typename Registry>
 class basic_snapshot_loader {
     static_assert(!std::is_const_v<Registry>, "Non-const registry type required");
-    using traits_type = typename Registry::traits_type;
+    using traits_type = entt_traits<typename Registry::entity_type>;
 
 public:
     /*! Basic registry type. */
@@ -39360,10 +41081,25 @@ class basic_snapshot_loader {
         ENTT_ASSERT(reg->template storage<entity_type>().free_list() == 0u, "Registry must be empty");
     }
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_snapshot_loader(const basic_snapshot_loader &) = delete;
+
     /*! @brief Default move constructor. */
     basic_snapshot_loader(basic_snapshot_loader &&) noexcept = default;
 
-    /*! @brief Default move assignment operator. @return This loader. */
+    /*! @brief Default destructor. */
+    ~basic_snapshot_loader() = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This loader.
+     */
+    basic_snapshot_loader &operator=(const basic_snapshot_loader &) = delete;
+
+    /**
+     * @brief Default move assignment operator.
+     * @return This loader.
+     */
     basic_snapshot_loader &operator=(basic_snapshot_loader &&) noexcept = default;
 
     /**
@@ -39417,10 +41153,10 @@ class basic_snapshot_loader {
     }
 
     /**
-     * @brief Destroys those entities that have no components.
+     * @brief Destroys those entities that have no elements.
      *
-     * In case all the entities were serialized but only part of the components
-     * was saved, it could happen that some of the entities have no components
+     * In case all the entities were serialized but only part of the elements
+     * was saved, it could happen that some of the entities have no elements
      * once restored.<br/>
      * This function helps to identify and destroy those entities.
      *
@@ -39454,7 +41190,7 @@ class basic_snapshot_loader {
 template<typename Registry>
 class basic_continuous_loader {
     static_assert(!std::is_const_v<Registry>, "Non-const registry type required");
-    using traits_type = typename Registry::traits_type;
+    using traits_type = entt_traits<typename Registry::entity_type>;
 
     void restore(typename Registry::entity_type entt) {
         if(const auto entity = to_entity(entt); remloc.contains(entity) && remloc[entity].first == entt) {
@@ -39525,11 +41261,26 @@ class basic_continuous_loader {
         : remloc{source.get_allocator()},
           reg{&source} {}
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_continuous_loader(const basic_continuous_loader &) = delete;
+
     /*! @brief Default move constructor. */
-    basic_continuous_loader(basic_continuous_loader &&) = default;
+    basic_continuous_loader(basic_continuous_loader &&) noexcept = default;
+
+    /*! @brief Default destructor. */
+    ~basic_continuous_loader() = default;
 
-    /*! @brief Default move assignment operator. @return This loader. */
-    basic_continuous_loader &operator=(basic_continuous_loader &&) = default;
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This loader.
+     */
+    basic_continuous_loader &operator=(const basic_continuous_loader &) = delete;
+
+    /**
+     * @brief Default move assignment operator.
+     * @return This loader.
+     */
+    basic_continuous_loader &operator=(basic_continuous_loader &&) noexcept = default;
 
     /**
      * @brief Restores all elements of a type with associated identifiers.
@@ -39599,10 +41350,10 @@ class basic_continuous_loader {
     }
 
     /**
-     * @brief Destroys those entities that have no components.
+     * @brief Destroys those entities that have no elements.
      *
-     * In case all the entities were serialized but only part of the components
-     * was saved, it could happen that some of the entities have no components
+     * In case all the entities were serialized but only part of the elements
+     * was saved, it could happen that some of the entities have no elements
      * once restored.<br/>
      * This function helps to identify and destroy those entities.
      *
@@ -39661,7 +41412,7 @@ class basic_continuous_loader {
 
 // #include "../core/any.hpp"
 
-// #include "../core/memory.hpp"
+// #include "../core/bit.hpp"
 
 // #include "../core/type_info.hpp"
 
@@ -39688,7 +41439,7 @@ struct sparse_set_iterator final {
           offset{} {}
 
     constexpr sparse_set_iterator(const Container &ref, const difference_type idx) noexcept
-        : packed{std::addressof(ref)},
+        : packed{&ref},
           offset{idx} {}
 
     constexpr sparse_set_iterator &operator++() noexcept {
@@ -39728,15 +41479,15 @@ struct sparse_set_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
-        return packed->data()[index() - value];
+        return (*packed)[index() - value];
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return packed->data() + index();
+        return std::addressof(operator[](0));
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
+        return operator[](0);
     }
 
     [[nodiscard]] constexpr pointer data() const noexcept {
@@ -39791,7 +41542,7 @@ template<typename Container>
 /*! @endcond */
 
 /**
- * @brief Basic sparse set implementation.
+ * @brief Sparse set implementation.
  *
  * Sparse set or packed array or whatever is the name users give it.<br/>
  * Two arrays: an _external_ one and an _internal_ one; a _sparse_ one and a
@@ -39815,7 +41566,13 @@ class basic_sparse_set {
     static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
     using sparse_container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
     using packed_container_type = std::vector<Entity, Allocator>;
-    using underlying_type = typename entt_traits<Entity>::entity_type;
+    using traits_type = entt_traits<Entity>;
+
+    static constexpr auto max_size = static_cast<std::size_t>(traits_type::to_entity(null));
+
+    [[nodiscard]] auto policy_to_head() const noexcept {
+        return static_cast<size_type>(max_size * static_cast<decltype(max_size)>(mode != deletion_policy::swap_only));
+    }
 
     [[nodiscard]] auto sparse_ptr(const Entity entt) const {
         const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
@@ -39863,27 +41620,23 @@ class basic_sparse_set {
         }
     }
 
-    void swap_at(const std::size_t from, const std::size_t to) {
-        auto &lhs = packed[from];
-        auto &rhs = packed[to];
+    void swap_at(const std::size_t lhs, const std::size_t rhs) {
+        auto &from = packed[lhs];
+        auto &to = packed[rhs];
 
-        sparse_ref(lhs) = traits_type::combine(static_cast<typename traits_type::entity_type>(to), traits_type::to_integral(lhs));
-        sparse_ref(rhs) = traits_type::combine(static_cast<typename traits_type::entity_type>(from), traits_type::to_integral(rhs));
-
-        std::swap(lhs, rhs);
-    }
+        sparse_ref(from) = traits_type::combine(static_cast<typename traits_type::entity_type>(rhs), traits_type::to_integral(from));
+        sparse_ref(to) = traits_type::combine(static_cast<typename traits_type::entity_type>(lhs), traits_type::to_integral(to));
 
-    underlying_type policy_to_head() {
-        return traits_type::entity_mask * (mode != deletion_policy::swap_only);
+        std::swap(from, to);
     }
 
 private:
-    virtual const void *get_at(const std::size_t) const {
+    [[nodiscard]] virtual const void *get_at(const std::size_t) const {
         return nullptr;
     }
 
     virtual void swap_or_move([[maybe_unused]] const std::size_t lhs, [[maybe_unused]] const std::size_t rhs) {
-        ENTT_ASSERT((mode != deletion_policy::swap_only) || (((lhs < free_list()) + (rhs < free_list())) != 1u), "Cross swapping is not supported");
+        ENTT_ASSERT((mode != deletion_policy::swap_only) || ((lhs < head) == (rhs < head)), "Cross swapping is not supported");
     }
 
 protected:
@@ -39896,9 +41649,9 @@ class basic_sparse_set {
      */
     void swap_only(const basic_iterator it) {
         ENTT_ASSERT(mode == deletion_policy::swap_only, "Deletion policy mismatch");
-        const auto pos = static_cast<underlying_type>(index(*it));
+        const auto pos = index(*it);
         bump(traits_type::next(*it));
-        swap_at(pos, static_cast<size_type>(head -= (pos < head)));
+        swap_at(pos, head -= (pos < head));
     }
 
     /**
@@ -39924,11 +41677,10 @@ class basic_sparse_set {
      */
     void in_place_pop(const basic_iterator it) {
         ENTT_ASSERT(mode == deletion_policy::in_place, "Deletion policy mismatch");
-        const auto entt = traits_type::to_entity(std::exchange(sparse_ref(*it), null));
-        packed[static_cast<size_type>(entt)] = traits_type::combine(std::exchange(head, entt), tombstone);
+        const auto pos = static_cast<size_type>(traits_type::to_entity(std::exchange(sparse_ref(*it), null)));
+        packed[pos] = traits_type::combine(static_cast<typename traits_type::entity_type>(std::exchange(head, pos)), tombstone);
     }
 
-protected:
     /**
      * @brief Erases entities from a sparse set.
      * @param first An iterator to the first element of the range of entities.
@@ -39958,7 +41710,7 @@ class basic_sparse_set {
     virtual void pop_all() {
         switch(mode) {
         case deletion_policy::in_place:
-            if(head != traits_type::to_entity(null)) {
+            if(head != max_size) {
                 for(auto first = begin(); !(first.index() < 0); ++first) {
                     if(*first != tombstone) {
                         sparse_ref(*first) = null;
@@ -39986,16 +41738,17 @@ class basic_sparse_set {
      * @return Iterator pointing to the emplaced element.
      */
     virtual basic_iterator try_emplace(const Entity entt, const bool force_back, const void * = nullptr) {
+        ENTT_ASSERT(entt != null && entt != tombstone, "Invalid element");
         auto &elem = assure_at_least(entt);
         auto pos = size();
 
         switch(mode) {
         case deletion_policy::in_place:
-            if(head != traits_type::to_entity(null) && !force_back) {
-                pos = static_cast<size_type>(head);
+            if(head != max_size && !force_back) {
+                pos = head;
                 ENTT_ASSERT(elem == null, "Slot not available");
-                elem = traits_type::combine(head, traits_type::to_integral(entt));
-                head = traits_type::to_entity(std::exchange(packed[pos], entt));
+                elem = traits_type::combine(static_cast<typename traits_type::entity_type>(head), traits_type::to_integral(entt));
+                head = static_cast<size_type>(traits_type::to_entity(std::exchange(packed[pos], entt)));
                 break;
             }
             [[fallthrough]];
@@ -40009,32 +41762,31 @@ class basic_sparse_set {
                 packed.push_back(entt);
                 elem = traits_type::combine(static_cast<typename traits_type::entity_type>(packed.size() - 1u), traits_type::to_integral(entt));
             } else {
-                ENTT_ASSERT(!(traits_type::to_entity(elem) < head), "Slot not available");
+                ENTT_ASSERT(!(static_cast<size_type>(traits_type::to_entity(elem)) < head), "Slot not available");
                 bump(entt);
             }
 
-            if(force_back) {
-                pos = static_cast<size_type>(head++);
-                swap_at(static_cast<size_type>(traits_type::to_entity(elem)), pos);
-            }
-
+            pos = head++;
+            swap_at(static_cast<size_type>(traits_type::to_entity(elem)), pos);
             break;
         }
 
-        return --(end() - pos);
+        return --(end() - static_cast<typename iterator::difference_type>(pos));
     }
 
+    /*! @brief Forwards variables to derived classes, if any. */
+    // NOLINTNEXTLINE(performance-unnecessary-value-param)
+    virtual void bind_any(any) noexcept {}
+
 public:
-    /*! @brief Entity traits. */
-    using traits_type = entt_traits<Entity>;
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Underlying entity identifier. */
     using entity_type = typename traits_type::value_type;
     /*! @brief Underlying version type. */
     using version_type = typename traits_type::version_type;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Pointer type to contained entities. */
     using pointer = typename packed_container_type::const_pointer;
     /*! @brief Random access iterator type. */
@@ -40055,7 +41807,7 @@ class basic_sparse_set {
      * @param allocator The allocator to use.
      */
     explicit basic_sparse_set(const allocator_type &allocator)
-        : basic_sparse_set{type_id<void>(), deletion_policy::swap_and_pop, allocator} {}
+        : basic_sparse_set{deletion_policy::swap_and_pop, allocator} {}
 
     /**
      * @brief Constructs an empty container with the given policy and allocator.
@@ -40077,7 +41829,12 @@ class basic_sparse_set {
           packed{allocator},
           info{&elem},
           mode{pol},
-          head{policy_to_head()} {}
+          head{policy_to_head()} {
+        ENTT_ASSERT(traits_type::version_mask || mode != deletion_policy::in_place, "Policy does not support zero-sized versions");
+    }
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_sparse_set(const basic_sparse_set &) = delete;
 
     /**
      * @brief Move constructor.
@@ -40095,13 +41852,13 @@ class basic_sparse_set {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_sparse_set(basic_sparse_set &&other, const allocator_type &allocator) noexcept
+    basic_sparse_set(basic_sparse_set &&other, const allocator_type &allocator)
         : sparse{std::move(other.sparse), allocator},
           packed{std::move(other.packed), allocator},
           info{other.info},
           mode{other.mode},
           head{std::exchange(other.head, policy_to_head())} {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || packed.get_allocator() == other.packed.get_allocator(), "Copying a sparse set is not allowed");
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a sparse set is not allowed");
     }
 
     /*! @brief Default destructor. */
@@ -40109,20 +41866,20 @@ class basic_sparse_set {
         release_sparse_pages();
     }
 
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This sparse set.
+     */
+    basic_sparse_set &operator=(const basic_sparse_set &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This sparse set.
      */
     basic_sparse_set &operator=(basic_sparse_set &&other) noexcept {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || packed.get_allocator() == other.packed.get_allocator(), "Copying a sparse set is not allowed");
-
-        release_sparse_pages();
-        sparse = std::move(other.sparse);
-        packed = std::move(other.packed);
-        info = other.info;
-        mode = other.mode;
-        head = std::exchange(other.head, policy_to_head());
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a sparse set is not allowed");
+        swap(other);
         return *this;
     }
 
@@ -40130,7 +41887,7 @@ class basic_sparse_set {
      * @brief Exchanges the contents with those of a given sparse set.
      * @param other Sparse set to exchange the content with.
      */
-    void swap(basic_sparse_set &other) {
+    void swap(basic_sparse_set &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -40156,20 +41913,20 @@ class basic_sparse_set {
     }
 
     /**
-     * @brief Returns the head of the free list, if any.
-     * @return The head of the free list.
+     * @brief Returns data on the free list whose meaning depends on the mode.
+     * @return Free list information that is mode dependent.
      */
     [[nodiscard]] size_type free_list() const noexcept {
-        return static_cast<size_type>(head);
+        return head;
     }
 
     /**
-     * @brief Sets the head of the free list, if possible.
-     * @param len The value to use as the new head of the free list.
+     * @brief Sets data on the free list whose meaning depends on the mode.
+     * @param value Free list information that is mode dependent.
      */
-    void free_list(const size_type len) noexcept {
-        ENTT_ASSERT((mode == deletion_policy::swap_only) && !(len > packed.size()), "Invalid value");
-        head = static_cast<underlying_type>(len);
+    void free_list(const size_type value) noexcept {
+        ENTT_ASSERT((mode == deletion_policy::swap_only) && !(value > packed.size()), "Invalid value");
+        head = value;
     }
 
     /**
@@ -40239,7 +41996,7 @@ class basic_sparse_set {
      * @return True if the sparse set is fully packed, false otherwise.
      */
     [[nodiscard]] bool contiguous() const noexcept {
-        return (mode != deletion_policy::in_place) || (head == traits_type::to_entity(null));
+        return (mode != deletion_policy::in_place) || (head == max_size);
     }
 
     /**
@@ -40314,46 +42071,6 @@ class basic_sparse_set {
         return rend();
     }
 
-    /*! @copydoc begin Useful only in case of swap-only policy. */
-    [[nodiscard]] iterator begin(int) const noexcept {
-        return (mode == deletion_policy::swap_only) ? (end() - static_cast<typename iterator::difference_type>(head)) : begin();
-    }
-
-    /*! @copydoc cbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] const_iterator cbegin(int) const noexcept {
-        return begin(0);
-    }
-
-    /*! @copydoc end Useful only in case of swap-only policy. */
-    [[nodiscard]] iterator end(int) const noexcept {
-        return end();
-    }
-
-    /*! @copydoc cend Useful only in case of swap-only policy. */
-    [[nodiscard]] const_iterator cend(int) const noexcept {
-        return end(0);
-    }
-
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] reverse_iterator rbegin(int) const noexcept {
-        return std::make_reverse_iterator(end(0));
-    }
-
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] const_reverse_iterator crbegin(int) const noexcept {
-        return rbegin(0);
-    }
-
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] reverse_iterator rend(int) const noexcept {
-        return std::make_reverse_iterator(begin(0));
-    }
-
-    /*! @copydoc rbegin Useful only in case of swap-only policy. */
-    [[nodiscard]] const_reverse_iterator crend(int) const noexcept {
-        return rend(0);
-    }
-
     /**
      * @brief Finds an entity.
      * @param entt A valid identifier.
@@ -40370,7 +42087,7 @@ class basic_sparse_set {
      * @return True if the sparse set contains the entity, false otherwise.
      */
     [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        const auto elem = sparse_ptr(entt);
+        const auto *elem = sparse_ptr(entt);
         constexpr auto cap = traits_type::entity_mask;
         constexpr auto mask = traits_type::to_integral(null) & ~cap;
         // testing versions permits to avoid accessing the packed array
@@ -40384,7 +42101,7 @@ class basic_sparse_set {
      * version otherwise.
      */
     [[nodiscard]] version_type current(const entity_type entt) const noexcept {
-        const auto elem = sparse_ptr(entt);
+        const auto *elem = sparse_ptr(entt);
         constexpr auto fallback = traits_type::to_version(tombstone);
         return elem ? traits_type::to_version(*elem) : fallback;
     }
@@ -40405,21 +42122,12 @@ class basic_sparse_set {
     }
 
     /**
-     * @brief Returns the entity at specified location, with bounds checking.
-     * @param pos The position for which to return the entity.
-     * @return The entity at specified location if any, a null entity otherwise.
-     */
-    [[deprecated("use .begin()[pos] instead")]] [[nodiscard]] entity_type at(const size_type pos) const noexcept {
-        return pos < packed.size() ? packed[pos] : null;
-    }
-
-    /**
-     * @brief Returns the entity at specified location, without bounds checking.
+     * @brief Returns the entity at specified location.
      * @param pos The position for which to return the entity.
      * @return The entity at specified location.
      */
     [[nodiscard]] entity_type operator[](const size_type pos) const noexcept {
-        ENTT_ASSERT(pos < packed.size(), "Position is out of bounds");
+        ENTT_ASSERT(pos < packed.size(), "Index out of bounds");
         return packed[pos];
     }
 
@@ -40455,7 +42163,7 @@ class basic_sparse_set {
      * `end()` iterator otherwise.
      */
     iterator push(const entity_type entt, const void *elem = nullptr) {
-        return try_emplace(entt, (mode == deletion_policy::swap_only), elem);
+        return try_emplace(entt, false, elem);
     }
 
     /**
@@ -40473,11 +42181,13 @@ class basic_sparse_set {
      */
     template<typename It>
     iterator push(It first, It last) {
-        for(auto it = first; it != last; ++it) {
-            try_emplace(*it, true);
+        auto curr = end();
+
+        for(; first != last; ++first) {
+            curr = try_emplace(*first, true);
         }
 
-        return first == last ? end() : find(*first);
+        return curr;
     }
 
     /**
@@ -40491,10 +42201,10 @@ class basic_sparse_set {
      * @return The version of the given identifier.
      */
     version_type bump(const entity_type entt) {
-        auto &entity = sparse_ref(entt);
-        ENTT_ASSERT(entt != tombstone && entity != null, "Cannot set the required version");
-        entity = traits_type::combine(traits_type::to_integral(entity), traits_type::to_integral(entt));
-        packed[static_cast<size_type>(traits_type::to_entity(entity))] = entt;
+        auto &elem = sparse_ref(entt);
+        ENTT_ASSERT(entt != null && elem != tombstone, "Cannot set the required version");
+        elem = traits_type::combine(traits_type::to_integral(elem), traits_type::to_integral(entt));
+        packed[static_cast<size_type>(traits_type::to_entity(elem))] = entt;
         return traits_type::to_version(entt);
     }
 
@@ -40580,17 +42290,18 @@ class basic_sparse_set {
     void compact() {
         if(mode == deletion_policy::in_place) {
             size_type from = packed.size();
+            size_type pos = std::exchange(head, max_size);
+
             for(; from && packed[from - 1u] == tombstone; --from) {}
-            underlying_type pos = std::exchange(head, traits_type::entity_mask);
 
-            while(pos != traits_type::to_entity(null)) {
-                if(const auto to = static_cast<size_type>(std::exchange(pos, traits_type::to_entity(packed[pos]))); to < from) {
+            while(pos != max_size) {
+                if(const auto to = std::exchange(pos, static_cast<size_type>(traits_type::to_entity(packed[pos]))); to < from) {
                     --from;
                     swap_or_move(from, to);
 
                     packed[to] = packed[from];
-                    const auto entity = static_cast<typename traits_type::entity_type>(to);
-                    sparse_ref(packed[to]) = traits_type::combine(entity, traits_type::to_integral(packed[to]));
+                    const auto elem = static_cast<typename traits_type::entity_type>(to);
+                    sparse_ref(packed[to]) = traits_type::combine(elem, traits_type::to_integral(packed[to]));
 
                     for(; from && packed[from - 1u] == tombstone; --from) {}
                 }
@@ -40654,7 +42365,7 @@ class basic_sparse_set {
      */
     template<typename Compare, typename Sort = std_sort, typename... Args>
     void sort_n(const size_type length, Compare compare, Sort algo = Sort{}, Args &&...args) {
-        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == traits_type::to_entity(null)), "Sorting with tombstones not allowed");
+        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == max_size), "Sorting with tombstones not allowed");
         ENTT_ASSERT(!(length > packed.size()), "Length exceeds the number of elements");
 
         algo(packed.rend() - length, packed.rend(), std::move(compare), std::forward<Args>(args)...);
@@ -40668,8 +42379,8 @@ class basic_sparse_set {
                 const auto entt = packed[curr];
 
                 swap_or_move(next, idx);
-                const auto entity = static_cast<typename traits_type::entity_type>(curr);
-                sparse_ref(entt) = traits_type::combine(entity, traits_type::to_integral(packed[curr]));
+                const auto elem = static_cast<typename traits_type::entity_type>(curr);
+                sparse_ref(entt) = traits_type::combine(elem, traits_type::to_integral(packed[curr]));
                 curr = std::exchange(next, idx);
             }
         }
@@ -40689,7 +42400,8 @@ class basic_sparse_set {
      */
     template<typename Compare, typename Sort = std_sort, typename... Args>
     void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
-        sort_n(static_cast<size_type>(end(0) - begin(0)), std::move(compare), std::move(algo), std::forward<Args>(args)...);
+        const size_type len = (mode == deletion_policy::swap_only) ? head : packed.size();
+        sort_n(len, std::move(compare), std::move(algo), std::forward<Args>(args)...);
     }
 
     /**
@@ -40703,12 +42415,15 @@ class basic_sparse_set {
      * @tparam It Type of input iterator.
      * @param first An iterator to the first element of the range of entities.
      * @param last An iterator past the last element of the range of entities.
+     * @return An iterator past the last of the elements actually shared.
      */
     template<typename It>
-    void sort_as(It first, It last) {
-        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == traits_type::to_entity(null)), "Sorting with tombstones not allowed");
+    iterator sort_as(It first, It last) {
+        ENTT_ASSERT((mode != deletion_policy::in_place) || (head == max_size), "Sorting with tombstones not allowed");
+        const size_type len = (mode == deletion_policy::swap_only) ? head : packed.size();
+        auto it = end() - static_cast<typename iterator::difference_type>(len);
 
-        for(auto it = begin(0); it.index() && first != last; ++first) {
+        for(const auto other = end(); (it != other) && (first != last); ++first) {
             if(const auto curr = *first; contains(curr)) {
                 if(const auto entt = *it; entt != curr) {
                     // basic no-leak guarantee (with invalid state) if swapping throws
@@ -40718,14 +42433,8 @@ class basic_sparse_set {
                 ++it;
             }
         }
-    }
 
-    /**
-     * @copybrief sort_as
-     * @param other The sparse sets that imposes the order of the entities.
-     */
-    [[deprecated("use iterator based sort_as instead")]] void sort_as(const basic_sparse_set &other) {
-        sort_as(other.begin(), other.end());
+        return it;
     }
 
     /*! @brief Clears a sparse set. */
@@ -40741,19 +42450,41 @@ class basic_sparse_set {
      * @brief Returned value type, if any.
      * @return Returned value type, if any.
      */
-    const type_info &type() const noexcept {
+    [[nodiscard]] const type_info &type() const noexcept {
         return *info;
     }
 
-    /*! @brief Forwards variables to derived classes, if any. */
-    virtual void bind(any) noexcept {}
+    /**
+     * @brief Forwards variables to derived classes, if any.
+     * @tparam Type Type of the element to forward.
+     * @param value The element to forward.
+     * @return Nothing.
+     */
+    template<typename Type>
+    [[deprecated("avoid wrapping elements with basic_any")]] std::enable_if_t<std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, basic_any<>>>
+    bind(Type &&value) noexcept {
+        // backward compatibility
+        bind_any(std::forward<Type>(value));
+    }
+
+    /**
+     * @brief Forwards variables to derived classes, if any.
+     * @tparam Type Type of the element to forward.
+     * @param value The element to forward.
+     * @return Nothing.
+     */
+    template<typename Type>
+    std::enable_if_t<!std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, basic_any<>>>
+    bind(Type &&value) noexcept {
+        bind_any(forward_as_any(std::forward<Type>(value)));
+    }
 
 private:
     sparse_container_type sparse;
     packed_container_type packed;
     const type_info *info;
     deletion_policy mode;
-    underlying_type head;
+    size_type head;
 };
 
 } // namespace entt
@@ -40773,6 +42504,8 @@ class basic_sparse_set {
 #include <vector>
 // #include "../config/config.h"
 
+// #include "../core/bit.hpp"
+
 // #include "../core/iterator.hpp"
 
 // #include "../core/memory.hpp"
@@ -40793,9 +42526,9 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename Container, std::size_t Size>
+template<typename Container>
 class storage_iterator final {
-    friend storage_iterator<const Container, Size>;
+    friend storage_iterator<const Container>;
 
     using container_type = std::remove_const_t<Container>;
     using alloc_traits = std::allocator_traits<typename container_type::allocator_type>;
@@ -40819,7 +42552,7 @@ class storage_iterator final {
           offset{idx} {}
 
     template<bool Const = std::is_const_v<Container>, typename = std::enable_if_t<Const>>
-    constexpr storage_iterator(const storage_iterator<std::remove_const_t<Container>, Size> &other) noexcept
+    constexpr storage_iterator(const storage_iterator<std::remove_const_t<Container>> &other) noexcept
         : storage_iterator{other.payload, other.offset} {}
 
     constexpr storage_iterator &operator++() noexcept {
@@ -40860,16 +42593,16 @@ class storage_iterator final {
 
     [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
         const auto pos = index() - value;
-        return (*payload)[pos / Size][fast_mod(pos, Size)];
+        constexpr auto page_size = component_traits<value_type>::page_size;
+        return (*payload)[pos / page_size][fast_mod(static_cast<std::size_t>(pos), page_size)];
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
-        const auto pos = index();
-        return (*payload)[pos / Size] + fast_mod(pos, Size);
+        return std::addressof(operator[](0));
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
+        return operator[](0);
     }
 
     [[nodiscard]] constexpr difference_type index() const noexcept {
@@ -40881,38 +42614,38 @@ class storage_iterator final {
     difference_type offset;
 };
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr std::ptrdiff_t operator-(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr std::ptrdiff_t operator-(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return rhs.index() - lhs.index();
 }
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator==(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator==(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return lhs.index() == rhs.index();
 }
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator!=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator!=(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return !(lhs == rhs);
 }
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator<(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator<(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return lhs.index() > rhs.index();
 }
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator>(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator>(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return rhs < lhs;
 }
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator<=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator<=(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return !(lhs > rhs);
 }
 
-template<typename Lhs, typename Rhs, std::size_t Size>
-[[nodiscard]] constexpr bool operator>=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
+template<typename Lhs, typename Rhs>
+[[nodiscard]] constexpr bool operator>=(const storage_iterator<Lhs> &lhs, const storage_iterator<Rhs> &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -40923,10 +42656,10 @@ class extended_storage_iterator final {
 
 public:
     using iterator_type = It;
-    using difference_type = std::ptrdiff_t;
     using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::forward_as_tuple(*std::declval<Other>()...)));
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
@@ -40982,7 +42715,7 @@ template<typename... Lhs, typename... Rhs>
 /*! @endcond */
 
 /**
- * @brief Basic storage implementation.
+ * @brief Storage implementation.
  *
  * Internal data structures arrange elements to maximize performance. There are
  * no guarantees that objects are returned in the insertion order when iterate
@@ -40992,7 +42725,7 @@ template<typename... Lhs, typename... Rhs>
  * Empty types aren't explicitly instantiated. Therefore, many of the functions
  * normally available for non-empty types will not be available for empty ones.
  *
- * @tparam Type Type of objects assigned to the entities.
+ * @tparam Type Element type.
  * @tparam Entity A valid entity type.
  * @tparam Allocator Type of allocator used to manage memory and elements.
  */
@@ -41003,6 +42736,7 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
     using container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
     using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
     using underlying_iterator = typename underlying_type::basic_iterator;
+    using traits_type = component_traits<Type>;
 
     [[nodiscard]] auto &element_at(const std::size_t pos) const {
         return payload[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
@@ -41035,8 +42769,8 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
         const auto it = base_type::try_emplace(entt, force_back);
 
         ENTT_TRY {
-            auto elem = assure_at_least(static_cast<size_type>(it.index()));
-            entt::uninitialized_construct_using_allocator(to_address(elem), get_allocator(), std::forward<Args>(args)...);
+            auto *elem = to_address(assure_at_least(static_cast<size_type>(it.index())));
+            entt::uninitialized_construct_using_allocator(elem, get_allocator(), std::forward<Args>(args)...);
         }
         ENTT_CATCH {
             base_type::pop(it, it + 1u);
@@ -41068,7 +42802,7 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
     }
 
 private:
-    const void *get_at(const std::size_t pos) const final {
+    [[nodiscard]] const void *get_at(const std::size_t pos) const final {
         return std::addressof(element_at(pos));
     }
 
@@ -41143,14 +42877,14 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @return Iterator pointing to the emplaced element.
      */
     underlying_iterator try_emplace([[maybe_unused]] const Entity entt, [[maybe_unused]] const bool force_back, const void *value) override {
-        if(value) {
-            if constexpr(std::is_copy_constructible_v<value_type>) {
-                return emplace_element(entt, force_back, *static_cast<const value_type *>(value));
+        if(value != nullptr) {
+            if constexpr(std::is_copy_constructible_v<element_type>) {
+                return emplace_element(entt, force_back, *static_cast<const element_type *>(value));
             } else {
                 return base_type::end();
             }
         } else {
-            if constexpr(std::is_default_constructible_v<value_type>) {
+            if constexpr(std::is_default_constructible_v<element_type>) {
                 return emplace_element(entt, force_back);
             } else {
                 return base_type::end();
@@ -41159,26 +42893,26 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Base type. */
     using base_type = underlying_type;
+    /*! @brief Element type. */
+    using element_type = Type;
     /*! @brief Type of the objects assigned to entities. */
-    using value_type = Type;
-    /*! @brief Component traits. */
-    using traits_type = component_traits<value_type>;
+    using value_type = element_type;
     /*! @brief Underlying entity identifier. */
     using entity_type = Entity;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Pointer type to contained elements. */
     using pointer = typename container_type::pointer;
     /*! @brief Constant pointer type to contained elements. */
     using const_pointer = typename alloc_traits::template rebind_traits<typename alloc_traits::const_pointer>::const_pointer;
     /*! @brief Random access iterator type. */
-    using iterator = internal::storage_iterator<container_type, traits_type::page_size>;
+    using iterator = internal::storage_iterator<container_type>;
     /*! @brief Constant random access iterator type. */
-    using const_iterator = internal::storage_iterator<const container_type, traits_type::page_size>;
+    using const_iterator = internal::storage_iterator<const container_type>;
     /*! @brief Reverse iterator type. */
     using reverse_iterator = std::reverse_iterator<iterator>;
     /*! @brief Constant reverse iterator type. */
@@ -41191,6 +42925,8 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
     using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator, reverse_iterator>>;
     /*! @brief Constant extended reverse iterable storage proxy. */
     using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator, const_reverse_iterator>>;
+    /*! @brief Storage deletion policy. */
+    static constexpr deletion_policy storage_policy{traits_type::in_place_delete};
 
     /*! @brief Default constructor. */
     basic_storage()
@@ -41201,9 +42937,12 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @param allocator The allocator to use.
      */
     explicit basic_storage(const allocator_type &allocator)
-        : base_type{type_id<value_type>(), deletion_policy{traits_type::in_place_delete}, allocator},
+        : base_type{type_id<element_type>(), storage_policy, allocator},
           payload{allocator} {}
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_storage(const basic_storage &) = delete;
+
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
@@ -41217,28 +42956,33 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
+    basic_storage(basic_storage &&other, const allocator_type &allocator)
         : base_type{std::move(other), allocator},
           payload{std::move(other.payload), allocator} {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || payload.get_allocator() == other.payload.get_allocator(), "Copying a storage is not allowed");
+        // NOLINTNEXTLINE(bugprone-use-after-move)
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a storage is not allowed");
     }
 
     /*! @brief Default destructor. */
+    // NOLINTNEXTLINE(bugprone-exception-escape)
     ~basic_storage() override {
         shrink_to_size(0u);
     }
 
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This storage.
+     */
+    basic_storage &operator=(const basic_storage &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This storage.
      */
     basic_storage &operator=(basic_storage &&other) noexcept {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || payload.get_allocator() == other.payload.get_allocator(), "Copying a storage is not allowed");
-
-        shrink_to_size(0u);
-        base_type::operator=(std::move(other));
-        payload = std::move(other.payload);
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a storage is not allowed");
+        swap(other);
         return *this;
     }
 
@@ -41246,10 +42990,10 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @brief Exchanges the contents with those of a given storage.
      * @param other Storage to exchange the content with.
      */
-    void swap(basic_storage &other) {
+    void swap(basic_storage &other) noexcept {
         using std::swap;
-        base_type::swap(other);
         swap(payload, other.payload);
+        base_type::swap(other);
     }
 
     /**
@@ -41468,7 +43212,7 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @param first An iterator to the first element of the range of entities.
      * @param last An iterator past the last element of the range of entities.
      * @param value An instance of the object to construct.
-     * @return Iterator pointing to the last element inserted, if any.
+     * @return Iterator pointing to the first element inserted, if any.
      */
     template<typename It>
     iterator insert(It first, It last, const value_type &value = {}) {
@@ -41505,17 +43249,17 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @brief Returns an iterable object to use to _visit_ a storage.
      *
      * The iterable object returns a tuple that contains the current entity and
-     * a reference to its component.
+     * a reference to its element.
      *
      * @return An iterable object to use to _visit_ the storage.
      */
     [[nodiscard]] iterable each() noexcept {
-        return {internal::extended_storage_iterator{base_type::begin(), begin()}, internal::extended_storage_iterator{base_type::end(), end()}};
+        return iterable{{base_type::begin(), begin()}, {base_type::end(), end()}};
     }
 
     /*! @copydoc each */
     [[nodiscard]] const_iterable each() const noexcept {
-        return {internal::extended_storage_iterator{base_type::cbegin(), cbegin()}, internal::extended_storage_iterator{base_type::cend(), cend()}};
+        return const_iterable{{base_type::cbegin(), cbegin()}, {base_type::cend(), cend()}};
     }
 
     /**
@@ -41526,12 +43270,12 @@ class basic_storage: public basic_sparse_set<Entity, typename std::allocator_tra
      * @return A reverse iterable object to use to _visit_ the storage.
      */
     [[nodiscard]] reverse_iterable reach() noexcept {
-        return {internal::extended_storage_iterator{base_type::rbegin(), rbegin()}, internal::extended_storage_iterator{base_type::rend(), rend()}};
+        return reverse_iterable{{base_type::rbegin(), rbegin()}, {base_type::rend(), rend()}};
     }
 
     /*! @copydoc reach */
     [[nodiscard]] const_reverse_iterable reach() const noexcept {
-        return {internal::extended_storage_iterator{base_type::crbegin(), crbegin()}, internal::extended_storage_iterator{base_type::crend(), crend()}};
+        return const_reverse_iterable{{base_type::crbegin(), crbegin()}, {base_type::crend(), crend()}};
     }
 
 private:
@@ -41544,20 +43288,21 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
     : public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
     using alloc_traits = std::allocator_traits<Allocator>;
     static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
+    using traits_type = component_traits<Type>;
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Base type. */
     using base_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
+    /*! @brief Element type. */
+    using element_type = Type;
     /*! @brief Type of the objects assigned to entities. */
-    using value_type = Type;
-    /*! @brief Component traits. */
-    using traits_type = component_traits<value_type>;
+    using value_type = void;
     /*! @brief Underlying entity identifier. */
     using entity_type = Entity;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Extended iterable storage proxy. */
     using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
     /*! @brief Constant extended iterable storage proxy. */
@@ -41566,6 +43311,8 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
     using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
     /*! @brief Constant extended reverse iterable storage proxy. */
     using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;
+    /*! @brief Storage deletion policy. */
+    static constexpr deletion_policy storage_policy{traits_type::in_place_delete};
 
     /*! @brief Default constructor. */
     basic_storage()
@@ -41576,7 +43323,10 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      * @param allocator The allocator to use.
      */
     explicit basic_storage(const allocator_type &allocator)
-        : base_type{type_id<value_type>(), deletion_policy{traits_type::in_place_delete}, allocator} {}
+        : base_type{type_id<element_type>(), storage_policy, allocator} {}
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_storage(const basic_storage &) = delete;
 
     /**
      * @brief Move constructor.
@@ -41589,9 +43339,18 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
+    basic_storage(basic_storage &&other, const allocator_type &allocator)
         : base_type{std::move(other), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~basic_storage() override = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This storage.
+     */
+    basic_storage &operator=(const basic_storage &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
@@ -41605,7 +43364,7 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      */
     [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
         // std::allocator<void> has no cross constructors (waiting for C++20)
-        if constexpr(std::is_void_v<value_type> && !std::is_constructible_v<allocator_type, typename base_type::allocator_type>) {
+        if constexpr(std::is_void_v<element_type> && !std::is_constructible_v<allocator_type, typename base_type::allocator_type>) {
             return allocator_type{};
         } else {
             return allocator_type{base_type::get_allocator()};
@@ -41622,21 +43381,16 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      * @param entt A valid identifier.
      */
     void get([[maybe_unused]] const entity_type entt) const noexcept {
-        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
+        ENTT_ASSERT(base_type::contains(entt), "Invalid entity");
     }
 
     /**
      * @brief Returns an empty tuple.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
      * @param entt A valid identifier.
      * @return Returns an empty tuple.
      */
     [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
-        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
+        ENTT_ASSERT(base_type::contains(entt), "Invalid entity");
         return std::tuple{};
     }
 
@@ -41663,7 +43417,7 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      */
     template<typename... Func>
     void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
-        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
+        ENTT_ASSERT(base_type::contains(entt), "Invalid entity");
         (std::forward<Func>(func)(), ...);
     }
 
@@ -41689,12 +43443,12 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      * @return An iterable object to use to _visit_ the storage.
      */
     [[nodiscard]] iterable each() noexcept {
-        return {internal::extended_storage_iterator{base_type::begin()}, internal::extended_storage_iterator{base_type::end()}};
+        return iterable{base_type::begin(), base_type::end()};
     }
 
     /*! @copydoc each */
     [[nodiscard]] const_iterable each() const noexcept {
-        return {internal::extended_storage_iterator{base_type::cbegin()}, internal::extended_storage_iterator{base_type::cend()}};
+        return const_iterable{base_type::cbegin(), base_type::cend()};
     }
 
     /**
@@ -41705,12 +43459,12 @@ class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<T
      * @return A reverse iterable object to use to _visit_ the storage.
      */
     [[nodiscard]] reverse_iterable reach() noexcept {
-        return {internal::extended_storage_iterator{base_type::rbegin()}, internal::extended_storage_iterator{base_type::rend()}};
+        return reverse_iterable{{base_type::rbegin()}, {base_type::rend()}};
     }
 
     /*! @copydoc reach */
     [[nodiscard]] const_reverse_iterable reach() const noexcept {
-        return {internal::extended_storage_iterator{base_type::crbegin()}, internal::extended_storage_iterator{base_type::crend()}};
+        return const_reverse_iterable{{base_type::crbegin()}, {base_type::crend()}};
     }
 };
 
@@ -41724,15 +43478,27 @@ class basic_storage<Entity, Entity, Allocator>
     : public basic_sparse_set<Entity, Allocator> {
     using alloc_traits = std::allocator_traits<Allocator>;
     static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
-    using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
-    using underlying_iterator = typename underlying_type::basic_iterator;
+    using underlying_iterator = typename basic_sparse_set<Entity, Allocator>::basic_iterator;
+    using traits_type = entt_traits<Entity>;
+
+    auto next() noexcept {
+        entity_type entt = null;
 
-    auto entity_at(const std::size_t pos) const noexcept {
-        ENTT_ASSERT(pos < underlying_type::traits_type::to_entity(null), "Invalid element");
-        return underlying_type::traits_type::combine(static_cast<typename underlying_type::traits_type::entity_type>(pos), {});
+        do {
+            ENTT_ASSERT(placeholder < traits_type::to_entity(null), "No more entities available");
+            entt = traits_type::combine(static_cast<typename traits_type::entity_type>(placeholder++), {});
+        } while(base_type::current(entt) != traits_type::to_version(tombstone) && entt != null);
+
+        return entt;
     }
 
 protected:
+    /*! @brief Erases all entities of a storage. */
+    void pop_all() override {
+        base_type::pop_all();
+        placeholder = {};
+    }
+
     /**
      * @brief Assigns an entity to a storage.
      * @param hint A valid identifier.
@@ -41743,16 +43509,18 @@ class basic_storage<Entity, Entity, Allocator>
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Base type. */
     using base_type = basic_sparse_set<Entity, Allocator>;
+    /*! @brief Element type. */
+    using element_type = Entity;
     /*! @brief Type of the objects assigned to entities. */
-    using value_type = Entity;
+    using value_type = void;
     /*! @brief Underlying entity identifier. */
     using entity_type = Entity;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Extended iterable storage proxy. */
     using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
     /*! @brief Constant extended iterable storage proxy. */
@@ -41761,6 +43529,8 @@ class basic_storage<Entity, Entity, Allocator>
     using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
     /*! @brief Constant extended reverse iterable storage proxy. */
     using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;
+    /*! @brief Storage deletion policy. */
+    static constexpr deletion_policy storage_policy = deletion_policy::swap_only;
 
     /*! @brief Default constructor. */
     basic_storage()
@@ -41772,22 +43542,36 @@ class basic_storage<Entity, Entity, Allocator>
      * @param allocator The allocator to use.
      */
     explicit basic_storage(const allocator_type &allocator)
-        : base_type{type_id<void>(), deletion_policy::swap_only, allocator} {}
+        : base_type{type_id<void>(), storage_policy, allocator} {}
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_storage(const basic_storage &) = delete;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
     basic_storage(basic_storage &&other) noexcept
-        : base_type{std::move(other)} {}
+        : base_type{std::move(other)},
+          placeholder{other.placeholder} {}
 
     /**
      * @brief Allocator-extended move constructor.
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
-        : base_type{std::move(other), allocator} {}
+    basic_storage(basic_storage &&other, const allocator_type &allocator)
+        : base_type{std::move(other), allocator},
+          placeholder{other.placeholder} {}
+
+    /*! @brief Default destructor. */
+    ~basic_storage() override = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This storage.
+     */
+    basic_storage &operator=(const basic_storage &) = delete;
 
     /**
      * @brief Move assignment operator.
@@ -41795,6 +43579,7 @@ class basic_storage<Entity, Entity, Allocator>
      * @return This storage.
      */
     basic_storage &operator=(basic_storage &&other) noexcept {
+        placeholder = other.placeholder;
         base_type::operator=(std::move(other));
         return *this;
     }
@@ -41814,11 +43599,6 @@ class basic_storage<Entity, Entity, Allocator>
 
     /**
      * @brief Returns an empty tuple.
-     *
-     * @warning
-     * Attempting to use an entity that doesn't belong to the storage results in
-     * undefined behavior.
-     *
      * @param entt A valid identifier.
      * @return Returns an empty tuple.
      */
@@ -41833,7 +43613,7 @@ class basic_storage<Entity, Entity, Allocator>
      */
     entity_type emplace() {
         const auto len = base_type::free_list();
-        const auto entt = (len == base_type::size()) ? entity_at(len) : base_type::data()[len];
+        const auto entt = (len == base_type::size()) ? next() : base_type::data()[len];
         return *base_type::try_emplace(entt, true);
     }
 
@@ -41847,22 +43627,13 @@ class basic_storage<Entity, Entity, Allocator>
      * @return A valid identifier.
      */
     entity_type emplace(const entity_type hint) {
-        if(hint == null || hint == tombstone) {
-            return emplace();
-        } else if(const auto curr = underlying_type::traits_type::construct(underlying_type::traits_type::to_entity(hint), base_type::current(hint)); curr == tombstone) {
-            const auto pos = static_cast<size_type>(underlying_type::traits_type::to_entity(hint));
-            const auto entt = *base_type::try_emplace(hint, true);
-
-            while(!(pos < base_type::size())) {
-                base_type::try_emplace(entity_at(base_type::size() - 1u), false);
+        if(hint != null && hint != tombstone) {
+            if(const auto curr = traits_type::construct(traits_type::to_entity(hint), base_type::current(hint)); curr == tombstone || !(base_type::index(curr) < base_type::free_list())) {
+                return *base_type::try_emplace(hint, true);
             }
-
-            return entt;
-        } else if(const auto idx = base_type::index(curr); idx < base_type::free_list()) {
-            return emplace();
-        } else {
-            return *base_type::try_emplace(hint, true);
         }
+
+        return emplace();
     }
 
     /**
@@ -41890,39 +43661,10 @@ class basic_storage<Entity, Entity, Allocator>
         }
 
         for(; first != last; ++first) {
-            *first = *base_type::try_emplace(entity_at(base_type::free_list()), true);
+            *first = *base_type::try_emplace(next(), true);
         }
     }
 
-    /**
-     * @brief Makes all elements in a range contiguous.
-     * @tparam It Type of forward iterator.
-     * @param first An iterator to the first element of the range to pack.
-     * @param last An iterator past the last element of the range to pack.
-     * @return The number of elements within the newly created range.
-     */
-    template<typename It>
-    [[deprecated("use sort_as instead")]] size_type pack(It first, It last) {
-        base_type::sort_as(first, last);
-        return static_cast<size_type>(std::distance(first, last));
-    }
-
-    /**
-     * @brief Returns the number of elements considered still in use.
-     * @return The number of elements considered still in use.
-     */
-    [[deprecated("use free_list() instead")]] [[nodiscard]] size_type in_use() const noexcept {
-        return base_type::free_list();
-    }
-
-    /**
-     * @brief Sets the number of elements considered still in use.
-     * @param len The number of elements considered still in use.
-     */
-    [[deprecated("use free_list(len) instead")]] void in_use(const size_type len) noexcept {
-        base_type::free_list(len);
-    }
-
     /**
      * @brief Returns an iterable object to use to _visit_ a storage.
      *
@@ -41931,12 +43673,13 @@ class basic_storage<Entity, Entity, Allocator>
      * @return An iterable object to use to _visit_ the storage.
      */
     [[nodiscard]] iterable each() noexcept {
-        return {internal::extended_storage_iterator{base_type::begin(0)}, internal::extended_storage_iterator{base_type::end(0)}};
+        return std::as_const(*this).each();
     }
 
     /*! @copydoc each */
     [[nodiscard]] const_iterable each() const noexcept {
-        return {internal::extended_storage_iterator{base_type::cbegin(0)}, internal::extended_storage_iterator{base_type::cend(0)}};
+        const auto it = base_type::cend();
+        return const_iterable{it - base_type::free_list(), it};
     }
 
     /**
@@ -41947,13 +43690,17 @@ class basic_storage<Entity, Entity, Allocator>
      * @return A reverse iterable object to use to _visit_ the storage.
      */
     [[nodiscard]] reverse_iterable reach() noexcept {
-        return {internal::extended_storage_iterator{base_type::rbegin()}, internal::extended_storage_iterator{base_type::rend(0)}};
+        return std::as_const(*this).reach();
     }
 
     /*! @copydoc reach */
     [[nodiscard]] const_reverse_iterable reach() const noexcept {
-        return {internal::extended_storage_iterator{base_type::crbegin()}, internal::extended_storage_iterator{base_type::crend(0)}};
+        const auto it = base_type::crbegin();
+        return const_reverse_iterable{it, it + base_type::free_list()};
     }
+
+private:
+    size_type placeholder{};
 };
 
 } // namespace entt
@@ -41965,6 +43712,7 @@ class basic_storage<Entity, Entity, Allocator>
 #define ENTT_ENTITY_VIEW_HPP
 
 #include <array>
+#include <cstddef>
 #include <iterator>
 #include <tuple>
 #include <type_traits>
@@ -41985,77 +43733,83 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename Type, typename Entity>
-[[nodiscard]] bool all_of_but(const std::size_t index, const Type *const *it, const std::size_t len, const Entity entt) noexcept {
-    std::size_t pos{};
-    for(; (pos != index) && it[pos]->contains(entt); ++pos) {}
-
-    if(pos == index) {
-        for(++pos; (pos != len) && it[pos]->contains(entt); ++pos) {}
-    }
+template<typename Type>
+const Type *view_placeholder() {
+    static_assert(std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, Type>, "Unexpected type");
+    static const Type placeholder{};
+    return &placeholder;
+}
 
-    return pos == len;
+template<typename It, typename Entity>
+[[nodiscard]] bool all_of(It first, const It last, const Entity entt) noexcept {
+    for(; (first != last) && (*first)->contains(entt); ++first) {}
+    return first == last;
 }
 
-template<typename Type, typename Entity>
-[[nodiscard]] bool none_of(const Type *const *it, const std::size_t len, const Entity entt) noexcept {
-    std::size_t pos{};
-    for(; (pos != len) && !(it[pos] && it[pos]->contains(entt)); ++pos) {}
-    return pos == len;
+template<typename It, typename Entity>
+[[nodiscard]] bool none_of(It first, const It last, const Entity entt) noexcept {
+    for(; (first != last) && !(*first)->contains(entt); ++first) {}
+    return first == last;
 }
 
-template<typename Type>
-[[nodiscard]] bool fully_initialized(const Type *const *it, const std::size_t len) noexcept {
-    std::size_t pos{};
-    for(; (pos != len) && it[pos]; ++pos) {}
-    return pos == len;
+template<typename It>
+[[nodiscard]] bool fully_initialized(It first, const It last) noexcept {
+    for(const auto *placeholder = view_placeholder<std::remove_const_t<std::remove_pointer_t<typename std::iterator_traits<It>::value_type>>>(); (first != last) && *first != placeholder; ++first) {}
+    return first == last;
 }
 
-template<typename Result, typename View, typename Other, std::size_t... VGet, std::size_t... VExclude, std::size_t... OGet, std::size_t... OExclude>
-[[nodiscard]] Result view_pack(const View &view, const Other &other, std::index_sequence<VGet...>, std::index_sequence<VExclude...>, std::index_sequence<OGet...>, std::index_sequence<OExclude...>) {
+template<typename Result, typename View, typename Other, std::size_t... GLhs, std::size_t... ELhs, std::size_t... GRhs, std::size_t... ERhs>
+[[nodiscard]] Result view_pack(const View &view, const Other &other, std::index_sequence<GLhs...>, std::index_sequence<ELhs...>, std::index_sequence<GRhs...>, std::index_sequence<ERhs...>) {
     Result elem{};
     // friend-initialization, avoid multiple calls to refresh
-    elem.pools = {view.template storage<VGet>()..., other.template storage<OGet>()...};
-    elem.filter = {view.template storage<sizeof...(VGet) + VExclude>()..., other.template storage<sizeof...(OGet) + OExclude>()...};
+    elem.pools = {view.template storage<GLhs>()..., other.template storage<GRhs>()...};
+    elem.filter = {view.template storage<sizeof...(GLhs) + ELhs>()..., other.template storage<sizeof...(GRhs) + ERhs>()...};
     elem.refresh();
     return elem;
 }
 
 template<typename Type, std::size_t Get, std::size_t Exclude>
 class view_iterator final {
+    template<typename, typename...>
+    friend class extended_view_iterator;
+
     using iterator_type = typename Type::const_iterator;
+    using iterator_traits = std::iterator_traits<iterator_type>;
+
+    [[nodiscard]] bool valid(const typename iterator_traits::value_type entt) const noexcept {
+        return ((Get != 1u) || (entt != tombstone))
+               && internal::all_of(pools.begin(), pools.begin() + index, entt) && internal::all_of(pools.begin() + index + 1, pools.end(), entt)
+               && internal::none_of(filter.begin(), filter.end(), entt);
+    }
 
-    [[nodiscard]] bool valid(const typename iterator_type::value_type entt) const noexcept {
-        return ((Get != 1u) || (entt != tombstone)) && all_of_but(index, pools.data(), Get, entt) && none_of(filter.data(), Exclude, entt);
+    void seek_next() {
+        for(constexpr iterator_type sentinel{}; it != sentinel && !valid(*it); ++it) {}
     }
 
 public:
-    using value_type = typename iterator_type::value_type;
-    using pointer = typename iterator_type::pointer;
-    using reference = typename iterator_type::reference;
-    using difference_type = typename iterator_type::difference_type;
+    using value_type = typename iterator_traits::value_type;
+    using pointer = typename iterator_traits::pointer;
+    using reference = typename iterator_traits::reference;
+    using difference_type = typename iterator_traits::difference_type;
     using iterator_category = std::forward_iterator_tag;
 
     constexpr view_iterator() noexcept
         : it{},
-          last{},
           pools{},
           filter{},
           index{} {}
 
-    view_iterator(iterator_type curr, iterator_type to, std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl, const std::size_t idx) noexcept
-        : it{curr},
-          last{to},
+    view_iterator(iterator_type first, std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl, const std::size_t idx) noexcept
+        : it{first},
           pools{value},
           filter{excl},
           index{idx} {
-        while(it != last && !valid(*it)) {
-            ++it;
-        }
+        seek_next();
     }
 
     view_iterator &operator++() noexcept {
-        while(++it != last && !valid(*it)) {}
+        ++it;
+        seek_next();
         return *this;
     }
 
@@ -42077,7 +43831,6 @@ class view_iterator final {
 
 private:
     iterator_type it;
-    iterator_type last;
     std::array<const Type *, Get> pools;
     std::array<const Type *, Exclude> filter;
     std::size_t index;
@@ -42093,23 +43846,27 @@ template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
     return !(lhs == rhs);
 }
 
-template<typename It, typename... Type>
-struct extended_view_iterator final {
+template<typename It, typename... Get>
+class extended_view_iterator final {
+    template<std::size_t... Index>
+    [[nodiscard]] auto dereference(std::index_sequence<Index...>) const noexcept {
+        return std::tuple_cat(std::make_tuple(*it), static_cast<Get *>(const_cast<constness_as_t<typename Get::base_type, Get> *>(std::get<Index>(it.pools)))->get_as_tuple(*it)...);
+    }
+
+public:
     using iterator_type = It;
-    using difference_type = std::ptrdiff_t;
-    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Type>().get_as_tuple({})...));
+    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Get>().get_as_tuple({})...));
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
     constexpr extended_view_iterator()
-        : it{},
-          pools{} {}
+        : it{} {}
 
-    extended_view_iterator(iterator_type from, std::tuple<Type *...> value)
-        : it{from},
-          pools{value} {}
+    extended_view_iterator(iterator_type from)
+        : it{from} {}
 
     extended_view_iterator &operator++() noexcept {
         return ++it, *this;
@@ -42121,7 +43878,7 @@ struct extended_view_iterator final {
     }
 
     [[nodiscard]] reference operator*() const noexcept {
-        return std::apply([entt = *it](auto *...curr) { return std::tuple_cat(std::make_tuple(entt), curr->get_as_tuple(entt)...); }, pools);
+        return dereference(std::index_sequence_for<Get...>{});
     }
 
     [[nodiscard]] pointer operator->() const noexcept {
@@ -42137,7 +43894,6 @@ struct extended_view_iterator final {
 
 private:
     It it;
-    std::tuple<Type *...> pools;
 };
 
 template<typename... Lhs, typename... Rhs>
@@ -42164,8 +43920,8 @@ template<typename... Lhs, typename... Rhs>
  * View iterators aren't invalidated if:
  *
  * * New elements are added to the storage iterated by the view.
- * * The entity currently returned is modified (for example, components are
- *   added or removed from it).
+ * * The entity currently returned is modified (for example, elements are added
+ *   or removed from it).
  * * The entity currently returned is destroyed.
  *
  * In all other cases, modifying the storage iterated by a view in any way can
@@ -42183,38 +43939,76 @@ class basic_view;
  */
 template<typename Type, std::size_t Get, std::size_t Exclude>
 class basic_common_view {
-    template<typename Return, typename View, typename Other, std::size_t... VGet, std::size_t... VExclude, std::size_t... OGet, std::size_t... OExclude>
-    friend Return internal::view_pack(const View &, const Other &, std::index_sequence<VGet...>, std::index_sequence<VExclude...>, std::index_sequence<OGet...>, std::index_sequence<OExclude...>);
+    static_assert(std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, Type>, "Unexpected type");
+
+    template<typename Return, typename View, typename Other, std::size_t... GLhs, std::size_t... ELhs, std::size_t... GRhs, std::size_t... ERhs>
+    friend Return internal::view_pack(const View &, const Other &, std::index_sequence<GLhs...>, std::index_sequence<ELhs...>, std::index_sequence<GRhs...>, std::index_sequence<ERhs...>);
+
+    [[nodiscard]] auto offset() const noexcept {
+        ENTT_ASSERT(index != Get, "Invalid view");
+        return (pools[index]->policy() == deletion_policy::swap_only) ? pools[index]->free_list() : pools[index]->size();
+    }
+
+    void unchecked_refresh() noexcept {
+        index = 0u;
+
+        if constexpr(Get > 1u) {
+            for(size_type pos{1u}; pos < Get; ++pos) {
+                if(pools[pos]->size() < pools[index]->size()) {
+                    index = pos;
+                }
+            }
+        }
+    }
 
 protected:
     /*! @cond TURN_OFF_DOXYGEN */
-    basic_common_view() noexcept = default;
+    basic_common_view() noexcept {
+        for(size_type pos{}; pos < Exclude; ++pos) {
+            filter[pos] = internal::view_placeholder<Type>();
+        }
+    }
 
     basic_common_view(std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl) noexcept
         : pools{value},
           filter{excl},
-          leading{},
           index{Get} {
         unchecked_refresh();
     }
 
-    void use(const std::size_t pos) noexcept {
-        if(leading) {
-            index = pos;
-            leading = pools[index];
+    [[nodiscard]] const Type *pool_at(const std::size_t pos) const noexcept {
+        return pools[pos];
+    }
+
+    [[nodiscard]] const Type *storage(const std::size_t pos) const noexcept {
+        if(pos < Get) {
+            return pools[pos];
+        }
+
+        if(const auto idx = pos - Get; filter[idx] != internal::view_placeholder<Type>()) {
+            return filter[idx];
         }
+
+        return nullptr;
     }
 
-    void unchecked_refresh() noexcept {
-        index = 0u;
+    void storage(const std::size_t pos, const Type *elem) noexcept {
+        ENTT_ASSERT(elem != nullptr, "Unexpected element");
 
-        for(size_type pos{1u}; pos < Get; ++pos) {
-            if(pools[pos]->size() < pools[index]->size()) {
-                index = pos;
-            }
+        if(pos < Get) {
+            pools[pos] = elem;
+            refresh();
+        } else {
+            filter[pos - Get] = elem;
         }
+    }
 
-        leading = pools[index];
+    [[nodiscard]] bool none_of(const typename Type::entity_type entt) const noexcept {
+        return internal::none_of(filter.begin(), filter.end(), entt);
+    }
+
+    void use(const std::size_t pos) noexcept {
+        index = (index != Get) ? pos : Get;
     }
     /*! @endcond */
 
@@ -42225,12 +44019,12 @@ class basic_common_view {
     using entity_type = typename Type::entity_type;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
-    /*! @brief Bidirectional iterator type. */
+    /*! @brief Forward iterator type. */
     using iterator = internal::view_iterator<common_type, Get, Exclude>;
 
     /*! @brief Updates the internal leading view if required. */
     void refresh() noexcept {
-        size_type pos = (leading != nullptr) * Get;
+        size_type pos = static_cast<size_type>(index != Get) * Get;
         for(; pos < Get && pools[pos] != nullptr; ++pos) {}
 
         if(pos == Get) {
@@ -42243,7 +44037,7 @@ class basic_common_view {
      * @return The leading storage of the view.
      */
     [[nodiscard]] const common_type *handle() const noexcept {
-        return leading;
+        return (index != Get) ? pools[index] : nullptr;
     }
 
     /**
@@ -42251,7 +44045,7 @@ class basic_common_view {
      * @return Estimated number of entities iterated by the view.
      */
     [[nodiscard]] size_type size_hint() const noexcept {
-        return leading ? leading->size() : size_type{};
+        return (index != Get) ? offset() : size_type{};
     }
 
     /**
@@ -42262,7 +44056,7 @@ class basic_common_view {
      * @return An iterator to the first entity of the view.
      */
     [[nodiscard]] iterator begin() const noexcept {
-        return leading ? iterator{leading->begin(0), leading->end(0), pools, filter, index} : iterator{};
+        return (index != Get) ? iterator{pools[index]->end() - static_cast<typename iterator::difference_type>(offset()), pools, filter, index} : iterator{};
     }
 
     /**
@@ -42270,7 +44064,7 @@ class basic_common_view {
      * @return An iterator to the entity following the last entity of the view.
      */
     [[nodiscard]] iterator end() const noexcept {
-        return leading ? iterator{leading->end(0), leading->end(0), pools, filter, index} : iterator{};
+        return (index != Get) ? iterator{pools[index]->end(), pools, filter, index} : iterator{};
     }
 
     /**
@@ -42289,9 +44083,9 @@ class basic_common_view {
      * otherwise.
      */
     [[nodiscard]] entity_type back() const noexcept {
-        if(leading) {
-            auto it = leading->rbegin(0);
-            const auto last = leading->rend(0);
+        if(index != Get) {
+            auto it = pools[index]->rbegin();
+            const auto last = it + static_cast<typename iterator::difference_type>(offset());
             for(; it != last && !contains(*it); ++it) {}
             return it == last ? null : *it;
         }
@@ -42306,7 +44100,7 @@ class basic_common_view {
      * iterator otherwise.
      */
     [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        return contains(entt) ? iterator{leading->find(entt), leading->end(), pools, filter, index} : end();
+        return contains(entt) ? iterator{pools[index]->find(entt), pools, filter, index} : end();
     }
 
     /**
@@ -42314,7 +44108,7 @@ class basic_common_view {
      * @return True if the view is fully initialized, false otherwise.
      */
     [[nodiscard]] explicit operator bool() const noexcept {
-        return leading && internal::fully_initialized(filter.data(), Exclude);
+        return (index != Get) && internal::fully_initialized(filter.begin(), filter.end());
     }
 
     /**
@@ -42323,21 +44117,16 @@ class basic_common_view {
      * @return True if the view contains the given entity, false otherwise.
      */
     [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        if(leading) {
-            const auto idx = leading->find(entt).index();
-            return (!(idx < 0 || idx > leading->begin(0).index())) && internal::all_of_but(index, pools.data(), Get, entt) && internal::none_of(filter.data(), Exclude, entt);
-        }
-
-        return false;
+        return (index != Get)
+               && internal::all_of(pools.begin(), pools.end(), entt)
+               && internal::none_of(filter.begin(), filter.end(), entt)
+               && pools[index]->index(entt) < offset();
     }
 
-protected:
-    /*! @cond TURN_OFF_DOXYGEN */
+private:
     std::array<const common_type *, Get> pools{};
     std::array<const common_type *, Exclude> filter{};
-    const common_type *leading{};
     size_type index{Get};
-    /*! @endcond */
 };
 
 /**
@@ -42353,15 +44142,16 @@ class basic_common_view {
  * @tparam Exclude Types of storage used to filter the view.
  */
 template<typename... Get, typename... Exclude>
-class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)> {
+class basic_view<get_t<Get...>, exclude_t<Exclude...>, std::enable_if_t<(sizeof...(Get) != 0u)>>
+    : public basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)> {
     using base_type = basic_common_view<std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>, sizeof...(Get), sizeof...(Exclude)>;
 
     template<typename Type>
-    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::value_type..., typename Exclude::value_type...>>;
+    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::element_type..., typename Exclude::element_type...>>;
 
     template<std::size_t... Index>
-    auto storage(std::index_sequence<Index...>) const noexcept {
-        return std::make_tuple(storage<Index>()...);
+    [[nodiscard]] auto get(const typename base_type::entity_type entt, std::index_sequence<Index...>) const noexcept {
+        return std::tuple_cat(storage<Index>()->get_as_tuple(entt)...);
     }
 
     template<std::size_t Curr, std::size_t Other, typename... Args>
@@ -42375,8 +44165,10 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
 
     template<std::size_t Curr, typename Func, std::size_t... Index>
     void each(Func &func, std::index_sequence<Index...>) const {
+        static constexpr bool tombstone_check_required = ((sizeof...(Get) == 1u) && ... && (Get::storage_policy == deletion_policy::in_place));
+
         for(const auto curr: storage<Curr>()->each()) {
-            if(const auto entt = std::get<0>(curr); ((sizeof...(Get) != 1u) || (entt != tombstone)) && internal::all_of_but(this->index, this->pools.data(), sizeof...(Get), entt) && internal::none_of(this->filter.data(), sizeof...(Exclude), entt)) {
+            if(const auto entt = std::get<0>(curr); (!tombstone_check_required || (entt != tombstone)) && ((Curr == Index || base_type::pool_at(Index)->contains(entt)) && ...) && base_type::none_of(entt)) {
                 if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_view>().get({})))>) {
                     std::apply(func, std::tuple_cat(std::make_tuple(entt), dispatch_get<Curr, Index>(curr)...));
                 } else {
@@ -42388,7 +44180,9 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
 
     template<typename Func, std::size_t... Index>
     void pick_and_each(Func &func, std::index_sequence<Index...> seq) const {
-        ((storage<Index>() == base_type::handle() ? each<Index>(func, seq) : void()), ...);
+        if(const auto *view = base_type::handle(); view != nullptr) {
+            ((view == base_type::pool_at(Index) ? each<Index>(func, seq) : void()), ...);
+        }
     }
 
 public:
@@ -42398,7 +44192,7 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     using entity_type = typename base_type::entity_type;
     /*! @brief Unsigned integer type. */
     using size_type = typename base_type::size_type;
-    /*! @brief Bidirectional iterator type. */
+    /*! @brief Forward iterator type. */
     using iterator = typename base_type::iterator;
     /*! @brief Iterable view type. */
     using iterable = iterable_adaptor<internal::extended_view_iterator<iterator, Get...>>;
@@ -42425,8 +44219,8 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
         : basic_view{std::make_from_tuple<basic_view>(std::tuple_cat(value, excl))} {}
 
     /**
-     * @brief Forces a view to use a given component to drive iterations
-     * @tparam Type Type of component to use to drive iterations.
+     * @brief Forces a view to use a given element to drive iterations
+     * @tparam Type Type of element to use to drive iterations.
      */
     template<typename Type>
     void use() noexcept {
@@ -42434,8 +44228,8 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     }
 
     /**
-     * @brief Forces a view to use a given component to drive iterations
-     * @tparam Index Index of the component to use to drive iterations.
+     * @brief Forces a view to use a given element to drive iterations
+     * @tparam Index Index of the element to use to drive iterations.
      */
     template<std::size_t Index>
     void use() noexcept {
@@ -42443,9 +44237,9 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     }
 
     /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
      */
     template<typename Type>
     [[nodiscard]] auto *storage() const noexcept {
@@ -42460,12 +44254,7 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     template<std::size_t Index>
     [[nodiscard]] auto *storage() const noexcept {
         using type = type_list_element_t<Index, type_list<Get..., Exclude...>>;
-
-        if constexpr(Index < sizeof...(Get)) {
-            return static_cast<type *>(const_cast<constness_as_t<common_type, type> *>(this->pools[Index]));
-        } else {
-            return static_cast<type *>(const_cast<constness_as_t<common_type, type> *>(this->filter[Index - sizeof...(Get)]));
-        }
+        return static_cast<type *>(const_cast<constness_as_t<common_type, type> *>(base_type::storage(Index)));
     }
 
     /**
@@ -42475,7 +44264,7 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
      */
     template<typename Type>
     void storage(Type &elem) noexcept {
-        storage<index_of<typename Type::value_type>>(elem);
+        storage<index_of<typename Type::element_type>>(elem);
     }
 
     /**
@@ -42487,30 +44276,24 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     template<std::size_t Index, typename Type>
     void storage(Type &elem) noexcept {
         static_assert(std::is_convertible_v<Type &, type_list_element_t<Index, type_list<Get..., Exclude...>> &>, "Unexpected type");
-
-        if constexpr(Index < sizeof...(Get)) {
-            this->pools[Index] = &elem;
-            base_type::refresh();
-        } else {
-            this->filter[Index - sizeof...(Get)] = &elem;
-        }
+        base_type::storage(Index, &elem);
     }
 
     /**
-     * @brief Returns the components assigned to the given entity.
+     * @brief Returns the elements assigned to the given entity.
      * @param entt A valid identifier.
-     * @return The components assigned to the given entity.
+     * @return The elements assigned to the given entity.
      */
     [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
         return get(entt);
     }
 
     /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Type Type of the component to get.
-     * @tparam Other Other types of components to get.
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Type Type of the element to get.
+     * @tparam Other Other types of elements to get.
      * @param entt A valid identifier.
-     * @return The components assigned to the entity.
+     * @return The elements assigned to the entity.
      */
     template<typename Type, typename... Other>
     [[nodiscard]] decltype(auto) get(const entity_type entt) const {
@@ -42518,15 +44301,15 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     }
 
     /**
-     * @brief Returns the components assigned to the given entity.
-     * @tparam Index Indexes of the components to get.
+     * @brief Returns the elements assigned to the given entity.
+     * @tparam Index Indexes of the elements to get.
      * @param entt A valid identifier.
-     * @return The components assigned to the entity.
+     * @return The elements assigned to the entity.
      */
     template<std::size_t... Index>
     [[nodiscard]] decltype(auto) get(const entity_type entt) const {
         if constexpr(sizeof...(Index) == 0) {
-            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, storage(std::index_sequence_for<Get...>{}));
+            return get(entt, std::index_sequence_for<Get...>{});
         } else if constexpr(sizeof...(Index) == 1) {
             return (storage<Index>()->get(entt), ...);
         } else {
@@ -42535,7 +44318,7 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
     }
 
     /**
-     * @brief Iterates entities and components and applies the given function
+     * @brief Iterates entities and elements and applies the given function
      * object to them.
      *
      * The signature of the function must be equivalent to one of the following
@@ -42551,28 +44334,25 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
      */
     template<typename Func>
     void each(Func func) const {
-        if(base_type::handle() != nullptr) {
-            pick_and_each(func, std::index_sequence_for<Get...>{});
-        }
+        pick_and_each(func, std::index_sequence_for<Get...>{});
     }
 
     /**
      * @brief Returns an iterable object to use to _visit_ a view.
      *
      * The iterable object returns a tuple that contains the current entity and
-     * a set of references to its non-empty components. The _constness_ of the
-     * components is as requested.
+     * a set of references to its non-empty elements. The _constness_ of the
+     * elements is as requested.
      *
      * @return An iterable object to use to _visit_ the view.
      */
     [[nodiscard]] iterable each() const noexcept {
-        const auto as_pools = storage(std::index_sequence_for<Get...>{});
-        return {internal::extended_view_iterator{base_type::begin(), as_pools}, internal::extended_view_iterator{base_type::end(), as_pools}};
+        return iterable{base_type::begin(), base_type::end()};
     }
 
     /**
      * @brief Combines two views in a _more specific_ one.
-     * @tparam OGet Component list of the view to combine with.
+     * @tparam OGet Element list of the view to combine with.
      * @tparam OExclude Filter list of the view to combine with.
      * @param other The view to combine with.
      * @return A more specific view.
@@ -42588,15 +44368,20 @@ class basic_view<get_t<Get...>, exclude_t<Exclude...>>: public basic_common_view
  * @brief Basic storage view implementation.
  * @warning For internal use only, backward compatibility not guaranteed.
  * @tparam Type Common type among all storage types.
+ * @tparam Policy Storage policy.
  */
-template<typename Type>
+template<typename Type, deletion_policy Policy>
 class basic_storage_view {
+    static_assert(std::is_same_v<std::remove_const_t<std::remove_reference_t<Type>>, Type>, "Unexpected type");
+
 protected:
     /*! @cond TURN_OFF_DOXYGEN */
     basic_storage_view() noexcept = default;
 
     basic_storage_view(const Type *value) noexcept
-        : leading{value} {}
+        : leading{value} {
+        ENTT_ASSERT(leading->policy() == Policy, "Unexpected storage policy");
+    }
     /*! @endcond */
 
 public:
@@ -42607,9 +44392,9 @@ class basic_storage_view {
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
     /*! @brief Random access iterator type. */
-    using iterator = typename common_type::iterator;
-    /*! @brief Reversed iterator type. */
-    using reverse_iterator = typename common_type::reverse_iterator;
+    using iterator = std::conditional_t<Policy == deletion_policy::in_place, internal::view_iterator<common_type, 1u, 0u>, typename common_type::iterator>;
+    /*! @brief Reverse iterator type. */
+    using reverse_iterator = std::conditional_t<Policy == deletion_policy::in_place, void, typename common_type::reverse_iterator>;
 
     /**
      * @brief Returns the leading storage of a view, if any.
@@ -42620,19 +44405,43 @@ class basic_storage_view {
     }
 
     /**
-     * @brief Returns the number of entities that have the given component.
-     * @return Number of entities that have the given component.
+     * @brief Returns the number of entities that have the given element.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
+     * @return Number of entities that have the given element.
      */
-    [[nodiscard]] size_type size() const noexcept {
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, size_type> size() const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->size() : size_type{};
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return leading ? leading->free_list() : size_type{};
+        }
+    }
+
+    /**
+     * @brief Estimates the number of entities iterated by the view.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
+     * @return Estimated number of entities iterated by the view.
+     */
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol == deletion_policy::in_place, size_type> size_hint() const noexcept {
         return leading ? leading->size() : size_type{};
     }
 
     /**
      * @brief Checks whether a view is empty.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
      * @return True if the view is empty, false otherwise.
      */
-    [[nodiscard]] bool empty() const noexcept {
-        return !leading || leading->empty();
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, bool> empty() const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return !leading || leading->empty();
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return !leading || (leading->free_list() == 0u);
+        }
     }
 
     /**
@@ -42643,7 +44452,14 @@ class basic_storage_view {
      * @return An iterator to the first entity of the view.
      */
     [[nodiscard]] iterator begin() const noexcept {
-        return leading ? leading->begin() : iterator{};
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->begin() : iterator{};
+        } else if constexpr(Policy == deletion_policy::swap_only) {
+            return leading ? (leading->end() - leading->free_list()) : iterator{};
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+            return leading ? iterator{leading->begin(), {leading}, {}, 0u} : iterator{};
+        }
     }
 
     /**
@@ -42651,7 +44467,12 @@ class basic_storage_view {
      * @return An iterator to the entity following the last entity of the view.
      */
     [[nodiscard]] iterator end() const noexcept {
-        return leading ? leading->end() : iterator{};
+        if constexpr(Policy == deletion_policy::swap_and_pop || Policy == deletion_policy::swap_only) {
+            return leading ? leading->end() : iterator{};
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+            return leading ? iterator{leading->end(), {leading}, {}, 0u} : iterator{};
+        }
     }
 
     /**
@@ -42659,20 +44480,29 @@ class basic_storage_view {
      *
      * If the view is empty, the returned iterator will be equal to `rend()`.
      *
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
      * @return An iterator to the first entity of the reversed view.
      */
-    [[nodiscard]] reverse_iterator rbegin() const noexcept {
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, reverse_iterator> rbegin() const noexcept {
         return leading ? leading->rbegin() : reverse_iterator{};
     }
 
     /**
      * @brief Returns an iterator that is past the last entity of the reversed
      * view.
+     * @tparam Pol Dummy template parameter used for sfinae purposes only.
      * @return An iterator to the entity following the last entity of the
      * reversed view.
      */
-    [[nodiscard]] reverse_iterator rend() const noexcept {
-        return leading ? leading->rend() : reverse_iterator{};
+    template<typename..., deletion_policy Pol = Policy>
+    [[nodiscard]] std::enable_if_t<Pol != deletion_policy::in_place, reverse_iterator> rend() const noexcept {
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->rend() : reverse_iterator{};
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return leading ? (leading->rbegin() + leading->free_list()) : reverse_iterator{};
+        }
     }
 
     /**
@@ -42681,7 +44511,15 @@ class basic_storage_view {
      * otherwise.
      */
     [[nodiscard]] entity_type front() const noexcept {
-        return empty() ? null : *leading->begin();
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return empty() ? null : *leading->begin();
+        } else if constexpr(Policy == deletion_policy::swap_only) {
+            return empty() ? null : *(leading->end() - leading->free_list());
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+            const auto it = begin();
+            return (it == end()) ? null : *it;
+        }
     }
 
     /**
@@ -42690,7 +44528,20 @@ class basic_storage_view {
      * otherwise.
      */
     [[nodiscard]] entity_type back() const noexcept {
-        return empty() ? null : *leading->rbegin();
+        if constexpr(Policy == deletion_policy::swap_and_pop || Policy == deletion_policy::swap_only) {
+            return empty() ? null : *leading->rbegin();
+        } else {
+            static_assert(Policy == deletion_policy::in_place, "Unexpected storage policy");
+
+            if(leading) {
+                auto it = leading->rbegin();
+                const auto last = leading->rend();
+                for(; (it != last) && (*it == tombstone); ++it) {}
+                return it == last ? null : *it;
+            }
+
+            return null;
+        }
     }
 
     /**
@@ -42700,7 +44551,15 @@ class basic_storage_view {
      * iterator otherwise.
      */
     [[nodiscard]] iterator find(const entity_type entt) const noexcept {
-        return leading ? leading->find(entt) : iterator{};
+        if constexpr(Policy == deletion_policy::swap_and_pop) {
+            return leading ? leading->find(entt) : iterator{};
+        } else if constexpr(Policy == deletion_policy::swap_only) {
+            const auto it = leading ? leading->find(entt) : iterator{};
+            return leading && (static_cast<size_type>(it.index()) < leading->free_list()) ? it : iterator{};
+        } else {
+            const auto it = leading ? leading->find(entt) : typename common_type::iterator{};
+            return iterator{it, {leading}, {}, 0u};
+        }
     }
 
     /**
@@ -42717,13 +44576,16 @@ class basic_storage_view {
      * @return True if the view contains the given entity, false otherwise.
      */
     [[nodiscard]] bool contains(const entity_type entt) const noexcept {
-        return leading && leading->contains(entt);
+        if constexpr(Policy == deletion_policy::swap_and_pop || Policy == deletion_policy::in_place) {
+            return leading && leading->contains(entt);
+        } else {
+            static_assert(Policy == deletion_policy::swap_only, "Unexpected storage policy");
+            return leading && leading->contains(entt) && (leading->index(entt) < leading->free_list());
+        }
     }
 
-protected:
-    /*! @cond TURN_OFF_DOXYGEN */
+private:
     const common_type *leading{};
-    /*! @endcond */
 };
 
 /**
@@ -42737,8 +44599,9 @@ class basic_storage_view {
  * @tparam Get Type of storage iterated by the view.
  */
 template<typename Get>
-class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::traits_type::in_place_delete>>>: public basic_storage_view<typename Get::base_type> {
-    using base_type = basic_storage_view<typename Get::base_type>;
+class basic_view<get_t<Get>, exclude_t<>>
+    : public basic_storage_view<typename Get::base_type, Get::storage_policy> {
+    using base_type = basic_storage_view<typename Get::base_type, Get::storage_policy>;
 
 public:
     /*! @brief Common type among all storage types. */
@@ -42749,10 +44612,10 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
     using size_type = typename base_type::size_type;
     /*! @brief Random access iterator type. */
     using iterator = typename base_type::iterator;
-    /*! @brief Reversed iterator type. */
+    /*! @brief Reverse iterator type. */
     using reverse_iterator = typename base_type::reverse_iterator;
     /*! @brief Iterable view type. */
-    using iterable = decltype(std::declval<Get>().each());
+    using iterable = std::conditional_t<Get::storage_policy == deletion_policy::in_place, iterable_adaptor<internal::extended_view_iterator<iterator, Get>>, decltype(std::declval<Get>().each())>;
 
     /*! @brief Default constructor to use to create empty, invalid views. */
     basic_view() noexcept
@@ -42774,13 +44637,13 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
         : basic_view{std::get<0>(value)} {}
 
     /**
-     * @brief Returns the storage for a given component type, if any.
-     * @tparam Type Type of component of which to return the storage.
-     * @return The storage for the given component type.
+     * @brief Returns the storage for a given element type, if any.
+     * @tparam Type Type of element of which to return the storage.
+     * @return The storage for the given element type.
      */
-    template<typename Type = typename Get::value_type>
+    template<typename Type = typename Get::element_type>
     [[nodiscard]] auto *storage() const noexcept {
-        static_assert(std::is_same_v<std::remove_const_t<Type>, typename Get::value_type>, "Invalid component type");
+        static_assert(std::is_same_v<std::remove_const_t<Type>, typename Get::element_type>, "Invalid element type");
         return storage<0>();
     }
 
@@ -42792,7 +44655,7 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
     template<std::size_t Index>
     [[nodiscard]] auto *storage() const noexcept {
         static_assert(Index == 0u, "Index out of bounds");
-        return static_cast<Get *>(const_cast<constness_as_t<common_type, Get> *>(this->leading));
+        return static_cast<Get *>(const_cast<constness_as_t<common_type, Get> *>(base_type::handle()));
     }
 
     /**
@@ -42811,44 +44674,43 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
     template<std::size_t Index>
     void storage(Get &elem) noexcept {
         static_assert(Index == 0u, "Index out of bounds");
-        this->leading = &elem;
+        *this = basic_view{elem};
     }
 
     /**
-     * @brief Returns the component assigned to the given entity.
-     * @param entt A valid identifier.
-     * @return The component assigned to the given entity.
+     * @brief Returns a pointer to the underlying storage.
+     * @return A pointer to the underlying storage.
      */
-    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
-        return storage()->get(entt);
+    [[nodiscard]] Get *operator->() const noexcept {
+        return storage();
     }
 
     /**
-     * @brief Returns the identifier that occupies the given position.
-     * @param pos Position of the element to return.
-     * @return The identifier that occupies the given position.
+     * @brief Returns the element assigned to the given entity.
+     * @param entt A valid identifier.
+     * @return The element assigned to the given entity.
      */
-    [[deprecated("use .begin()[pos] instead")]] [[nodiscard]] entity_type operator[](const size_type pos) const {
-        return base_type::begin()[pos];
+    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
+        return storage()->get(entt);
     }
 
     /**
-     * @brief Returns the component assigned to the given entity.
-     * @tparam Elem Type of the component to get.
+     * @brief Returns the element assigned to the given entity.
+     * @tparam Elem Type of the element to get.
      * @param entt A valid identifier.
-     * @return The component assigned to the entity.
+     * @return The element assigned to the entity.
      */
     template<typename Elem>
     [[nodiscard]] decltype(auto) get(const entity_type entt) const {
-        static_assert(std::is_same_v<std::remove_const_t<Elem>, typename Get::value_type>, "Invalid component type");
+        static_assert(std::is_same_v<std::remove_const_t<Elem>, typename Get::element_type>, "Invalid element type");
         return get<0>(entt);
     }
 
     /**
-     * @brief Returns the component assigned to the given entity.
-     * @tparam Index Index of the component to get.
+     * @brief Returns the element assigned to the given entity.
+     * @tparam Index Index of the element to get.
      * @param entt A valid identifier.
-     * @return The component assigned to the entity.
+     * @return The element assigned to the entity.
      */
     template<std::size_t... Index>
     [[nodiscard]] decltype(auto) get(const entity_type entt) const {
@@ -42860,7 +44722,7 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
     }
 
     /**
-     * @brief Iterates entities and components and applies the given function
+     * @brief Iterates entities and elements and applies the given function
      * object to them.
      *
      * The signature of the function must be equivalent to one of the following
@@ -42876,20 +44738,28 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
      */
     template<typename Func>
     void each(Func func) const {
-        if(auto *elem = storage(); elem) {
-            if constexpr(is_applicable_v<Func, decltype(*elem->each().begin())>) {
-                for(const auto pack: elem->each()) {
-                    std::apply(func, pack);
-                }
-            } else if constexpr(std::is_invocable_v<Func, decltype(*elem->begin())>) {
-                for(auto &&component: *elem) {
-                    func(component);
+        if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_view>().get({})))>) {
+            for(const auto pack: each()) {
+                std::apply(func, pack);
+            }
+        } else if constexpr(Get::storage_policy == deletion_policy::swap_and_pop || Get::storage_policy == deletion_policy::swap_only) {
+            if constexpr(std::is_void_v<typename Get::value_type>) {
+                for(size_type pos = base_type::size(); pos; --pos) {
+                    func();
                 }
             } else {
-                for(size_type pos = elem->size(); pos; --pos) {
-                    func();
+                if(const auto len = base_type::size(); len != 0u) {
+                    for(auto last = storage()->end(), first = last - len; first != last; ++first) {
+                        func(*first);
+                    }
                 }
             }
+        } else {
+            static_assert(Get::storage_policy == deletion_policy::in_place, "Unexpected storage policy");
+
+            for(const auto pack: each()) {
+                std::apply([&func](const auto, auto &&...elem) { func(std::forward<decltype(elem)>(elem)...); }, pack);
+            }
         }
     }
 
@@ -42897,19 +44767,23 @@ class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::tra
      * @brief Returns an iterable object to use to _visit_ a view.
      *
      * The iterable object returns a tuple that contains the current entity and
-     * a reference to its component if it's a non-empty one. The _constness_ of
-     * the component is as requested.
+     * a reference to its element if it's a non-empty one. The _constness_ of
+     * the element is as requested.
      *
      * @return An iterable object to use to _visit_ the view.
      */
     [[nodiscard]] iterable each() const noexcept {
-        auto *elem = storage();
-        return elem ? elem->each() : iterable{};
+        if constexpr(Get::storage_policy == deletion_policy::swap_and_pop || Get::storage_policy == deletion_policy::swap_only) {
+            return base_type::handle() ? storage()->each() : iterable{};
+        } else {
+            static_assert(Get::storage_policy == deletion_policy::in_place, "Unexpected storage policy");
+            return iterable{base_type::begin(), base_type::end()};
+        }
     }
 
     /**
      * @brief Combines two views in a _more specific_ one.
-     * @tparam OGet Component list of the view to combine with.
+     * @tparam OGet Element list of the view to combine with.
      * @tparam OExclude Filter list of the view to combine with.
      * @param other The view to combine with.
      * @return A more specific view.
@@ -42931,8 +44805,8 @@ basic_view(Type &...storage) -> basic_view<get_t<Type...>, exclude_t<>>;
 
 /**
  * @brief Deduction guide.
- * @tparam Get Types of components iterated by the view.
- * @tparam Exclude Types of components used to filter the view.
+ * @tparam Get Types of elements iterated by the view.
+ * @tparam Exclude Types of elements used to filter the view.
  */
 template<typename... Get, typename... Exclude>
 basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<get_t<Get...>, exclude_t<Exclude...>>;
@@ -42963,23 +44837,33 @@ basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<ge
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -43019,7 +44903,7 @@ basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<ge
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -43037,6 +44921,12 @@ basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<ge
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -43059,6 +44949,8 @@ basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<ge
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/iterator.hpp"
@@ -43211,7 +45103,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -43220,7 +45112,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -43283,23 +45175,33 @@ struct iterable_adaptor final {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -43339,7 +45241,7 @@ struct iterable_adaptor final {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -43357,6 +45259,12 @@ struct iterable_adaptor final {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -43379,11 +45287,14 @@ struct iterable_adaptor final {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -43393,6 +45304,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -43437,13 +45363,9 @@ class edge_iterator {
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    constexpr edge_iterator() noexcept
-        : it{},
-          vert{},
-          pos{},
-          last{},
-          offset{} {}
+    constexpr edge_iterator() noexcept = default;
 
+    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
     constexpr edge_iterator(It base, const size_type vertices, const size_type from, const size_type to, const size_type step) noexcept
         : it{std::move(base)},
           vert{vertices},
@@ -43475,10 +45397,10 @@ class edge_iterator {
     friend constexpr bool operator==(const edge_iterator<Type> &, const edge_iterator<Type> &) noexcept;
 
 private:
-    It it;
-    size_type vert;
-    size_type pos;
-    size_type last;
+    It it{};
+    size_type vert{};
+    size_type pos{};
+    size_type last{};
     size_type offset{};
 };
 
@@ -43520,16 +45442,17 @@ class adjacency_matrix {
     using vertex_iterator = iota_iterator<vertex_type>;
     /*! @brief Edge iterator type. */
     using edge_iterator = internal::edge_iterator<typename container_type::const_iterator>;
-    /*! @brief Out edge iterator type. */
+    /*! @brief Out-edge iterator type. */
     using out_edge_iterator = edge_iterator;
-    /*! @brief In edge iterator type. */
+    /*! @brief In-edge iterator type. */
     using in_edge_iterator = edge_iterator;
     /*! @brief Graph category tag. */
     using graph_category = Category;
 
     /*! @brief Default constructor. */
     adjacency_matrix() noexcept(noexcept(allocator_type{}))
-        : adjacency_matrix{0u} {}
+        : adjacency_matrix{0u} {
+    }
 
     /**
      * @brief Constructs an empty container with a given allocator.
@@ -43548,12 +45471,8 @@ class adjacency_matrix {
         : matrix{vertices * vertices, allocator},
           vert{vertices} {}
 
-    /**
-     * @brief Copy constructor.
-     * @param other The instance to copy from.
-     */
-    adjacency_matrix(const adjacency_matrix &other)
-        : adjacency_matrix{other, other.get_allocator()} {}
+    /*! @brief Default copy constructor. */
+    adjacency_matrix(const adjacency_matrix &) = default;
 
     /**
      * @brief Allocator-extended copy constructor.
@@ -43564,12 +45483,8 @@ class adjacency_matrix {
         : matrix{other.matrix, allocator},
           vert{other.vert} {}
 
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    adjacency_matrix(adjacency_matrix &&other) noexcept
-        : adjacency_matrix{std::move(other), other.get_allocator()} {}
+    /*! @brief Default move constructor. */
+    adjacency_matrix(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -43578,29 +45493,22 @@ class adjacency_matrix {
      */
     adjacency_matrix(adjacency_matrix &&other, const allocator_type &allocator)
         : matrix{std::move(other.matrix), allocator},
-          vert{std::exchange(other.vert, 0u)} {}
+          vert{other.vert} {}
+
+    /*! @brief Default destructor. */
+    ~adjacency_matrix() = default;
 
     /**
      * @brief Default copy assignment operator.
-     * @param other The instance to copy from.
      * @return This container.
      */
-    adjacency_matrix &operator=(const adjacency_matrix &other) {
-        matrix = other.matrix;
-        vert = other.vert;
-        return *this;
-    }
+    adjacency_matrix &operator=(const adjacency_matrix &) = default;
 
     /**
      * @brief Default move assignment operator.
-     * @param other The instance to move from.
      * @return This container.
      */
-    adjacency_matrix &operator=(adjacency_matrix &&other) noexcept {
-        matrix = std::move(other.matrix);
-        vert = std::exchange(other.vert, 0u);
-        return *this;
-    }
+    adjacency_matrix &operator=(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -43620,12 +45528,25 @@ class adjacency_matrix {
      * @brief Exchanges the contents with those of a given adjacency matrix.
      * @param other Adjacency matrix to exchange the content with.
      */
-    void swap(adjacency_matrix &other) {
+    void swap(adjacency_matrix &other) noexcept {
         using std::swap;
         swap(matrix, other.matrix);
         swap(vert, other.vert);
     }
 
+    /**
+     * @brief Returns true if an adjacency matrix is empty, false otherwise.
+     *
+     * @warning
+     * Potentially expensive, try to avoid it on hot paths.
+     *
+     * @return True if the adjacency matrix is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        const auto iterable = edges();
+        return (iterable.begin() == iterable.end());
+    }
+
     /**
      * @brief Returns the number of vertices.
      * @return The number of vertices.
@@ -43653,9 +45574,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all out edges of a vertex.
-     * @param vertex The vertex of which to return all out edges.
-     * @return An iterable object to visit all out edges of a vertex.
+     * @brief Returns an iterable object to visit all out-edges of a vertex.
+     * @param vertex The vertex of which to return all out-edges.
+     * @return An iterable object to visit all out-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<out_edge_iterator> out_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -43665,9 +45586,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all in edges of a vertex.
-     * @param vertex The vertex of which to return all in edges.
-     * @return An iterable object to visit all in edges of a vertex.
+     * @brief Returns an iterable object to visit all in-edges of a vertex.
+     * @param vertex The vertex of which to return all in-edges.
+     * @return An iterable object to visit all in-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<in_edge_iterator> in_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -43850,23 +45771,33 @@ void dot(std::ostream &out, const Graph &graph) {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -43906,7 +45837,7 @@ void dot(std::ostream &out, const Graph &graph) {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -43924,6 +45855,12 @@ void dot(std::ostream &out, const Graph &graph) {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -43946,25 +45883,17 @@ void dot(std::ostream &out, const Graph &graph) {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -43977,23 +45906,33 @@ void dot(std::ostream &out, const Graph &graph) {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -44033,7 +45972,7 @@ void dot(std::ostream &out, const Graph &graph) {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -44051,6 +45990,12 @@ void dot(std::ostream &out, const Graph &graph) {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -44073,8 +46018,81 @@ void dot(std::ostream &out, const Graph &graph) {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
+#endif
+
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -44085,6 +46103,7 @@ void dot(std::ostream &out, const Graph &graph) {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -44094,10 +46113,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -44664,7 +46711,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -44672,12 +46719,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -44862,14 +46906,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -44883,6 +46924,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -44963,9 +47005,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -44981,8 +47023,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -45021,9 +47066,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -45042,7 +47087,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -45051,7 +47096,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -45106,7 +47151,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -45114,13 +47159,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -45130,7 +47175,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -45142,23 +47187,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -45190,7 +47238,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -45203,7 +47251,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -45214,7 +47262,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -45246,8 +47294,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -45270,7 +47316,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -45424,7 +47469,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -45433,7 +47478,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -45478,7 +47523,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -45488,44 +47532,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -45752,7 +47758,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -46338,7 +48344,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -46346,12 +48352,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -46536,14 +48539,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -46557,6 +48557,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -46637,9 +48638,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -46655,8 +48656,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -46691,6 +48695,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -46698,17 +48703,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -46818,7 +48833,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -46963,6 +48978,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -47021,7 +49037,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -47037,6 +49053,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -47049,8 +49067,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -47100,8 +49116,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -47119,7 +49134,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -47131,6 +49146,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -47141,7 +49159,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -47373,7 +49391,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -47389,7 +49407,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -47718,7 +49736,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -47751,9 +49769,9 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #include <vector>
 // #include "../config/config.h"
 
-// #include "../core/compressed_pair.hpp"
+// #include "../core/bit.hpp"
 
-// #include "../core/memory.hpp"
+// #include "../core/compressed_pair.hpp"
 
 // #include "../core/type_traits.hpp"
 
@@ -47828,11 +49846,11 @@ class dense_set_iterator final {
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return std::addressof(it->second);
+        return std::addressof(operator[](0));
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -48014,7 +50032,7 @@ class dense_set {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + value_to_bucket(packed.first().back().second);
+            size_type *curr = &sparse.first()[value_to_bucket(packed.first().back().second)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].first) {}
             *curr = pos;
@@ -48030,6 +50048,8 @@ class dense_set {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Type;
     /*! @brief Value type of the container. */
@@ -48040,8 +50060,6 @@ class dense_set {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the elements for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Random access iterator type. */
     using iterator = internal::dense_set_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant random access iterator type. */
@@ -48095,8 +50113,7 @@ class dense_set {
      */
     explicit dense_set(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -48114,7 +50131,7 @@ class dense_set {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_set(dense_set &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set(dense_set &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -48126,6 +50143,9 @@ class dense_set {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_set() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -48136,7 +50156,7 @@ class dense_set {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_set &operator=(dense_set &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set &operator=(dense_set &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -48352,7 +50372,7 @@ class dense_set {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const value_type &value) {
-        for(size_type *curr = sparse.first().data() + value_to_bucket(value); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
+        for(size_type *curr = &sparse.first()[value_to_bucket(value)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
             if(packed.second()(packed.first()[*curr].second, value)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].first;
@@ -48368,7 +50388,7 @@ class dense_set {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_set &other) {
+    void swap(dense_set &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -48660,7 +50680,7 @@ class dense_set {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -48675,17 +50695,6 @@ class dense_set {
 #include <tuple>
 #include <type_traits>
 #include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
-
-#include <cstddef>
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "../config/config.h"
-
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -48696,6 +50705,7 @@ class dense_set {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -48705,10 +50715,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -49275,7 +51313,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -49283,12 +51321,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -49473,14 +51508,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -49494,6 +51526,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -49574,9 +51607,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -49592,8 +51625,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -49632,9 +51668,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -49653,7 +51689,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -49662,7 +51698,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -49717,7 +51753,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -49725,13 +51761,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -49741,7 +51777,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -49753,23 +51789,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -49801,7 +51840,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -49814,7 +51853,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -49825,7 +51864,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -49857,8 +51896,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -49881,7 +51918,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -50026,13 +52062,9 @@ class edge_iterator {
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    constexpr edge_iterator() noexcept
-        : it{},
-          vert{},
-          pos{},
-          last{},
-          offset{} {}
+    constexpr edge_iterator() noexcept = default;
 
+    // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
     constexpr edge_iterator(It base, const size_type vertices, const size_type from, const size_type to, const size_type step) noexcept
         : it{std::move(base)},
           vert{vertices},
@@ -50064,10 +52096,10 @@ class edge_iterator {
     friend constexpr bool operator==(const edge_iterator<Type> &, const edge_iterator<Type> &) noexcept;
 
 private:
-    It it;
-    size_type vert;
-    size_type pos;
-    size_type last;
+    It it{};
+    size_type vert{};
+    size_type pos{};
+    size_type last{};
     size_type offset{};
 };
 
@@ -50109,16 +52141,17 @@ class adjacency_matrix {
     using vertex_iterator = iota_iterator<vertex_type>;
     /*! @brief Edge iterator type. */
     using edge_iterator = internal::edge_iterator<typename container_type::const_iterator>;
-    /*! @brief Out edge iterator type. */
+    /*! @brief Out-edge iterator type. */
     using out_edge_iterator = edge_iterator;
-    /*! @brief In edge iterator type. */
+    /*! @brief In-edge iterator type. */
     using in_edge_iterator = edge_iterator;
     /*! @brief Graph category tag. */
     using graph_category = Category;
 
     /*! @brief Default constructor. */
     adjacency_matrix() noexcept(noexcept(allocator_type{}))
-        : adjacency_matrix{0u} {}
+        : adjacency_matrix{0u} {
+    }
 
     /**
      * @brief Constructs an empty container with a given allocator.
@@ -50137,12 +52170,8 @@ class adjacency_matrix {
         : matrix{vertices * vertices, allocator},
           vert{vertices} {}
 
-    /**
-     * @brief Copy constructor.
-     * @param other The instance to copy from.
-     */
-    adjacency_matrix(const adjacency_matrix &other)
-        : adjacency_matrix{other, other.get_allocator()} {}
+    /*! @brief Default copy constructor. */
+    adjacency_matrix(const adjacency_matrix &) = default;
 
     /**
      * @brief Allocator-extended copy constructor.
@@ -50153,12 +52182,8 @@ class adjacency_matrix {
         : matrix{other.matrix, allocator},
           vert{other.vert} {}
 
-    /**
-     * @brief Move constructor.
-     * @param other The instance to move from.
-     */
-    adjacency_matrix(adjacency_matrix &&other) noexcept
-        : adjacency_matrix{std::move(other), other.get_allocator()} {}
+    /*! @brief Default move constructor. */
+    adjacency_matrix(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -50167,29 +52192,22 @@ class adjacency_matrix {
      */
     adjacency_matrix(adjacency_matrix &&other, const allocator_type &allocator)
         : matrix{std::move(other.matrix), allocator},
-          vert{std::exchange(other.vert, 0u)} {}
+          vert{other.vert} {}
+
+    /*! @brief Default destructor. */
+    ~adjacency_matrix() = default;
 
     /**
      * @brief Default copy assignment operator.
-     * @param other The instance to copy from.
      * @return This container.
      */
-    adjacency_matrix &operator=(const adjacency_matrix &other) {
-        matrix = other.matrix;
-        vert = other.vert;
-        return *this;
-    }
+    adjacency_matrix &operator=(const adjacency_matrix &) = default;
 
     /**
      * @brief Default move assignment operator.
-     * @param other The instance to move from.
      * @return This container.
      */
-    adjacency_matrix &operator=(adjacency_matrix &&other) noexcept {
-        matrix = std::move(other.matrix);
-        vert = std::exchange(other.vert, 0u);
-        return *this;
-    }
+    adjacency_matrix &operator=(adjacency_matrix &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -50209,12 +52227,25 @@ class adjacency_matrix {
      * @brief Exchanges the contents with those of a given adjacency matrix.
      * @param other Adjacency matrix to exchange the content with.
      */
-    void swap(adjacency_matrix &other) {
+    void swap(adjacency_matrix &other) noexcept {
         using std::swap;
         swap(matrix, other.matrix);
         swap(vert, other.vert);
     }
 
+    /**
+     * @brief Returns true if an adjacency matrix is empty, false otherwise.
+     *
+     * @warning
+     * Potentially expensive, try to avoid it on hot paths.
+     *
+     * @return True if the adjacency matrix is empty, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        const auto iterable = edges();
+        return (iterable.begin() == iterable.end());
+    }
+
     /**
      * @brief Returns the number of vertices.
      * @return The number of vertices.
@@ -50242,9 +52273,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all out edges of a vertex.
-     * @param vertex The vertex of which to return all out edges.
-     * @return An iterable object to visit all out edges of a vertex.
+     * @brief Returns an iterable object to visit all out-edges of a vertex.
+     * @param vertex The vertex of which to return all out-edges.
+     * @return An iterable object to visit all out-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<out_edge_iterator> out_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -50254,9 +52285,9 @@ class adjacency_matrix {
     }
 
     /**
-     * @brief Returns an iterable object to visit all in edges of a vertex.
-     * @param vertex The vertex of which to return all in edges.
-     * @return An iterable object to visit all in edges of a vertex.
+     * @brief Returns an iterable object to visit all in-edges of a vertex.
+     * @param vertex The vertex of which to return all in-edges.
+     * @return An iterable object to visit all in-edges of a vertex.
      */
     [[nodiscard]] iterable_adaptor<in_edge_iterator> in_edges(const vertex_type vertex) const noexcept {
         const auto it = matrix.cbegin();
@@ -50351,9 +52382,9 @@ template<typename Allocator>
 class basic_flow {
     using alloc_traits = std::allocator_traits<Allocator>;
     static_assert(std::is_same_v<typename alloc_traits::value_type, id_type>, "Invalid value type");
-    using task_container_type = dense_set<id_type, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<id_type>>;
+    using task_container_type = dense_set<id_type, identity, std::equal_to<>, typename alloc_traits::template rebind_alloc<id_type>>;
     using ro_rw_container_type = std::vector<std::pair<std::size_t, bool>, typename alloc_traits::template rebind_alloc<std::pair<std::size_t, bool>>>;
-    using deps_container_type = dense_map<id_type, ro_rw_container_type, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, ro_rw_container_type>>>;
+    using deps_container_type = dense_map<id_type, ro_rw_container_type, identity, std::equal_to<>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, ro_rw_container_type>>>;
     using adjacency_matrix_type = adjacency_matrix<directed_tag, typename alloc_traits::template rebind_alloc<std::size_t>>;
 
     void emplace(const id_type res, const bool is_rw) {
@@ -50457,8 +52488,7 @@ class basic_flow {
     explicit basic_flow(const allocator_type &allocator)
         : index{0u, allocator},
           vertices{allocator},
-          deps{allocator},
-          sync_on{} {}
+          deps{allocator} {}
 
     /*! @brief Default copy constructor. */
     basic_flow(const basic_flow &) = default;
@@ -50488,6 +52518,9 @@ class basic_flow {
           deps{std::move(other.deps), allocator},
           sync_on{other.sync_on} {}
 
+    /*! @brief Default destructor. */
+    ~basic_flow() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This flow builder.
@@ -50529,7 +52562,7 @@ class basic_flow {
      * @brief Exchanges the contents with those of a given flow builder.
      * @param other Flow builder to exchange the content with.
      */
-    void swap(basic_flow &other) {
+    void swap(basic_flow &other) noexcept {
         using std::swap;
         std::swap(index, other.index);
         std::swap(vertices, other.vertices);
@@ -50537,6 +52570,14 @@ class basic_flow {
         std::swap(sync_on, other.sync_on);
     }
 
+    /**
+     * @brief Returns true if a flow builder contains no tasks, false otherwise.
+     * @return True if the flow builder contains no tasks, false otherwise.
+     */
+    [[nodiscard]] bool empty() const noexcept {
+        return vertices.empty();
+    }
+
     /**
      * @brief Returns the number of tasks.
      * @return The number of tasks.
@@ -50655,7 +52696,7 @@ class basic_flow {
     compressed_pair<size_type, allocator_type> index;
     task_container_type vertices;
     deps_container_type deps;
-    size_type sync_on;
+    size_type sync_on{};
 };
 
 } // namespace entt
@@ -50680,23 +52721,33 @@ class basic_flow {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -50736,7 +52787,7 @@ class basic_flow {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -50754,6 +52805,12 @@ class basic_flow {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -50776,6 +52833,8 @@ class basic_flow {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
@@ -50812,9 +52871,19 @@ class locator final {
 
     /*! @brief Default constructor, deleted on purpose. */
     locator() = delete;
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    locator(const locator &) = delete;
+
     /*! @brief Default destructor, deleted on purpose. */
     ~locator() = delete;
 
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This locator.
+     */
+    locator &operator=(const locator &) = delete;
+
     /**
      * @brief Checks whether a service locator contains a value.
      * @return True if the service locator contains a value, false otherwise.
@@ -50913,6 +52982,7 @@ class locator final {
 
 private:
     // std::shared_ptr because of its type erased allocator which is useful here
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
     inline static std::shared_ptr<Service> service{};
 };
 
@@ -50958,6 +53028,8 @@ struct adl_meta_pointer_like {
 #endif
 
 // #include "meta/container.hpp"
+// IWYU pragma: always_keep
+
 #ifndef ENTT_META_CONTAINER_HPP
 #define ENTT_META_CONTAINER_HPP
 
@@ -50997,23 +53069,33 @@ struct adl_meta_pointer_like {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -51053,7 +53135,7 @@ struct adl_meta_pointer_like {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -51071,6 +53153,12 @@ struct adl_meta_pointer_like {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -51093,25 +53181,17 @@ struct adl_meta_pointer_like {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+#endif
 
-#include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -51124,23 +53204,33 @@ struct adl_meta_pointer_like {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -51180,7 +53270,7 @@ struct adl_meta_pointer_like {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -51198,6 +53288,12 @@ struct adl_meta_pointer_like {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -51220,8 +53316,81 @@ struct adl_meta_pointer_like {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
 #endif
 
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -51232,6 +53401,7 @@ struct adl_meta_pointer_like {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -51241,10 +53411,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -51811,7 +54009,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -51819,12 +54017,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -52009,14 +54204,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -52030,6 +54222,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -52110,9 +54303,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -52128,8 +54321,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -52168,9 +54364,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -52189,7 +54385,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -52198,7 +54394,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -52253,7 +54449,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -52261,13 +54457,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -52277,7 +54473,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -52289,23 +54485,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -52337,7 +54536,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -52350,7 +54549,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -52361,7 +54560,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -52393,8 +54592,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -52417,7 +54614,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -52571,7 +54767,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -52580,7 +54776,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -52625,7 +54821,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -52635,44 +54830,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -52899,7 +55056,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -53485,7 +55642,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -53493,12 +55650,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -53683,14 +55837,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -53704,6 +55855,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -53784,9 +55936,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -53802,8 +55954,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -53838,6 +55993,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -53845,17 +56001,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -53965,7 +56131,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -54110,6 +56276,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -54168,7 +56335,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -54184,6 +56351,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -54196,8 +56365,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -54247,8 +56414,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -54266,7 +56432,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -54278,6 +56444,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -54288,7 +56457,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -54520,7 +56689,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -54536,7 +56705,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -54865,7 +57034,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -54898,9 +57067,9 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #include <vector>
 // #include "../config/config.h"
 
-// #include "../core/compressed_pair.hpp"
+// #include "../core/bit.hpp"
 
-// #include "../core/memory.hpp"
+// #include "../core/compressed_pair.hpp"
 
 // #include "../core/type_traits.hpp"
 
@@ -54975,11 +57144,11 @@ class dense_set_iterator final {
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
-        return std::addressof(it->second);
+        return std::addressof(operator[](0));
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return *operator->();
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -55161,7 +57330,7 @@ class dense_set {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + value_to_bucket(packed.first().back().second);
+            size_type *curr = &sparse.first()[value_to_bucket(packed.first().back().second)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].first) {}
             *curr = pos;
@@ -55177,6 +57346,8 @@ class dense_set {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Type;
     /*! @brief Value type of the container. */
@@ -55187,8 +57358,6 @@ class dense_set {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the elements for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Random access iterator type. */
     using iterator = internal::dense_set_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant random access iterator type. */
@@ -55242,8 +57411,7 @@ class dense_set {
      */
     explicit dense_set(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -55261,7 +57429,7 @@ class dense_set {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_set(dense_set &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set(dense_set &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -55273,6 +57441,9 @@ class dense_set {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_set() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -55283,7 +57454,7 @@ class dense_set {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_set &operator=(dense_set &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_set &operator=(dense_set &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -55499,7 +57670,7 @@ class dense_set {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const value_type &value) {
-        for(size_type *curr = sparse.first().data() + value_to_bucket(value); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
+        for(size_type *curr = &sparse.first()[value_to_bucket(value)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
             if(packed.second()(packed.first()[*curr].second, value)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].first;
@@ -55515,7 +57686,7 @@ class dense_set {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_set &other) {
+    void swap(dense_set &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -55807,7 +57978,7 @@ class dense_set {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -55837,23 +58008,33 @@ class dense_set {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -55893,7 +58074,7 @@ class dense_set {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -55911,6 +58092,12 @@ class dense_set {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -55933,11 +58120,14 @@ class dense_set {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -55947,6 +58137,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -56104,6 +58309,7 @@ class meta_ctx: private internal::meta_context {
 #ifndef ENTT_META_META_HPP
 #define ENTT_META_META_HPP
 
+#include <array>
 #include <cstddef>
 #include <iterator>
 #include <memory>
@@ -56121,23 +58327,33 @@ class meta_ctx: private internal::meta_context {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -56177,7 +58393,7 @@ class meta_ctx: private internal::meta_context {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -56195,6 +58411,12 @@ class meta_ctx: private internal::meta_context {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -56217,6 +58439,8 @@ class meta_ctx: private internal::meta_context {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/any.hpp"
@@ -56342,6 +58566,7 @@ struct y_combinator {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -56351,6 +58576,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -56404,6 +58644,7 @@ using any = basic_any<>;
 
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 // #include "fwd.hpp"
 
 
@@ -56412,21 +58653,19 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename>
-struct fnv1a_traits;
+template<typename = id_type>
+struct fnv_1a_params;
 
 template<>
-struct fnv1a_traits<std::uint32_t> {
-    using type = std::uint32_t;
-    static constexpr std::uint32_t offset = 2166136261;
-    static constexpr std::uint32_t prime = 16777619;
+struct fnv_1a_params<std::uint32_t> {
+    static constexpr auto offset = 2166136261;
+    static constexpr auto prime = 16777619;
 };
 
 template<>
-struct fnv1a_traits<std::uint64_t> {
-    using type = std::uint64_t;
-    static constexpr std::uint64_t offset = 14695981039346656037ull;
-    static constexpr std::uint64_t prime = 1099511628211ull;
+struct fnv_1a_params<std::uint64_t> {
+    static constexpr auto offset = 14695981039346656037ull;
+    static constexpr auto prime = 1099511628211ull;
 };
 
 template<typename Char>
@@ -56461,7 +58700,7 @@ struct basic_hashed_string {
 template<typename Char>
 class basic_hashed_string: internal::basic_hashed_string<Char> {
     using base_type = internal::basic_hashed_string<Char>;
-    using traits_type = internal::fnv1a_traits<id_type>;
+    using params = internal::fnv_1a_params<>;
 
     struct const_wrapper {
         // non-explicit constructor on purpose
@@ -56472,22 +58711,11 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
     };
 
     // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
-        base_type base{str, 0u, traits_type::offset};
-
-        for(; str[base.length]; ++base.length) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
-        }
-
-        return base;
-    }
-
-    // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
-        base_type base{str, len, traits_type::offset};
+    [[nodiscard]] static constexpr auto helper(const std::basic_string_view<Char> view) noexcept {
+        base_type base{view.data(), view.size(), params::offset};
 
-        for(size_type pos{}; pos < len; ++pos) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
+        for(auto &&curr: view) {
+            base.hash = (base.hash ^ static_cast<id_type>(curr)) * params::prime;
         }
 
         return base;
@@ -56518,6 +58746,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @return The numeric representation of the string.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
         return basic_hashed_string{str};
     }
@@ -56533,7 +58762,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
 
     /*! @brief Constructs an empty hashed string. */
     constexpr basic_hashed_string() noexcept
-        : base_type{} {}
+        : basic_hashed_string{nullptr, 0u} {}
 
     /**
      * @brief Constructs a hashed string from a string view.
@@ -56541,7 +58770,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param len Length of the string to hash.
      */
     constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
-        : base_type{helper(str, len)} {}
+        : base_type{helper({str, len})} {}
 
     /**
      * @brief Constructs a hashed string from an array of const characters.
@@ -56549,8 +58778,9 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param str Human-readable identifier.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
-        : base_type{helper(str)} {}
+        : base_type{helper({static_cast<const value_type *>(str)})} {}
 
     /**
      * @brief Explicit constructor on purpose to avoid constructing a hashed
@@ -56562,14 +58792,14 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param wrapper Helps achieving the purpose by relying on overloading.
      */
     explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
-        : base_type{helper(wrapper.repr)} {}
+        : base_type{helper({wrapper.repr})} {}
 
     /**
      * @brief Returns the size a hashed string.
      * @return The size of the hashed string.
      */
     [[nodiscard]] constexpr size_type size() const noexcept {
-        return base_type::length; // NOLINT
+        return base_type::length;
     }
 
     /**
@@ -56609,7 +58839,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
  * @param len Length of the string to hash.
  */
 template<typename Char>
-basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;
+basic_hashed_string(const Char *str, std::size_t len) -> basic_hashed_string<Char>;
 
 /**
  * @brief Deduction guide.
@@ -56618,6 +58848,7 @@ basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_stri
  * @param str Human-readable identifier.
  */
 template<typename Char, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;
 
 /**
@@ -56695,12 +58926,6 @@ template<typename Char>
     return !(lhs < rhs);
 }
 
-/*! @brief Aliases for common character types. */
-using hashed_string = basic_hashed_string<char>;
-
-/*! @brief Aliases for common character types. */
-using hashed_wstring = basic_hashed_string<wchar_t>;
-
 inline namespace literals {
 
 /**
@@ -56743,7 +58968,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -56855,10 +59080,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -56916,7 +59143,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -56927,7 +59154,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -56938,7 +59165,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -56949,7 +59176,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -57563,7 +59790,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -57571,12 +59798,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -57761,14 +59985,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -57782,6 +60003,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -57862,9 +60084,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -57880,8 +60102,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -57949,66 +60174,67 @@ class basic_any {
     using vtable_type = const void *(const operation, const basic_any &, const void *);
 
     struct storage_type {
-        alignas(Align) std::byte data[Len + !Len];
+        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+        alignas(Align) std::byte data[Len + static_cast<std::size_t>(Len == 0u)];
     };
 
     template<typename Type>
-    static constexpr bool in_situ = Len && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
+    static constexpr bool in_situ = (Len != 0u) && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
 
     template<typename Type>
     static const void *basic_vtable(const operation op, const basic_any &value, const void *other) {
         static_assert(!std::is_void_v<Type> && std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");
-        const Type *element = nullptr;
+        const Type *elem = nullptr;
 
         if constexpr(in_situ<Type>) {
-            element = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
+            elem = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
         } else {
-            element = static_cast<const Type *>(value.instance);
+            elem = static_cast<const Type *>(value.instance);
         }
 
         switch(op) {
         case operation::copy:
             if constexpr(std::is_copy_constructible_v<Type>) {
-                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*element);
+                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*elem);
             }
             break;
         case operation::move:
             if constexpr(in_situ<Type>) {
                 if(value.mode == any_policy::owner) {
-                    return new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(element))};
+                    return ::new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(elem))};
                 }
             }
 
             return (static_cast<basic_any *>(const_cast<void *>(other))->instance = std::exchange(const_cast<basic_any &>(value).instance, nullptr));
         case operation::transfer:
             if constexpr(std::is_move_assignable_v<Type>) {
-                *const_cast<Type *>(element) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
+                *const_cast<Type *>(elem) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
                 return other;
             }
             [[fallthrough]];
         case operation::assign:
             if constexpr(std::is_copy_assignable_v<Type>) {
-                *const_cast<Type *>(element) = *static_cast<const Type *>(other);
+                *const_cast<Type *>(elem) = *static_cast<const Type *>(other);
                 return other;
             }
             break;
         case operation::destroy:
             if constexpr(in_situ<Type>) {
-                element->~Type();
+                elem->~Type();
             } else if constexpr(std::is_array_v<Type>) {
-                delete[] element;
+                delete[] elem;
             } else {
-                delete element;
+                delete elem;
             }
             break;
         case operation::compare:
             if constexpr(!std::is_function_v<Type> && !std::is_array_v<Type> && is_equality_comparable_v<Type>) {
-                return *element == *static_cast<const Type *>(other) ? other : nullptr;
+                return *elem == *static_cast<const Type *>(other) ? other : nullptr;
             } else {
-                return (element == other) ? other : nullptr;
+                return (elem == other) ? other : nullptr;
             }
         case operation::get:
-            return element;
+            return elem;
         }
 
         return nullptr;
@@ -58016,26 +60242,31 @@ class basic_any {
 
     template<typename Type, typename... Args>
     void initialize([[maybe_unused]] Args &&...args) {
-        info = &type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
+        using plain_type = std::remove_cv_t<std::remove_reference_t<Type>>;
+        info = &type_id<plain_type>();
 
         if constexpr(!std::is_void_v<Type>) {
-            vtable = basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>;
+            vtable = basic_vtable<plain_type>;
 
             if constexpr(std::is_lvalue_reference_v<Type>) {
                 static_assert((std::is_lvalue_reference_v<Args> && ...) && (sizeof...(Args) == 1u), "Invalid arguments");
                 mode = std::is_const_v<std::remove_reference_t<Type>> ? any_policy::cref : any_policy::ref;
                 instance = (std::addressof(args), ...);
-            } else if constexpr(in_situ<std::remove_cv_t<std::remove_reference_t<Type>>>) {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
+            } else if constexpr(in_situ<plain_type>) {
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    ::new(&storage) plain_type{std::forward<Args>(args)...};
                 } else {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
+                    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
+                    ::new(&storage) plain_type(std::forward<Args>(args)...);
                 }
             } else {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    instance = new plain_type{std::forward<Args>(args)...};
+                } else if constexpr(std::is_array_v<plain_type>) {
+                    static_assert(sizeof...(Args) == 0u, "Invalid arguments");
+                    instance = new plain_type[std::extent_v<plain_type>]();
                 } else {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
+                    instance = new plain_type(std::forward<Args>(args)...);
                 }
             }
         }
@@ -58119,10 +60350,12 @@ class basic_any {
      * @return This any object.
      */
     basic_any &operator=(const basic_any &other) {
-        reset();
+        if(this != &other) {
+            reset();
 
-        if(other.vtable) {
-            other.vtable(operation::copy, other, this);
+            if(other.vtable) {
+                other.vtable(operation::copy, other, this);
+            }
         }
 
         return *this;
@@ -58134,6 +60367,8 @@ class basic_any {
      * @return This any object.
      */
     basic_any &operator=(basic_any &&other) noexcept {
+        ENTT_ASSERT(this != &other, "Self move assignment");
+
         reset();
 
         if(other.vtable) {
@@ -58152,9 +60387,8 @@ class basic_any {
      * @param value An instance of an object to use to initialize the wrapper.
      * @return This any object.
      */
-    template<typename Type>
-    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>, basic_any &>
-    operator=(Type &&value) {
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
+    basic_any &operator=(Type &&value) {
         emplace<std::decay_t<Type>>(std::forward<Type>(value));
         return *this;
     }
@@ -58231,9 +60465,9 @@ class basic_any {
         if(vtable && mode != any_policy::cref && *info == *other.info) {
             if(auto *val = other.data(); val) {
                 return (vtable(operation::transfer, *this, val) != nullptr);
-            } else {
-                return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
             }
+
+            return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
         }
 
         return false;
@@ -58295,14 +60529,6 @@ class basic_any {
         return basic_any{*this, any_policy::cref};
     }
 
-    /**
-     * @brief Returns true if a wrapper owns its object, false otherwise.
-     * @return True if the wrapper owns its object, false otherwise.
-     */
-    [[deprecated("use policy() and any_policy instead")]] [[nodiscard]] bool owner() const noexcept {
-        return (mode == any_policy::owner);
-    }
-
     /**
      * @brief Returns the current mode of an any object.
      * @return The current mode of the any object.
@@ -58330,7 +60556,7 @@ class basic_any {
  * @return The element converted to the requested type.
  */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(const basic_any<Len, Align> &data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(const basic_any<Len, Align> &data) noexcept {
     const auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
     ENTT_ASSERT(instance, "Invalid instance");
     return static_cast<Type>(*instance);
@@ -58338,7 +60564,7 @@ template<typename Type, std::size_t Len, std::size_t Align>
 
 /*! @copydoc any_cast */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &data) noexcept {
     // forces const on non-reference types to make them work also with wrappers for const references
     auto *const instance = any_cast<std::remove_reference_t<const Type>>(&data);
     ENTT_ASSERT(instance, "Invalid instance");
@@ -58347,13 +60573,13 @@ template<typename Type, std::size_t Len, std::size_t Align>
 
 /*! @copydoc any_cast */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &&data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &&data) noexcept {
     if constexpr(std::is_copy_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>) {
         if(auto *const instance = any_cast<std::remove_reference_t<Type>>(&data); instance) {
             return static_cast<Type>(std::move(*instance));
-        } else {
-            return any_cast<Type>(data);
         }
+
+        return any_cast<Type>(data);
     } else {
         auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
         ENTT_ASSERT(instance, "Invalid instance");
@@ -58563,7 +60789,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -58572,7 +60798,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -58643,7 +60869,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -58755,10 +60981,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -58816,7 +61044,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -58827,7 +61055,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -58838,7 +61066,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -58849,7 +61077,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -59463,7 +61691,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -59471,12 +61699,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -59661,14 +61886,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -59682,6 +61904,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -59762,9 +61985,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -59780,8 +62003,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -59829,23 +62055,33 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -59885,7 +62121,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -59903,6 +62139,12 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -59925,6 +62167,8 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
@@ -59961,9 +62205,19 @@ class locator final {
 
     /*! @brief Default constructor, deleted on purpose. */
     locator() = delete;
+
+    /*! @brief Default copy constructor, deleted on purpose. */
+    locator(const locator &) = delete;
+
     /*! @brief Default destructor, deleted on purpose. */
     ~locator() = delete;
 
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This locator.
+     */
+    locator &operator=(const locator &) = delete;
+
     /**
      * @brief Checks whether a service locator contains a value.
      * @return True if the service locator contains a value, false otherwise.
@@ -60062,6 +62316,7 @@ class locator final {
 
 private:
     // std::shared_ptr because of its type erased allocator which is useful here
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
     inline static std::shared_ptr<Service> service{};
 };
 
@@ -60124,6 +62379,8 @@ struct meta_handle;
 
 struct meta_prop;
 
+struct meta_custom;
+
 struct meta_data;
 
 struct meta_func;
@@ -60142,10 +62399,9 @@ class meta_type;
 #include <memory>
 #include <type_traits>
 #include <utility>
+#include <vector>
 // #include "../config/config.h"
 
-// #include "../container/dense_map.hpp"
-
 // #include "../core/attribute.h"
 #ifndef ENTT_CORE_ATTRIBUTE_H
 #define ENTT_CORE_ATTRIBUTE_H
@@ -60178,6 +62434,78 @@ class meta_type;
 
 #endif
 
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
+
+#include <cstddef>
+#include <limits>
+#include <type_traits>
+// #include "../config/config.h"
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
+#endif
+
 // #include "../core/enum.hpp"
 #ifndef ENTT_CORE_ENUM_HPP
 #define ENTT_CORE_ENUM_HPP
@@ -60363,31 +62691,58 @@ enum class meta_traits : std::uint32_t {
     is_array = 0x0020,
     is_enum = 0x0040,
     is_class = 0x0080,
-    is_meta_pointer_like = 0x0100,
-    is_meta_sequence_container = 0x0200,
-    is_meta_associative_container = 0x0400,
-    _entt_enum_as_bitmask
+    is_pointer = 0x0100,
+    is_meta_pointer_like = 0x0200,
+    is_meta_sequence_container = 0x0400,
+    is_meta_associative_container = 0x0800,
+    _user_defined_traits = 0xFFFF,
+    _entt_enum_as_bitmask = 0xFFFF
 };
 
+template<typename Type>
+[[nodiscard]] auto meta_to_user_traits(const meta_traits traits) noexcept {
+    static_assert(std::is_enum_v<Type>, "Invalid enum type");
+    constexpr auto shift = popcount(static_cast<std::underlying_type_t<meta_traits>>(meta_traits::_user_defined_traits));
+    return Type{static_cast<std::underlying_type_t<Type>>(static_cast<std::underlying_type_t<meta_traits>>(traits) >> shift)};
+}
+
+template<typename Type>
+[[nodiscard]] auto user_to_meta_traits(const Type value) noexcept {
+    static_assert(std::is_enum_v<Type>, "Invalid enum type");
+    constexpr auto shift = popcount(static_cast<std::underlying_type_t<meta_traits>>(meta_traits::_user_defined_traits));
+    const auto traits = static_cast<std::underlying_type_t<internal::meta_traits>>(static_cast<std::underlying_type_t<Type>>(value));
+    ENTT_ASSERT(traits < ((~static_cast<std::underlying_type_t<meta_traits>>(meta_traits::_user_defined_traits)) >> shift), "Invalid traits");
+    return meta_traits{traits << shift};
+}
+
 struct meta_type_node;
 
+struct meta_custom_node {
+    id_type type{};
+    std::shared_ptr<void> value{};
+};
+
 struct meta_prop_node {
+    id_type id{};
     meta_type_node (*type)(const meta_context &) noexcept {};
     std::shared_ptr<void> value{};
 };
 
 struct meta_base_node {
-    meta_type_node (*type)(const meta_context &) noexcept {};
+    id_type type{};
+    meta_type_node (*resolve)(const meta_context &) noexcept {};
     const void *(*cast)(const void *) noexcept {};
 };
 
 struct meta_conv_node {
+    id_type type{};
     meta_any (*conv)(const meta_ctx &, const void *){};
 };
 
 struct meta_ctor_node {
     using size_type = std::size_t;
 
+    id_type id{};
     size_type arity{0u};
     meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
     meta_any (*invoke)(const meta_ctx &, meta_any *const){};
@@ -60400,42 +62755,46 @@ struct meta_dtor_node {
 struct meta_data_node {
     using size_type = std::size_t;
 
+    id_type id{};
     meta_traits traits{meta_traits::is_none};
     size_type arity{0u};
     meta_type_node (*type)(const meta_context &) noexcept {};
     meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
     bool (*set)(meta_handle, meta_any){};
     meta_any (*get)(const meta_ctx &, meta_handle){};
-    dense_map<id_type, meta_prop_node, identity> prop{};
+    meta_custom_node custom{};
+    std::vector<meta_prop_node> prop{};
 };
 
 struct meta_func_node {
     using size_type = std::size_t;
 
+    id_type id{};
     meta_traits traits{meta_traits::is_none};
     size_type arity{0u};
     meta_type_node (*ret)(const meta_context &) noexcept {};
     meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
     meta_any (*invoke)(const meta_ctx &, meta_handle, meta_any *const){};
     std::shared_ptr<meta_func_node> next{};
-    dense_map<id_type, meta_prop_node, identity> prop{};
+    meta_custom_node custom{};
+    std::vector<meta_prop_node> prop{};
 };
 
 struct meta_template_node {
     using size_type = std::size_t;
 
     size_type arity{0u};
-    meta_type_node (*type)(const meta_context &) noexcept {};
+    meta_type_node (*resolve)(const meta_context &) noexcept {};
     meta_type_node (*arg)(const meta_context &, const size_type) noexcept {};
 };
 
 struct meta_type_descriptor {
-    dense_map<id_type, meta_ctor_node, identity> ctor{};
-    dense_map<id_type, meta_base_node, identity> base{};
-    dense_map<id_type, meta_conv_node, identity> conv{};
-    dense_map<id_type, meta_data_node, identity> data{};
-    dense_map<id_type, meta_func_node, identity> func{};
-    dense_map<id_type, meta_prop_node, identity> prop{};
+    std::vector<meta_ctor_node> ctor{};
+    std::vector<meta_base_node> base{};
+    std::vector<meta_conv_node> conv{};
+    std::vector<meta_data_node> data{};
+    std::vector<meta_func_node> func{};
+    std::vector<meta_prop_node> prop{};
 };
 
 struct meta_type_node {
@@ -60452,24 +62811,43 @@ struct meta_type_node {
     meta_any (*from_void)(const meta_ctx &, void *, const void *){};
     meta_template_node templ{};
     meta_dtor_node dtor{};
+    meta_custom_node custom{};
     std::shared_ptr<meta_type_descriptor> details{};
 };
 
+template<auto Member, typename Type, typename Value>
+[[nodiscard]] auto *find_member(Type &from, const Value value) {
+    for(auto &&elem: from) {
+        if((elem.*Member) == value) {
+            return &elem;
+        }
+    }
+
+    return static_cast<typename Type::value_type *>(nullptr);
+}
+
+[[nodiscard]] inline auto *find_overload(meta_func_node *curr, std::remove_pointer_t<decltype(meta_func_node::invoke)> *const ref) {
+    while((curr != nullptr) && (curr->invoke != ref)) { curr = curr->next.get(); }
+    return curr;
+}
+
 template<auto Member>
-auto *look_for(const meta_context &context, const meta_type_node &node, const id_type id) {
+[[nodiscard]] auto *look_for(const meta_context &context, const meta_type_node &node, const id_type id) {
+    using value_type = typename std::remove_reference_t<decltype((node.details.get()->*Member))>::value_type;
+
     if(node.details) {
-        if(const auto it = (node.details.get()->*Member).find(id); it != (node.details.get()->*Member).cend()) {
-            return &it->second;
+        if(auto *member = find_member<&value_type::id>((node.details.get()->*Member), id); member != nullptr) {
+            return member;
         }
 
         for(auto &&curr: node.details->base) {
-            if(auto *elem = look_for<Member>(context, curr.second.type(context), id); elem) {
+            if(auto *elem = look_for<Member>(context, curr.resolve(context), id); elem) {
                 return elem;
             }
         }
     }
 
-    return static_cast<typename std::remove_reference_t<decltype(node.details.get()->*Member)>::mapped_type *>(nullptr);
+    return static_cast<value_type *>(nullptr);
 }
 
 template<typename Type>
@@ -60485,13 +62863,13 @@ template<typename... Args>
 }
 
 [[nodiscard]] inline const void *try_cast(const meta_context &context, const meta_type_node &from, const meta_type_node &to, const void *instance) noexcept {
-    if(from.info && to.info && *from.info == *to.info) {
+    if((from.info != nullptr) && (to.info != nullptr) && *from.info == *to.info) {
         return instance;
     }
 
     if(from.details) {
         for(auto &&curr: from.details->base) {
-            if(const void *elem = try_cast(context, curr.second.type(context), to, curr.second.cast(instance)); elem) {
+            if(const void *elem = try_cast(context, curr.resolve(context), to, curr.cast(instance)); elem) {
                 return elem;
             }
         }
@@ -60507,12 +62885,14 @@ template<typename Func>
     }
 
     if(from.details) {
-        if(auto it = from.details->conv.find(to.hash()); it != from.details->conv.cend()) {
-            return func(instance, it->second);
+        for(auto &&elem: from.details->conv) {
+            if(elem.type == to.hash()) {
+                return func(instance, elem);
+            }
         }
 
         for(auto &&curr: from.details->base) {
-            if(auto other = try_convert(context, curr.second.type(context), to, arithmetic_or_enum, curr.second.cast(instance), func); other) {
+            if(auto other = try_convert(context, curr.resolve(context), to, arithmetic_or_enum, curr.cast(instance), func); other) {
                 return other;
             }
         }
@@ -60547,6 +62927,7 @@ template<typename Type>
             | (std::is_array_v<Type> ? meta_traits::is_array : meta_traits::is_none)
             | (std::is_enum_v<Type> ? meta_traits::is_enum : meta_traits::is_none)
             | (std::is_class_v<Type> ? meta_traits::is_class : meta_traits::is_none)
+            | (std::is_pointer_v<Type> ? meta_traits::is_pointer : meta_traits::is_none)
             | (is_meta_pointer_like_v<Type> ? meta_traits::is_meta_pointer_like : meta_traits::is_none)
             | (is_complete_v<meta_sequence_container_traits<Type>> ? meta_traits::is_meta_sequence_container : meta_traits::is_none)
             | (is_complete_v<meta_associative_container_traits<Type>> ? meta_traits::is_meta_associative_container : meta_traits::is_none),
@@ -60561,22 +62942,22 @@ template<typename Type>
     }
 
     if constexpr(std::is_arithmetic_v<Type>) {
-        node.conversion_helper = +[](void *bin, const void *value) {
-            return bin ? static_cast<double>(*static_cast<Type *>(bin) = static_cast<Type>(*static_cast<const double *>(value))) : static_cast<double>(*static_cast<const Type *>(value));
+        node.conversion_helper = +[](void *lhs, const void *rhs) {
+            return lhs ? static_cast<double>(*static_cast<Type *>(lhs) = static_cast<Type>(*static_cast<const double *>(rhs))) : static_cast<double>(*static_cast<const Type *>(rhs));
         };
     } else if constexpr(std::is_enum_v<Type>) {
-        node.conversion_helper = +[](void *bin, const void *value) {
-            return bin ? static_cast<double>(*static_cast<Type *>(bin) = static_cast<Type>(static_cast<std::underlying_type_t<Type>>(*static_cast<const double *>(value)))) : static_cast<double>(*static_cast<const Type *>(value));
+        node.conversion_helper = +[](void *lhs, const void *rhs) {
+            return lhs ? static_cast<double>(*static_cast<Type *>(lhs) = static_cast<Type>(static_cast<std::underlying_type_t<Type>>(*static_cast<const double *>(rhs)))) : static_cast<double>(*static_cast<const Type *>(rhs));
         };
     }
 
     if constexpr(!std::is_void_v<Type> && !std::is_function_v<Type>) {
-        node.from_void = +[](const meta_ctx &ctx, void *element, const void *as_const) {
-            if(element) {
-                return meta_any{ctx, std::in_place_type<std::decay_t<Type> &>, *static_cast<std::decay_t<Type> *>(element)};
+        node.from_void = +[](const meta_ctx &ctx, void *elem, const void *celem) {
+            if(elem) {
+                return meta_any{ctx, std::in_place_type<std::decay_t<Type> &>, *static_cast<std::decay_t<Type> *>(elem)};
             }
 
-            return meta_any{ctx, std::in_place_type<const std::decay_t<Type> &>, *static_cast<const std::decay_t<Type> *>(as_const)};
+            return meta_any{ctx, std::in_place_type<const std::decay_t<Type> &>, *static_cast<const std::decay_t<Type> *>(celem)};
         };
     }
 
@@ -60616,12 +62997,14 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
+struct meta_base_node;
+
 template<typename Type, typename It>
 struct meta_range_iterator final {
-    using difference_type = std::ptrdiff_t;
     using value_type = std::pair<id_type, Type>;
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::random_access_iterator_tag;
 
@@ -60670,7 +63053,13 @@ struct meta_range_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
-        return {it[value].first, Type{*ctx, it[value].second}};
+        if constexpr(std::is_same_v<It, typename decltype(meta_context::value)::const_iterator>) {
+            return {it[value].first, Type{*ctx, it[value].second}};
+        } else if constexpr(std::is_same_v<typename std::iterator_traits<It>::value_type, meta_base_node>) {
+            return {it[value].type, Type{*ctx, it[value]}};
+        } else {
+            return {it[value].id, Type{*ctx, it[value]}};
+        }
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
@@ -60678,7 +63067,7 @@ struct meta_range_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->first, Type{*ctx, it->second}};
+        return operator[](0);
     }
 
     template<typename... Args>
@@ -60764,8 +63153,7 @@ class meta_sequence_container {
     using iterator = meta_iterator;
 
     /*! @brief Default constructor. */
-    meta_sequence_container() noexcept
-        : meta_sequence_container{locator<meta_ctx>::value_or()} {}
+    meta_sequence_container() = default;
 
     /**
      * @brief Context aware constructor.
@@ -60797,18 +63185,18 @@ class meta_sequence_container {
 
     [[nodiscard]] inline meta_type value_type() const noexcept;
     [[nodiscard]] inline size_type size() const noexcept;
-    inline bool resize(const size_type);
+    inline bool resize(size_type);
     inline bool clear();
-    inline bool reserve(const size_type);
+    inline bool reserve(size_type);
     [[nodiscard]] inline iterator begin();
     [[nodiscard]] inline iterator end();
-    inline iterator insert(iterator, meta_any);
-    inline iterator erase(iterator);
-    [[nodiscard]] inline meta_any operator[](const size_type);
+    inline iterator insert(const iterator &, meta_any);
+    inline iterator erase(const iterator &);
+    [[nodiscard]] inline meta_any operator[](size_type);
     [[nodiscard]] inline explicit operator bool() const noexcept;
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     internal::meta_type_node (*value_type_node)(const internal::meta_context &){};
     internal::meta_type_node (*const_reference_node)(const internal::meta_context &){};
     size_type (*size_fn)(const void *){};
@@ -60834,8 +63222,7 @@ class meta_associative_container {
     using iterator = meta_iterator;
 
     /*! @brief Default constructor. */
-    meta_associative_container() noexcept
-        : meta_associative_container{locator<meta_ctx>::value_or()} {}
+    meta_associative_container() = default;
 
     /**
      * @brief Context aware constructor.
@@ -60870,13 +63257,12 @@ class meta_associative_container {
         data = &instance;
     }
 
-    [[nodiscard]] inline bool key_only() const noexcept;
     [[nodiscard]] inline meta_type key_type() const noexcept;
     [[nodiscard]] inline meta_type mapped_type() const noexcept;
     [[nodiscard]] inline meta_type value_type() const noexcept;
     [[nodiscard]] inline size_type size() const noexcept;
     inline bool clear();
-    inline bool reserve(const size_type);
+    inline bool reserve(size_type);
     [[nodiscard]] inline iterator begin();
     [[nodiscard]] inline iterator end();
     inline bool insert(meta_any, meta_any);
@@ -60885,7 +63271,7 @@ class meta_associative_container {
     [[nodiscard]] inline explicit operator bool() const noexcept;
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     internal::meta_type_node (*key_type_node)(const internal::meta_context &){};
     internal::meta_type_node (*mapped_type_node)(const internal::meta_context &){};
     internal::meta_type_node (*value_type_node)(const internal::meta_context &){};
@@ -60942,31 +63328,27 @@ class meta_any {
     }
 
     void release() {
-        if(node.dtor.dtor && (storage.policy() == any_policy::owner)) {
+        if((node.dtor.dtor != nullptr) && (storage.policy() == any_policy::owner)) {
             node.dtor.dtor(storage.data());
         }
     }
 
-    meta_any(const meta_ctx &area, const meta_any &other, any ref) noexcept
+    meta_any(const meta_any &other, any ref) noexcept
         : storage{std::move(ref)},
-          ctx{&area},
+          ctx{other.ctx},
           node{storage ? other.node : internal::meta_type_node{}},
           vtable{storage ? other.vtable : &basic_vtable<void>} {}
 
 public:
     /*! Default constructor. */
-    meta_any() noexcept
-        : meta_any{meta_ctx_arg, locator<meta_ctx>::value_or()} {}
+    meta_any() = default;
 
     /**
      * @brief Context aware constructor.
      * @param area The context from which to search for meta types.
      */
-    meta_any(meta_ctx_arg_t, const meta_ctx &area) noexcept
-        : storage{},
-          ctx{&area},
-          node{},
-          vtable{&basic_vtable<void>} {}
+    meta_any(meta_ctx_arg_t, const meta_ctx &area)
+        : ctx{&area} {}
 
     /**
      * @brief Constructs a wrapper by directly initializing the new object.
@@ -61017,10 +63399,10 @@ class meta_any {
      * @param other The instance to copy from.
      */
     meta_any(const meta_ctx &area, const meta_any &other)
-        : meta_any{other} {
-        ctx = &area;
-        node = node.resolve ? node.resolve(internal::meta_context::from(*ctx)) : node;
-    }
+        : storage{other.storage},
+          ctx{&area},
+          node{(other.node.resolve != nullptr) ? other.node.resolve(internal::meta_context::from(*ctx)) : other.node},
+          vtable{other.vtable} {}
 
     /**
      * @brief Context aware move constructor.
@@ -61028,10 +63410,10 @@ class meta_any {
      * @param other The instance to move from.
      */
     meta_any(const meta_ctx &area, meta_any &&other)
-        : meta_any{std::move(other)} {
-        ctx = &area;
-        node = node.resolve ? node.resolve(internal::meta_context::from(*ctx)) : node;
-    }
+        : storage{std::move(other.storage)},
+          ctx{&area},
+          node{(other.node.resolve != nullptr) ? std::exchange(other.node, internal::meta_type_node{}).resolve(internal::meta_context::from(*ctx)) : std::exchange(other.node, internal::meta_type_node{})},
+          vtable{std::exchange(other.vtable, &basic_vtable<void>)} {}
 
     /**
      * @brief Copy constructor.
@@ -61060,11 +63442,14 @@ class meta_any {
      * @return This meta any object.
      */
     meta_any &operator=(const meta_any &other) {
-        release();
-        storage = other.storage;
-        ctx = other.ctx;
-        node = other.node;
-        vtable = other.vtable;
+        if(this != &other) {
+            release();
+            storage = other.storage;
+            ctx = other.ctx;
+            node = other.node;
+            vtable = other.vtable;
+        }
+
         return *this;
     }
 
@@ -61074,6 +63459,8 @@ class meta_any {
      * @return This meta any object.
      */
     meta_any &operator=(meta_any &&other) noexcept {
+        ENTT_ASSERT(this != &other, "Self move assignment");
+
         release();
         storage = std::move(other.storage);
         ctx = other.ctx;
@@ -61088,9 +63475,8 @@ class meta_any {
      * @param value An instance of an object to use to initialize the wrapper.
      * @return This meta any object.
      */
-    template<typename Type>
-    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>, meta_any &>
-    operator=(Type &&value) {
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>>>
+    meta_any &operator=(Type &&value) {
         emplace<std::decay_t<Type>>(std::forward<Type>(value));
         return *this;
     }
@@ -61116,11 +63502,11 @@ class meta_any {
      * @return A wrapper containing the returned value, if any.
      */
     template<typename... Args>
-    meta_any invoke(const id_type id, Args &&...args) const;
+    meta_any invoke(id_type id, Args &&...args) const;
 
     /*! @copydoc invoke */
     template<typename... Args>
-    meta_any invoke(const id_type id, Args &&...args);
+    meta_any invoke(id_type id, Args &&...args);
 
     /**
      * @brief Sets the value of a given variable.
@@ -61130,17 +63516,17 @@ class meta_any {
      * @return True in case of success, false otherwise.
      */
     template<typename Type>
-    bool set(const id_type id, Type &&value);
+    bool set(id_type id, Type &&value);
 
     /**
      * @brief Gets the value of a given variable.
      * @param id Unique identifier.
      * @return A wrapper containing the value of the underlying variable.
      */
-    [[nodiscard]] meta_any get(const id_type id) const;
+    [[nodiscard]] meta_any get(id_type id) const;
 
     /*! @copydoc get */
-    [[nodiscard]] meta_any get(const id_type id);
+    [[nodiscard]] meta_any get(id_type id);
 
     /**
      * @brief Tries to cast an instance to a given type.
@@ -61170,7 +63556,7 @@ class meta_any {
      * @return A reference to the contained instance.
      */
     template<typename Type>
-    [[nodiscard]] Type cast() const {
+    [[nodiscard]] std::remove_const_t<Type> cast() const {
         auto *const instance = try_cast<std::remove_reference_t<Type>>();
         ENTT_ASSERT(instance, "Invalid instance");
         return static_cast<Type>(*instance);
@@ -61178,7 +63564,7 @@ class meta_any {
 
     /*! @copydoc cast */
     template<typename Type>
-    [[nodiscard]] Type cast() {
+    [[nodiscard]] std::remove_const_t<Type> cast() {
         // forces const on non-reference types to make them work also with wrappers for const references
         auto *const instance = try_cast<std::remove_reference_t<const Type>>();
         ENTT_ASSERT(instance, "Invalid instance");
@@ -61315,7 +63701,7 @@ class meta_any {
 
     /*! @copydoc any::operator== */
     [[nodiscard]] bool operator==(const meta_any &other) const noexcept {
-        return (ctx == other.ctx) && ((!node.info && !other.node.info) || (node.info && other.node.info && *node.info == *other.node.info && storage == other.storage));
+        return (ctx == other.ctx) && (((node.info == nullptr) && (other.node.info == nullptr)) || ((node.info != nullptr) && (other.node.info != nullptr) && *node.info == *other.node.info && storage == other.storage));
     }
 
     /*! @copydoc any::operator!= */
@@ -61325,17 +63711,12 @@ class meta_any {
 
     /*! @copydoc any::as_ref */
     [[nodiscard]] meta_any as_ref() noexcept {
-        return meta_any{*ctx, *this, storage.as_ref()};
+        return meta_any{*this, storage.as_ref()};
     }
 
     /*! @copydoc any::as_ref */
     [[nodiscard]] meta_any as_ref() const noexcept {
-        return meta_any{*ctx, *this, storage.as_ref()};
-    }
-
-    /*! @copydoc any::owner */
-    [[deprecated("use policy() and meta_any_policy instead")]] [[nodiscard]] bool owner() const noexcept {
-        return (storage.policy() == any_policy::owner);
+        return meta_any{*this, storage.as_ref()};
     }
 
     /**
@@ -61347,10 +63728,10 @@ class meta_any {
     }
 
 private:
-    any storage;
-    const meta_ctx *ctx;
-    internal::meta_type_node node;
-    vtable_type *vtable;
+    any storage{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
+    internal::meta_type_node node{};
+    vtable_type *vtable{&basic_vtable<void>};
 };
 
 /**
@@ -61384,28 +63765,27 @@ template<typename Type>
  */
 struct meta_handle {
     /*! Default constructor. */
-    meta_handle() noexcept
-        : meta_handle{meta_ctx_arg, locator<meta_ctx>::value_or()} {}
+    meta_handle() = default;
 
     /**
      * @brief Context aware constructor.
      * @param area The context from which to search for meta types.
      */
-    meta_handle(meta_ctx_arg_t, const meta_ctx &area) noexcept
+    meta_handle(meta_ctx_arg_t, const meta_ctx &area)
         : any{meta_ctx_arg, area} {}
 
     /**
      * @brief Creates a handle that points to an unmanaged object.
      * @param value An instance of an object to use to initialize the handle.
      */
-    meta_handle(meta_any &value) noexcept
+    meta_handle(meta_any &value)
         : any{value.as_ref()} {}
 
     /**
      * @brief Creates a handle that points to an unmanaged object.
      * @param value An instance of an object to use to initialize the handle.
      */
-    meta_handle(const meta_any &value) noexcept
+    meta_handle(const meta_any &value)
         : any{value.as_ref()} {}
 
     /**
@@ -61415,7 +63795,7 @@ struct meta_handle {
      * @param value An instance of an object to use to initialize the handle.
      */
     template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_handle>>>
-    meta_handle(const meta_ctx &ctx, Type &value) noexcept
+    meta_handle(const meta_ctx &ctx, Type &value)
         : any{ctx, std::in_place_type<Type &>, value} {}
 
     /**
@@ -61424,7 +63804,7 @@ struct meta_handle {
      * @param value An instance of an object to use to initialize the handle.
      */
     template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_handle>>>
-    meta_handle(Type &value) noexcept
+    meta_handle(Type &value)
         : meta_handle{locator<meta_ctx>::value_or(), value} {}
 
     /**
@@ -61449,6 +63829,9 @@ struct meta_handle {
     /*! @brief Default move constructor. */
     meta_handle(meta_handle &&) = default;
 
+    /*! @brief Default destructor. */
+    ~meta_handle() = default;
+
     /**
      * @brief Default copy assignment operator, deleted on purpose.
      * @return This meta handle.
@@ -61493,23 +63876,21 @@ struct meta_handle {
     }
 
 private:
-    meta_any any;
+    meta_any any{meta_ctx_arg, locator<meta_ctx>::value_or()};
 };
 
 /*! @brief Opaque wrapper for properties of any type. */
 struct meta_prop {
     /*! @brief Default constructor. */
-    meta_prop() noexcept
-        : node{},
-          ctx{} {}
+    meta_prop() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
      * @param area The context from which to search for meta types.
      * @param curr The underlying node with which to construct the instance.
      */
-    meta_prop(const meta_ctx &area, const internal::meta_prop_node &curr) noexcept
-        : node{&curr},
+    meta_prop(const meta_ctx &area, internal::meta_prop_node curr) noexcept
+        : node{std::move(curr)},
           ctx{&area} {}
 
     /**
@@ -61517,7 +63898,7 @@ struct meta_prop {
      * @return A wrapper containing the value stored with the property.
      */
     [[nodiscard]] meta_any value() const {
-        return node->value ? node->type(internal::meta_context::from(*ctx)).from_void(*ctx, nullptr, node->value.get()) : meta_any{meta_ctx_arg, *ctx};
+        return node.value ? node.type(internal::meta_context::from(*ctx)).from_void(*ctx, nullptr, node.value.get()) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /**
@@ -61525,7 +63906,7 @@ struct meta_prop {
      * @return A wrapper containing the value stored with the property.
      */
     [[nodiscard]] meta_any value() {
-        return node->value ? node->type(internal::meta_context::from(*ctx)).from_void(*ctx, node->value.get(), nullptr) : meta_any{meta_ctx_arg, *ctx};
+        return node.value ? node.type(internal::meta_context::from(*ctx)).from_void(*ctx, node.value.get(), nullptr) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /**
@@ -61533,7 +63914,7 @@ struct meta_prop {
      * @return True if the object is valid, false otherwise.
      */
     [[nodiscard]] explicit operator bool() const noexcept {
-        return (node != nullptr);
+        return static_cast<bool>(node.type);
     }
 
     /**
@@ -61542,12 +63923,12 @@ struct meta_prop {
      * @return True if the objects refer to the same type, false otherwise.
      */
     [[nodiscard]] bool operator==(const meta_prop &other) const noexcept {
-        return (ctx == other.ctx && node == other.node);
+        return (ctx == other.ctx && node.value == other.node.value);
     }
 
 private:
-    const internal::meta_prop_node *node;
-    const meta_ctx *ctx;
+    internal::meta_prop_node node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -61560,15 +63941,48 @@ struct meta_prop {
     return !(lhs == rhs);
 }
 
+/*! @brief Opaque wrapper for user defined data of any type. */
+struct meta_custom {
+    /*! @brief Default constructor. */
+    meta_custom() noexcept = default;
+
+    /**
+     * @brief Basic constructor for meta objects.
+     * @param curr The underlying node with which to construct the instance.
+     */
+    meta_custom(internal::meta_custom_node curr) noexcept
+        : node{std::move(curr)} {}
+
+    /**
+     * @brief Generic conversion operator.
+     * @tparam Type Type to which conversion is requested.
+     */
+    template<typename Type>
+    [[nodiscard]] operator Type *() const noexcept {
+        return (type_id<Type>().hash() == node.type) ? std::static_pointer_cast<Type>(node.value).get() : nullptr;
+    }
+
+    /**
+     * @brief Generic conversion operator.
+     * @tparam Type Type to which conversion is requested.
+     */
+    template<typename Type>
+    [[nodiscard]] operator Type &() const noexcept {
+        ENTT_ASSERT(type_id<Type>().hash() == node.type, "Invalid type");
+        return *std::static_pointer_cast<Type>(node.value);
+    }
+
+private:
+    internal::meta_custom_node node{};
+};
+
 /*! @brief Opaque wrapper for data members. */
 struct meta_data {
     /*! @brief Unsigned integer type. */
     using size_type = typename internal::meta_data_node::size_type;
 
     /*! @brief Default constructor. */
-    meta_data() noexcept
-        : node{},
-          ctx{} {}
+    meta_data() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
@@ -61614,6 +64028,7 @@ struct meta_data {
      * @return True in case of success, false otherwise.
      */
     template<typename Type>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
     bool set(meta_handle instance, Type &&value) const {
         return node->set && node->set(meta_handle{*ctx, std::move(instance)}, meta_any{*ctx, std::forward<Type>(value)});
     }
@@ -61632,13 +64047,13 @@ struct meta_data {
      * @param index Index of the setter of which to return the accepted type.
      * @return The type accepted by the i-th setter.
      */
-    [[nodiscard]] inline meta_type arg(const size_type index) const noexcept;
+    [[nodiscard]] inline meta_type arg(size_type index) const noexcept;
 
     /**
      * @brief Returns a range to visit registered meta properties.
      * @return An iterable range to visit registered meta properties.
      */
-    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_data_node::prop)::const_iterator> prop() const noexcept {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_range<meta_prop, typename decltype(internal::meta_data_node::prop)::const_iterator> prop() const noexcept {
         return {{*ctx, node->prop.cbegin()}, {*ctx, node->prop.cend()}};
     }
 
@@ -61647,9 +64062,32 @@ struct meta_data {
      * @param key The key to use to search for a property.
      * @return The registered meta property for the given key, if any.
      */
-    [[nodiscard]] meta_prop prop(const id_type key) const {
-        const auto it = node->prop.find(key);
-        return it != node->prop.cend() ? meta_prop{*ctx, it->second} : meta_prop{};
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_prop prop(const id_type key) const {
+        for(auto &&elem: node->prop) {
+            if(elem.id == key) {
+                return meta_prop{*ctx, elem};
+            }
+        }
+
+        return meta_prop{};
+    }
+
+    /**
+     * @brief Returns all meta traits for a given meta object.
+     * @tparam Type The type to convert the meta traits to.
+     * @return The registered meta traits, if any.
+     */
+    template<typename Type>
+    [[nodiscard]] Type traits() const noexcept {
+        return internal::meta_to_user_traits<Type>(node->traits);
+    }
+
+    /**
+     * @brief Returns user defined data for a given meta object.
+     * @return User defined arbitrary data.
+     */
+    [[nodiscard]] meta_custom custom() const noexcept {
+        return {node->custom};
     }
 
     /**
@@ -61666,8 +64104,8 @@ struct meta_data {
     }
 
 private:
-    const internal::meta_data_node *node;
-    const meta_ctx *ctx;
+    const internal::meta_data_node *node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -61686,9 +64124,7 @@ struct meta_func {
     using size_type = typename internal::meta_func_node::size_type;
 
     /*! @brief Default constructor. */
-    meta_func() noexcept
-        : node{},
-          ctx{} {}
+    meta_func() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
@@ -61734,14 +64170,10 @@ struct meta_func {
      * @param index Index of the argument of which to return the type.
      * @return The type of the i-th argument of a member function.
      */
-    [[nodiscard]] inline meta_type arg(const size_type index) const noexcept;
+    [[nodiscard]] inline meta_type arg(size_type index) const noexcept;
 
     /**
      * @brief Invokes the underlying function, if possible.
-     *
-     * @warning
-     * The context of the arguments is **never** changed.
-     *
      * @param instance An opaque instance of the underlying type.
      * @param args Parameters to use to invoke the function.
      * @param sz Number of parameters to use to invoke the function.
@@ -61759,13 +64191,14 @@ struct meta_func {
      * @return A wrapper containing the returned value, if any.
      */
     template<typename... Args>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
     meta_any invoke(meta_handle instance, Args &&...args) const {
-        meta_any arguments[sizeof...(Args) + !sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
-        return invoke(std::move(instance), arguments, sizeof...(Args));
+        std::array<meta_any, sizeof...(Args)> arguments{meta_any{*ctx, std::forward<Args>(args)}...};
+        return invoke(std::move(instance), arguments.data(), sizeof...(Args));
     }
 
     /*! @copydoc meta_data::prop */
-    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_func_node::prop)::const_iterator> prop() const noexcept {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_range<meta_prop, typename decltype(internal::meta_func_node::prop)::const_iterator> prop() const noexcept {
         return {{*ctx, node->prop.cbegin()}, {*ctx, node->prop.cend()}};
     }
 
@@ -61774,9 +64207,25 @@ struct meta_func {
      * @param key The key to use to search for a property.
      * @return The registered meta property for the given key, if any.
      */
-    [[nodiscard]] meta_prop prop(const id_type key) const {
-        const auto it = node->prop.find(key);
-        return it != node->prop.cend() ? meta_prop{*ctx, it->second} : meta_prop{};
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_prop prop(const id_type key) const {
+        for(auto &&elem: node->prop) {
+            if(elem.id == key) {
+                return meta_prop{*ctx, elem};
+            }
+        }
+
+        return meta_prop{};
+    }
+
+    /*! @copydoc meta_data::traits */
+    template<typename Type>
+    [[nodiscard]] Type traits() const noexcept {
+        return internal::meta_to_user_traits<Type>(node->traits);
+    }
+
+    /*! @copydoc meta_data::custom */
+    [[nodiscard]] meta_custom custom() const noexcept {
+        return {node->custom};
     }
 
     /**
@@ -61801,8 +64250,8 @@ struct meta_func {
     }
 
 private:
-    const internal::meta_func_node *node;
-    const meta_ctx *ctx;
+    const internal::meta_func_node *node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -61834,16 +64283,18 @@ class meta_type {
                 size_type match{};
                 size_type pos{};
 
+                // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
                 for(; pos < sz && args[pos]; ++pos) {
                     const auto other = curr->arg(*ctx, pos);
                     const auto type = args[pos].type();
 
                     if(const auto &info = other.info(); info == type.info()) {
                         ++match;
-                    } else if(!((type.node.details && (type.node.details->base.contains(info.hash()) || type.node.details->conv.contains(info.hash()))) || (type.node.conversion_helper && other.node.conversion_helper))) {
+                    } else if(!(type.node.conversion_helper && other.node.conversion_helper) && !(type.node.details && (internal::find_member<&internal::meta_base_node::type>(type.node.details->base, info.hash()) || internal::find_member<&internal::meta_conv_node::type>(type.node.details->conv, info.hash())))) {
                         break;
                     }
                 }
+                // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
                 if(pos == sz) {
                     if(!candidate || match > same) {
@@ -61873,17 +64324,15 @@ class meta_type {
     using size_type = typename internal::meta_type_node::size_type;
 
     /*! @brief Default constructor. */
-    meta_type() noexcept
-        : node{},
-          ctx{} {}
+    meta_type() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
      * @param area The context from which to search for meta types.
      * @param curr The underlying node with which to construct the instance.
      */
-    meta_type(const meta_ctx &area, const internal::meta_type_node &curr) noexcept
-        : node{curr},
+    meta_type(const meta_ctx &area, internal::meta_type_node curr) noexcept
+        : node{std::move(curr)},
           ctx{&area} {}
 
     /**
@@ -61892,7 +64341,7 @@ class meta_type {
      * @param curr The underlying node with which to construct the instance.
      */
     meta_type(const meta_ctx &area, const internal::meta_base_node &curr) noexcept
-        : meta_type{area, curr.type(internal::meta_context::from(area))} {}
+        : meta_type{area, curr.resolve(internal::meta_context::from(area))} {}
 
     /**
      * @brief Returns the type info object of the underlying type.
@@ -61972,7 +64421,7 @@ class meta_type {
      * @return True if the underlying type is a pointer, false otherwise.
      */
     [[nodiscard]] bool is_pointer() const noexcept {
-        return node.info && (node.info->hash() != remove_pointer().info().hash());
+        return static_cast<bool>(node.traits & internal::meta_traits::is_pointer);
     }
 
     /**
@@ -61981,7 +64430,7 @@ class meta_type {
      * doesn't refer to a pointer type.
      */
     [[nodiscard]] meta_type remove_pointer() const noexcept {
-        return {*ctx, node.remove_pointer(internal::meta_context::from(*ctx))}; // NOLINT
+        return {*ctx, node.remove_pointer(internal::meta_context::from(*ctx))};
     }
 
     /**
@@ -62031,7 +64480,7 @@ class meta_type {
      * @return The tag for the class template of the underlying type.
      */
     [[nodiscard]] inline meta_type template_type() const noexcept {
-        return node.templ.type ? meta_type{*ctx, node.templ.type(internal::meta_context::from(*ctx))} : meta_type{};
+        return (node.templ.resolve != nullptr) ? meta_type{*ctx, node.templ.resolve(internal::meta_context::from(*ctx))} : meta_type{};
     }
 
     /**
@@ -62087,7 +64536,7 @@ class meta_type {
      */
     [[nodiscard]] meta_data data(const id_type id) const {
         const auto *elem = internal::look_for<&internal::meta_type_descriptor::data>(internal::meta_context::from(*ctx), node, id);
-        return elem ? meta_data{*ctx, *elem} : meta_data{};
+        return (elem != nullptr) ? meta_data{*ctx, *elem} : meta_data{};
     }
 
     /**
@@ -62109,27 +64558,23 @@ class meta_type {
      */
     [[nodiscard]] meta_func func(const id_type id) const {
         const auto *elem = internal::look_for<&internal::meta_type_descriptor::func>(internal::meta_context::from(*ctx), node, id);
-        return elem ? meta_func{*ctx, *elem} : meta_func{};
+        return (elem != nullptr) ? meta_func{*ctx, *elem} : meta_func{};
     }
 
     /**
      * @brief Creates an instance of the underlying type, if possible.
-     *
-     * @warning
-     * The context of the arguments is **never** changed.
-     *
      * @param args Parameters to use to construct the instance.
      * @param sz Number of parameters to use to construct the instance.
      * @return A wrapper containing the new instance, if any.
      */
     [[nodiscard]] meta_any construct(meta_any *const args, const size_type sz) const {
         if(node.details) {
-            if(const auto *candidate = lookup(args, sz, false, [first = node.details->ctor.cbegin(), last = node.details->ctor.cend()]() mutable { return first == last ? nullptr : &(first++)->second; }); candidate) {
+            if(const auto *candidate = lookup(args, sz, false, [first = node.details->ctor.cbegin(), last = node.details->ctor.cend()]() mutable { return first == last ? nullptr : &*(first++); }); candidate) {
                 return candidate->invoke(*ctx, args);
             }
         }
 
-        if(sz == 0u && node.default_constructor) {
+        if(sz == 0u && (node.default_constructor != nullptr)) {
             return node.default_constructor(*ctx);
         }
 
@@ -62144,30 +64589,26 @@ class meta_type {
      */
     template<typename... Args>
     [[nodiscard]] meta_any construct(Args &&...args) const {
-        meta_any arguments[sizeof...(Args) + !sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
-        return construct(arguments, sizeof...(Args));
+        std::array<meta_any, sizeof...(Args)> arguments{meta_any{*ctx, std::forward<Args>(args)}...};
+        return construct(arguments.data(), sizeof...(Args));
     }
 
     /**
      * @brief Wraps an opaque element of the underlying type.
-     * @param element A valid pointer to an element of the underlying type.
+     * @param elem A valid pointer to an element of the underlying type.
      * @return A wrapper that references the given instance.
      */
-    [[nodiscard]] meta_any from_void(void *element) const {
-        return (element && node.from_void) ? node.from_void(*ctx, element, nullptr) : meta_any{meta_ctx_arg, *ctx};
+    [[nodiscard]] meta_any from_void(void *elem) const {
+        return ((elem != nullptr) && (node.from_void != nullptr)) ? node.from_void(*ctx, elem, nullptr) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /*! @copydoc from_void */
-    [[nodiscard]] meta_any from_void(const void *element) const {
-        return (element && node.from_void) ? node.from_void(*ctx, nullptr, element) : meta_any{meta_ctx_arg, *ctx};
+    [[nodiscard]] meta_any from_void(const void *elem) const {
+        return ((elem != nullptr) && (node.from_void != nullptr)) ? node.from_void(*ctx, nullptr, elem) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /**
      * @brief Invokes a function given an identifier, if possible.
-     *
-     * @warning
-     * The context of the arguments is **never** changed.
-     *
      * @param id Unique identifier.
      * @param instance An opaque instance of the underlying type.
      * @param args Parameters to use to invoke the function.
@@ -62176,8 +64617,8 @@ class meta_type {
      */
     meta_any invoke(const id_type id, meta_handle instance, meta_any *const args, const size_type sz) const {
         if(node.details) {
-            if(auto it = node.details->func.find(id); it != node.details->func.cend()) {
-                if(const auto *candidate = lookup(args, sz, instance && (instance->data() == nullptr), [curr = &it->second]() mutable { return curr ? std::exchange(curr, curr->next.get()) : nullptr; }); candidate) {
+            if(auto *elem = internal::find_member<&internal::meta_func_node::id>(node.details->func, id); elem != nullptr) {
+                if(const auto *candidate = lookup(args, sz, instance && (instance->data() == nullptr), [curr = elem]() mutable { return (curr != nullptr) ? std::exchange(curr, curr->next.get()) : nullptr; }); candidate) {
                     return candidate->invoke(*ctx, meta_handle{*ctx, std::move(instance)}, args);
                 }
             }
@@ -62201,9 +64642,10 @@ class meta_type {
      * @return A wrapper containing the returned value, if any.
      */
     template<typename... Args>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
     meta_any invoke(const id_type id, meta_handle instance, Args &&...args) const {
-        meta_any arguments[sizeof...(Args) + !sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
-        return invoke(id, std::move(instance), arguments, sizeof...(Args));
+        std::array<meta_any, sizeof...(Args)> arguments{meta_any{*ctx, std::forward<Args>(args)}...};
+        return invoke(id, std::move(instance), arguments.data(), sizeof...(Args));
     }
 
     /**
@@ -62235,7 +64677,7 @@ class meta_type {
      * @brief Returns a range to visit registered top-level meta properties.
      * @return An iterable range to visit registered top-level meta properties.
      */
-    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator> prop() const noexcept {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator> prop() const noexcept {
         using range_type = meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator>;
         return node.details ? range_type{{*ctx, node.details->prop.cbegin()}, {*ctx, node.details->prop.cend()}} : range_type{};
     }
@@ -62245,9 +64687,20 @@ class meta_type {
      * @param key The key to use to search for a property.
      * @return The registered meta property for the given key, if any.
      */
-    [[nodiscard]] meta_prop prop(const id_type key) const {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_prop prop(const id_type key) const {
         const auto *elem = internal::look_for<&internal::meta_type_descriptor::prop>(internal::meta_context::from(*ctx), node, key);
-        return elem ? meta_prop{*ctx, *elem} : meta_prop{};
+        return (elem != nullptr) ? meta_prop{*ctx, *elem} : meta_prop{};
+    }
+
+    /*! @copydoc meta_data::traits */
+    template<typename Type>
+    [[nodiscard]] Type traits() const noexcept {
+        return internal::meta_to_user_traits<Type>(node.traits);
+    }
+
+    /*! @copydoc meta_data::custom */
+    [[nodiscard]] meta_custom custom() const noexcept {
+        return {node.custom};
     }
 
     /**
@@ -62260,12 +64713,12 @@ class meta_type {
 
     /*! @copydoc meta_prop::operator== */
     [[nodiscard]] bool operator==(const meta_type &other) const noexcept {
-        return (ctx == other.ctx) && ((!node.info && !other.node.info) || (node.info && other.node.info && *node.info == *other.node.info));
+        return (ctx == other.ctx) && (((node.info == nullptr) && (other.node.info == nullptr)) || ((node.info != nullptr) && (other.node.info != nullptr) && *node.info == *other.node.info));
     }
 
 private:
-    internal::meta_type_node node;
-    const meta_ctx *ctx;
+    internal::meta_type_node node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -62279,10 +64732,11 @@ class meta_type {
 }
 
 [[nodiscard]] inline meta_type meta_any::type() const noexcept {
-    return node.info ? meta_type{*ctx, node} : meta_type{};
+    return (node.info != nullptr) ? meta_type{*ctx, node} : meta_type{};
 }
 
 template<typename... Args>
+// NOLINTNEXTLINE(modernize-use-nodiscard)
 meta_any meta_any::invoke(const id_type id, Args &&...args) const {
     return type().invoke(id, *this, std::forward<Args>(args)...);
 }
@@ -62364,18 +64818,14 @@ class meta_sequence_container::meta_iterator final {
     }
 
 public:
-    using difference_type = std::ptrdiff_t;
     using value_type = meta_any;
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::bidirectional_iterator_tag;
 
-    meta_iterator() noexcept
-        : meta_iterator{locator<meta_ctx>::value_or()} {}
-
-    meta_iterator(const meta_ctx &area) noexcept
-        : ctx{&area} {}
+    meta_iterator() = default;
 
     template<typename It>
     meta_iterator(const meta_ctx &area, It iter) noexcept
@@ -62432,7 +64882,7 @@ class meta_sequence_container::meta_iterator final {
     }
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     vtable_type *vtable{};
     any handle{};
 };
@@ -62455,18 +64905,14 @@ class meta_associative_container::meta_iterator final {
     }
 
 public:
-    using difference_type = std::ptrdiff_t;
     using value_type = std::pair<meta_any, meta_any>;
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    meta_iterator() noexcept
-        : meta_iterator{locator<meta_ctx>::value_or()} {}
-
-    meta_iterator(const meta_ctx &area) noexcept
-        : ctx{&area} {}
+    meta_iterator() = default;
 
     template<bool KeyOnly, typename It>
     meta_iterator(const meta_ctx &area, std::bool_constant<KeyOnly>, It iter) noexcept
@@ -62508,7 +64954,7 @@ class meta_associative_container::meta_iterator final {
     }
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     vtable_type *vtable{};
     any handle{};
 };
@@ -62519,7 +64965,7 @@ class meta_associative_container::meta_iterator final {
  * @return The meta value type of the container.
  */
 [[nodiscard]] inline meta_type meta_sequence_container::value_type() const noexcept {
-    return value_type_node ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (value_type_node != nullptr) ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /**
@@ -62578,14 +65024,14 @@ inline bool meta_sequence_container::reserve(const size_type sz) {
  * @param value Element value to insert.
  * @return A possibly invalid iterator to the inserted element.
  */
-inline meta_sequence_container::iterator meta_sequence_container::insert(iterator it, meta_any value) {
+inline meta_sequence_container::iterator meta_sequence_container::insert(const iterator &it, meta_any value) {
     // this abomination is necessary because only on macos value_type and const_reference are different types for std::vector<bool>
     if(const auto vtype = value_type_node(internal::meta_context::from(*ctx)); !const_only && (value.allow_cast({*ctx, vtype}) || value.allow_cast({*ctx, const_reference_node(internal::meta_context::from(*ctx))}))) {
         const bool is_value_type = (value.type().info() == *vtype.info);
         return insert_fn(*ctx, const_cast<void *>(data), is_value_type ? std::as_const(value).data() : nullptr, is_value_type ? nullptr : std::as_const(value).data(), it);
     }
 
-    return iterator{*ctx};
+    return iterator{};
 }
 
 /**
@@ -62593,13 +65039,12 @@ inline meta_sequence_container::iterator meta_sequence_container::insert(iterato
  * @param it Iterator to the element to remove.
  * @return A possibly invalid iterator following the last removed element.
  */
-inline meta_sequence_container::iterator meta_sequence_container::erase(iterator it) {
-    return const_only ? iterator{*ctx} : erase_fn(*ctx, const_cast<void *>(data), it);
+inline meta_sequence_container::iterator meta_sequence_container::erase(const iterator &it) {
+    return const_only ? iterator{} : erase_fn(*ctx, const_cast<void *>(data), it);
 }
 
 /**
- * @brief Returns a reference to the element at a given location of a container
- * (no bounds checking is performed).
+ * @brief Returns a reference to the element at a given location of a container.
  * @param pos The position of the element to return.
  * @return A reference to the requested element properly wrapped.
  */
@@ -62617,20 +65062,12 @@ inline meta_sequence_container::iterator meta_sequence_container::erase(iterator
     return (data != nullptr);
 }
 
-/**
- * @brief Returns true if a container is also key-only, false otherwise.
- * @return True if the associative container is also key-only, false otherwise.
- */
-[[deprecated("use mapped_type() instead")]] [[nodiscard]] inline bool meta_associative_container::key_only() const noexcept {
-    return (mapped_type_node == nullptr);
-}
-
 /**
  * @brief Returns the meta key type of a container.
  * @return The meta key type of the a container.
  */
 [[nodiscard]] inline meta_type meta_associative_container::key_type() const noexcept {
-    return key_type_node ? meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (key_type_node != nullptr) ? meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /**
@@ -62638,12 +65075,12 @@ inline meta_sequence_container::iterator meta_sequence_container::erase(iterator
  * @return The meta mapped type of the a container.
  */
 [[nodiscard]] inline meta_type meta_associative_container::mapped_type() const noexcept {
-    return mapped_type_node ? meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (mapped_type_node != nullptr) ? meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /*! @copydoc meta_sequence_container::value_type */
 [[nodiscard]] inline meta_type meta_associative_container::value_type() const noexcept {
-    return value_type_node ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (value_type_node != nullptr) ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /*! @copydoc meta_sequence_container::size */
@@ -62679,7 +65116,7 @@ inline bool meta_associative_container::reserve(const size_type sz) {
  */
 inline bool meta_associative_container::insert(meta_any key, meta_any value = {}) {
     return !const_only && key.allow_cast(meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))})
-           && (!mapped_type_node || value.allow_cast(meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))}))
+           && ((mapped_type_node == nullptr) || value.allow_cast(meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))}))
            && insert_fn(const_cast<void *>(data), std::as_const(key).data(), std::as_const(value).data());
 }
 
@@ -62698,7 +65135,7 @@ inline meta_associative_container::size_type meta_associative_container::erase(m
  * @return An iterator to the element with the given key, if any.
  */
 [[nodiscard]] inline meta_associative_container::iterator meta_associative_container::find(meta_any key) {
-    return key.allow_cast(meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))}) ? find_fn(*ctx, const_only ? nullptr : const_cast<void *>(data), data, std::as_const(key).data()) : iterator{*ctx};
+    return key.allow_cast(meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))}) ? find_fn(*ctx, const_only ? nullptr : const_cast<void *>(data), data, std::as_const(key).data()) : iterator{};
 }
 
 /**
@@ -62759,14 +65196,14 @@ template<typename Type>
 struct basic_meta_sequence_container_traits {
     static_assert(std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<Type>>>, "Unexpected type");
 
-    /*! @brief True in case of key-only containers, false otherwise. */
-    static constexpr bool fixed_size = internal::fixed_size_sequence_container_v<Type>;
-
     /*! @brief Unsigned integer type. */
     using size_type = typename meta_sequence_container::size_type;
     /*! @brief Meta iterator type. */
     using iterator = typename meta_sequence_container::iterator;
 
+    /*! @brief True in case of key-only containers, false otherwise. */
+    static constexpr bool fixed_size = internal::fixed_size_sequence_container_v<Type>;
+
     /**
      * @brief Returns the number of elements in a container.
      * @param container Opaque pointer to a container of the given type.
@@ -62828,8 +65265,8 @@ struct basic_meta_sequence_container_traits {
      * @return An iterator to the first element of the container.
      */
     static iterator begin(const meta_ctx &area, void *container, const void *as_const) {
-        return container ? iterator{area, static_cast<Type *>(container)->begin()}
-                         : iterator{area, static_cast<const Type *>(as_const)->begin()};
+        return (container != nullptr) ? iterator{area, static_cast<Type *>(container)->begin()}
+                                      : iterator{area, static_cast<const Type *>(as_const)->begin()};
     }
 
     /**
@@ -62840,8 +65277,8 @@ struct basic_meta_sequence_container_traits {
      * @return An iterator that is past the last element of the container.
      */
     static iterator end(const meta_ctx &area, void *container, const void *as_const) {
-        return container ? iterator{area, static_cast<Type *>(container)->end()}
-                         : iterator{area, static_cast<const Type *>(as_const)->end()};
+        return (container != nullptr) ? iterator{area, static_cast<Type *>(container)->end()}
+                                      : iterator{area, static_cast<const Type *>(as_const)->end()};
     }
 
     /**
@@ -62856,14 +65293,14 @@ struct basic_meta_sequence_container_traits {
      * @param it Iterator before which the element will be inserted.
      * @return A possibly invalid iterator to the inserted element.
      */
-    [[nodiscard]] static iterator insert(const meta_ctx &area, [[maybe_unused]] void *container, [[maybe_unused]] const void *value, [[maybe_unused]] const void *cref, [[maybe_unused]] const iterator &it) {
+    [[nodiscard]] static iterator insert([[maybe_unused]] const meta_ctx &area, [[maybe_unused]] void *container, [[maybe_unused]] const void *value, [[maybe_unused]] const void *cref, [[maybe_unused]] const iterator &it) {
         if constexpr(fixed_size) {
-            return iterator{area};
+            return iterator{};
         } else {
             auto *const non_const = any_cast<typename Type::iterator>(&it.base());
             return {area, static_cast<Type *>(container)->insert(
                               non_const ? *non_const : any_cast<const typename Type::const_iterator &>(it.base()),
-                              value ? *static_cast<const typename Type::value_type *>(value) : *static_cast<const std::remove_reference_t<typename Type::const_reference> *>(cref))};
+                              (value != nullptr) ? *static_cast<const typename Type::value_type *>(value) : *static_cast<const std::remove_reference_t<typename Type::const_reference> *>(cref))};
         }
     }
 
@@ -62874,9 +65311,9 @@ struct basic_meta_sequence_container_traits {
      * @param it An opaque iterator to the element to erase.
      * @return A possibly invalid iterator following the last removed element.
      */
-    [[nodiscard]] static iterator erase(const meta_ctx &area, [[maybe_unused]] void *container, [[maybe_unused]] const iterator &it) {
+    [[nodiscard]] static iterator erase([[maybe_unused]] const meta_ctx &area, [[maybe_unused]] void *container, [[maybe_unused]] const iterator &it) {
         if constexpr(fixed_size) {
-            return iterator{area};
+            return iterator{};
         } else {
             auto *const non_const = any_cast<typename Type::iterator>(&it.base());
             return {area, static_cast<Type *>(container)->erase(non_const ? *non_const : any_cast<const typename Type::const_iterator &>(it.base()))};
@@ -62892,14 +65329,14 @@ template<typename Type>
 struct basic_meta_associative_container_traits {
     static_assert(std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<Type>>>, "Unexpected type");
 
-    /*! @brief True in case of key-only containers, false otherwise. */
-    static constexpr bool key_only = internal::key_only_associative_container_v<Type>;
-
     /*! @brief Unsigned integer type. */
     using size_type = typename meta_associative_container::size_type;
     /*! @brief Meta iterator type. */
     using iterator = typename meta_associative_container::iterator;
 
+    /*! @brief True in case of key-only containers, false otherwise. */
+    static constexpr bool key_only = internal::key_only_associative_container_v<Type>;
+
     /**
      * @brief Returns the number of elements in a container.
      * @param container Opaque pointer to a container of the given type.
@@ -62942,8 +65379,8 @@ struct basic_meta_associative_container_traits {
      * @return An iterator to the first element of the container.
      */
     static iterator begin(const meta_ctx &area, void *container, const void *as_const) {
-        return container ? iterator{area, std::bool_constant<key_only>{}, static_cast<Type *>(container)->begin()}
-                         : iterator{area, std::bool_constant<key_only>{}, static_cast<const Type *>(as_const)->begin()};
+        return (container != nullptr) ? iterator{area, std::bool_constant<key_only>{}, static_cast<Type *>(container)->begin()}
+                                      : iterator{area, std::bool_constant<key_only>{}, static_cast<const Type *>(as_const)->begin()};
     }
 
     /**
@@ -62954,8 +65391,8 @@ struct basic_meta_associative_container_traits {
      * @return An iterator that is past the last element of the container.
      */
     static iterator end(const meta_ctx &area, void *container, const void *as_const) {
-        return container ? iterator{area, std::bool_constant<key_only>{}, static_cast<Type *>(container)->end()}
-                         : iterator{area, std::bool_constant<key_only>{}, static_cast<const Type *>(as_const)->end()};
+        return (container != nullptr) ? iterator{area, std::bool_constant<key_only>{}, static_cast<Type *>(container)->end()}
+                                      : iterator{area, std::bool_constant<key_only>{}, static_cast<const Type *>(as_const)->end()};
     }
 
     /**
@@ -62992,8 +65429,8 @@ struct basic_meta_associative_container_traits {
      * @return An iterator to the element with the given key, if any.
      */
     static iterator find(const meta_ctx &area, void *container, const void *as_const, const void *key) {
-        return container ? iterator{area, std::bool_constant<key_only>{}, static_cast<Type *>(container)->find(*static_cast<const typename Type::key_type *>(key))}
-                         : iterator{area, std::bool_constant<key_only>{}, static_cast<const Type *>(as_const)->find(*static_cast<const typename Type::key_type *>(key))};
+        return (container != nullptr) ? iterator{area, std::bool_constant<key_only>{}, static_cast<Type *>(container)->find(*static_cast<const typename Type::key_type *>(key))}
+                                      : iterator{area, std::bool_constant<key_only>{}, static_cast<const Type *>(as_const)->find(*static_cast<const typename Type::key_type *>(key))};
     }
 };
 
@@ -63145,6 +65582,7 @@ class meta_ctx: private internal::meta_context {
 #define ENTT_META_FACTORY_HPP
 
 #include <cstddef>
+#include <cstdint>
 #include <functional>
 #include <memory>
 #include <tuple>
@@ -63152,6 +65590,8 @@ class meta_ctx: private internal::meta_context {
 #include <utility>
 // #include "../config/config.h"
 
+// #include "../core/bit.hpp"
+
 // #include "../core/fwd.hpp"
 
 // #include "../core/type_info.hpp"
@@ -63322,7 +65762,7 @@ template<typename Type>
 [[nodiscard]] inline meta_type resolve(const meta_ctx &ctx, const type_info &info) noexcept {
     auto &&context = internal::meta_context::from(ctx);
     const auto *elem = internal::try_resolve(context, info);
-    return elem ? meta_type{ctx, *elem} : meta_type{};
+    return (elem != nullptr) ? meta_type{ctx, *elem} : meta_type{};
 }
 
 /**
@@ -63475,7 +65915,7 @@ class meta_function_helper {
     template<typename Ret, typename... Args, typename Class>
     static constexpr meta_function_descriptor<Type, Ret (Class::*)(Args...)> get_rid_of_noexcept(Ret (Class::*)(Args...));
 
-    template<typename Ret, typename Class>
+    template<typename Ret, typename Class, typename = std::enable_if_t<std::is_member_object_pointer_v<Ret Class::*>>>
     static constexpr meta_function_descriptor<Type, Ret Class::*> get_rid_of_noexcept(Ret Class::*);
 
     template<typename Ret, typename... Args>
@@ -63673,15 +66113,16 @@ template<typename Policy, typename Candidate, typename... Args>
 }
 
 template<typename Type, typename Policy, typename Candidate, std::size_t... Index>
-[[nodiscard]] meta_any meta_invoke(const meta_ctx &ctx, [[maybe_unused]] meta_handle instance, Candidate &&candidate, [[maybe_unused]] meta_any *args, std::index_sequence<Index...>) {
+[[nodiscard]] meta_any meta_invoke(const meta_ctx &ctx, [[maybe_unused]] meta_handle instance, Candidate &&candidate, [[maybe_unused]] meta_any *const args, std::index_sequence<Index...>) {
     using descriptor = meta_function_helper_t<Type, std::remove_reference_t<Candidate>>;
 
+    // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
     if constexpr(std::is_invocable_v<std::remove_reference_t<Candidate>, const Type &, type_list_element_t<Index, typename descriptor::args_type>...>) {
         if(const auto *const clazz = instance->try_cast<const Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
             return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), *clazz, (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
         }
     } else if constexpr(std::is_invocable_v<std::remove_reference_t<Candidate>, Type &, type_list_element_t<Index, typename descriptor::args_type>...>) {
-        if(auto *const clazz = instance->try_cast<Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) { // NOLINT
+        if(auto *const clazz = instance->try_cast<Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
             return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), *clazz, (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
         }
     } else {
@@ -63689,15 +66130,18 @@ template<typename Type, typename Policy, typename Candidate, std::size_t... Inde
             return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
         }
     }
+    // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
     return meta_any{meta_ctx_arg, ctx};
 }
 
 template<typename Type, typename... Args, std::size_t... Index>
 [[nodiscard]] meta_any meta_construct(const meta_ctx &ctx, meta_any *const args, std::index_sequence<Index...>) {
+    // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
     if(((args + Index)->allow_cast<Args>() && ...)) {
         return meta_any{ctx, std::in_place_type<Type>, (args + Index)->cast<Args>()...};
     }
+    // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
     return meta_any{meta_ctx_arg, ctx};
 }
@@ -63825,6 +66269,7 @@ template<typename Type, typename Policy = as_is_t, typename Candidate>
     if constexpr(meta_function_helper_t<Type, Candidate>::is_static || std::is_class_v<std::remove_cv_t<std::remove_reference_t<Candidate>>>) {
         return internal::meta_invoke<Type, Policy>(ctx, {}, std::forward<Candidate>(candidate), args, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
     } else {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
         return internal::meta_invoke<Type, Policy>(ctx, *args, std::forward<Candidate>(candidate), args + 1u, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
     }
 }
@@ -63885,52 +66330,154 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-[[nodiscard]] inline decltype(auto) owner(meta_ctx &ctx, const type_info &info) {
-    auto &&context = internal::meta_context::from(ctx);
-    ENTT_ASSERT(context.value.contains(info.hash()), "Type not available");
-    return context.value[info.hash()];
-}
+class basic_meta_factory {
+    using invoke_type = std::remove_pointer_t<decltype(meta_func_node::invoke)>;
 
-inline meta_data_node &meta_extend(internal::meta_type_node &parent, const id_type id, meta_data_node node) {
-    return parent.details->data.insert_or_assign(id, std::move(node)).first->second;
-}
+    auto *find_member_or_assert() {
+        auto *member = find_member<&meta_data_node::id>(details->data, bucket);
+        ENTT_ASSERT(member != nullptr, "Cannot find member");
+        return member;
+    }
 
-inline meta_func_node &meta_extend(internal::meta_type_node &parent, const id_type id, meta_func_node node) {
-    if(auto it = parent.details->func.find(id); it != parent.details->func.end()) {
-        for(auto *curr = &it->second; curr; curr = curr->next.get()) {
-            if(curr->invoke == node.invoke) {
-                node.next = std::move(curr->next);
-                *curr = std::move(node);
-                return *curr;
-            }
+    auto *find_overload_or_assert() {
+        auto *overload = find_overload(find_member<&meta_func_node::id>(details->func, bucket), invoke);
+        ENTT_ASSERT(overload != nullptr, "Cannot find overload");
+        return overload;
+    }
+
+    void reset_bucket(const id_type id, invoke_type *const ref = nullptr) {
+        invoke = ref;
+        bucket = id;
+    }
+
+protected:
+    void type(const id_type id) noexcept {
+        reset_bucket(parent);
+        auto &&elem = meta_context::from(*ctx).value[parent];
+        ENTT_ASSERT(elem.id == id || !resolve(*ctx, id), "Duplicate identifier");
+        elem.id = id;
+    }
+
+    template<typename Type>
+    void insert_or_assign(Type node) {
+        reset_bucket(parent);
+
+        if constexpr(std::is_same_v<Type, meta_base_node>) {
+            auto *member = find_member<&meta_base_node::type>(details->base, node.type);
+            member ? (*member = node) : details->base.emplace_back(node);
+        } else if constexpr(std::is_same_v<Type, meta_conv_node>) {
+            auto *member = find_member<&meta_conv_node::type>(details->conv, node.type);
+            member ? (*member = node) : details->conv.emplace_back(node);
+        } else {
+            static_assert(std::is_same_v<Type, meta_ctor_node>, "Unexpected type");
+            auto *member = find_member<&meta_ctor_node::id>(details->ctor, node.id);
+            member ? (*member = node) : details->ctor.emplace_back(node);
         }
+    }
 
-        // locally overloaded function
-        node.next = std::make_shared<meta_func_node>(std::move(parent.details->func[id]));
+    void dtor(meta_dtor_node node) {
+        reset_bucket(parent);
+        meta_context::from(*ctx).value[parent].dtor = node;
     }
 
-    return parent.details->func.insert_or_assign(id, std::move(node)).first->second;
-}
+    void data(meta_data_node node) {
+        reset_bucket(node.id);
+
+        if(auto *member = find_member<&meta_data_node::id>(details->data, node.id); member == nullptr) {
+            details->data.emplace_back(std::move(node));
+        } else if(member->set != node.set || member->get != node.get) {
+            *member = std::move(node);
+        }
+    }
+
+    void func(meta_func_node node) {
+        reset_bucket(node.id, node.invoke);
+
+        if(auto *member = find_member<&meta_func_node::id>(details->func, node.id); member == nullptr) {
+            details->func.emplace_back(std::move(node));
+        } else if(auto *overload = find_overload(member, node.invoke); overload == nullptr) {
+            while(member->next != nullptr) { member = member->next.get(); }
+            member->next = std::make_shared<meta_func_node>(std::move(node));
+        }
+    }
+
+    void prop(meta_prop_node node) {
+        std::vector<meta_prop_node> *container = nullptr;
+
+        if(bucket == parent) {
+            container = &details->prop;
+        } else if(invoke == nullptr) {
+            container = &find_member_or_assert()->prop;
+        } else {
+            container = &find_overload_or_assert()->prop;
+        }
+
+        auto *member = find_member<&meta_prop_node::id>(*container, node.id);
+        (member != nullptr) ? (*member = std::move(node)) : container->emplace_back(std::move(node));
+    }
+
+    void traits(const meta_traits value) {
+        if(bucket == parent) {
+            meta_context::from(*ctx).value[bucket].traits |= value;
+        } else if(invoke == nullptr) {
+            find_member_or_assert()->traits |= value;
+        } else {
+            find_overload_or_assert()->traits |= value;
+        }
+    }
+
+    void custom(meta_custom_node node) {
+        if(bucket == parent) {
+            meta_context::from(*ctx).value[bucket].custom = std::move(node);
+        } else if(invoke == nullptr) {
+            find_member_or_assert()->custom = std::move(node);
+        } else {
+            find_overload_or_assert()->custom = std::move(node);
+        }
+    }
+
+public:
+    basic_meta_factory(const id_type id, meta_ctx &area)
+        : ctx{&area},
+          parent{id},
+          bucket{id} {
+        auto &&elem = meta_context::from(*ctx).value[parent];
+
+        if(!elem.details) {
+            elem.details = std::make_shared<meta_type_descriptor>();
+        }
+
+        details = elem.details.get();
+    }
+
+private:
+    meta_ctx *ctx{};
+    id_type parent{};
+    id_type bucket{};
+    invoke_type *invoke{};
+    meta_type_descriptor *details{};
+};
 
 } // namespace internal
 /*! @endcond */
 
 /**
- * @brief Basic meta factory to be used for reflection purposes.
+ * @brief Meta factory to be used for reflection purposes.
  * @tparam Type Reflected type for which the factory was created.
  */
 template<typename Type>
-class meta_factory {
+class meta_factory: private internal::basic_meta_factory {
+    using base_type = internal::basic_meta_factory;
+
     template<typename Setter, auto Getter, typename Policy, std::size_t... Index>
     void data(const id_type id, std::index_sequence<Index...>) noexcept {
         using data_type = std::invoke_result_t<decltype(Getter), Type &>;
         using args_type = type_list<typename meta_function_helper_t<Type, decltype(value_list_element_v<Index, Setter>)>::args_type...>;
         static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");
 
-        auto &&elem = internal::meta_extend(
-            internal::owner(*ctx, *info),
-            id,
+        base_type::data(
             internal::meta_data_node{
+                id,
                 /* this is never static */
                 (std::is_member_object_pointer_v<decltype(value_list_element_v<Index, Setter>)> && ... && std::is_const_v<std::remove_reference_t<data_type>>) ? internal::meta_traits::is_const : internal::meta_traits::is_none,
                 Setter::size,
@@ -63938,42 +66485,27 @@ class meta_factory {
                 &meta_arg<type_list<type_list_element_t<type_list_element_t<Index, args_type>::size != 1u, type_list_element_t<Index, args_type>>...>>,
                 +[](meta_handle instance, meta_any value) { return (meta_setter<Type, value_list_element_v<Index, Setter>>(*instance.operator->(), value.as_ref()) || ...); },
                 &meta_getter<Type, Getter, Policy>});
-
-        bucket = &elem.prop;
     }
 
 public:
     /*! @brief Default constructor. */
     meta_factory() noexcept
-        : meta_factory{locator<meta_ctx>::value_or()} {}
+        : internal::basic_meta_factory{type_id<Type>(), locator<meta_ctx>::value_or()} {}
 
     /**
      * @brief Context aware constructor.
      * @param area The context into which to construct meta types.
      */
     meta_factory(meta_ctx &area) noexcept
-        : ctx{&area},
-          bucket{},
-          info{&type_id<Type>()} {
-        auto &&elem = internal::owner(*ctx, *info);
-
-        if(!elem.details) {
-            elem.details = std::make_shared<internal::meta_type_descriptor>();
-        }
-
-        bucket = &elem.details->prop;
-    }
+        : internal::basic_meta_factory{type_id<Type>().hash(), area} {}
 
     /**
      * @brief Assigns a custom unique identifier to a meta type.
      * @param id A custom unique identifier.
      * @return A meta factory for the given type.
      */
-    auto type(const id_type id) noexcept {
-        auto &&elem = internal::owner(*ctx, *info);
-        ENTT_ASSERT(elem.id == id || !resolve(*ctx, id), "Duplicate identifier");
-        bucket = &elem.details->prop;
-        elem.id = id;
+    meta_factory type(const id_type id) noexcept {
+        base_type::type(id);
         return *this;
     }
 
@@ -63986,11 +66518,10 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<typename Base>
-    auto base() noexcept {
+    meta_factory base() noexcept {
         static_assert(!std::is_same_v<Type, Base> && std::is_base_of_v<Base, Type>, "Invalid base type");
         auto *const op = +[](const void *instance) noexcept { return static_cast<const void *>(static_cast<const Base *>(static_cast<const Type *>(instance))); };
-        internal::owner(*ctx, *info).details->base.insert_or_assign(type_id<Base>().hash(), internal::meta_base_node{&internal::resolve<Base>, op});
-        bucket = nullptr;
+        base_type::insert_or_assign(internal::meta_base_node{type_id<Base>().hash(), &internal::resolve<Base>, op});
         return *this;
     }
 
@@ -64010,8 +66541,7 @@ class meta_factory {
     auto conv() noexcept {
         using conv_type = std::remove_cv_t<std::remove_reference_t<std::invoke_result_t<decltype(Candidate), Type &>>>;
         auto *const op = +[](const meta_ctx &area, const void *instance) { return forward_as_meta(area, std::invoke(Candidate, *static_cast<const Type *>(instance))); };
-        internal::owner(*ctx, *info).details->conv.insert_or_assign(type_id<conv_type>().hash(), internal::meta_conv_node{op});
-        bucket = nullptr;
+        base_type::insert_or_assign(internal::meta_conv_node{type_id<conv_type>().hash(), op});
         return *this;
     }
 
@@ -64025,11 +66555,10 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<typename To>
-    auto conv() noexcept {
+    meta_factory conv() noexcept {
         using conv_type = std::remove_cv_t<std::remove_reference_t<To>>;
         auto *const op = +[](const meta_ctx &area, const void *instance) { return forward_as_meta(area, static_cast<To>(*static_cast<const Type *>(instance))); };
-        internal::owner(*ctx, *info).details->conv.insert_or_assign(type_id<conv_type>().hash(), internal::meta_conv_node{op});
-        bucket = nullptr;
+        base_type::insert_or_assign(internal::meta_conv_node{type_id<conv_type>().hash(), op});
         return *this;
     }
 
@@ -64047,12 +66576,11 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<auto Candidate, typename Policy = as_is_t>
-    auto ctor() noexcept {
+    meta_factory ctor() noexcept {
         using descriptor = meta_function_helper_t<Type, decltype(Candidate)>;
         static_assert(Policy::template value<typename descriptor::return_type>, "Invalid return type for the given policy");
         static_assert(std::is_same_v<std::remove_cv_t<std::remove_reference_t<typename descriptor::return_type>>, Type>, "The function doesn't return an object of the required type");
-        internal::owner(*ctx, *info).details->ctor.insert_or_assign(type_id<typename descriptor::args_type>().hash(), internal::meta_ctor_node{descriptor::args_type::size, &meta_arg<typename descriptor::args_type>, &meta_construct<Type, Candidate, Policy>});
-        bucket = nullptr;
+        base_type::insert_or_assign(internal::meta_ctor_node{type_id<typename descriptor::args_type>().hash(), descriptor::args_type::size, &meta_arg<typename descriptor::args_type>, &meta_construct<Type, Candidate, Policy>});
         return *this;
     }
 
@@ -64067,14 +66595,13 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<typename... Args>
-    auto ctor() noexcept {
+    meta_factory ctor() noexcept {
         // default constructor is already implicitly generated, no need for redundancy
         if constexpr(sizeof...(Args) != 0u) {
             using descriptor = meta_function_helper_t<Type, Type (*)(Args...)>;
-            internal::owner(*ctx, *info).details->ctor.insert_or_assign(type_id<typename descriptor::args_type>().hash(), internal::meta_ctor_node{descriptor::args_type::size, &meta_arg<typename descriptor::args_type>, &meta_construct<Type, Args...>});
+            base_type::insert_or_assign(internal::meta_ctor_node{type_id<typename descriptor::args_type>().hash(), descriptor::args_type::size, &meta_arg<typename descriptor::args_type>, &meta_construct<Type, Args...>});
         }
 
-        bucket = nullptr;
         return *this;
     }
 
@@ -64097,11 +66624,10 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<auto Func>
-    auto dtor() noexcept {
+    meta_factory dtor() noexcept {
         static_assert(std::is_invocable_v<decltype(Func), Type &>, "The function doesn't accept an object of the type provided");
         auto *const op = +[](void *instance) { std::invoke(Func, *static_cast<Type *>(instance)); };
-        internal::owner(*ctx, *info).dtor = internal::meta_dtor_node{op};
-        bucket = nullptr;
+        base_type::dtor(internal::meta_dtor_node{op});
         return *this;
     }
 
@@ -64119,15 +66645,14 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<auto Data, typename Policy = as_is_t>
-    auto data(const id_type id) noexcept {
+    meta_factory data(const id_type id) noexcept {
         if constexpr(std::is_member_object_pointer_v<decltype(Data)>) {
             using data_type = std::invoke_result_t<decltype(Data), Type &>;
             static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");
 
-            auto &&elem = internal::meta_extend(
-                internal::owner(*ctx, *info),
-                id,
+            base_type::data(
                 internal::meta_data_node{
+                    id,
                     /* this is never static */
                     std::is_const_v<std::remove_reference_t<data_type>> ? internal::meta_traits::is_const : internal::meta_traits::is_none,
                     1u,
@@ -64135,8 +66660,6 @@ class meta_factory {
                     &meta_arg<type_list<std::remove_cv_t<std::remove_reference_t<data_type>>>>,
                     &meta_setter<Type, Data>,
                     &meta_getter<Type, Data, Policy>});
-
-            bucket = &elem.prop;
         } else {
             using data_type = std::remove_pointer_t<decltype(Data)>;
 
@@ -64146,18 +66669,15 @@ class meta_factory {
                 static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");
             }
 
-            auto &&elem = internal::meta_extend(
-                internal::owner(*ctx, *info),
-                id,
+            base_type::data(
                 internal::meta_data_node{
+                    id,
                     ((std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<data_type>>> || std::is_const_v<std::remove_reference_t<data_type>>) ? internal::meta_traits::is_const : internal::meta_traits::is_none) | internal::meta_traits::is_static,
                     1u,
                     &internal::resolve<std::remove_cv_t<std::remove_reference_t<data_type>>>,
                     &meta_arg<type_list<std::remove_cv_t<std::remove_reference_t<data_type>>>>,
                     &meta_setter<Type, Data>,
                     &meta_getter<Type, Data, Policy>});
-
-            bucket = &elem.prop;
         }
 
         return *this;
@@ -64184,15 +66704,14 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<auto Setter, auto Getter, typename Policy = as_is_t>
-    auto data(const id_type id) noexcept {
+    meta_factory data(const id_type id) noexcept {
         using data_type = std::invoke_result_t<decltype(Getter), Type &>;
         static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");
 
         if constexpr(std::is_same_v<decltype(Setter), std::nullptr_t>) {
-            auto &&elem = internal::meta_extend(
-                internal::owner(*ctx, *info),
-                id,
+            base_type::data(
                 internal::meta_data_node{
+                    id,
                     /* this is never static */
                     internal::meta_traits::is_const,
                     0u,
@@ -64200,15 +66719,12 @@ class meta_factory {
                     &meta_arg<type_list<>>,
                     &meta_setter<Type, Setter>,
                     &meta_getter<Type, Getter, Policy>});
-
-            bucket = &elem.prop;
         } else {
             using args_type = typename meta_function_helper_t<Type, decltype(Setter)>::args_type;
 
-            auto &&elem = internal::meta_extend(
-                internal::owner(*ctx, *info),
-                id,
+            base_type::data(
                 internal::meta_data_node{
+                    id,
                     /* this is never static nor const */
                     internal::meta_traits::is_none,
                     1u,
@@ -64216,8 +66732,6 @@ class meta_factory {
                     &meta_arg<type_list<type_list_element_t<args_type::size != 1u, args_type>>>,
                     &meta_setter<Type, Setter>,
                     &meta_getter<Type, Getter, Policy>});
-
-            bucket = &elem.prop;
         }
 
         return *this;
@@ -64241,7 +66755,7 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<typename Setter, auto Getter, typename Policy = as_is_t>
-    auto data(const id_type id) noexcept {
+    meta_factory data(const id_type id) noexcept {
         data<Setter, Getter, Policy>(id, std::make_index_sequence<Setter::size>{});
         return *this;
     }
@@ -64260,26 +66774,24 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<auto Candidate, typename Policy = as_is_t>
-    auto func(const id_type id) noexcept {
+    meta_factory func(const id_type id) noexcept {
         using descriptor = meta_function_helper_t<Type, decltype(Candidate)>;
         static_assert(Policy::template value<typename descriptor::return_type>, "Invalid return type for the given policy");
 
-        auto &&elem = internal::meta_extend(
-            internal::owner(*ctx, *info),
-            id,
+        base_type::func(
             internal::meta_func_node{
+                id,
                 (descriptor::is_const ? internal::meta_traits::is_const : internal::meta_traits::is_none) | (descriptor::is_static ? internal::meta_traits::is_static : internal::meta_traits::is_none),
                 descriptor::args_type::size,
                 &internal::resolve<std::conditional_t<std::is_same_v<Policy, as_void_t>, void, std::remove_cv_t<std::remove_reference_t<typename descriptor::return_type>>>>,
                 &meta_arg<typename descriptor::args_type>,
                 &meta_invoke<Type, Candidate, Policy>});
 
-        bucket = &elem.prop;
         return *this;
     }
 
     /**
-     * @brief Assigns a property to the last meta object created.
+     * @brief Assigns a property to the last created meta object.
      *
      * Both the key and the value (if any) must be at least copy constructible.
      *
@@ -64289,24 +66801,44 @@ class meta_factory {
      * @return A meta factory for the parent type.
      */
     template<typename... Value>
-    meta_factory prop(id_type id, [[maybe_unused]] Value &&...value) {
-        ENTT_ASSERT(bucket != nullptr, "Meta object does not support properties");
-
+    [[deprecated("use ::custom() instead")]] meta_factory prop(id_type id, [[maybe_unused]] Value &&...value) {
         if constexpr(sizeof...(Value) == 0u) {
-            (*bucket)[id] = internal::meta_prop_node{&internal::resolve<void>};
+            base_type::prop(internal::meta_prop_node{id, &internal::resolve<void>});
         } else {
-            (*bucket)[id] = internal::meta_prop_node{
-                &internal::resolve<std::decay_t<Value>>...,
-                std::make_shared<std::decay_t<Value>>(std::forward<Value>(value))...};
+            base_type::prop(internal::meta_prop_node{id, &internal::resolve<std::decay_t<Value>>..., std::make_shared<std::decay_t<Value>>(std::forward<Value>(value))...});
         }
 
         return *this;
     }
 
-private:
-    meta_ctx *ctx;
-    dense_map<id_type, internal::meta_prop_node, identity> *bucket;
-    const type_info *info;
+    /**
+     * @brief Sets traits on the last created meta object.
+     *
+     * The assigned value must be an enum and intended as a bitmask.
+     *
+     * @tparam Value Type of the traits value.
+     * @param value Traits value.
+     * @return A meta factory for the parent type.
+     */
+    template<typename Value>
+    meta_factory traits(const Value value) {
+        static_assert(std::is_enum_v<Value>, "Invalid enum type");
+        base_type::traits(internal::user_to_meta_traits(value));
+        return *this;
+    }
+
+    /**
+     * @brief Sets user defined data that will never be used by the library.
+     * @tparam Value Type of user defined data to store.
+     * @tparam Args Types of arguments to use to construct the user data.
+     * @param args Parameters to use to initialize the user data.
+     * @return A meta factory for the parent type.
+     */
+    template<typename Value, typename... Args>
+    meta_factory custom(Args &&...args) {
+        base_type::custom(internal::meta_custom_node{type_id<Value>().hash(), std::make_shared<Value>(std::forward<Args>(args)...)});
+        return *this;
+    }
 };
 
 /**
@@ -64437,6 +66969,7 @@ inline void meta_reset() noexcept {
 #ifndef ENTT_META_META_HPP
 #define ENTT_META_META_HPP
 
+#include <array>
 #include <cstddef>
 #include <iterator>
 #include <memory>
@@ -64487,8 +67020,7 @@ class meta_sequence_container {
     using iterator = meta_iterator;
 
     /*! @brief Default constructor. */
-    meta_sequence_container() noexcept
-        : meta_sequence_container{locator<meta_ctx>::value_or()} {}
+    meta_sequence_container() = default;
 
     /**
      * @brief Context aware constructor.
@@ -64520,18 +67052,18 @@ class meta_sequence_container {
 
     [[nodiscard]] inline meta_type value_type() const noexcept;
     [[nodiscard]] inline size_type size() const noexcept;
-    inline bool resize(const size_type);
+    inline bool resize(size_type);
     inline bool clear();
-    inline bool reserve(const size_type);
+    inline bool reserve(size_type);
     [[nodiscard]] inline iterator begin();
     [[nodiscard]] inline iterator end();
-    inline iterator insert(iterator, meta_any);
-    inline iterator erase(iterator);
-    [[nodiscard]] inline meta_any operator[](const size_type);
+    inline iterator insert(const iterator &, meta_any);
+    inline iterator erase(const iterator &);
+    [[nodiscard]] inline meta_any operator[](size_type);
     [[nodiscard]] inline explicit operator bool() const noexcept;
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     internal::meta_type_node (*value_type_node)(const internal::meta_context &){};
     internal::meta_type_node (*const_reference_node)(const internal::meta_context &){};
     size_type (*size_fn)(const void *){};
@@ -64557,8 +67089,7 @@ class meta_associative_container {
     using iterator = meta_iterator;
 
     /*! @brief Default constructor. */
-    meta_associative_container() noexcept
-        : meta_associative_container{locator<meta_ctx>::value_or()} {}
+    meta_associative_container() = default;
 
     /**
      * @brief Context aware constructor.
@@ -64593,13 +67124,12 @@ class meta_associative_container {
         data = &instance;
     }
 
-    [[nodiscard]] inline bool key_only() const noexcept;
     [[nodiscard]] inline meta_type key_type() const noexcept;
     [[nodiscard]] inline meta_type mapped_type() const noexcept;
     [[nodiscard]] inline meta_type value_type() const noexcept;
     [[nodiscard]] inline size_type size() const noexcept;
     inline bool clear();
-    inline bool reserve(const size_type);
+    inline bool reserve(size_type);
     [[nodiscard]] inline iterator begin();
     [[nodiscard]] inline iterator end();
     inline bool insert(meta_any, meta_any);
@@ -64608,7 +67138,7 @@ class meta_associative_container {
     [[nodiscard]] inline explicit operator bool() const noexcept;
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     internal::meta_type_node (*key_type_node)(const internal::meta_context &){};
     internal::meta_type_node (*mapped_type_node)(const internal::meta_context &){};
     internal::meta_type_node (*value_type_node)(const internal::meta_context &){};
@@ -64665,31 +67195,27 @@ class meta_any {
     }
 
     void release() {
-        if(node.dtor.dtor && (storage.policy() == any_policy::owner)) {
+        if((node.dtor.dtor != nullptr) && (storage.policy() == any_policy::owner)) {
             node.dtor.dtor(storage.data());
         }
     }
 
-    meta_any(const meta_ctx &area, const meta_any &other, any ref) noexcept
+    meta_any(const meta_any &other, any ref) noexcept
         : storage{std::move(ref)},
-          ctx{&area},
+          ctx{other.ctx},
           node{storage ? other.node : internal::meta_type_node{}},
           vtable{storage ? other.vtable : &basic_vtable<void>} {}
 
 public:
     /*! Default constructor. */
-    meta_any() noexcept
-        : meta_any{meta_ctx_arg, locator<meta_ctx>::value_or()} {}
+    meta_any() = default;
 
     /**
      * @brief Context aware constructor.
      * @param area The context from which to search for meta types.
      */
-    meta_any(meta_ctx_arg_t, const meta_ctx &area) noexcept
-        : storage{},
-          ctx{&area},
-          node{},
-          vtable{&basic_vtable<void>} {}
+    meta_any(meta_ctx_arg_t, const meta_ctx &area)
+        : ctx{&area} {}
 
     /**
      * @brief Constructs a wrapper by directly initializing the new object.
@@ -64740,10 +67266,10 @@ class meta_any {
      * @param other The instance to copy from.
      */
     meta_any(const meta_ctx &area, const meta_any &other)
-        : meta_any{other} {
-        ctx = &area;
-        node = node.resolve ? node.resolve(internal::meta_context::from(*ctx)) : node;
-    }
+        : storage{other.storage},
+          ctx{&area},
+          node{(other.node.resolve != nullptr) ? other.node.resolve(internal::meta_context::from(*ctx)) : other.node},
+          vtable{other.vtable} {}
 
     /**
      * @brief Context aware move constructor.
@@ -64751,10 +67277,10 @@ class meta_any {
      * @param other The instance to move from.
      */
     meta_any(const meta_ctx &area, meta_any &&other)
-        : meta_any{std::move(other)} {
-        ctx = &area;
-        node = node.resolve ? node.resolve(internal::meta_context::from(*ctx)) : node;
-    }
+        : storage{std::move(other.storage)},
+          ctx{&area},
+          node{(other.node.resolve != nullptr) ? std::exchange(other.node, internal::meta_type_node{}).resolve(internal::meta_context::from(*ctx)) : std::exchange(other.node, internal::meta_type_node{})},
+          vtable{std::exchange(other.vtable, &basic_vtable<void>)} {}
 
     /**
      * @brief Copy constructor.
@@ -64783,11 +67309,14 @@ class meta_any {
      * @return This meta any object.
      */
     meta_any &operator=(const meta_any &other) {
-        release();
-        storage = other.storage;
-        ctx = other.ctx;
-        node = other.node;
-        vtable = other.vtable;
+        if(this != &other) {
+            release();
+            storage = other.storage;
+            ctx = other.ctx;
+            node = other.node;
+            vtable = other.vtable;
+        }
+
         return *this;
     }
 
@@ -64797,6 +67326,8 @@ class meta_any {
      * @return This meta any object.
      */
     meta_any &operator=(meta_any &&other) noexcept {
+        ENTT_ASSERT(this != &other, "Self move assignment");
+
         release();
         storage = std::move(other.storage);
         ctx = other.ctx;
@@ -64811,9 +67342,8 @@ class meta_any {
      * @param value An instance of an object to use to initialize the wrapper.
      * @return This meta any object.
      */
-    template<typename Type>
-    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>, meta_any &>
-    operator=(Type &&value) {
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>>>
+    meta_any &operator=(Type &&value) {
         emplace<std::decay_t<Type>>(std::forward<Type>(value));
         return *this;
     }
@@ -64839,11 +67369,11 @@ class meta_any {
      * @return A wrapper containing the returned value, if any.
      */
     template<typename... Args>
-    meta_any invoke(const id_type id, Args &&...args) const;
+    meta_any invoke(id_type id, Args &&...args) const;
 
     /*! @copydoc invoke */
     template<typename... Args>
-    meta_any invoke(const id_type id, Args &&...args);
+    meta_any invoke(id_type id, Args &&...args);
 
     /**
      * @brief Sets the value of a given variable.
@@ -64853,17 +67383,17 @@ class meta_any {
      * @return True in case of success, false otherwise.
      */
     template<typename Type>
-    bool set(const id_type id, Type &&value);
+    bool set(id_type id, Type &&value);
 
     /**
      * @brief Gets the value of a given variable.
      * @param id Unique identifier.
      * @return A wrapper containing the value of the underlying variable.
      */
-    [[nodiscard]] meta_any get(const id_type id) const;
+    [[nodiscard]] meta_any get(id_type id) const;
 
     /*! @copydoc get */
-    [[nodiscard]] meta_any get(const id_type id);
+    [[nodiscard]] meta_any get(id_type id);
 
     /**
      * @brief Tries to cast an instance to a given type.
@@ -64893,7 +67423,7 @@ class meta_any {
      * @return A reference to the contained instance.
      */
     template<typename Type>
-    [[nodiscard]] Type cast() const {
+    [[nodiscard]] std::remove_const_t<Type> cast() const {
         auto *const instance = try_cast<std::remove_reference_t<Type>>();
         ENTT_ASSERT(instance, "Invalid instance");
         return static_cast<Type>(*instance);
@@ -64901,7 +67431,7 @@ class meta_any {
 
     /*! @copydoc cast */
     template<typename Type>
-    [[nodiscard]] Type cast() {
+    [[nodiscard]] std::remove_const_t<Type> cast() {
         // forces const on non-reference types to make them work also with wrappers for const references
         auto *const instance = try_cast<std::remove_reference_t<const Type>>();
         ENTT_ASSERT(instance, "Invalid instance");
@@ -65038,7 +67568,7 @@ class meta_any {
 
     /*! @copydoc any::operator== */
     [[nodiscard]] bool operator==(const meta_any &other) const noexcept {
-        return (ctx == other.ctx) && ((!node.info && !other.node.info) || (node.info && other.node.info && *node.info == *other.node.info && storage == other.storage));
+        return (ctx == other.ctx) && (((node.info == nullptr) && (other.node.info == nullptr)) || ((node.info != nullptr) && (other.node.info != nullptr) && *node.info == *other.node.info && storage == other.storage));
     }
 
     /*! @copydoc any::operator!= */
@@ -65048,17 +67578,12 @@ class meta_any {
 
     /*! @copydoc any::as_ref */
     [[nodiscard]] meta_any as_ref() noexcept {
-        return meta_any{*ctx, *this, storage.as_ref()};
+        return meta_any{*this, storage.as_ref()};
     }
 
     /*! @copydoc any::as_ref */
     [[nodiscard]] meta_any as_ref() const noexcept {
-        return meta_any{*ctx, *this, storage.as_ref()};
-    }
-
-    /*! @copydoc any::owner */
-    [[deprecated("use policy() and meta_any_policy instead")]] [[nodiscard]] bool owner() const noexcept {
-        return (storage.policy() == any_policy::owner);
+        return meta_any{*this, storage.as_ref()};
     }
 
     /**
@@ -65070,10 +67595,10 @@ class meta_any {
     }
 
 private:
-    any storage;
-    const meta_ctx *ctx;
-    internal::meta_type_node node;
-    vtable_type *vtable;
+    any storage{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
+    internal::meta_type_node node{};
+    vtable_type *vtable{&basic_vtable<void>};
 };
 
 /**
@@ -65107,28 +67632,27 @@ template<typename Type>
  */
 struct meta_handle {
     /*! Default constructor. */
-    meta_handle() noexcept
-        : meta_handle{meta_ctx_arg, locator<meta_ctx>::value_or()} {}
+    meta_handle() = default;
 
     /**
      * @brief Context aware constructor.
      * @param area The context from which to search for meta types.
      */
-    meta_handle(meta_ctx_arg_t, const meta_ctx &area) noexcept
+    meta_handle(meta_ctx_arg_t, const meta_ctx &area)
         : any{meta_ctx_arg, area} {}
 
     /**
      * @brief Creates a handle that points to an unmanaged object.
      * @param value An instance of an object to use to initialize the handle.
      */
-    meta_handle(meta_any &value) noexcept
+    meta_handle(meta_any &value)
         : any{value.as_ref()} {}
 
     /**
      * @brief Creates a handle that points to an unmanaged object.
      * @param value An instance of an object to use to initialize the handle.
      */
-    meta_handle(const meta_any &value) noexcept
+    meta_handle(const meta_any &value)
         : any{value.as_ref()} {}
 
     /**
@@ -65138,7 +67662,7 @@ struct meta_handle {
      * @param value An instance of an object to use to initialize the handle.
      */
     template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_handle>>>
-    meta_handle(const meta_ctx &ctx, Type &value) noexcept
+    meta_handle(const meta_ctx &ctx, Type &value)
         : any{ctx, std::in_place_type<Type &>, value} {}
 
     /**
@@ -65147,7 +67671,7 @@ struct meta_handle {
      * @param value An instance of an object to use to initialize the handle.
      */
     template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_handle>>>
-    meta_handle(Type &value) noexcept
+    meta_handle(Type &value)
         : meta_handle{locator<meta_ctx>::value_or(), value} {}
 
     /**
@@ -65172,6 +67696,9 @@ struct meta_handle {
     /*! @brief Default move constructor. */
     meta_handle(meta_handle &&) = default;
 
+    /*! @brief Default destructor. */
+    ~meta_handle() = default;
+
     /**
      * @brief Default copy assignment operator, deleted on purpose.
      * @return This meta handle.
@@ -65216,23 +67743,21 @@ struct meta_handle {
     }
 
 private:
-    meta_any any;
+    meta_any any{meta_ctx_arg, locator<meta_ctx>::value_or()};
 };
 
 /*! @brief Opaque wrapper for properties of any type. */
 struct meta_prop {
     /*! @brief Default constructor. */
-    meta_prop() noexcept
-        : node{},
-          ctx{} {}
+    meta_prop() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
      * @param area The context from which to search for meta types.
      * @param curr The underlying node with which to construct the instance.
      */
-    meta_prop(const meta_ctx &area, const internal::meta_prop_node &curr) noexcept
-        : node{&curr},
+    meta_prop(const meta_ctx &area, internal::meta_prop_node curr) noexcept
+        : node{std::move(curr)},
           ctx{&area} {}
 
     /**
@@ -65240,7 +67765,7 @@ struct meta_prop {
      * @return A wrapper containing the value stored with the property.
      */
     [[nodiscard]] meta_any value() const {
-        return node->value ? node->type(internal::meta_context::from(*ctx)).from_void(*ctx, nullptr, node->value.get()) : meta_any{meta_ctx_arg, *ctx};
+        return node.value ? node.type(internal::meta_context::from(*ctx)).from_void(*ctx, nullptr, node.value.get()) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /**
@@ -65248,7 +67773,7 @@ struct meta_prop {
      * @return A wrapper containing the value stored with the property.
      */
     [[nodiscard]] meta_any value() {
-        return node->value ? node->type(internal::meta_context::from(*ctx)).from_void(*ctx, node->value.get(), nullptr) : meta_any{meta_ctx_arg, *ctx};
+        return node.value ? node.type(internal::meta_context::from(*ctx)).from_void(*ctx, node.value.get(), nullptr) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /**
@@ -65256,7 +67781,7 @@ struct meta_prop {
      * @return True if the object is valid, false otherwise.
      */
     [[nodiscard]] explicit operator bool() const noexcept {
-        return (node != nullptr);
+        return static_cast<bool>(node.type);
     }
 
     /**
@@ -65265,12 +67790,12 @@ struct meta_prop {
      * @return True if the objects refer to the same type, false otherwise.
      */
     [[nodiscard]] bool operator==(const meta_prop &other) const noexcept {
-        return (ctx == other.ctx && node == other.node);
+        return (ctx == other.ctx && node.value == other.node.value);
     }
 
 private:
-    const internal::meta_prop_node *node;
-    const meta_ctx *ctx;
+    internal::meta_prop_node node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -65283,15 +67808,48 @@ struct meta_prop {
     return !(lhs == rhs);
 }
 
+/*! @brief Opaque wrapper for user defined data of any type. */
+struct meta_custom {
+    /*! @brief Default constructor. */
+    meta_custom() noexcept = default;
+
+    /**
+     * @brief Basic constructor for meta objects.
+     * @param curr The underlying node with which to construct the instance.
+     */
+    meta_custom(internal::meta_custom_node curr) noexcept
+        : node{std::move(curr)} {}
+
+    /**
+     * @brief Generic conversion operator.
+     * @tparam Type Type to which conversion is requested.
+     */
+    template<typename Type>
+    [[nodiscard]] operator Type *() const noexcept {
+        return (type_id<Type>().hash() == node.type) ? std::static_pointer_cast<Type>(node.value).get() : nullptr;
+    }
+
+    /**
+     * @brief Generic conversion operator.
+     * @tparam Type Type to which conversion is requested.
+     */
+    template<typename Type>
+    [[nodiscard]] operator Type &() const noexcept {
+        ENTT_ASSERT(type_id<Type>().hash() == node.type, "Invalid type");
+        return *std::static_pointer_cast<Type>(node.value);
+    }
+
+private:
+    internal::meta_custom_node node{};
+};
+
 /*! @brief Opaque wrapper for data members. */
 struct meta_data {
     /*! @brief Unsigned integer type. */
     using size_type = typename internal::meta_data_node::size_type;
 
     /*! @brief Default constructor. */
-    meta_data() noexcept
-        : node{},
-          ctx{} {}
+    meta_data() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
@@ -65337,6 +67895,7 @@ struct meta_data {
      * @return True in case of success, false otherwise.
      */
     template<typename Type>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
     bool set(meta_handle instance, Type &&value) const {
         return node->set && node->set(meta_handle{*ctx, std::move(instance)}, meta_any{*ctx, std::forward<Type>(value)});
     }
@@ -65355,13 +67914,13 @@ struct meta_data {
      * @param index Index of the setter of which to return the accepted type.
      * @return The type accepted by the i-th setter.
      */
-    [[nodiscard]] inline meta_type arg(const size_type index) const noexcept;
+    [[nodiscard]] inline meta_type arg(size_type index) const noexcept;
 
     /**
      * @brief Returns a range to visit registered meta properties.
      * @return An iterable range to visit registered meta properties.
      */
-    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_data_node::prop)::const_iterator> prop() const noexcept {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_range<meta_prop, typename decltype(internal::meta_data_node::prop)::const_iterator> prop() const noexcept {
         return {{*ctx, node->prop.cbegin()}, {*ctx, node->prop.cend()}};
     }
 
@@ -65370,9 +67929,32 @@ struct meta_data {
      * @param key The key to use to search for a property.
      * @return The registered meta property for the given key, if any.
      */
-    [[nodiscard]] meta_prop prop(const id_type key) const {
-        const auto it = node->prop.find(key);
-        return it != node->prop.cend() ? meta_prop{*ctx, it->second} : meta_prop{};
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_prop prop(const id_type key) const {
+        for(auto &&elem: node->prop) {
+            if(elem.id == key) {
+                return meta_prop{*ctx, elem};
+            }
+        }
+
+        return meta_prop{};
+    }
+
+    /**
+     * @brief Returns all meta traits for a given meta object.
+     * @tparam Type The type to convert the meta traits to.
+     * @return The registered meta traits, if any.
+     */
+    template<typename Type>
+    [[nodiscard]] Type traits() const noexcept {
+        return internal::meta_to_user_traits<Type>(node->traits);
+    }
+
+    /**
+     * @brief Returns user defined data for a given meta object.
+     * @return User defined arbitrary data.
+     */
+    [[nodiscard]] meta_custom custom() const noexcept {
+        return {node->custom};
     }
 
     /**
@@ -65389,8 +67971,8 @@ struct meta_data {
     }
 
 private:
-    const internal::meta_data_node *node;
-    const meta_ctx *ctx;
+    const internal::meta_data_node *node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -65409,9 +67991,7 @@ struct meta_func {
     using size_type = typename internal::meta_func_node::size_type;
 
     /*! @brief Default constructor. */
-    meta_func() noexcept
-        : node{},
-          ctx{} {}
+    meta_func() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
@@ -65457,14 +68037,10 @@ struct meta_func {
      * @param index Index of the argument of which to return the type.
      * @return The type of the i-th argument of a member function.
      */
-    [[nodiscard]] inline meta_type arg(const size_type index) const noexcept;
+    [[nodiscard]] inline meta_type arg(size_type index) const noexcept;
 
     /**
      * @brief Invokes the underlying function, if possible.
-     *
-     * @warning
-     * The context of the arguments is **never** changed.
-     *
      * @param instance An opaque instance of the underlying type.
      * @param args Parameters to use to invoke the function.
      * @param sz Number of parameters to use to invoke the function.
@@ -65482,13 +68058,14 @@ struct meta_func {
      * @return A wrapper containing the returned value, if any.
      */
     template<typename... Args>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
     meta_any invoke(meta_handle instance, Args &&...args) const {
-        meta_any arguments[sizeof...(Args) + !sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
-        return invoke(std::move(instance), arguments, sizeof...(Args));
+        std::array<meta_any, sizeof...(Args)> arguments{meta_any{*ctx, std::forward<Args>(args)}...};
+        return invoke(std::move(instance), arguments.data(), sizeof...(Args));
     }
 
     /*! @copydoc meta_data::prop */
-    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_func_node::prop)::const_iterator> prop() const noexcept {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_range<meta_prop, typename decltype(internal::meta_func_node::prop)::const_iterator> prop() const noexcept {
         return {{*ctx, node->prop.cbegin()}, {*ctx, node->prop.cend()}};
     }
 
@@ -65497,9 +68074,25 @@ struct meta_func {
      * @param key The key to use to search for a property.
      * @return The registered meta property for the given key, if any.
      */
-    [[nodiscard]] meta_prop prop(const id_type key) const {
-        const auto it = node->prop.find(key);
-        return it != node->prop.cend() ? meta_prop{*ctx, it->second} : meta_prop{};
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_prop prop(const id_type key) const {
+        for(auto &&elem: node->prop) {
+            if(elem.id == key) {
+                return meta_prop{*ctx, elem};
+            }
+        }
+
+        return meta_prop{};
+    }
+
+    /*! @copydoc meta_data::traits */
+    template<typename Type>
+    [[nodiscard]] Type traits() const noexcept {
+        return internal::meta_to_user_traits<Type>(node->traits);
+    }
+
+    /*! @copydoc meta_data::custom */
+    [[nodiscard]] meta_custom custom() const noexcept {
+        return {node->custom};
     }
 
     /**
@@ -65524,8 +68117,8 @@ struct meta_func {
     }
 
 private:
-    const internal::meta_func_node *node;
-    const meta_ctx *ctx;
+    const internal::meta_func_node *node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -65557,16 +68150,18 @@ class meta_type {
                 size_type match{};
                 size_type pos{};
 
+                // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
                 for(; pos < sz && args[pos]; ++pos) {
                     const auto other = curr->arg(*ctx, pos);
                     const auto type = args[pos].type();
 
                     if(const auto &info = other.info(); info == type.info()) {
                         ++match;
-                    } else if(!((type.node.details && (type.node.details->base.contains(info.hash()) || type.node.details->conv.contains(info.hash()))) || (type.node.conversion_helper && other.node.conversion_helper))) {
+                    } else if(!(type.node.conversion_helper && other.node.conversion_helper) && !(type.node.details && (internal::find_member<&internal::meta_base_node::type>(type.node.details->base, info.hash()) || internal::find_member<&internal::meta_conv_node::type>(type.node.details->conv, info.hash())))) {
                         break;
                     }
                 }
+                // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
                 if(pos == sz) {
                     if(!candidate || match > same) {
@@ -65596,17 +68191,15 @@ class meta_type {
     using size_type = typename internal::meta_type_node::size_type;
 
     /*! @brief Default constructor. */
-    meta_type() noexcept
-        : node{},
-          ctx{} {}
+    meta_type() noexcept = default;
 
     /**
      * @brief Context aware constructor for meta objects.
      * @param area The context from which to search for meta types.
      * @param curr The underlying node with which to construct the instance.
      */
-    meta_type(const meta_ctx &area, const internal::meta_type_node &curr) noexcept
-        : node{curr},
+    meta_type(const meta_ctx &area, internal::meta_type_node curr) noexcept
+        : node{std::move(curr)},
           ctx{&area} {}
 
     /**
@@ -65615,7 +68208,7 @@ class meta_type {
      * @param curr The underlying node with which to construct the instance.
      */
     meta_type(const meta_ctx &area, const internal::meta_base_node &curr) noexcept
-        : meta_type{area, curr.type(internal::meta_context::from(area))} {}
+        : meta_type{area, curr.resolve(internal::meta_context::from(area))} {}
 
     /**
      * @brief Returns the type info object of the underlying type.
@@ -65695,7 +68288,7 @@ class meta_type {
      * @return True if the underlying type is a pointer, false otherwise.
      */
     [[nodiscard]] bool is_pointer() const noexcept {
-        return node.info && (node.info->hash() != remove_pointer().info().hash());
+        return static_cast<bool>(node.traits & internal::meta_traits::is_pointer);
     }
 
     /**
@@ -65704,7 +68297,7 @@ class meta_type {
      * doesn't refer to a pointer type.
      */
     [[nodiscard]] meta_type remove_pointer() const noexcept {
-        return {*ctx, node.remove_pointer(internal::meta_context::from(*ctx))}; // NOLINT
+        return {*ctx, node.remove_pointer(internal::meta_context::from(*ctx))};
     }
 
     /**
@@ -65754,7 +68347,7 @@ class meta_type {
      * @return The tag for the class template of the underlying type.
      */
     [[nodiscard]] inline meta_type template_type() const noexcept {
-        return node.templ.type ? meta_type{*ctx, node.templ.type(internal::meta_context::from(*ctx))} : meta_type{};
+        return (node.templ.resolve != nullptr) ? meta_type{*ctx, node.templ.resolve(internal::meta_context::from(*ctx))} : meta_type{};
     }
 
     /**
@@ -65810,7 +68403,7 @@ class meta_type {
      */
     [[nodiscard]] meta_data data(const id_type id) const {
         const auto *elem = internal::look_for<&internal::meta_type_descriptor::data>(internal::meta_context::from(*ctx), node, id);
-        return elem ? meta_data{*ctx, *elem} : meta_data{};
+        return (elem != nullptr) ? meta_data{*ctx, *elem} : meta_data{};
     }
 
     /**
@@ -65832,27 +68425,23 @@ class meta_type {
      */
     [[nodiscard]] meta_func func(const id_type id) const {
         const auto *elem = internal::look_for<&internal::meta_type_descriptor::func>(internal::meta_context::from(*ctx), node, id);
-        return elem ? meta_func{*ctx, *elem} : meta_func{};
+        return (elem != nullptr) ? meta_func{*ctx, *elem} : meta_func{};
     }
 
     /**
      * @brief Creates an instance of the underlying type, if possible.
-     *
-     * @warning
-     * The context of the arguments is **never** changed.
-     *
      * @param args Parameters to use to construct the instance.
      * @param sz Number of parameters to use to construct the instance.
      * @return A wrapper containing the new instance, if any.
      */
     [[nodiscard]] meta_any construct(meta_any *const args, const size_type sz) const {
         if(node.details) {
-            if(const auto *candidate = lookup(args, sz, false, [first = node.details->ctor.cbegin(), last = node.details->ctor.cend()]() mutable { return first == last ? nullptr : &(first++)->second; }); candidate) {
+            if(const auto *candidate = lookup(args, sz, false, [first = node.details->ctor.cbegin(), last = node.details->ctor.cend()]() mutable { return first == last ? nullptr : &*(first++); }); candidate) {
                 return candidate->invoke(*ctx, args);
             }
         }
 
-        if(sz == 0u && node.default_constructor) {
+        if(sz == 0u && (node.default_constructor != nullptr)) {
             return node.default_constructor(*ctx);
         }
 
@@ -65867,30 +68456,26 @@ class meta_type {
      */
     template<typename... Args>
     [[nodiscard]] meta_any construct(Args &&...args) const {
-        meta_any arguments[sizeof...(Args) + !sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
-        return construct(arguments, sizeof...(Args));
+        std::array<meta_any, sizeof...(Args)> arguments{meta_any{*ctx, std::forward<Args>(args)}...};
+        return construct(arguments.data(), sizeof...(Args));
     }
 
     /**
      * @brief Wraps an opaque element of the underlying type.
-     * @param element A valid pointer to an element of the underlying type.
+     * @param elem A valid pointer to an element of the underlying type.
      * @return A wrapper that references the given instance.
      */
-    [[nodiscard]] meta_any from_void(void *element) const {
-        return (element && node.from_void) ? node.from_void(*ctx, element, nullptr) : meta_any{meta_ctx_arg, *ctx};
+    [[nodiscard]] meta_any from_void(void *elem) const {
+        return ((elem != nullptr) && (node.from_void != nullptr)) ? node.from_void(*ctx, elem, nullptr) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /*! @copydoc from_void */
-    [[nodiscard]] meta_any from_void(const void *element) const {
-        return (element && node.from_void) ? node.from_void(*ctx, nullptr, element) : meta_any{meta_ctx_arg, *ctx};
+    [[nodiscard]] meta_any from_void(const void *elem) const {
+        return ((elem != nullptr) && (node.from_void != nullptr)) ? node.from_void(*ctx, nullptr, elem) : meta_any{meta_ctx_arg, *ctx};
     }
 
     /**
      * @brief Invokes a function given an identifier, if possible.
-     *
-     * @warning
-     * The context of the arguments is **never** changed.
-     *
      * @param id Unique identifier.
      * @param instance An opaque instance of the underlying type.
      * @param args Parameters to use to invoke the function.
@@ -65899,8 +68484,8 @@ class meta_type {
      */
     meta_any invoke(const id_type id, meta_handle instance, meta_any *const args, const size_type sz) const {
         if(node.details) {
-            if(auto it = node.details->func.find(id); it != node.details->func.cend()) {
-                if(const auto *candidate = lookup(args, sz, instance && (instance->data() == nullptr), [curr = &it->second]() mutable { return curr ? std::exchange(curr, curr->next.get()) : nullptr; }); candidate) {
+            if(auto *elem = internal::find_member<&internal::meta_func_node::id>(node.details->func, id); elem != nullptr) {
+                if(const auto *candidate = lookup(args, sz, instance && (instance->data() == nullptr), [curr = elem]() mutable { return (curr != nullptr) ? std::exchange(curr, curr->next.get()) : nullptr; }); candidate) {
                     return candidate->invoke(*ctx, meta_handle{*ctx, std::move(instance)}, args);
                 }
             }
@@ -65924,9 +68509,10 @@ class meta_type {
      * @return A wrapper containing the returned value, if any.
      */
     template<typename... Args>
+    // NOLINTNEXTLINE(modernize-use-nodiscard)
     meta_any invoke(const id_type id, meta_handle instance, Args &&...args) const {
-        meta_any arguments[sizeof...(Args) + !sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
-        return invoke(id, std::move(instance), arguments, sizeof...(Args));
+        std::array<meta_any, sizeof...(Args)> arguments{meta_any{*ctx, std::forward<Args>(args)}...};
+        return invoke(id, std::move(instance), arguments.data(), sizeof...(Args));
     }
 
     /**
@@ -65958,7 +68544,7 @@ class meta_type {
      * @brief Returns a range to visit registered top-level meta properties.
      * @return An iterable range to visit registered top-level meta properties.
      */
-    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator> prop() const noexcept {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator> prop() const noexcept {
         using range_type = meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator>;
         return node.details ? range_type{{*ctx, node.details->prop.cbegin()}, {*ctx, node.details->prop.cend()}} : range_type{};
     }
@@ -65968,9 +68554,20 @@ class meta_type {
      * @param key The key to use to search for a property.
      * @return The registered meta property for the given key, if any.
      */
-    [[nodiscard]] meta_prop prop(const id_type key) const {
+    [[nodiscard]] [[deprecated("use ::custom() instead")]] meta_prop prop(const id_type key) const {
         const auto *elem = internal::look_for<&internal::meta_type_descriptor::prop>(internal::meta_context::from(*ctx), node, key);
-        return elem ? meta_prop{*ctx, *elem} : meta_prop{};
+        return (elem != nullptr) ? meta_prop{*ctx, *elem} : meta_prop{};
+    }
+
+    /*! @copydoc meta_data::traits */
+    template<typename Type>
+    [[nodiscard]] Type traits() const noexcept {
+        return internal::meta_to_user_traits<Type>(node.traits);
+    }
+
+    /*! @copydoc meta_data::custom */
+    [[nodiscard]] meta_custom custom() const noexcept {
+        return {node.custom};
     }
 
     /**
@@ -65983,12 +68580,12 @@ class meta_type {
 
     /*! @copydoc meta_prop::operator== */
     [[nodiscard]] bool operator==(const meta_type &other) const noexcept {
-        return (ctx == other.ctx) && ((!node.info && !other.node.info) || (node.info && other.node.info && *node.info == *other.node.info));
+        return (ctx == other.ctx) && (((node.info == nullptr) && (other.node.info == nullptr)) || ((node.info != nullptr) && (other.node.info != nullptr) && *node.info == *other.node.info));
     }
 
 private:
-    internal::meta_type_node node;
-    const meta_ctx *ctx;
+    internal::meta_type_node node{};
+    const meta_ctx *ctx{};
 };
 
 /**
@@ -66002,10 +68599,11 @@ class meta_type {
 }
 
 [[nodiscard]] inline meta_type meta_any::type() const noexcept {
-    return node.info ? meta_type{*ctx, node} : meta_type{};
+    return (node.info != nullptr) ? meta_type{*ctx, node} : meta_type{};
 }
 
 template<typename... Args>
+// NOLINTNEXTLINE(modernize-use-nodiscard)
 meta_any meta_any::invoke(const id_type id, Args &&...args) const {
     return type().invoke(id, *this, std::forward<Args>(args)...);
 }
@@ -66087,18 +68685,14 @@ class meta_sequence_container::meta_iterator final {
     }
 
 public:
-    using difference_type = std::ptrdiff_t;
     using value_type = meta_any;
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::bidirectional_iterator_tag;
 
-    meta_iterator() noexcept
-        : meta_iterator{locator<meta_ctx>::value_or()} {}
-
-    meta_iterator(const meta_ctx &area) noexcept
-        : ctx{&area} {}
+    meta_iterator() = default;
 
     template<typename It>
     meta_iterator(const meta_ctx &area, It iter) noexcept
@@ -66155,7 +68749,7 @@ class meta_sequence_container::meta_iterator final {
     }
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     vtable_type *vtable{};
     any handle{};
 };
@@ -66178,18 +68772,14 @@ class meta_associative_container::meta_iterator final {
     }
 
 public:
-    using difference_type = std::ptrdiff_t;
     using value_type = std::pair<meta_any, meta_any>;
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::forward_iterator_tag;
 
-    meta_iterator() noexcept
-        : meta_iterator{locator<meta_ctx>::value_or()} {}
-
-    meta_iterator(const meta_ctx &area) noexcept
-        : ctx{&area} {}
+    meta_iterator() = default;
 
     template<bool KeyOnly, typename It>
     meta_iterator(const meta_ctx &area, std::bool_constant<KeyOnly>, It iter) noexcept
@@ -66231,7 +68821,7 @@ class meta_associative_container::meta_iterator final {
     }
 
 private:
-    const meta_ctx *ctx{};
+    const meta_ctx *ctx{&locator<meta_ctx>::value_or()};
     vtable_type *vtable{};
     any handle{};
 };
@@ -66242,7 +68832,7 @@ class meta_associative_container::meta_iterator final {
  * @return The meta value type of the container.
  */
 [[nodiscard]] inline meta_type meta_sequence_container::value_type() const noexcept {
-    return value_type_node ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (value_type_node != nullptr) ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /**
@@ -66301,14 +68891,14 @@ inline bool meta_sequence_container::reserve(const size_type sz) {
  * @param value Element value to insert.
  * @return A possibly invalid iterator to the inserted element.
  */
-inline meta_sequence_container::iterator meta_sequence_container::insert(iterator it, meta_any value) {
+inline meta_sequence_container::iterator meta_sequence_container::insert(const iterator &it, meta_any value) {
     // this abomination is necessary because only on macos value_type and const_reference are different types for std::vector<bool>
     if(const auto vtype = value_type_node(internal::meta_context::from(*ctx)); !const_only && (value.allow_cast({*ctx, vtype}) || value.allow_cast({*ctx, const_reference_node(internal::meta_context::from(*ctx))}))) {
         const bool is_value_type = (value.type().info() == *vtype.info);
         return insert_fn(*ctx, const_cast<void *>(data), is_value_type ? std::as_const(value).data() : nullptr, is_value_type ? nullptr : std::as_const(value).data(), it);
     }
 
-    return iterator{*ctx};
+    return iterator{};
 }
 
 /**
@@ -66316,13 +68906,12 @@ inline meta_sequence_container::iterator meta_sequence_container::insert(iterato
  * @param it Iterator to the element to remove.
  * @return A possibly invalid iterator following the last removed element.
  */
-inline meta_sequence_container::iterator meta_sequence_container::erase(iterator it) {
-    return const_only ? iterator{*ctx} : erase_fn(*ctx, const_cast<void *>(data), it);
+inline meta_sequence_container::iterator meta_sequence_container::erase(const iterator &it) {
+    return const_only ? iterator{} : erase_fn(*ctx, const_cast<void *>(data), it);
 }
 
 /**
- * @brief Returns a reference to the element at a given location of a container
- * (no bounds checking is performed).
+ * @brief Returns a reference to the element at a given location of a container.
  * @param pos The position of the element to return.
  * @return A reference to the requested element properly wrapped.
  */
@@ -66340,20 +68929,12 @@ inline meta_sequence_container::iterator meta_sequence_container::erase(iterator
     return (data != nullptr);
 }
 
-/**
- * @brief Returns true if a container is also key-only, false otherwise.
- * @return True if the associative container is also key-only, false otherwise.
- */
-[[deprecated("use mapped_type() instead")]] [[nodiscard]] inline bool meta_associative_container::key_only() const noexcept {
-    return (mapped_type_node == nullptr);
-}
-
 /**
  * @brief Returns the meta key type of a container.
  * @return The meta key type of the a container.
  */
 [[nodiscard]] inline meta_type meta_associative_container::key_type() const noexcept {
-    return key_type_node ? meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (key_type_node != nullptr) ? meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /**
@@ -66361,12 +68942,12 @@ inline meta_sequence_container::iterator meta_sequence_container::erase(iterator
  * @return The meta mapped type of the a container.
  */
 [[nodiscard]] inline meta_type meta_associative_container::mapped_type() const noexcept {
-    return mapped_type_node ? meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (mapped_type_node != nullptr) ? meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /*! @copydoc meta_sequence_container::value_type */
 [[nodiscard]] inline meta_type meta_associative_container::value_type() const noexcept {
-    return value_type_node ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
+    return (value_type_node != nullptr) ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
 }
 
 /*! @copydoc meta_sequence_container::size */
@@ -66402,7 +68983,7 @@ inline bool meta_associative_container::reserve(const size_type sz) {
  */
 inline bool meta_associative_container::insert(meta_any key, meta_any value = {}) {
     return !const_only && key.allow_cast(meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))})
-           && (!mapped_type_node || value.allow_cast(meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))}))
+           && ((mapped_type_node == nullptr) || value.allow_cast(meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))}))
            && insert_fn(const_cast<void *>(data), std::as_const(key).data(), std::as_const(value).data());
 }
 
@@ -66421,7 +69002,7 @@ inline meta_associative_container::size_type meta_associative_container::erase(m
  * @return An iterator to the element with the given key, if any.
  */
 [[nodiscard]] inline meta_associative_container::iterator meta_associative_container::find(meta_any key) {
-    return key.allow_cast(meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))}) ? find_fn(*ctx, const_only ? nullptr : const_cast<void *>(data), data, std::as_const(key).data()) : iterator{*ctx};
+    return key.allow_cast(meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))}) ? find_fn(*ctx, const_only ? nullptr : const_cast<void *>(data), data, std::as_const(key).data()) : iterator{};
 }
 
 /**
@@ -66444,12 +69025,13 @@ inline meta_associative_container::size_type meta_associative_container::erase(m
 #include <memory>
 #include <type_traits>
 #include <utility>
+#include <vector>
 // #include "../config/config.h"
 
-// #include "../container/dense_map.hpp"
-
 // #include "../core/attribute.h"
 
+// #include "../core/bit.hpp"
+
 // #include "../core/enum.hpp"
 
 // #include "../core/fwd.hpp"
@@ -66484,31 +69066,58 @@ enum class meta_traits : std::uint32_t {
     is_array = 0x0020,
     is_enum = 0x0040,
     is_class = 0x0080,
-    is_meta_pointer_like = 0x0100,
-    is_meta_sequence_container = 0x0200,
-    is_meta_associative_container = 0x0400,
-    _entt_enum_as_bitmask
+    is_pointer = 0x0100,
+    is_meta_pointer_like = 0x0200,
+    is_meta_sequence_container = 0x0400,
+    is_meta_associative_container = 0x0800,
+    _user_defined_traits = 0xFFFF,
+    _entt_enum_as_bitmask = 0xFFFF
 };
 
+template<typename Type>
+[[nodiscard]] auto meta_to_user_traits(const meta_traits traits) noexcept {
+    static_assert(std::is_enum_v<Type>, "Invalid enum type");
+    constexpr auto shift = popcount(static_cast<std::underlying_type_t<meta_traits>>(meta_traits::_user_defined_traits));
+    return Type{static_cast<std::underlying_type_t<Type>>(static_cast<std::underlying_type_t<meta_traits>>(traits) >> shift)};
+}
+
+template<typename Type>
+[[nodiscard]] auto user_to_meta_traits(const Type value) noexcept {
+    static_assert(std::is_enum_v<Type>, "Invalid enum type");
+    constexpr auto shift = popcount(static_cast<std::underlying_type_t<meta_traits>>(meta_traits::_user_defined_traits));
+    const auto traits = static_cast<std::underlying_type_t<internal::meta_traits>>(static_cast<std::underlying_type_t<Type>>(value));
+    ENTT_ASSERT(traits < ((~static_cast<std::underlying_type_t<meta_traits>>(meta_traits::_user_defined_traits)) >> shift), "Invalid traits");
+    return meta_traits{traits << shift};
+}
+
 struct meta_type_node;
 
+struct meta_custom_node {
+    id_type type{};
+    std::shared_ptr<void> value{};
+};
+
 struct meta_prop_node {
+    id_type id{};
     meta_type_node (*type)(const meta_context &) noexcept {};
     std::shared_ptr<void> value{};
 };
 
 struct meta_base_node {
-    meta_type_node (*type)(const meta_context &) noexcept {};
+    id_type type{};
+    meta_type_node (*resolve)(const meta_context &) noexcept {};
     const void *(*cast)(const void *) noexcept {};
 };
 
 struct meta_conv_node {
+    id_type type{};
     meta_any (*conv)(const meta_ctx &, const void *){};
 };
 
 struct meta_ctor_node {
     using size_type = std::size_t;
 
+    id_type id{};
     size_type arity{0u};
     meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
     meta_any (*invoke)(const meta_ctx &, meta_any *const){};
@@ -66521,42 +69130,46 @@ struct meta_dtor_node {
 struct meta_data_node {
     using size_type = std::size_t;
 
+    id_type id{};
     meta_traits traits{meta_traits::is_none};
     size_type arity{0u};
     meta_type_node (*type)(const meta_context &) noexcept {};
     meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
     bool (*set)(meta_handle, meta_any){};
     meta_any (*get)(const meta_ctx &, meta_handle){};
-    dense_map<id_type, meta_prop_node, identity> prop{};
+    meta_custom_node custom{};
+    std::vector<meta_prop_node> prop{};
 };
 
 struct meta_func_node {
     using size_type = std::size_t;
 
+    id_type id{};
     meta_traits traits{meta_traits::is_none};
     size_type arity{0u};
     meta_type_node (*ret)(const meta_context &) noexcept {};
     meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
     meta_any (*invoke)(const meta_ctx &, meta_handle, meta_any *const){};
     std::shared_ptr<meta_func_node> next{};
-    dense_map<id_type, meta_prop_node, identity> prop{};
+    meta_custom_node custom{};
+    std::vector<meta_prop_node> prop{};
 };
 
 struct meta_template_node {
     using size_type = std::size_t;
 
     size_type arity{0u};
-    meta_type_node (*type)(const meta_context &) noexcept {};
+    meta_type_node (*resolve)(const meta_context &) noexcept {};
     meta_type_node (*arg)(const meta_context &, const size_type) noexcept {};
 };
 
 struct meta_type_descriptor {
-    dense_map<id_type, meta_ctor_node, identity> ctor{};
-    dense_map<id_type, meta_base_node, identity> base{};
-    dense_map<id_type, meta_conv_node, identity> conv{};
-    dense_map<id_type, meta_data_node, identity> data{};
-    dense_map<id_type, meta_func_node, identity> func{};
-    dense_map<id_type, meta_prop_node, identity> prop{};
+    std::vector<meta_ctor_node> ctor{};
+    std::vector<meta_base_node> base{};
+    std::vector<meta_conv_node> conv{};
+    std::vector<meta_data_node> data{};
+    std::vector<meta_func_node> func{};
+    std::vector<meta_prop_node> prop{};
 };
 
 struct meta_type_node {
@@ -66573,24 +69186,43 @@ struct meta_type_node {
     meta_any (*from_void)(const meta_ctx &, void *, const void *){};
     meta_template_node templ{};
     meta_dtor_node dtor{};
+    meta_custom_node custom{};
     std::shared_ptr<meta_type_descriptor> details{};
 };
 
+template<auto Member, typename Type, typename Value>
+[[nodiscard]] auto *find_member(Type &from, const Value value) {
+    for(auto &&elem: from) {
+        if((elem.*Member) == value) {
+            return &elem;
+        }
+    }
+
+    return static_cast<typename Type::value_type *>(nullptr);
+}
+
+[[nodiscard]] inline auto *find_overload(meta_func_node *curr, std::remove_pointer_t<decltype(meta_func_node::invoke)> *const ref) {
+    while((curr != nullptr) && (curr->invoke != ref)) { curr = curr->next.get(); }
+    return curr;
+}
+
 template<auto Member>
-auto *look_for(const meta_context &context, const meta_type_node &node, const id_type id) {
+[[nodiscard]] auto *look_for(const meta_context &context, const meta_type_node &node, const id_type id) {
+    using value_type = typename std::remove_reference_t<decltype((node.details.get()->*Member))>::value_type;
+
     if(node.details) {
-        if(const auto it = (node.details.get()->*Member).find(id); it != (node.details.get()->*Member).cend()) {
-            return &it->second;
+        if(auto *member = find_member<&value_type::id>((node.details.get()->*Member), id); member != nullptr) {
+            return member;
         }
 
         for(auto &&curr: node.details->base) {
-            if(auto *elem = look_for<Member>(context, curr.second.type(context), id); elem) {
+            if(auto *elem = look_for<Member>(context, curr.resolve(context), id); elem) {
                 return elem;
             }
         }
     }
 
-    return static_cast<typename std::remove_reference_t<decltype(node.details.get()->*Member)>::mapped_type *>(nullptr);
+    return static_cast<value_type *>(nullptr);
 }
 
 template<typename Type>
@@ -66606,13 +69238,13 @@ template<typename... Args>
 }
 
 [[nodiscard]] inline const void *try_cast(const meta_context &context, const meta_type_node &from, const meta_type_node &to, const void *instance) noexcept {
-    if(from.info && to.info && *from.info == *to.info) {
+    if((from.info != nullptr) && (to.info != nullptr) && *from.info == *to.info) {
         return instance;
     }
 
     if(from.details) {
         for(auto &&curr: from.details->base) {
-            if(const void *elem = try_cast(context, curr.second.type(context), to, curr.second.cast(instance)); elem) {
+            if(const void *elem = try_cast(context, curr.resolve(context), to, curr.cast(instance)); elem) {
                 return elem;
             }
         }
@@ -66628,12 +69260,14 @@ template<typename Func>
     }
 
     if(from.details) {
-        if(auto it = from.details->conv.find(to.hash()); it != from.details->conv.cend()) {
-            return func(instance, it->second);
+        for(auto &&elem: from.details->conv) {
+            if(elem.type == to.hash()) {
+                return func(instance, elem);
+            }
         }
 
         for(auto &&curr: from.details->base) {
-            if(auto other = try_convert(context, curr.second.type(context), to, arithmetic_or_enum, curr.second.cast(instance), func); other) {
+            if(auto other = try_convert(context, curr.resolve(context), to, arithmetic_or_enum, curr.cast(instance), func); other) {
                 return other;
             }
         }
@@ -66668,6 +69302,7 @@ template<typename Type>
             | (std::is_array_v<Type> ? meta_traits::is_array : meta_traits::is_none)
             | (std::is_enum_v<Type> ? meta_traits::is_enum : meta_traits::is_none)
             | (std::is_class_v<Type> ? meta_traits::is_class : meta_traits::is_none)
+            | (std::is_pointer_v<Type> ? meta_traits::is_pointer : meta_traits::is_none)
             | (is_meta_pointer_like_v<Type> ? meta_traits::is_meta_pointer_like : meta_traits::is_none)
             | (is_complete_v<meta_sequence_container_traits<Type>> ? meta_traits::is_meta_sequence_container : meta_traits::is_none)
             | (is_complete_v<meta_associative_container_traits<Type>> ? meta_traits::is_meta_associative_container : meta_traits::is_none),
@@ -66682,22 +69317,22 @@ template<typename Type>
     }
 
     if constexpr(std::is_arithmetic_v<Type>) {
-        node.conversion_helper = +[](void *bin, const void *value) {
-            return bin ? static_cast<double>(*static_cast<Type *>(bin) = static_cast<Type>(*static_cast<const double *>(value))) : static_cast<double>(*static_cast<const Type *>(value));
+        node.conversion_helper = +[](void *lhs, const void *rhs) {
+            return lhs ? static_cast<double>(*static_cast<Type *>(lhs) = static_cast<Type>(*static_cast<const double *>(rhs))) : static_cast<double>(*static_cast<const Type *>(rhs));
         };
     } else if constexpr(std::is_enum_v<Type>) {
-        node.conversion_helper = +[](void *bin, const void *value) {
-            return bin ? static_cast<double>(*static_cast<Type *>(bin) = static_cast<Type>(static_cast<std::underlying_type_t<Type>>(*static_cast<const double *>(value)))) : static_cast<double>(*static_cast<const Type *>(value));
+        node.conversion_helper = +[](void *lhs, const void *rhs) {
+            return lhs ? static_cast<double>(*static_cast<Type *>(lhs) = static_cast<Type>(static_cast<std::underlying_type_t<Type>>(*static_cast<const double *>(rhs)))) : static_cast<double>(*static_cast<const Type *>(rhs));
         };
     }
 
     if constexpr(!std::is_void_v<Type> && !std::is_function_v<Type>) {
-        node.from_void = +[](const meta_ctx &ctx, void *element, const void *as_const) {
-            if(element) {
-                return meta_any{ctx, std::in_place_type<std::decay_t<Type> &>, *static_cast<std::decay_t<Type> *>(element)};
+        node.from_void = +[](const meta_ctx &ctx, void *elem, const void *celem) {
+            if(elem) {
+                return meta_any{ctx, std::in_place_type<std::decay_t<Type> &>, *static_cast<std::decay_t<Type> *>(elem)};
             }
 
-            return meta_any{ctx, std::in_place_type<const std::decay_t<Type> &>, *static_cast<const std::decay_t<Type> *>(as_const)};
+            return meta_any{ctx, std::in_place_type<const std::decay_t<Type> &>, *static_cast<const std::decay_t<Type> *>(celem)};
         };
     }
 
@@ -66719,6 +69354,8 @@ template<typename Type>
 #endif
 
 // #include "meta/pointer.hpp"
+// IWYU pragma: always_keep
+
 #ifndef ENTT_META_POINTER_HPP
 #define ENTT_META_POINTER_HPP
 
@@ -66743,6 +69380,7 @@ struct is_meta_pointer_like<Type *>
  * @tparam N Number of elements of the array.
  */
 template<typename Type, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 struct is_meta_pointer_like<Type (*)[N]>
     : std::false_type {};
 
@@ -66848,12 +69486,14 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
+struct meta_base_node;
+
 template<typename Type, typename It>
 struct meta_range_iterator final {
-    using difference_type = std::ptrdiff_t;
     using value_type = std::pair<id_type, Type>;
     using pointer = input_iterator_pointer<value_type>;
     using reference = value_type;
+    using difference_type = std::ptrdiff_t;
     using iterator_category = std::input_iterator_tag;
     using iterator_concept = std::random_access_iterator_tag;
 
@@ -66902,7 +69542,13 @@ struct meta_range_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
-        return {it[value].first, Type{*ctx, it[value].second}};
+        if constexpr(std::is_same_v<It, typename decltype(meta_context::value)::const_iterator>) {
+            return {it[value].first, Type{*ctx, it[value].second}};
+        } else if constexpr(std::is_same_v<typename std::iterator_traits<It>::value_type, meta_base_node>) {
+            return {it[value].type, Type{*ctx, it[value]}};
+        } else {
+            return {it[value].id, Type{*ctx, it[value]}};
+        }
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
@@ -66910,7 +69556,7 @@ struct meta_range_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->first, Type{*ctx, it->second}};
+        return operator[](0);
     }
 
     template<typename... Args>
@@ -67071,7 +69717,7 @@ template<typename Type>
 [[nodiscard]] inline meta_type resolve(const meta_ctx &ctx, const type_info &info) noexcept {
     auto &&context = internal::meta_context::from(ctx);
     const auto *elem = internal::try_resolve(context, info);
-    return elem ? meta_type{ctx, *elem} : meta_type{};
+    return (elem != nullptr) ? meta_type{ctx, *elem} : meta_type{};
 }
 
 /**
@@ -67088,6 +69734,8 @@ template<typename Type>
 #endif
 
 // #include "meta/template.hpp"
+// IWYU pragma: always_keep
+
 #ifndef ENTT_META_TEMPLATE_HPP
 #define ENTT_META_TEMPLATE_HPP
 
@@ -67310,7 +69958,7 @@ class meta_function_helper {
     template<typename Ret, typename... Args, typename Class>
     static constexpr meta_function_descriptor<Type, Ret (Class::*)(Args...)> get_rid_of_noexcept(Ret (Class::*)(Args...));
 
-    template<typename Ret, typename Class>
+    template<typename Ret, typename Class, typename = std::enable_if_t<std::is_member_object_pointer_v<Ret Class::*>>>
     static constexpr meta_function_descriptor<Type, Ret Class::*> get_rid_of_noexcept(Ret Class::*);
 
     template<typename Ret, typename... Args>
@@ -67508,15 +70156,16 @@ template<typename Policy, typename Candidate, typename... Args>
 }
 
 template<typename Type, typename Policy, typename Candidate, std::size_t... Index>
-[[nodiscard]] meta_any meta_invoke(const meta_ctx &ctx, [[maybe_unused]] meta_handle instance, Candidate &&candidate, [[maybe_unused]] meta_any *args, std::index_sequence<Index...>) {
+[[nodiscard]] meta_any meta_invoke(const meta_ctx &ctx, [[maybe_unused]] meta_handle instance, Candidate &&candidate, [[maybe_unused]] meta_any *const args, std::index_sequence<Index...>) {
     using descriptor = meta_function_helper_t<Type, std::remove_reference_t<Candidate>>;
 
+    // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
     if constexpr(std::is_invocable_v<std::remove_reference_t<Candidate>, const Type &, type_list_element_t<Index, typename descriptor::args_type>...>) {
         if(const auto *const clazz = instance->try_cast<const Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
             return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), *clazz, (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
         }
     } else if constexpr(std::is_invocable_v<std::remove_reference_t<Candidate>, Type &, type_list_element_t<Index, typename descriptor::args_type>...>) {
-        if(auto *const clazz = instance->try_cast<Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) { // NOLINT
+        if(auto *const clazz = instance->try_cast<Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
             return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), *clazz, (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
         }
     } else {
@@ -67524,15 +70173,18 @@ template<typename Type, typename Policy, typename Candidate, std::size_t... Inde
             return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
         }
     }
+    // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
     return meta_any{meta_ctx_arg, ctx};
 }
 
 template<typename Type, typename... Args, std::size_t... Index>
 [[nodiscard]] meta_any meta_construct(const meta_ctx &ctx, meta_any *const args, std::index_sequence<Index...>) {
+    // NOLINTBEGIN(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
     if(((args + Index)->allow_cast<Args>() && ...)) {
         return meta_any{ctx, std::in_place_type<Type>, (args + Index)->cast<Args>()...};
     }
+    // NOLINTEND(cppcoreguidelines-pro-bounds-pointer-arithmetic)
 
     return meta_any{meta_ctx_arg, ctx};
 }
@@ -67660,6 +70312,7 @@ template<typename Type, typename Policy = as_is_t, typename Candidate>
     if constexpr(meta_function_helper_t<Type, Candidate>::is_static || std::is_class_v<std::remove_cv_t<std::remove_reference_t<Candidate>>>) {
         return internal::meta_invoke<Type, Policy>(ctx, {}, std::forward<Candidate>(candidate), args, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
     } else {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic) - waiting for C++20 (and std::span)
         return internal::meta_invoke<Type, Policy>(ctx, *args, std::forward<Candidate>(candidate), args + 1u, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
     }
 }
@@ -67714,67 +70367,6 @@ template<typename Type, auto Candidate, typename Policy = as_is_t>
 
 #endif
 
-// #include "platform/android-ndk-r17.hpp"
-#ifndef ENTT_PLATFORM_ANDROID_NDK_R17_HPP
-#define ENTT_PLATFORM_ANDROID_NDK_R17_HPP
-
-/*! @cond TURN_OFF_DOXYGEN */
-#ifdef __ANDROID__
-#    include <android/ndk-version.h>
-#    if __NDK_MAJOR__ == 17
-
-#        include <functional>
-#        include <type_traits>
-#        include <utility>
-
-namespace std {
-
-namespace internal {
-
-template<typename Func, typename... Args>
-constexpr auto is_invocable(int) -> decltype(std::invoke(std::declval<Func>(), std::declval<Args>()...), std::true_type{});
-
-template<typename, typename...>
-constexpr std::false_type is_invocable(...);
-
-template<typename Ret, typename Func, typename... Args>
-constexpr auto is_invocable_r(int)
--> std::enable_if_t<decltype(std::is_convertible_v<decltype(std::invoke(std::declval<Func>(), std::declval<Args>()...)), Ret>, std::true_type>;
-
-
-template<typename, typename, typename...>
-constexpr std::false_type is_invocable_r(...);
-
-} // namespace internal
-
-template<typename Func, typename... Args>
-struct is_invocable: decltype(internal::is_invocable<Func, Args...>(0)) {};
-
-template<typename Func, typename... Argsv>
-inline constexpr bool is_invocable_v = std::is_invocable<Func, Args...>::value;
-
-template<typename Ret, typename Func, typename... Args>
-struct is_invocable_r: decltype(internal::is_invocable_r<Ret, Func, Args...>(0)) {};
-
-template<typename Ret, typename Func, typename... Args>
-inline constexpr bool is_invocable_r_v = std::is_invocable_r<Ret, Func, Args...>::value;
-
-template<typename Func, typename... Args>
-struct invoke_result {
-    using type = decltype(std::invoke(std::declval<Func>(), std::declval<Args>()...));
-};
-
-template<typename Func, typename... Args>
-using invoke_result_t = typename std::invoke_result<Func, Args...>::type;
-
-} // namespace std
-
-#    endif
-#endif
-/*! @endcond */
-
-#endif
-
 // #include "poly/poly.hpp"
 #ifndef ENTT_POLY_POLY_HPP
 #define ENTT_POLY_POLY_HPP
@@ -67804,23 +70396,33 @@ using invoke_result_t = typename std::invoke_result<Func, Args...>::type;
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -67860,7 +70462,7 @@ using invoke_result_t = typename std::invoke_result<Func, Args...>::type;
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -67878,6 +70480,12 @@ using invoke_result_t = typename std::invoke_result<Func, Args...>::type;
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -67900,6 +70508,8 @@ using invoke_result_t = typename std::invoke_result<Func, Args...>::type;
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/utility.hpp"
@@ -68015,6 +70625,7 @@ struct y_combinator {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -68024,6 +70635,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -68077,6 +70703,7 @@ using any = basic_any<>;
 
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 // #include "fwd.hpp"
 
 
@@ -68085,21 +70712,19 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename>
-struct fnv1a_traits;
+template<typename = id_type>
+struct fnv_1a_params;
 
 template<>
-struct fnv1a_traits<std::uint32_t> {
-    using type = std::uint32_t;
-    static constexpr std::uint32_t offset = 2166136261;
-    static constexpr std::uint32_t prime = 16777619;
+struct fnv_1a_params<std::uint32_t> {
+    static constexpr auto offset = 2166136261;
+    static constexpr auto prime = 16777619;
 };
 
 template<>
-struct fnv1a_traits<std::uint64_t> {
-    using type = std::uint64_t;
-    static constexpr std::uint64_t offset = 14695981039346656037ull;
-    static constexpr std::uint64_t prime = 1099511628211ull;
+struct fnv_1a_params<std::uint64_t> {
+    static constexpr auto offset = 14695981039346656037ull;
+    static constexpr auto prime = 1099511628211ull;
 };
 
 template<typename Char>
@@ -68134,7 +70759,7 @@ struct basic_hashed_string {
 template<typename Char>
 class basic_hashed_string: internal::basic_hashed_string<Char> {
     using base_type = internal::basic_hashed_string<Char>;
-    using traits_type = internal::fnv1a_traits<id_type>;
+    using params = internal::fnv_1a_params<>;
 
     struct const_wrapper {
         // non-explicit constructor on purpose
@@ -68145,22 +70770,11 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
     };
 
     // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
-        base_type base{str, 0u, traits_type::offset};
+    [[nodiscard]] static constexpr auto helper(const std::basic_string_view<Char> view) noexcept {
+        base_type base{view.data(), view.size(), params::offset};
 
-        for(; str[base.length]; ++base.length) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
-        }
-
-        return base;
-    }
-
-    // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
-        base_type base{str, len, traits_type::offset};
-
-        for(size_type pos{}; pos < len; ++pos) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
+        for(auto &&curr: view) {
+            base.hash = (base.hash ^ static_cast<id_type>(curr)) * params::prime;
         }
 
         return base;
@@ -68191,6 +70805,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @return The numeric representation of the string.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
         return basic_hashed_string{str};
     }
@@ -68206,7 +70821,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
 
     /*! @brief Constructs an empty hashed string. */
     constexpr basic_hashed_string() noexcept
-        : base_type{} {}
+        : basic_hashed_string{nullptr, 0u} {}
 
     /**
      * @brief Constructs a hashed string from a string view.
@@ -68214,7 +70829,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param len Length of the string to hash.
      */
     constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
-        : base_type{helper(str, len)} {}
+        : base_type{helper({str, len})} {}
 
     /**
      * @brief Constructs a hashed string from an array of const characters.
@@ -68222,8 +70837,9 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param str Human-readable identifier.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
-        : base_type{helper(str)} {}
+        : base_type{helper({static_cast<const value_type *>(str)})} {}
 
     /**
      * @brief Explicit constructor on purpose to avoid constructing a hashed
@@ -68235,14 +70851,14 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param wrapper Helps achieving the purpose by relying on overloading.
      */
     explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
-        : base_type{helper(wrapper.repr)} {}
+        : base_type{helper({wrapper.repr})} {}
 
     /**
      * @brief Returns the size a hashed string.
      * @return The size of the hashed string.
      */
     [[nodiscard]] constexpr size_type size() const noexcept {
-        return base_type::length; // NOLINT
+        return base_type::length;
     }
 
     /**
@@ -68282,7 +70898,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
  * @param len Length of the string to hash.
  */
 template<typename Char>
-basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;
+basic_hashed_string(const Char *str, std::size_t len) -> basic_hashed_string<Char>;
 
 /**
  * @brief Deduction guide.
@@ -68291,6 +70907,7 @@ basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_stri
  * @param str Human-readable identifier.
  */
 template<typename Char, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;
 
 /**
@@ -68368,12 +70985,6 @@ template<typename Char>
     return !(lhs < rhs);
 }
 
-/*! @brief Aliases for common character types. */
-using hashed_string = basic_hashed_string<char>;
-
-/*! @brief Aliases for common character types. */
-using hashed_wstring = basic_hashed_string<wchar_t>;
-
 inline namespace literals {
 
 /**
@@ -68416,7 +71027,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -68528,10 +71139,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -68589,7 +71202,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -68600,7 +71213,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -68611,7 +71224,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -68622,7 +71235,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -69236,7 +71849,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -69244,12 +71857,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -69434,14 +72044,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -69455,6 +72062,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -69535,9 +72143,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -69553,8 +72161,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -69622,66 +72233,67 @@ class basic_any {
     using vtable_type = const void *(const operation, const basic_any &, const void *);
 
     struct storage_type {
-        alignas(Align) std::byte data[Len + !Len];
+        // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
+        alignas(Align) std::byte data[Len + static_cast<std::size_t>(Len == 0u)];
     };
 
     template<typename Type>
-    static constexpr bool in_situ = Len && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
+    static constexpr bool in_situ = (Len != 0u) && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;
 
     template<typename Type>
     static const void *basic_vtable(const operation op, const basic_any &value, const void *other) {
         static_assert(!std::is_void_v<Type> && std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");
-        const Type *element = nullptr;
+        const Type *elem = nullptr;
 
         if constexpr(in_situ<Type>) {
-            element = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
+            elem = (value.mode == any_policy::owner) ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
         } else {
-            element = static_cast<const Type *>(value.instance);
+            elem = static_cast<const Type *>(value.instance);
         }
 
         switch(op) {
         case operation::copy:
             if constexpr(std::is_copy_constructible_v<Type>) {
-                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*element);
+                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*elem);
             }
             break;
         case operation::move:
             if constexpr(in_situ<Type>) {
                 if(value.mode == any_policy::owner) {
-                    return new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(element))};
+                    return ::new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(elem))};
                 }
             }
 
             return (static_cast<basic_any *>(const_cast<void *>(other))->instance = std::exchange(const_cast<basic_any &>(value).instance, nullptr));
         case operation::transfer:
             if constexpr(std::is_move_assignable_v<Type>) {
-                *const_cast<Type *>(element) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
+                *const_cast<Type *>(elem) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
                 return other;
             }
             [[fallthrough]];
         case operation::assign:
             if constexpr(std::is_copy_assignable_v<Type>) {
-                *const_cast<Type *>(element) = *static_cast<const Type *>(other);
+                *const_cast<Type *>(elem) = *static_cast<const Type *>(other);
                 return other;
             }
             break;
         case operation::destroy:
             if constexpr(in_situ<Type>) {
-                element->~Type();
+                elem->~Type();
             } else if constexpr(std::is_array_v<Type>) {
-                delete[] element;
+                delete[] elem;
             } else {
-                delete element;
+                delete elem;
             }
             break;
         case operation::compare:
             if constexpr(!std::is_function_v<Type> && !std::is_array_v<Type> && is_equality_comparable_v<Type>) {
-                return *element == *static_cast<const Type *>(other) ? other : nullptr;
+                return *elem == *static_cast<const Type *>(other) ? other : nullptr;
             } else {
-                return (element == other) ? other : nullptr;
+                return (elem == other) ? other : nullptr;
             }
         case operation::get:
-            return element;
+            return elem;
         }
 
         return nullptr;
@@ -69689,26 +72301,31 @@ class basic_any {
 
     template<typename Type, typename... Args>
     void initialize([[maybe_unused]] Args &&...args) {
-        info = &type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
+        using plain_type = std::remove_cv_t<std::remove_reference_t<Type>>;
+        info = &type_id<plain_type>();
 
         if constexpr(!std::is_void_v<Type>) {
-            vtable = basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>;
+            vtable = basic_vtable<plain_type>;
 
             if constexpr(std::is_lvalue_reference_v<Type>) {
                 static_assert((std::is_lvalue_reference_v<Args> && ...) && (sizeof...(Args) == 1u), "Invalid arguments");
                 mode = std::is_const_v<std::remove_reference_t<Type>> ? any_policy::cref : any_policy::ref;
                 instance = (std::addressof(args), ...);
-            } else if constexpr(in_situ<std::remove_cv_t<std::remove_reference_t<Type>>>) {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
+            } else if constexpr(in_situ<plain_type>) {
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    ::new(&storage) plain_type{std::forward<Args>(args)...};
                 } else {
-                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
+                    // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
+                    ::new(&storage) plain_type(std::forward<Args>(args)...);
                 }
             } else {
-                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
+                if constexpr(std::is_aggregate_v<plain_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<plain_type>)) {
+                    instance = new plain_type{std::forward<Args>(args)...};
+                } else if constexpr(std::is_array_v<plain_type>) {
+                    static_assert(sizeof...(Args) == 0u, "Invalid arguments");
+                    instance = new plain_type[std::extent_v<plain_type>]();
                 } else {
-                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
+                    instance = new plain_type(std::forward<Args>(args)...);
                 }
             }
         }
@@ -69792,10 +72409,12 @@ class basic_any {
      * @return This any object.
      */
     basic_any &operator=(const basic_any &other) {
-        reset();
+        if(this != &other) {
+            reset();
 
-        if(other.vtable) {
-            other.vtable(operation::copy, other, this);
+            if(other.vtable) {
+                other.vtable(operation::copy, other, this);
+            }
         }
 
         return *this;
@@ -69807,6 +72426,8 @@ class basic_any {
      * @return This any object.
      */
     basic_any &operator=(basic_any &&other) noexcept {
+        ENTT_ASSERT(this != &other, "Self move assignment");
+
         reset();
 
         if(other.vtable) {
@@ -69825,9 +72446,8 @@ class basic_any {
      * @param value An instance of an object to use to initialize the wrapper.
      * @return This any object.
      */
-    template<typename Type>
-    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>, basic_any &>
-    operator=(Type &&value) {
+    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
+    basic_any &operator=(Type &&value) {
         emplace<std::decay_t<Type>>(std::forward<Type>(value));
         return *this;
     }
@@ -69904,9 +72524,9 @@ class basic_any {
         if(vtable && mode != any_policy::cref && *info == *other.info) {
             if(auto *val = other.data(); val) {
                 return (vtable(operation::transfer, *this, val) != nullptr);
-            } else {
-                return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
             }
+
+            return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
         }
 
         return false;
@@ -69968,14 +72588,6 @@ class basic_any {
         return basic_any{*this, any_policy::cref};
     }
 
-    /**
-     * @brief Returns true if a wrapper owns its object, false otherwise.
-     * @return True if the wrapper owns its object, false otherwise.
-     */
-    [[deprecated("use policy() and any_policy instead")]] [[nodiscard]] bool owner() const noexcept {
-        return (mode == any_policy::owner);
-    }
-
     /**
      * @brief Returns the current mode of an any object.
      * @return The current mode of the any object.
@@ -70003,7 +72615,7 @@ class basic_any {
  * @return The element converted to the requested type.
  */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(const basic_any<Len, Align> &data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(const basic_any<Len, Align> &data) noexcept {
     const auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
     ENTT_ASSERT(instance, "Invalid instance");
     return static_cast<Type>(*instance);
@@ -70011,7 +72623,7 @@ template<typename Type, std::size_t Len, std::size_t Align>
 
 /*! @copydoc any_cast */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &data) noexcept {
     // forces const on non-reference types to make them work also with wrappers for const references
     auto *const instance = any_cast<std::remove_reference_t<const Type>>(&data);
     ENTT_ASSERT(instance, "Invalid instance");
@@ -70020,13 +72632,13 @@ template<typename Type, std::size_t Len, std::size_t Align>
 
 /*! @copydoc any_cast */
 template<typename Type, std::size_t Len, std::size_t Align>
-[[nodiscard]] Type any_cast(basic_any<Len, Align> &&data) noexcept {
+[[nodiscard]] std::remove_const_t<Type> any_cast(basic_any<Len, Align> &&data) noexcept {
     if constexpr(std::is_copy_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>) {
         if(auto *const instance = any_cast<std::remove_reference_t<Type>>(&data); instance) {
             return static_cast<Type>(std::move(*instance));
-        } else {
-            return any_cast<Type>(data);
         }
+
+        return any_cast<Type>(data);
     } else {
         auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
         ENTT_ASSERT(instance, "Invalid instance");
@@ -70115,7 +72727,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -70227,10 +72839,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -70288,7 +72902,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -70299,7 +72913,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -70310,7 +72924,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -70321,7 +72935,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -70935,7 +73549,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -70943,12 +73557,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -71133,14 +73744,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -71154,6 +73762,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -71234,9 +73843,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -71252,8 +73861,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -71289,6 +73901,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<typename, std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_poly;
 
@@ -71323,11 +73936,11 @@ struct poly_inspector {
      * @return A poly inspector convertible to any type.
      */
     template<std::size_t Member, typename... Args>
-    poly_inspector invoke(Args &&...args) const;
+    [[nodiscard]] poly_inspector invoke(Args &&...args) const;
 
     /*! @copydoc invoke */
     template<std::size_t Member, typename... Args>
-    poly_inspector invoke(Args &&...args);
+    [[nodiscard]] poly_inspector invoke(Args &&...args);
 };
 
 /**
@@ -71340,20 +73953,21 @@ template<typename Concept, std::size_t Len, std::size_t Align>
 class poly_vtable {
     using inspector = typename Concept::template type<poly_inspector>;
 
-    template<typename Ret, typename... Args>
-    static auto vtable_entry(Ret (*)(inspector &, Args...)) -> Ret (*)(basic_any<Len, Align> &, Args...);
+    template<typename Ret, typename Clazz, typename... Args>
+    static auto vtable_entry(Ret (*)(Clazz &, Args...))
+        -> std::enable_if_t<std::is_base_of_v<std::remove_const_t<Clazz>, inspector>, Ret (*)(constness_as_t<basic_any<Len, Align>, Clazz> &, Args...)>;
 
     template<typename Ret, typename... Args>
-    static auto vtable_entry(Ret (*)(const inspector &, Args...)) -> Ret (*)(const basic_any<Len, Align> &, Args...);
+    static auto vtable_entry(Ret (*)(Args...))
+        -> Ret (*)(const basic_any<Len, Align> &, Args...);
 
-    template<typename Ret, typename... Args>
-    static auto vtable_entry(Ret (*)(Args...)) -> Ret (*)(const basic_any<Len, Align> &, Args...);
-
-    template<typename Ret, typename... Args>
-    static auto vtable_entry(Ret (inspector::*)(Args...)) -> Ret (*)(basic_any<Len, Align> &, Args...);
+    template<typename Ret, typename Clazz, typename... Args>
+    static auto vtable_entry(Ret (Clazz::*)(Args...))
+        -> std::enable_if_t<std::is_base_of_v<Clazz, inspector>, Ret (*)(basic_any<Len, Align> &, Args...)>;
 
-    template<typename Ret, typename... Args>
-    static auto vtable_entry(Ret (inspector::*)(Args...) const) -> Ret (*)(const basic_any<Len, Align> &, Args...);
+    template<typename Ret, typename Clazz, typename... Args>
+    static auto vtable_entry(Ret (Clazz::*)(Args...) const)
+        -> std::enable_if_t<std::is_base_of_v<Clazz, inspector>, Ret (*)(const basic_any<Len, Align> &, Args...)>;
 
     template<auto... Candidate>
     static auto make_vtable(value_list<Candidate...>) noexcept
@@ -71492,9 +74106,7 @@ class basic_poly: private Concept::template type<poly_base<basic_poly<Concept, L
     using vtable_type = typename poly_vtable<Concept, Len, Align>::type;
 
     /*! @brief Default constructor. */
-    basic_poly() noexcept
-        : storage{},
-          vtable{} {}
+    basic_poly() noexcept = default;
 
     /**
      * @brief Constructs a poly by directly initializing the new object.
@@ -71596,8 +74208,8 @@ class basic_poly: private Concept::template type<poly_base<basic_poly<Concept, L
     }
 
 private:
-    basic_any<Len, Align> storage;
-    vtable_type vtable;
+    basic_any<Len, Align> storage{};
+    vtable_type vtable{};
 };
 
 } // namespace entt
@@ -71738,7 +74350,8 @@ class process {
         static_cast<Target *>(this)->aborted();
     }
 
-    void next(...) const noexcept {}
+    template<typename... Args>
+    void next(Args &&...) const noexcept {}
 
 protected:
     /**
@@ -71793,8 +74406,29 @@ class process {
     /*! @brief Type used to provide elapsed time. */
     using delta_type = Delta;
 
+    /*! @brief Default constructor. */
+    constexpr process() = default;
+
+    /*! @brief Default copy constructor. */
+    process(const process &) = default;
+
+    /*! @brief Default move constructor. */
+    process(process &&) noexcept = default;
+
+    /**
+     * @brief Default copy assignment operator.
+     * @return This process.
+     */
+    process &operator=(const process &) = default;
+
+    /**
+     * @brief Default move assignment operator.
+     * @return This process.
+     */
+    process &operator=(process &&) noexcept = default;
+
     /*! @brief Default destructor. */
-    virtual ~process() noexcept {
+    virtual ~process() {
         static_assert(std::is_base_of_v<process, Derived>, "Incorrect use of the class template");
     }
 
@@ -71980,23 +74614,33 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -72036,7 +74680,7 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -72054,6 +74698,12 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -72076,6 +74726,8 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/compressed_pair.hpp"
@@ -72086,15 +74738,11 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #include <tuple>
 #include <type_traits>
 #include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "fwd.hpp"
+#ifndef ENTT_CORE_FWD_HPP
+#define ENTT_CORE_FWD_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -72107,23 +74755,33 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -72163,7 +74821,7 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -72181,6 +74839,12 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -72203,18 +74867,14 @@ struct process_adaptor: process<process_adaptor<Func, Delta>, Delta>, private Fu
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
-
-// #include "fwd.hpp"
-#ifndef ENTT_CORE_FWD_HPP
-#define ENTT_CORE_FWD_HPP
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-#include <cstddef>
-// #include "../config/config.h"
+#endif
 
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -72224,10 +74884,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -72794,7 +75482,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -72802,12 +75490,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -72992,14 +75677,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -73013,6 +75695,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -73093,9 +75776,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -73111,8 +75794,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -73151,9 +75837,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -73172,7 +75858,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -73181,7 +75867,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -73236,7 +75922,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -73244,13 +75930,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -73260,7 +75946,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -73272,23 +75958,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -73320,7 +76009,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -73333,7 +76022,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -73344,7 +76033,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -73376,8 +76065,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -73400,7 +76087,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -73520,7 +76206,8 @@ class process {
         static_cast<Target *>(this)->aborted();
     }
 
-    void next(...) const noexcept {}
+    template<typename... Args>
+    void next(Args &&...) const noexcept {}
 
 protected:
     /**
@@ -73575,8 +76262,29 @@ class process {
     /*! @brief Type used to provide elapsed time. */
     using delta_type = Delta;
 
+    /*! @brief Default constructor. */
+    constexpr process() = default;
+
+    /*! @brief Default copy constructor. */
+    process(const process &) = default;
+
+    /*! @brief Default move constructor. */
+    process(process &&) noexcept = default;
+
+    /**
+     * @brief Default copy assignment operator.
+     * @return This process.
+     */
+    process &operator=(const process &) = default;
+
+    /**
+     * @brief Default move assignment operator.
+     * @return This process.
+     */
+    process &operator=(process &&) noexcept = default;
+
     /*! @brief Default destructor. */
-    virtual ~process() noexcept {
+    virtual ~process() {
         static_assert(std::is_base_of_v<process, Derived>, "Incorrect use of the class template");
     }
 
@@ -73751,8 +76459,8 @@ template<typename Delta>
 struct basic_process_handler {
     virtual ~basic_process_handler() = default;
 
-    virtual bool update(const Delta, void *) = 0;
-    virtual void abort(const bool) = 0;
+    virtual bool update(Delta, void *) = 0;
+    virtual void abort(bool) = 0;
 
     // std::shared_ptr because of its type erased allocator which is useful here
     std::shared_ptr<basic_process_handler> next;
@@ -73840,6 +76548,9 @@ class basic_scheduler {
     explicit basic_scheduler(const allocator_type &allocator)
         : handlers{allocator, allocator} {}
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_scheduler(const basic_scheduler &) = delete;
+
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
@@ -73852,19 +76563,28 @@ class basic_scheduler {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_scheduler(basic_scheduler &&other, const allocator_type &allocator) noexcept
+    basic_scheduler(basic_scheduler &&other, const allocator_type &allocator)
         : handlers{container_type{std::move(other.handlers.first()), allocator}, allocator} {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || handlers.second() == other.handlers.second(), "Copying a scheduler is not allowed");
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a scheduler is not allowed");
     }
 
+    /*! @brief Default destructor. */
+    ~basic_scheduler() = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This process scheduler.
+     */
+    basic_scheduler &operator=(const basic_scheduler &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
-     * @return This scheduler.
+     * @return This process scheduler.
      */
     basic_scheduler &operator=(basic_scheduler &&other) noexcept {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || handlers.second() == other.handlers.second(), "Copying a scheduler is not allowed");
-        handlers = std::move(other.handlers);
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a scheduler is not allowed");
+        swap(other);
         return *this;
     }
 
@@ -73872,7 +76592,7 @@ class basic_scheduler {
      * @brief Exchanges the contents with those of a given scheduler.
      * @param other Scheduler to exchange the content with.
      */
-    void swap(basic_scheduler &other) {
+    void swap(basic_scheduler &other) noexcept {
         using std::swap;
         swap(handlers, other.handlers);
     }
@@ -74119,23 +76839,33 @@ class basic_scheduler {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -74175,7 +76905,7 @@ class basic_scheduler {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -74193,6 +76923,12 @@ class basic_scheduler {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -74215,25 +76951,17 @@ class basic_scheduler {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+#endif
 
-#include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -74246,23 +76974,33 @@ class basic_scheduler {
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -74302,7 +77040,7 @@ class basic_scheduler {
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -74320,6 +77058,12 @@ class basic_scheduler {
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -74342,8 +77086,81 @@ class basic_scheduler {
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
 #endif
 
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -74354,6 +77171,7 @@ class basic_scheduler {
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -74363,10 +77181,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -74933,7 +77779,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -74941,12 +77787,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -75131,14 +77974,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -75152,6 +77992,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -75232,9 +78073,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -75250,8 +78091,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -75290,9 +78134,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -75311,7 +78155,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -75320,7 +78164,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -75375,7 +78219,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -75383,13 +78227,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -75399,7 +78243,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -75411,23 +78255,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -75459,7 +78306,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -75472,7 +78319,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -75483,7 +78330,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -75515,8 +78362,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -75539,7 +78384,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -75693,7 +78537,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -75702,7 +78546,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -75747,7 +78591,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -75757,44 +78600,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -76021,7 +78826,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -76607,7 +79412,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -76615,12 +79420,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -76805,14 +79607,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -76826,6 +79625,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -76906,9 +79706,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -76924,8 +79724,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -76960,6 +79763,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -76967,17 +79771,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -77087,7 +79901,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -77232,6 +80046,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -77290,7 +80105,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -77306,6 +80121,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -77318,8 +80135,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -77369,8 +80184,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -77388,7 +80202,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -77400,6 +80214,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -77410,7 +80227,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -77642,7 +80459,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -77658,7 +80475,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -77987,7 +80804,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -78012,15 +80829,11 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #include <tuple>
 #include <type_traits>
 #include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "fwd.hpp"
+#ifndef ENTT_CORE_FWD_HPP
+#define ENTT_CORE_FWD_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
-#include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -78033,23 +80846,33 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -78089,7 +80912,7 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -78107,6 +80930,12 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -78129,18 +80958,14 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-// #include "fwd.hpp"
-#ifndef ENTT_CORE_FWD_HPP
-#define ENTT_CORE_FWD_HPP
-
-#include <cstddef>
-// #include "../config/config.h"
+#endif
 
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -78150,10 +80975,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -78720,7 +81573,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -78728,12 +81581,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -78918,14 +81768,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -78939,6 +81786,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -79019,9 +81867,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -79037,8 +81885,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -79077,9 +81928,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -79098,7 +81949,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -79107,7 +81958,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -79162,7 +82013,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -79170,13 +82021,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -79186,7 +82037,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -79198,23 +82049,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -79246,7 +82100,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -79259,7 +82113,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -79270,7 +82124,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -79302,8 +82156,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -79326,7 +82178,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -79340,6 +82191,7 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -79349,6 +82201,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -79503,7 +82370,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -79512,7 +82379,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -79753,8 +82620,8 @@ class resource {
         : value{} {}
 
     /**
-     * @brief Creates a handle from a weak pointer, namely a resource.
-     * @param res A weak pointer to a resource.
+     * @brief Creates a new resource handle.
+     * @param res A handle to a resource.
      */
     explicit resource(handle_type res) noexcept
         : value{std::move(res)} {}
@@ -79793,6 +82660,9 @@ class resource {
     resource(resource<Other> &&other) noexcept
         : value{std::move(other.value)} {}
 
+    /*! @brief Default destructor. */
+    ~resource() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This resource handle.
@@ -79811,9 +82681,8 @@ class resource {
      * @param other The handle to copy from.
      * @return This resource handle.
      */
-    template<typename Other>
-    std::enable_if_t<is_acceptable_v<Other>, resource &>
-    operator=(const resource<Other> &other) noexcept {
+    template<typename Other, typename = std::enable_if_t<is_acceptable_v<Other>>>
+    resource &operator=(const resource<Other> &other) noexcept {
         value = other.value;
         return *this;
     }
@@ -79824,13 +82693,21 @@ class resource {
      * @param other The handle to move from.
      * @return This resource handle.
      */
-    template<typename Other>
-    std::enable_if_t<is_acceptable_v<Other>, resource &>
-    operator=(resource<Other> &&other) noexcept {
+    template<typename Other, typename = std::enable_if_t<is_acceptable_v<Other>>>
+    resource &operator=(resource<Other> &&other) noexcept {
         value = std::move(other.value);
         return *this;
     }
 
+    /**
+     * @brief Exchanges the content with that of a given resource.
+     * @param other Resource to exchange the content with.
+     */
+    void swap(resource &other) noexcept {
+        using std::swap;
+        swap(value, other.value);
+    }
+
     /**
      * @brief Returns a reference to the managed resource.
      *
@@ -79864,6 +82741,19 @@ class resource {
         return static_cast<bool>(value);
     }
 
+    /*! @brief Releases the ownership of the managed resource. */
+    void reset() {
+        value.reset();
+    }
+
+    /**
+     * @brief Replaces the managed resource.
+     * @param other A handle to a resource.
+     */
+    void reset(handle_type other) {
+        value = std::move(other);
+    }
+
     /**
      * @brief Returns the underlying resource handle.
      * @return The underlying resource handle.
@@ -80029,7 +82919,7 @@ class resource_cache_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return (*this)[0];
+        return operator[](0);
     }
 
     [[nodiscard]] constexpr pointer operator->() const noexcept {
@@ -80098,17 +82988,17 @@ class resource_cache {
     using alloc_traits = std::allocator_traits<Allocator>;
     static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
     using container_allocator = typename alloc_traits::template rebind_alloc<std::pair<const id_type, typename Loader::result_type>>;
-    using container_type = dense_map<id_type, typename Loader::result_type, identity, std::equal_to<id_type>, container_allocator>;
+    using container_type = dense_map<id_type, typename Loader::result_type, identity, std::equal_to<>, container_allocator>;
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Resource type. */
     using value_type = Type;
     /*! @brief Unsigned integer type. */
     using size_type = std::size_t;
     /*! @brief Loader type. */
     using loader_type = Loader;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::resource_cache_iterator<Type, typename container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -80145,7 +83035,7 @@ class resource_cache {
         : pool{std::piecewise_construct, std::forward_as_tuple(other.pool.first(), allocator), std::forward_as_tuple(other.pool.second())} {}
 
     /*! @brief Default move constructor. */
-    resource_cache(resource_cache &&) = default;
+    resource_cache(resource_cache &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -80155,6 +83045,9 @@ class resource_cache {
     resource_cache(resource_cache &&other, const allocator_type &allocator)
         : pool{std::piecewise_construct, std::forward_as_tuple(std::move(other.pool.first()), allocator), std::forward_as_tuple(std::move(other.pool.second()))} {}
 
+    /*! @brief Default destructor. */
+    ~resource_cache() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This cache.
@@ -80165,7 +83058,7 @@ class resource_cache {
      * @brief Default move assignment operator.
      * @return This cache.
      */
-    resource_cache &operator=(resource_cache &&) = default;
+    resource_cache &operator=(resource_cache &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -80430,8 +83323,8 @@ class resource {
         : value{} {}
 
     /**
-     * @brief Creates a handle from a weak pointer, namely a resource.
-     * @param res A weak pointer to a resource.
+     * @brief Creates a new resource handle.
+     * @param res A handle to a resource.
      */
     explicit resource(handle_type res) noexcept
         : value{std::move(res)} {}
@@ -80470,6 +83363,9 @@ class resource {
     resource(resource<Other> &&other) noexcept
         : value{std::move(other.value)} {}
 
+    /*! @brief Default destructor. */
+    ~resource() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This resource handle.
@@ -80488,9 +83384,8 @@ class resource {
      * @param other The handle to copy from.
      * @return This resource handle.
      */
-    template<typename Other>
-    std::enable_if_t<is_acceptable_v<Other>, resource &>
-    operator=(const resource<Other> &other) noexcept {
+    template<typename Other, typename = std::enable_if_t<is_acceptable_v<Other>>>
+    resource &operator=(const resource<Other> &other) noexcept {
         value = other.value;
         return *this;
     }
@@ -80501,13 +83396,21 @@ class resource {
      * @param other The handle to move from.
      * @return This resource handle.
      */
-    template<typename Other>
-    std::enable_if_t<is_acceptable_v<Other>, resource &>
-    operator=(resource<Other> &&other) noexcept {
+    template<typename Other, typename = std::enable_if_t<is_acceptable_v<Other>>>
+    resource &operator=(resource<Other> &&other) noexcept {
         value = std::move(other.value);
         return *this;
     }
 
+    /**
+     * @brief Exchanges the content with that of a given resource.
+     * @param other Resource to exchange the content with.
+     */
+    void swap(resource &other) noexcept {
+        using std::swap;
+        swap(value, other.value);
+    }
+
     /**
      * @brief Returns a reference to the managed resource.
      *
@@ -80541,6 +83444,19 @@ class resource {
         return static_cast<bool>(value);
     }
 
+    /*! @brief Releases the ownership of the managed resource. */
+    void reset() {
+        value.reset();
+    }
+
+    /**
+     * @brief Replaces the managed resource.
+     * @param other A handle to a resource.
+     */
+    void reset(handle_type other) {
+        value = std::move(other);
+    }
+
     /**
      * @brief Returns the underlying resource handle.
      * @return The underlying resource handle.
@@ -80658,23 +83574,33 @@ template<typename Lhs, typename Rhs>
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -80714,7 +83640,7 @@ template<typename Lhs, typename Rhs>
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -80732,6 +83658,12 @@ template<typename Lhs, typename Rhs>
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -80754,6 +83686,8 @@ template<typename Lhs, typename Rhs>
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "../core/type_traits.hpp"
@@ -80777,23 +83711,33 @@ template<typename Lhs, typename Rhs>
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -80833,7 +83777,7 @@ template<typename Lhs, typename Rhs>
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -80851,6 +83795,12 @@ template<typename Lhs, typename Rhs>
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -80873,6 +83823,8 @@ template<typename Lhs, typename Rhs>
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 // #include "fwd.hpp"
@@ -80885,6 +83837,7 @@ template<typename Lhs, typename Rhs>
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -80894,6 +83847,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -81464,7 +84432,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -81472,12 +84440,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -81662,14 +84627,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -81683,6 +84645,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -81763,9 +84726,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -81781,8 +84744,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -81876,7 +84842,7 @@ constexpr auto function_pointer(Ret (Class::*)(Args...), Other &&...) -> Ret (*)
 template<typename Class, typename Ret, typename... Args, typename... Other>
 constexpr auto function_pointer(Ret (Class::*)(Args...) const, Other &&...) -> Ret (*)(Args...);
 
-template<typename Class, typename Type, typename... Other>
+template<typename Class, typename Type, typename... Other, typename = std::enable_if_t<std::is_member_object_pointer_v<Type Class::*>>>
 constexpr auto function_pointer(Type Class::*, Other &&...) -> Type (*)();
 
 template<typename... Type>
@@ -81913,47 +84879,35 @@ class delegate;
  */
 template<typename Ret, typename... Args>
 class delegate<Ret(Args...)> {
+    using return_type = std::remove_const_t<Ret>;
+    using delegate_type = return_type(const void *, Args...);
+
     template<auto Candidate, std::size_t... Index>
     [[nodiscard]] auto wrap(std::index_sequence<Index...>) noexcept {
-        return [](const void *, Args... args) -> Ret {
+        return [](const void *, Args... args) -> return_type {
             [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
     template<auto Candidate, typename Type, std::size_t... Index>
     [[nodiscard]] auto wrap(Type &, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+        return [](const void *payload, Args... args) -> return_type {
             Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
     template<auto Candidate, typename Type, std::size_t... Index>
     [[nodiscard]] auto wrap(Type *, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+        return [](const void *payload, Args... args) -> return_type {
             Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
@@ -81966,9 +84920,7 @@ class delegate<Ret(Args...)> {
     using result_type = Ret;
 
     /*! @brief Default constructor. */
-    delegate() noexcept
-        : instance{nullptr},
-          fn{nullptr} {}
+    delegate() noexcept = default;
 
     /**
      * @brief Constructs a delegate with a given object or payload, if any.
@@ -82000,7 +84952,7 @@ class delegate<Ret(Args...)> {
         instance = nullptr;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
-            fn = [](const void *, Args... args) -> Ret {
+            fn = [](const void *, Args... args) -> return_type {
                 return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
             };
         } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
@@ -82030,7 +84982,7 @@ class delegate<Ret(Args...)> {
         instance = &value_or_instance;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
+            fn = [](const void *payload, Args... args) -> return_type {
                 Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                 return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
             };
@@ -82054,7 +85006,7 @@ class delegate<Ret(Args...)> {
         instance = value_or_instance;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
+            fn = [](const void *payload, Args... args) -> return_type {
                 Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                 return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
             };
@@ -82144,8 +85096,8 @@ class delegate<Ret(Args...)> {
     }
 
 private:
-    const void *instance;
-    function_type *fn;
+    const void *instance{};
+    delegate_type *fn{};
 };
 
 /**
@@ -82224,23 +85176,33 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -82280,7 +85242,7 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -82298,6 +85260,12 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -82320,25 +85288,17 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
-#endif
+// NOLINTEND(cppcoreguidelines-macro-usage)
 
-// #include "../core/compressed_pair.hpp"
-#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
-#define ENTT_CORE_COMPRESSED_PAIR_HPP
+#endif
 
-#include <cstddef>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-// #include "type_traits.hpp"
-#ifndef ENTT_CORE_TYPE_TRAITS_HPP
-#define ENTT_CORE_TYPE_TRAITS_HPP
+// #include "../core/bit.hpp"
+#ifndef ENTT_CORE_BIT_HPP
+#define ENTT_CORE_BIT_HPP
 
 #include <cstddef>
-#include <iterator>
-#include <tuple>
+#include <limits>
 #include <type_traits>
-#include <utility>
 // #include "../config/config.h"
 #ifndef ENTT_CONFIG_CONFIG_H
 #define ENTT_CONFIG_CONFIG_H
@@ -82351,23 +85311,33 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #ifndef ENTT_CONFIG_MACRO_H
 #define ENTT_CONFIG_MACRO_H
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_STR(arg) #arg
 #define ENTT_XSTR(arg) ENTT_STR(arg)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #define ENTT_VERSION_MAJOR 3
-#define ENTT_VERSION_MINOR 13
-#define ENTT_VERSION_PATCH 2
+#define ENTT_VERSION_MINOR 14
+#define ENTT_VERSION_PATCH 0
 
 #define ENTT_VERSION \
     ENTT_XSTR(ENTT_VERSION_MAJOR) \
     "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
 #endif
 
 
+// NOLINTBEGIN(cppcoreguidelines-macro-usage)
+
 #if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
 #    define ENTT_CONSTEXPR
 #    define ENTT_THROW throw
@@ -82407,7 +85377,7 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #    define ENTT_ASSERT(condition, msg) (void(0))
 #elif !defined ENTT_ASSERT
 #    include <cassert>
-#    define ENTT_ASSERT(condition, msg) assert(condition)
+#    define ENTT_ASSERT(condition, msg) assert(((condition) && (msg)))
 #endif
 
 #ifdef ENTT_DISABLE_ASSERT
@@ -82425,6 +85395,12 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #    define ENTT_ETO_TYPE(Type) Type
 #endif
 
+#ifdef ENTT_NO_MIXIN
+#    define ENTT_STORAGE(Mixin, ...) __VA_ARGS__
+#else
+#    define ENTT_STORAGE(Mixin, ...) Mixin<__VA_ARGS__>
+#endif
+
 #ifdef ENTT_STANDARD_CPP
 #    define ENTT_NONSTD false
 #else
@@ -82447,8 +85423,81 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 #    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
 #endif
 
+// NOLINTEND(cppcoreguidelines-macro-usage)
+
+#endif
+
+
+namespace entt {
+
+/**
+ * @brief Returns the number of set bits in a value (waiting for C++20 and
+ * `std::popcount`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The number of set bits in the value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, int> popcount(const Type value) noexcept {
+    return value ? (int(value & 1) + popcount(static_cast<Type>(value >> 1))) : 0;
+}
+
+/**
+ * @brief Checks whether a value is a power of two or not (waiting for C++20 and
+ * `std::has_single_bit`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return True if the value is a power of two, false otherwise.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, bool> has_single_bit(const Type value) noexcept {
+    return value && ((value & (value - 1)) == 0);
+}
+
+/**
+ * @brief Computes the smallest power of two greater than or equal to a value
+ * (waiting for C++20 and `std::bit_ceil`).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @return The smallest power of two greater than or equal to the given value.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> next_power_of_two(const Type value) noexcept {
+    ENTT_ASSERT_CONSTEXPR(value < (Type{1u} << (std::numeric_limits<Type>::digits - 1)), "Numeric limits exceeded");
+    Type curr = value - (value != 0u);
+
+    for(int next = 1; next < std::numeric_limits<Type>::digits; next = next * 2) {
+        curr |= (curr >> next);
+    }
+
+    return ++curr;
+}
+
+/**
+ * @brief Fast module utility function (powers of two only).
+ * @tparam Type Unsigned integer type.
+ * @param value A value of unsigned integer type.
+ * @param mod _Modulus_, it must be a power of two.
+ * @return The common remainder.
+ */
+template<typename Type>
+[[nodiscard]] constexpr std::enable_if_t<std::is_unsigned_v<Type>, Type> fast_mod(const Type value, const std::size_t mod) noexcept {
+    ENTT_ASSERT_CONSTEXPR(has_single_bit(mod), "Value must be a power of two");
+    return value & (mod - 1u);
+}
+
+} // namespace entt
+
 #endif
 
+// #include "../core/compressed_pair.hpp"
+#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
+#define ENTT_CORE_COMPRESSED_PAIR_HPP
+
+#include <cstddef>
+#include <tuple>
+#include <type_traits>
+#include <utility>
 // #include "fwd.hpp"
 #ifndef ENTT_CORE_FWD_HPP
 #define ENTT_CORE_FWD_HPP
@@ -82459,6 +85508,7 @@ delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -82468,10 +85518,38 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
 
+// #include "type_traits.hpp"
+#ifndef ENTT_CORE_TYPE_TRAITS_HPP
+#define ENTT_CORE_TYPE_TRAITS_HPP
+
+#include <cstddef>
+#include <iterator>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+// #include "../config/config.h"
+
+// #include "fwd.hpp"
+
 
 namespace entt {
 
@@ -83038,7 +86116,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -83046,12 +86124,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -83236,14 +86311,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -83257,6 +86329,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -83337,9 +86410,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -83355,8 +86428,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -83395,9 +86471,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -83416,7 +86492,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -83425,7 +86501,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -83480,7 +86556,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -83488,13 +86564,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -83504,7 +86580,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -83516,23 +86592,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -83564,7 +86643,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -83577,7 +86656,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -83588,7 +86667,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -83620,8 +86699,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -83644,7 +86721,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -83798,7 +86874,7 @@ struct iterable_adaptor final {
     using sentinel = Sentinel;
 
     /*! @brief Default constructor. */
-    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
+    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> && std::is_nothrow_default_constructible_v<sentinel>)
         : first{},
           last{} {}
 
@@ -83807,7 +86883,7 @@ struct iterable_adaptor final {
      * @param from Begin iterator.
      * @param to End iterator.
      */
-    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
+    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> && std::is_nothrow_move_constructible_v<sentinel>)
         : first{std::move(from)},
           last{std::move(to)} {}
 
@@ -83852,7 +86928,6 @@ struct iterable_adaptor final {
 #define ENTT_CORE_MEMORY_HPP
 
 #include <cstddef>
-#include <limits>
 #include <memory>
 #include <tuple>
 #include <type_traits>
@@ -83862,44 +86937,6 @@ struct iterable_adaptor final {
 
 namespace entt {
 
-/**
- * @brief Checks whether a value is a power of two or not (waiting for C++20 and
- * `std::has_single_bit`).
- * @param value A value that may or may not be a power of two.
- * @return True if the value is a power of two, false otherwise.
- */
-[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
-    return value && ((value & (value - 1)) == 0);
-}
-
-/**
- * @brief Computes the smallest power of two greater than or equal to a value
- * (waiting for C++20 and `std::bit_ceil`).
- * @param value The value to use.
- * @return The smallest power of two greater than or equal to the given value.
- */
-[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
-    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
-    std::size_t curr = value - (value != 0u);
-
-    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
-        curr |= curr >> next;
-    }
-
-    return ++curr;
-}
-
-/**
- * @brief Fast module utility function (powers of two only).
- * @param value A value for which to calculate the modulus.
- * @param mod _Modulus_, it must be a power of two.
- * @return The common remainder.
- */
-[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
-    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
-    return value & (mod - 1u);
-}
-
 /**
  * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
  * @tparam Type Pointer type.
@@ -84126,7 +87163,7 @@ constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...ar
  */
 template<typename Type, typename Allocator, typename... Args>
 constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
-    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
+    return std::apply([value](auto &&...curr) { return ::new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
 }
 
 } // namespace entt
@@ -84712,7 +87749,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -84720,12 +87757,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -84910,14 +87944,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -84931,6 +87962,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -85011,9 +88043,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -85029,8 +88061,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -85065,6 +88100,7 @@ struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_e
 #include <functional>
 #include <memory>
 #include <utility>
+#include <vector>
 
 namespace entt {
 
@@ -85072,17 +88108,27 @@ template<
     typename Key,
     typename Type,
     typename = std::hash<Key>,
-    typename = std::equal_to<Key>,
+    typename = std::equal_to<>,
     typename = std::allocator<std::pair<const Key, Type>>>
 class dense_map;
 
 template<
     typename Type,
     typename = std::hash<Type>,
-    typename = std::equal_to<Type>,
+    typename = std::equal_to<>,
     typename = std::allocator<Type>>
 class dense_set;
 
+template<typename...>
+class basic_table;
+
+/**
+ * @brief Alias declaration for the most common use case.
+ * @tparam Type Element types.
+ */
+template<typename... Type>
+using table = basic_table<std::vector<Type>...>;
+
 } // namespace entt
 
 #endif
@@ -85192,7 +88238,7 @@ class dense_map_iterator final {
     }
 
     [[nodiscard]] constexpr reference operator*() const noexcept {
-        return {it->element.first, it->element.second};
+        return operator[](0);
     }
 
     template<typename Lhs, typename Rhs>
@@ -85337,6 +88383,7 @@ class dense_map {
 
     template<typename Other>
     [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
+        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)
         return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
     }
 
@@ -85395,7 +88442,7 @@ class dense_map {
 
     void move_and_pop(const std::size_t pos) {
         if(const auto last = size() - 1u; pos != last) {
-            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
+            size_type *curr = &sparse.first()[key_to_bucket(packed.first().back().element.first)];
             packed.first()[pos] = std::move(packed.first().back());
             for(; *curr != last; curr = &packed.first()[*curr].next) {}
             *curr = pos;
@@ -85411,6 +88458,8 @@ class dense_map {
     }
 
 public:
+    /*! @brief Allocator type. */
+    using allocator_type = Allocator;
     /*! @brief Key type of the container. */
     using key_type = Key;
     /*! @brief Mapped type of the container. */
@@ -85423,8 +88472,6 @@ class dense_map {
     using hasher = Hash;
     /*! @brief Type of function to use to compare the keys for equality. */
     using key_equal = KeyEqual;
-    /*! @brief Allocator type. */
-    using allocator_type = Allocator;
     /*! @brief Input iterator type. */
     using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
     /*! @brief Constant input iterator type. */
@@ -85474,8 +88521,7 @@ class dense_map {
      */
     explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
         : sparse{allocator, hash},
-          packed{allocator, equal},
-          threshold{default_threshold} {
+          packed{allocator, equal} {
         rehash(cnt);
     }
 
@@ -85493,7 +88539,7 @@ class dense_map {
           threshold{other.threshold} {}
 
     /*! @brief Default move constructor. */
-    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map(dense_map &&) noexcept = default;
 
     /**
      * @brief Allocator-extended move constructor.
@@ -85505,6 +88551,9 @@ class dense_map {
           packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
           threshold{other.threshold} {}
 
+    /*! @brief Default destructor. */
+    ~dense_map() = default;
+
     /**
      * @brief Default copy assignment operator.
      * @return This container.
@@ -85515,7 +88564,7 @@ class dense_map {
      * @brief Default move assignment operator.
      * @return This container.
      */
-    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;
+    dense_map &operator=(dense_map &&) noexcept = default;
 
     /**
      * @brief Returns the associated allocator.
@@ -85747,7 +88796,7 @@ class dense_map {
      * @return Number of elements removed (either 0 or 1).
      */
     size_type erase(const key_type &key) {
-        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
+        for(size_type *curr = &sparse.first()[key_to_bucket(key)]; *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
             if(packed.second()(packed.first()[*curr].element.first, key)) {
                 const auto index = *curr;
                 *curr = packed.first()[*curr].next;
@@ -85763,7 +88812,7 @@ class dense_map {
      * @brief Exchanges the contents with those of a given container.
      * @param other Container to exchange the content with.
      */
-    void swap(dense_map &other) {
+    void swap(dense_map &other) noexcept {
         using std::swap;
         swap(sparse, other.sparse);
         swap(packed, other.packed);
@@ -86092,7 +89141,7 @@ class dense_map {
 private:
     compressed_pair<sparse_container_type, hasher> sparse;
     compressed_pair<packed_container_type, key_equal> packed;
-    float threshold;
+    float threshold{default_threshold};
 };
 
 } // namespace entt
@@ -86117,6 +89166,8 @@ struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
 #include <tuple>
 #include <type_traits>
 #include <utility>
+// #include "fwd.hpp"
+
 // #include "type_traits.hpp"
 #ifndef ENTT_CORE_TYPE_TRAITS_HPP
 #define ENTT_CORE_TYPE_TRAITS_HPP
@@ -86696,7 +89747,7 @@ inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::
 
 /*! @brief Primary template isn't defined on purpose. */
 template<typename...>
-class value_list_diff;
+struct value_list_diff;
 
 /**
  * @brief Computes the difference between two value lists.
@@ -86704,12 +89755,9 @@ class value_list_diff;
  * @tparam Other Values provided by the second value list.
  */
 template<auto... Value, auto... Other>
-class value_list_diff<value_list<Value...>, value_list<Other...>> {
-    using v141_toolset_workaround = value_list<Other...>;
-
-public:
+struct value_list_diff<value_list<Value...>, value_list<Other...>> {
     /*! @brief A value list that is the difference between the two value lists. */
-    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
+    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<value_list<Other...>, Value>, value_list<>, value_list<Value>>...>;
 };
 
 /**
@@ -86894,14 +89942,11 @@ template<typename Type>
 
 template<typename Type>
 [[nodiscard]] constexpr bool dispatch_is_equality_comparable() {
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     if constexpr(std::is_array_v<Type>) {
         return false;
-    } else if constexpr(is_iterator_v<Type>) {
-        return maybe_equality_comparable<Type>(0);
-    } else if constexpr(has_value_type<Type>::value) {
-        if constexpr(std::is_same_v<typename Type::value_type, Type>) {
-            return maybe_equality_comparable<Type>(0);
-        } else if constexpr(dispatch_is_equality_comparable<typename Type::value_type>()) {
+    } else if constexpr(!is_iterator_v<Type> && has_value_type<Type>::value) {
+        if constexpr(std::is_same_v<typename Type::value_type, Type> || dispatch_is_equality_comparable<typename Type::value_type>()) {
             return maybe_equality_comparable<Type>(0);
         } else {
             return false;
@@ -86915,6 +89960,7 @@ template<typename Type>
     } else {
         return maybe_equality_comparable<Type>(0);
     }
+    // NOLINTEND(modernize-use-transparent-functors)
 }
 
 } // namespace internal
@@ -86995,9 +90041,9 @@ template<typename Member>
 using member_class_t = typename member_class<Member>::type;
 
 /**
- * @brief Extracts the n-th argument of a given function or member function.
+ * @brief Extracts the n-th argument of a _callable_ type.
  * @tparam Index The index of the argument to extract.
- * @tparam Candidate A valid function, member function or data member type.
+ * @tparam Candidate A valid _callable_ type.
  */
 template<std::size_t Index, typename Candidate>
 class nth_argument {
@@ -87013,8 +90059,11 @@ class nth_argument {
     template<typename Type, typename Class>
     static constexpr type_list<Type> pick_up(Type Class ::*);
 
+    template<typename Type>
+    static constexpr decltype(pick_up(&Type::operator())) pick_up(Type &&);
+
 public:
-    /*! @brief N-th argument of the given function or member function. */
+    /*! @brief N-th argument of the _callable_ type. */
     using type = type_list_element_t<Index, decltype(pick_up(std::declval<Candidate>()))>;
 };
 
@@ -87053,9 +90102,9 @@ struct compressed_pair_element {
     using reference = Type &;
     using const_reference = const Type &;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
-    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
-        : value{} {}
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
+    // NOLINTNEXTLINE(modernize-use-equals-default)
+    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>) {}
 
     template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
     constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
@@ -87074,7 +90123,7 @@ struct compressed_pair_element {
     }
 
 private:
-    Type value;
+    Type value{};
 };
 
 template<typename Type, std::size_t Tag>
@@ -87083,7 +90132,7 @@ struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Ty
     using const_reference = const Type &;
     using base_type = Type;
 
-    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
+    template<typename Dummy = Type, typename = std::enable_if_t<std::is_default_constructible_v<Dummy>>>
     constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
         : base_type{} {}
 
@@ -87138,7 +90187,7 @@ class compressed_pair final
      * @tparam Dummy Dummy template parameter used for internal purposes.
      */
     template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
-    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
+    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> && std::is_nothrow_default_constructible_v<second_base>)
         : first_base{},
           second_base{} {}
 
@@ -87146,13 +90195,13 @@ class compressed_pair final
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;
+    constexpr compressed_pair(const compressed_pair &other) = default;
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;
+    constexpr compressed_pair(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Constructs a pair from its values.
@@ -87162,7 +90211,7 @@ class compressed_pair final
      * @param other Value to use to initialize the second element.
      */
     template<typename Arg, typename Other>
-    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
+    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> && std::is_nothrow_constructible_v<second_base, Other>)
         : first_base{std::forward<Arg>(arg)},
           second_base{std::forward<Other>(other)} {}
 
@@ -87174,23 +90223,26 @@ class compressed_pair final
      * @param other Arguments to use to initialize the second element.
      */
     template<typename... Args, typename... Other>
-    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
+    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> && std::is_nothrow_constructible_v<second_base, Other...>)
         : first_base{std::move(args), std::index_sequence_for<Args...>{}},
           second_base{std::move(other), std::index_sequence_for<Other...>{}} {}
 
+    /*! @brief Default destructor. */
+    ~compressed_pair() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(const compressed_pair &other) = default;
 
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This compressed pair object.
      */
-    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;
+    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept = default;
 
     /**
      * @brief Returns the first element that a pair stores.
@@ -87222,7 +90274,7 @@ class compressed_pair final
      * @brief Swaps two compressed pair objects.
      * @param other The compressed pair to swap with.
      */
-    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
+    constexpr void swap(compressed_pair &other) noexcept {
         using std::swap;
         swap(first(), other.first());
         swap(second(), other.second());
@@ -87235,7 +90287,7 @@ class compressed_pair final
      * reference to the second element if `Index` is 1.
      */
     template<std::size_t Index>
-    constexpr decltype(auto) get() noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -87246,7 +90298,7 @@ class compressed_pair final
 
     /*! @copydoc get */
     template<std::size_t Index>
-    constexpr decltype(auto) get() const noexcept {
+    [[nodiscard]] constexpr decltype(auto) get() const noexcept {
         if constexpr(Index == 0u) {
             return first();
         } else {
@@ -87278,8 +90330,6 @@ inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<
 
 } // namespace entt
 
-// disable structured binding support for clang 6, it messes when specializing tuple_size
-#if !defined __clang_major__ || __clang_major__ > 6
 namespace std {
 
 /**
@@ -87302,7 +90352,6 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 };
 
 } // namespace std
-#endif
 
 #endif
 
@@ -87316,6 +90365,7 @@ struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<I
 
 namespace entt {
 
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
 class basic_any;
 
@@ -87325,6 +90375,21 @@ using id_type = ENTT_ID_TYPE;
 /*! @brief Alias declaration for the most common use case. */
 using any = basic_any<>;
 
+template<typename, typename>
+class compressed_pair;
+
+template<typename>
+class basic_hashed_string;
+
+/*! @brief Aliases for common character types. */
+using hashed_string = basic_hashed_string<char>;
+
+/*! @brief Aliases for common character types. */
+using hashed_wstring = basic_hashed_string<wchar_t>;
+
+// NOLINTNEXTLINE(bugprone-forward-declaration-namespace)
+struct type_info;
+
 } // namespace entt
 
 #endif
@@ -87378,6 +90443,7 @@ using any = basic_any<>;
 
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 // #include "fwd.hpp"
 
 
@@ -87386,21 +90452,19 @@ namespace entt {
 /*! @cond TURN_OFF_DOXYGEN */
 namespace internal {
 
-template<typename>
-struct fnv1a_traits;
+template<typename = id_type>
+struct fnv_1a_params;
 
 template<>
-struct fnv1a_traits<std::uint32_t> {
-    using type = std::uint32_t;
-    static constexpr std::uint32_t offset = 2166136261;
-    static constexpr std::uint32_t prime = 16777619;
+struct fnv_1a_params<std::uint32_t> {
+    static constexpr auto offset = 2166136261;
+    static constexpr auto prime = 16777619;
 };
 
 template<>
-struct fnv1a_traits<std::uint64_t> {
-    using type = std::uint64_t;
-    static constexpr std::uint64_t offset = 14695981039346656037ull;
-    static constexpr std::uint64_t prime = 1099511628211ull;
+struct fnv_1a_params<std::uint64_t> {
+    static constexpr auto offset = 14695981039346656037ull;
+    static constexpr auto prime = 1099511628211ull;
 };
 
 template<typename Char>
@@ -87435,7 +90499,7 @@ struct basic_hashed_string {
 template<typename Char>
 class basic_hashed_string: internal::basic_hashed_string<Char> {
     using base_type = internal::basic_hashed_string<Char>;
-    using traits_type = internal::fnv1a_traits<id_type>;
+    using params = internal::fnv_1a_params<>;
 
     struct const_wrapper {
         // non-explicit constructor on purpose
@@ -87446,22 +90510,11 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
     };
 
     // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
-        base_type base{str, 0u, traits_type::offset};
+    [[nodiscard]] static constexpr auto helper(const std::basic_string_view<Char> view) noexcept {
+        base_type base{view.data(), view.size(), params::offset};
 
-        for(; str[base.length]; ++base.length) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
-        }
-
-        return base;
-    }
-
-    // FowlerNollVo hash function v. 1a - the good
-    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
-        base_type base{str, len, traits_type::offset};
-
-        for(size_type pos{}; pos < len; ++pos) {
-            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
+        for(auto &&curr: view) {
+            base.hash = (base.hash ^ static_cast<id_type>(curr)) * params::prime;
         }
 
         return base;
@@ -87492,6 +90545,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @return The numeric representation of the string.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
         return basic_hashed_string{str};
     }
@@ -87507,7 +90561,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
 
     /*! @brief Constructs an empty hashed string. */
     constexpr basic_hashed_string() noexcept
-        : base_type{} {}
+        : basic_hashed_string{nullptr, 0u} {}
 
     /**
      * @brief Constructs a hashed string from a string view.
@@ -87515,7 +90569,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param len Length of the string to hash.
      */
     constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
-        : base_type{helper(str, len)} {}
+        : base_type{helper({str, len})} {}
 
     /**
      * @brief Constructs a hashed string from an array of const characters.
@@ -87523,8 +90577,9 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param str Human-readable identifier.
      */
     template<std::size_t N>
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
     constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
-        : base_type{helper(str)} {}
+        : base_type{helper({static_cast<const value_type *>(str)})} {}
 
     /**
      * @brief Explicit constructor on purpose to avoid constructing a hashed
@@ -87536,14 +90591,14 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
      * @param wrapper Helps achieving the purpose by relying on overloading.
      */
     explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
-        : base_type{helper(wrapper.repr)} {}
+        : base_type{helper({wrapper.repr})} {}
 
     /**
      * @brief Returns the size a hashed string.
      * @return The size of the hashed string.
      */
     [[nodiscard]] constexpr size_type size() const noexcept {
-        return base_type::length; // NOLINT
+        return base_type::length;
     }
 
     /**
@@ -87583,7 +90638,7 @@ class basic_hashed_string: internal::basic_hashed_string<Char> {
  * @param len Length of the string to hash.
  */
 template<typename Char>
-basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;
+basic_hashed_string(const Char *str, std::size_t len) -> basic_hashed_string<Char>;
 
 /**
  * @brief Deduction guide.
@@ -87592,6 +90647,7 @@ basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_stri
  * @param str Human-readable identifier.
  */
 template<typename Char, std::size_t N>
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays, modernize-avoid-c-arrays)
 basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;
 
 /**
@@ -87669,12 +90725,6 @@ template<typename Char>
     return !(lhs < rhs);
 }
 
-/*! @brief Aliases for common character types. */
-using hashed_string = basic_hashed_string<char>;
-
-/*! @brief Aliases for common character types. */
-using hashed_wstring = basic_hashed_string<wchar_t>;
-
 inline namespace literals {
 
 /**
@@ -87717,7 +90767,7 @@ struct ENTT_API type_index final {
 template<typename Type>
 [[nodiscard]] constexpr auto stripped_type_name() noexcept {
 #if defined ENTT_PRETTY_FUNCTION
-    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
+    std::string_view pretty_function{static_cast<const char *>(ENTT_PRETTY_FUNCTION)};
     auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
     auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
     return value;
@@ -87829,10 +90879,12 @@ struct type_info final {
      * @tparam Type Type for which to construct a type info object.
      */
     template<typename Type>
+    // NOLINTBEGIN(modernize-use-transparent-functors)
     constexpr type_info(std::in_place_type_t<Type>) noexcept
         : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
           alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}
+    // NOLINTEND(modernize-use-transparent-functors)
 
     /**
      * @brief Type index.
@@ -87890,7 +90942,7 @@ struct type_info final {
  * @param rhs A valid type info object.
  * @return True if the first element is less than the second, false otherwise.
  */
-[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
     return lhs.index() < rhs.index();
 }
 
@@ -87901,7 +90953,7 @@ struct type_info final {
  * @return True if the first element is less than or equal to the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(rhs < lhs);
 }
 
@@ -87912,7 +90964,7 @@ struct type_info final {
  * @return True if the first element is greater than the second, false
  * otherwise.
  */
-[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
     return rhs < lhs;
 }
 
@@ -87923,7 +90975,7 @@ struct type_info final {
  * @return True if the first element is greater than or equal to the second,
  * false otherwise.
  */
-[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
+[[nodiscard]] inline constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
     return !(lhs < rhs);
 }
 
@@ -88105,7 +91157,7 @@ constexpr auto function_pointer(Ret (Class::*)(Args...), Other &&...) -> Ret (*)
 template<typename Class, typename Ret, typename... Args, typename... Other>
 constexpr auto function_pointer(Ret (Class::*)(Args...) const, Other &&...) -> Ret (*)(Args...);
 
-template<typename Class, typename Type, typename... Other>
+template<typename Class, typename Type, typename... Other, typename = std::enable_if_t<std::is_member_object_pointer_v<Type Class::*>>>
 constexpr auto function_pointer(Type Class::*, Other &&...) -> Type (*)();
 
 template<typename... Type>
@@ -88142,47 +91194,35 @@ class delegate;
  */
 template<typename Ret, typename... Args>
 class delegate<Ret(Args...)> {
+    using return_type = std::remove_const_t<Ret>;
+    using delegate_type = return_type(const void *, Args...);
+
     template<auto Candidate, std::size_t... Index>
     [[nodiscard]] auto wrap(std::index_sequence<Index...>) noexcept {
-        return [](const void *, Args... args) -> Ret {
+        return [](const void *, Args... args) -> return_type {
             [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
     template<auto Candidate, typename Type, std::size_t... Index>
     [[nodiscard]] auto wrap(Type &, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+        return [](const void *payload, Args... args) -> return_type {
             Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
     template<auto Candidate, typename Type, std::size_t... Index>
     [[nodiscard]] auto wrap(Type *, std::index_sequence<Index...>) noexcept {
-        return [](const void *payload, Args... args) -> Ret {
-            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+        return [](const void *payload, Args... args) -> return_type {
             Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
-
-            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...>) {
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
-            } else {
-                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
-                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
-            }
+            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
+            [[maybe_unused]] constexpr auto offset = !std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...> * (sizeof...(Args) - sizeof...(Index));
+            return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
         };
     }
 
@@ -88195,9 +91235,7 @@ class delegate<Ret(Args...)> {
     using result_type = Ret;
 
     /*! @brief Default constructor. */
-    delegate() noexcept
-        : instance{nullptr},
-          fn{nullptr} {}
+    delegate() noexcept = default;
 
     /**
      * @brief Constructs a delegate with a given object or payload, if any.
@@ -88229,7 +91267,7 @@ class delegate<Ret(Args...)> {
         instance = nullptr;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
-            fn = [](const void *, Args... args) -> Ret {
+            fn = [](const void *, Args... args) -> return_type {
                 return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
             };
         } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
@@ -88259,7 +91297,7 @@ class delegate<Ret(Args...)> {
         instance = &value_or_instance;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
+            fn = [](const void *payload, Args... args) -> return_type {
                 Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                 return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
             };
@@ -88283,7 +91321,7 @@ class delegate<Ret(Args...)> {
         instance = value_or_instance;
 
         if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
-            fn = [](const void *payload, Args... args) -> Ret {
+            fn = [](const void *payload, Args... args) -> return_type {
                 Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                 return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
             };
@@ -88373,8 +91411,8 @@ class delegate<Ret(Args...)> {
     }
 
 private:
-    const void *instance;
-    function_type *fn;
+    const void *instance{};
+    delegate_type *fn{};
 };
 
 /**
@@ -88478,21 +91516,21 @@ class sigh<Ret(Args...), Allocator> {
     using sink_type = sink<sigh<Ret(Args...), Allocator>>;
 
     /*! @brief Default constructor. */
-    sigh() noexcept(std::is_nothrow_default_constructible_v<allocator_type> &&std::is_nothrow_constructible_v<container_type, const allocator_type &>)
+    sigh() noexcept(noexcept(allocator_type{}))
         : sigh{allocator_type{}} {}
 
     /**
      * @brief Constructs a signal handler with a given allocator.
      * @param allocator The allocator to use.
      */
-    explicit sigh(const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const allocator_type &>)
+    explicit sigh(const allocator_type &allocator) noexcept
         : calls{allocator} {}
 
     /**
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    sigh(const sigh &other) noexcept(std::is_nothrow_copy_constructible_v<container_type>)
+    sigh(const sigh &other)
         : calls{other.calls} {}
 
     /**
@@ -88500,14 +91538,14 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to copy from.
      * @param allocator The allocator to use.
      */
-    sigh(const sigh &other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const container_type &, const allocator_type &>)
+    sigh(const sigh &other, const allocator_type &allocator)
         : calls{other.calls, allocator} {}
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    sigh(sigh &&other) noexcept(std::is_nothrow_move_constructible_v<container_type>)
+    sigh(sigh &&other) noexcept
         : calls{std::move(other.calls)} {}
 
     /**
@@ -88515,15 +91553,18 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    sigh(sigh &&other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, container_type &&, const allocator_type &>)
+    sigh(sigh &&other, const allocator_type &allocator)
         : calls{std::move(other.calls), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~sigh() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This signal handler.
      */
-    sigh &operator=(const sigh &other) noexcept(std::is_nothrow_copy_assignable_v<container_type>) {
+    sigh &operator=(const sigh &other) {
         calls = other.calls;
         return *this;
     }
@@ -88533,8 +91574,8 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to move from.
      * @return This signal handler.
      */
-    sigh &operator=(sigh &&other) noexcept(std::is_nothrow_move_assignable_v<container_type>) {
-        calls = std::move(other.calls);
+    sigh &operator=(sigh &&other) noexcept {
+        swap(other);
         return *this;
     }
 
@@ -88542,7 +91583,7 @@ class sigh<Ret(Args...), Allocator> {
      * @brief Exchanges the contents with those of a given signal handler.
      * @param other Signal handler to exchange the content with.
      */
-    void swap(sigh &other) noexcept(std::is_nothrow_swappable_v<container_type>) {
+    void swap(sigh &other) noexcept {
         using std::swap;
         swap(calls, other.calls);
     }
@@ -88644,8 +91685,7 @@ class connection {
 public:
     /*! @brief Default constructor. */
     connection()
-        : disconnect{},
-          signal{} {}
+        : signal{} {}
 
     /**
      * @brief Checks whether a connection is properly initialized.
@@ -88725,7 +91765,7 @@ struct scoped_connection {
      * @return This scoped connection.
      */
     scoped_connection &operator=(connection other) {
-        conn = std::move(other);
+        conn = other;
         return *this;
     }
 
@@ -88825,7 +91865,7 @@ class sink<sigh<Ret(Args...), Allocator>> {
 
         delegate<void(void *)> conn{};
         conn.template connect<&release<Candidate, Type...>>(value_or_instance...);
-        return {std::move(conn), signal};
+        return {conn, signal};
     }
 
     /**
@@ -88848,9 +91888,8 @@ class sink<sigh<Ret(Args...), Allocator>> {
      * @param value_or_instance A valid object that fits the purpose.
      */
     void disconnect(const void *value_or_instance) {
-        if(value_or_instance) {
-            disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
-        }
+        ENTT_ASSERT(value_or_instance != nullptr, "Invalid value or instance");
+        disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
     }
 
     /*! @brief Disconnects all the listeners from a signal. */
@@ -88890,7 +91929,7 @@ struct basic_dispatcher_handler {
     virtual void publish() = 0;
     virtual void disconnect(void *) = 0;
     virtual void clear() noexcept = 0;
-    virtual std::size_t size() const noexcept = 0;
+    [[nodiscard]] virtual std::size_t size() const noexcept = 0;
 };
 
 template<typename Type, typename Allocator>
@@ -88980,7 +92019,7 @@ class basic_dispatcher {
 
     using alloc_traits = std::allocator_traits<Allocator>;
     using container_allocator = typename alloc_traits::template rebind_alloc<std::pair<const key_type, mapped_type>>;
-    using container_type = dense_map<key_type, mapped_type, identity, std::equal_to<key_type>, container_allocator>;
+    using container_type = dense_map<key_type, mapped_type, identity, std::equal_to<>, container_allocator>;
 
     template<typename Type>
     [[nodiscard]] handler_type<Type> &assure(const id_type id) {
@@ -89023,6 +92062,9 @@ class basic_dispatcher {
     explicit basic_dispatcher(const allocator_type &allocator)
         : pools{allocator, allocator} {}
 
+    /*! @brief Default copy constructor, deleted on purpose. */
+    basic_dispatcher(const basic_dispatcher &) = delete;
+
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
@@ -89035,19 +92077,28 @@ class basic_dispatcher {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    basic_dispatcher(basic_dispatcher &&other, const allocator_type &allocator) noexcept
+    basic_dispatcher(basic_dispatcher &&other, const allocator_type &allocator)
         : pools{container_type{std::move(other.pools.first()), allocator}, allocator} {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || pools.second() == other.pools.second(), "Copying a dispatcher is not allowed");
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a dispatcher is not allowed");
     }
 
+    /*! @brief Default destructor. */
+    ~basic_dispatcher() = default;
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This dispatcher.
+     */
+    basic_dispatcher &operator=(const basic_dispatcher &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
      * @return This dispatcher.
      */
     basic_dispatcher &operator=(basic_dispatcher &&other) noexcept {
-        ENTT_ASSERT(alloc_traits::is_always_equal::value || pools.second() == other.pools.second(), "Copying a dispatcher is not allowed");
-        pools = std::move(other.pools);
+        ENTT_ASSERT(alloc_traits::is_always_equal::value || get_allocator() == other.get_allocator(), "Copying a dispatcher is not allowed");
+        swap(other);
         return *this;
     }
 
@@ -89055,7 +92106,7 @@ class basic_dispatcher {
      * @brief Exchanges the contents with those of a given dispatcher.
      * @param other Dispatcher to exchange the content with.
      */
-    void swap(basic_dispatcher &other) {
+    void swap(basic_dispatcher &other) noexcept {
         using std::swap;
         swap(pools, other.pools);
     }
@@ -89075,7 +92126,7 @@ class basic_dispatcher {
      * @return The number of pending events for the given type.
      */
     template<typename Type>
-    size_type size(const id_type id = type_hash<Type>::value()) const noexcept {
+    [[nodiscard]] size_type size(const id_type id = type_hash<Type>::value()) const noexcept {
         const auto *cpool = assure<std::decay_t<Type>>(id);
         return cpool ? cpool->size() : 0u;
     }
@@ -89084,7 +92135,7 @@ class basic_dispatcher {
      * @brief Returns the total number of pending events.
      * @return The total number of pending events.
      */
-    size_type size() const noexcept {
+    [[nodiscard]] size_type size() const noexcept {
         size_type count{};
 
         for(auto &&cpool: pools.first()) {
@@ -89297,7 +92348,7 @@ class emitter {
 
     using alloc_traits = std::allocator_traits<Allocator>;
     using container_allocator = typename alloc_traits::template rebind_alloc<std::pair<const key_type, mapped_type>>;
-    using container_type = dense_map<key_type, mapped_type, identity, std::equal_to<key_type>, container_allocator>;
+    using container_type = dense_map<key_type, mapped_type, identity, std::equal_to<>, container_allocator>;
 
 public:
     /*! @brief Allocator type. */
@@ -89316,10 +92367,8 @@ class emitter {
     explicit emitter(const allocator_type &allocator)
         : handlers{allocator, allocator} {}
 
-    /*! @brief Default destructor. */
-    virtual ~emitter() noexcept {
-        static_assert(std::is_base_of_v<emitter<Derived, Allocator>, Derived>, "Invalid emitter type");
-    }
+    /*! @brief Default copy constructor, deleted on purpose. */
+    emitter(const emitter &) = delete;
 
     /**
      * @brief Move constructor.
@@ -89333,20 +92382,30 @@ class emitter {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    emitter(emitter &&other, const allocator_type &allocator) noexcept
+    emitter(emitter &&other, const allocator_type &allocator)
         : handlers{container_type{std::move(other.handlers.first()), allocator}, allocator} {
         ENTT_ASSERT(alloc_traits::is_always_equal::value || handlers.second() == other.handlers.second(), "Copying an emitter is not allowed");
     }
 
+    /*! @brief Default destructor. */
+    virtual ~emitter() {
+        static_assert(std::is_base_of_v<emitter<Derived, Allocator>, Derived>, "Invalid emitter type");
+    }
+
+    /**
+     * @brief Default copy assignment operator, deleted on purpose.
+     * @return This emitter.
+     */
+    emitter &operator=(const emitter &) = delete;
+
     /**
      * @brief Move assignment operator.
      * @param other The instance to move from.
-     * @return This dispatcher.
+     * @return This emitter.
      */
     emitter &operator=(emitter &&other) noexcept {
         ENTT_ASSERT(alloc_traits::is_always_equal::value || handlers.second() == other.handlers.second(), "Copying an emitter is not allowed");
-
-        handlers = std::move(other.handlers);
+        swap(other);
         return *this;
     }
 
@@ -89354,7 +92413,7 @@ class emitter {
      * @brief Exchanges the contents with those of a given emitter.
      * @param other Emitter to exchange the content with.
      */
-    void swap(emitter &other) {
+    void swap(emitter &other) noexcept {
         using std::swap;
         swap(handlers, other.handlers);
     }
@@ -89503,21 +92562,21 @@ class sigh<Ret(Args...), Allocator> {
     using sink_type = sink<sigh<Ret(Args...), Allocator>>;
 
     /*! @brief Default constructor. */
-    sigh() noexcept(std::is_nothrow_default_constructible_v<allocator_type> &&std::is_nothrow_constructible_v<container_type, const allocator_type &>)
+    sigh() noexcept(noexcept(allocator_type{}))
         : sigh{allocator_type{}} {}
 
     /**
      * @brief Constructs a signal handler with a given allocator.
      * @param allocator The allocator to use.
      */
-    explicit sigh(const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const allocator_type &>)
+    explicit sigh(const allocator_type &allocator) noexcept
         : calls{allocator} {}
 
     /**
      * @brief Copy constructor.
      * @param other The instance to copy from.
      */
-    sigh(const sigh &other) noexcept(std::is_nothrow_copy_constructible_v<container_type>)
+    sigh(const sigh &other)
         : calls{other.calls} {}
 
     /**
@@ -89525,14 +92584,14 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to copy from.
      * @param allocator The allocator to use.
      */
-    sigh(const sigh &other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const container_type &, const allocator_type &>)
+    sigh(const sigh &other, const allocator_type &allocator)
         : calls{other.calls, allocator} {}
 
     /**
      * @brief Move constructor.
      * @param other The instance to move from.
      */
-    sigh(sigh &&other) noexcept(std::is_nothrow_move_constructible_v<container_type>)
+    sigh(sigh &&other) noexcept
         : calls{std::move(other.calls)} {}
 
     /**
@@ -89540,15 +92599,18 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to move from.
      * @param allocator The allocator to use.
      */
-    sigh(sigh &&other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, container_type &&, const allocator_type &>)
+    sigh(sigh &&other, const allocator_type &allocator)
         : calls{std::move(other.calls), allocator} {}
 
+    /*! @brief Default destructor. */
+    ~sigh() = default;
+
     /**
      * @brief Copy assignment operator.
      * @param other The instance to copy from.
      * @return This signal handler.
      */
-    sigh &operator=(const sigh &other) noexcept(std::is_nothrow_copy_assignable_v<container_type>) {
+    sigh &operator=(const sigh &other) {
         calls = other.calls;
         return *this;
     }
@@ -89558,8 +92620,8 @@ class sigh<Ret(Args...), Allocator> {
      * @param other The instance to move from.
      * @return This signal handler.
      */
-    sigh &operator=(sigh &&other) noexcept(std::is_nothrow_move_assignable_v<container_type>) {
-        calls = std::move(other.calls);
+    sigh &operator=(sigh &&other) noexcept {
+        swap(other);
         return *this;
     }
 
@@ -89567,7 +92629,7 @@ class sigh<Ret(Args...), Allocator> {
      * @brief Exchanges the contents with those of a given signal handler.
      * @param other Signal handler to exchange the content with.
      */
-    void swap(sigh &other) noexcept(std::is_nothrow_swappable_v<container_type>) {
+    void swap(sigh &other) noexcept {
         using std::swap;
         swap(calls, other.calls);
     }
@@ -89669,8 +92731,7 @@ class connection {
 public:
     /*! @brief Default constructor. */
     connection()
-        : disconnect{},
-          signal{} {}
+        : signal{} {}
 
     /**
      * @brief Checks whether a connection is properly initialized.
@@ -89750,7 +92811,7 @@ struct scoped_connection {
      * @return This scoped connection.
      */
     scoped_connection &operator=(connection other) {
-        conn = std::move(other);
+        conn = other;
         return *this;
     }
 
@@ -89850,7 +92911,7 @@ class sink<sigh<Ret(Args...), Allocator>> {
 
         delegate<void(void *)> conn{};
         conn.template connect<&release<Candidate, Type...>>(value_or_instance...);
-        return {std::move(conn), signal};
+        return {conn, signal};
     }
 
     /**
@@ -89873,9 +92934,8 @@ class sink<sigh<Ret(Args...), Allocator>> {
      * @param value_or_instance A valid object that fits the purpose.
      */
     void disconnect(const void *value_or_instance) {
-        if(value_or_instance) {
-            disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
-        }
+        ENTT_ASSERT(value_or_instance != nullptr, "Invalid value or instance");
+        disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
     }
 
     /*! @brief Disconnects all the listeners from a signal. */
