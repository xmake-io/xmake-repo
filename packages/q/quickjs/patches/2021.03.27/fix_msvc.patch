From 826401510609759782e8d37c2207b8b89a4aa10a Mon Sep 17 00:00:00 2001
From: yszhou <987912102@qq.com>
Date: Fri, 24 Jun 2022 21:58:24 +0800
Subject: [PATCH] fix msvc

---
 cutils.c           |    47 +-
 cutils.h           |    81 +-
 libregexp.c        |   218 +-
 libregexp.h        |     1 -
 libunicode-table.h |  3183 +++++----
 quickjs-atom.h     |    33 +-
 quickjs-libc.c     |  2128 ++----
 quickjs-libc.h     |    13 -
 quickjs-opcode.h   |    21 +-
 quickjs.c          | 16294 +++++++++++++++++--------------------------
 quickjs.h          |   220 +-
 11 files changed, 8671 insertions(+), 13568 deletions(-)

diff --git a/cutils.c b/cutils.c
index a02fb76..af1f61b 100644
--- a/cutils.c
+++ b/cutils.c
@@ -166,13 +166,16 @@ int dbuf_putstr(DynBuf *s, const char *str)
     return dbuf_put(s, (const uint8_t *)str, strlen(str));
 }
 
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...)
+int
+#ifndef _MSC_VER
+__attribute__((format(printf, 2, 3)))
+#endif
+dbuf_printf(DynBuf *s, const char *fmt, ...)
 {
     va_list ap;
     char buf[128];
     int len;
-    
+
     va_start(ap, fmt);
     len = vsnprintf(buf, sizeof(buf), fmt, ap);
     va_end(ap);
@@ -257,36 +260,42 @@ int unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp)
         *pp = p;
         return c;
     }
+
+#ifdef _MSC_VER
+    if (c >= 0xc0 && c <= 0xdf)
+        l = 1;
+    else if (c >= 0xe0 && c <= 0xef)
+        l = 2;
+    else if (c >= 0xf0 && c <= 0xf7)
+        l = 3;
+    else if (c >= 0xf8 && c <= 0xfb)
+        l = 4;
+    else if (c >= 0xfc && c <= 0xfd)
+        l = 5;
+    else
+        return -1;
+#else
     switch(c) {
-    case 0xc0: case 0xc1: case 0xc2: case 0xc3:
-    case 0xc4: case 0xc5: case 0xc6: case 0xc7:
-    case 0xc8: case 0xc9: case 0xca: case 0xcb:
-    case 0xcc: case 0xcd: case 0xce: case 0xcf:
-    case 0xd0: case 0xd1: case 0xd2: case 0xd3:
-    case 0xd4: case 0xd5: case 0xd6: case 0xd7:
-    case 0xd8: case 0xd9: case 0xda: case 0xdb:
-    case 0xdc: case 0xdd: case 0xde: case 0xdf:
+    case 0xc0 ... 0xdf:
         l = 1;
         break;
-    case 0xe0: case 0xe1: case 0xe2: case 0xe3:
-    case 0xe4: case 0xe5: case 0xe6: case 0xe7:
-    case 0xe8: case 0xe9: case 0xea: case 0xeb:
-    case 0xec: case 0xed: case 0xee: case 0xef:
+    case 0xe0 ... 0xef:
         l = 2;
         break;
-    case 0xf0: case 0xf1: case 0xf2: case 0xf3:
-    case 0xf4: case 0xf5: case 0xf6: case 0xf7:
+    case 0xf0 ... 0xf7:
         l = 3;
         break;
-    case 0xf8: case 0xf9: case 0xfa: case 0xfb:
+    case 0xf8 ... 0xfb:
         l = 4;
         break;
-    case 0xfc: case 0xfd:
+    case 0xfc ... 0xfd:
         l = 5;
         break;
     default:
         return -1;
     }
+#endif
+
     /* check that we have enough characters */
     if (l > (max_len - 1))
         return -1;
diff --git a/cutils.h b/cutils.h
index 31f7cd8..69992af 100644
--- a/cutils.h
+++ b/cutils.h
@@ -1,6 +1,6 @@
 /*
  * C utilities
- * 
+ *
  * Copyright (c) 2017 Fabrice Bellard
  * Copyright (c) 2018 Charlie Gordon
  *
@@ -28,14 +28,26 @@
 #include <stdlib.h>
 #include <inttypes.h>
 
+#ifdef _MSC_VER
+#include <intrin.h>
+#endif
+
 /* set if CPU is big endian */
 #undef WORDS_BIGENDIAN
 
+#ifdef _MSC_VER
+#define likely(x)    (x)
+#define unlikely(x)  (x)
+#define force_inline __forceinline
+#define no_inline __declspec(noinline)
+#define __maybe_unused
+#else
 #define likely(x)       __builtin_expect(!!(x), 1)
 #define unlikely(x)     __builtin_expect(!!(x), 0)
 #define force_inline inline __attribute__((always_inline))
 #define no_inline __attribute__((noinline))
 #define __maybe_unused __attribute__((unused))
+#endif
 
 #define xglue(x, y) x ## y
 #define glue(x, y) xglue(x, y)
@@ -114,27 +126,66 @@ static inline int64_t min_int64(int64_t a, int64_t b)
 /* WARNING: undefined if a = 0 */
 static inline int clz32(unsigned int a)
 {
+#ifdef _MSC_VER
+    unsigned long idx;
+    _BitScanReverse(&idx, a);
+    return 31 ^ idx;
+#else
     return __builtin_clz(a);
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int clz64(uint64_t a)
 {
+#ifdef _MSC_VER
+    unsigned long idx;
+    _BitScanReverse64(&idx, a);
+    return 63 ^ idx;
+#else
     return __builtin_clzll(a);
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz32(unsigned int a)
 {
+#ifdef _MSC_VER
+    unsigned long idx;
+    _BitScanForward(&idx, a);
+    return 31 ^ idx;
+#else
     return __builtin_ctz(a);
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz64(uint64_t a)
 {
+#ifdef _MSC_VER
+    unsigned long idx;
+    _BitScanForward64(&idx, a);
+    return 63 ^ idx;
+#else
     return __builtin_ctzll(a);
+#endif
 }
 
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+struct packed_u64 {
+    uint64_t v;
+};
+
+struct packed_u32 {
+    uint32_t v;
+};
+
+struct packed_u16 {
+    uint16_t v;
+};
+#pragma pack(pop)
+#else
 struct __attribute__((packed)) packed_u64 {
     uint64_t v;
 };
@@ -146,6 +197,7 @@ struct __attribute__((packed)) packed_u32 {
 struct __attribute__((packed)) packed_u16 {
     uint16_t v;
 };
+#endif
 
 static inline uint64_t get_u64(const uint8_t *tab)
 {
@@ -220,13 +272,13 @@ static inline uint32_t bswap32(uint32_t v)
 
 static inline uint64_t bswap64(uint64_t v)
 {
-    return ((v & ((uint64_t)0xff << (7 * 8))) >> (7 * 8)) | 
-        ((v & ((uint64_t)0xff << (6 * 8))) >> (5 * 8)) | 
-        ((v & ((uint64_t)0xff << (5 * 8))) >> (3 * 8)) | 
-        ((v & ((uint64_t)0xff << (4 * 8))) >> (1 * 8)) | 
-        ((v & ((uint64_t)0xff << (3 * 8))) << (1 * 8)) | 
-        ((v & ((uint64_t)0xff << (2 * 8))) << (3 * 8)) | 
-        ((v & ((uint64_t)0xff << (1 * 8))) << (5 * 8)) | 
+    return ((v & ((uint64_t)0xff << (7 * 8))) >> (7 * 8)) |
+        ((v & ((uint64_t)0xff << (6 * 8))) >> (5 * 8)) |
+        ((v & ((uint64_t)0xff << (5 * 8))) >> (3 * 8)) |
+        ((v & ((uint64_t)0xff << (4 * 8))) >> (1 * 8)) |
+        ((v & ((uint64_t)0xff << (3 * 8))) << (1 * 8)) |
+        ((v & ((uint64_t)0xff << (2 * 8))) << (3 * 8)) |
+        ((v & ((uint64_t)0xff << (1 * 8))) << (5 * 8)) |
         ((v & ((uint64_t)0xff << (0 * 8))) << (7 * 8));
 }
 
@@ -262,16 +314,17 @@ static inline int dbuf_put_u64(DynBuf *s, uint64_t val)
 {
     return dbuf_put(s, (uint8_t *)&val, 8);
 }
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...);
+
+int
+#ifndef _MSC_VER
+__attribute__((format(printf, 2, 3)))
+#endif
+dbuf_printf(DynBuf *s, const char *fmt, ...);
+
 void dbuf_free(DynBuf *s);
 static inline BOOL dbuf_error(DynBuf *s) {
     return s->error;
 }
-static inline void dbuf_set_error(DynBuf *s)
-{
-    s->error = TRUE;
-}
 
 #define UTF8_CHAR_LEN_MAX 6
 
diff --git a/libregexp.c b/libregexp.c
index 379bfc7..0d3db9e 100644
--- a/libregexp.c
+++ b/libregexp.c
@@ -28,6 +28,7 @@
 #include <string.h>
 #include <assert.h>
 
+#include "quickjs.h"
 #include "cutils.h"
 #include "libregexp.h"
 
@@ -75,7 +76,7 @@ typedef struct {
     int capture_count;
     int total_capture_count; /* -1 = not computed yet */
     int has_named_captures; /* -1 = don't know, 0 = no, 1 = yes */
-    void *opaque;
+    void *mem_opaque;
     DynBuf group_names;
     union {
         char error_msg[TMP_BUF_SIZE];
@@ -106,18 +107,12 @@ static const REOpCode reopcode_info[REOP_COUNT] = {
 
 #define RE_HEADER_LEN 7
 
-static inline int is_digit(int c) {
-    return c >= '0' && c <= '9';
-}
-
-/* insert 'len' bytes at position 'pos'. Return < 0 if error. */
-static int dbuf_insert(DynBuf *s, int pos, int len)
+/* insert 'len' bytes at position 'pos' */
+static void dbuf_insert(DynBuf *s, int pos, int len)
 {
-    if (dbuf_realloc(s, s->size + len))
-        return -1;
+    dbuf_realloc(s, s->size + len);
     memmove(s->buf + pos + len, s->buf + pos, s->size - pos);
     s->size += len;
-    return 0;
 }
 
 /* canonicalize with the specific JS regexp rules */
@@ -230,7 +225,7 @@ static int cr_init_char_range(REParseState *s, CharRange *cr, uint32_t c)
     invert = c & 1;
     c_pt = char_range_table[c >> 1];
     len = *c_pt++;
-    cr_init(cr, s->opaque, lre_realloc);
+    cr_init(cr, s->mem_opaque, lre_realloc);
     for(i = 0; i < len * 2; i++) {
         if (cr_add_point(cr, c_pt[i]))
             goto fail;
@@ -427,7 +422,7 @@ static void re_emit_op_u16(REParseState *s, int op, uint32_t val)
     dbuf_put_u16(&s->byte_code, val);
 }
 
-static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)
+static int __js_printf_like(2, 3) re_parse_error(REParseState *s, const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
@@ -436,14 +431,8 @@ static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s,
     return -1;
 }
 
-static int re_parse_out_of_memory(REParseState *s)
-{
-    return re_parse_error(s, "out of memory");
-}
-
-/* If allow_overflow is false, return -1 in case of
-   overflow. Otherwise return INT32_MAX. */
-static int parse_digits(const uint8_t **pp, BOOL allow_overflow)
+/* Return -1 in case of overflow */
+static int parse_digits(const uint8_t **pp)
 {
     const uint8_t *p;
     uint64_t v;
@@ -456,12 +445,8 @@ static int parse_digits(const uint8_t **pp, BOOL allow_overflow)
         if (c < '0' || c > '9')
             break;
         v = v * 10 + c - '0';
-        if (v >= INT32_MAX) {
-            if (allow_overflow)
-                v = INT32_MAX;
-            else
-                return -1;
-        }
+        if (v >= INT32_MAX)
+            return -1;
         p++;
     }
     *pp = p;
@@ -569,12 +554,18 @@ int lre_parse_escape(const uint8_t **pp, int allow_utf16)
             }
         }
         break;
-    case '0': case '1': case '2': case '3':
-    case '4': case '5': case '6': case '7':
+    case '0':
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
         c -= '0';
         if (allow_utf16 == 2) {
             /* only accept \0 not followed by digit */
-            if (c != 0 || is_digit(*p))
+            if (c != 0 || isdigit(*p))
                 return -1;
         } else {
             /* parse a legacy octal sequence */
@@ -625,7 +616,7 @@ static int parse_unicode_property(REParseState *s, CharRange *cr,
     p++;
     q = name;
     while (is_unicode_char(*p)) {
-        if ((q - name) >= sizeof(name) - 1)
+        if ((q - name) > sizeof(name) - 1)
             goto unknown_property_name;
         *q++ = *p++;
     }
@@ -634,7 +625,7 @@ static int parse_unicode_property(REParseState *s, CharRange *cr,
     if (*p == '=') {
         p++;
         while (is_unicode_char(*p)) {
-            if ((q - value) >= sizeof(value) - 1)
+            if ((q - value) > sizeof(value) - 1)
                 return re_parse_error(s, "unknown unicode property value");
             *q++ = *p++;
         }
@@ -651,7 +642,7 @@ static int parse_unicode_property(REParseState *s, CharRange *cr,
     } else if (!strcmp(name, "Script_Extensions") || !strcmp(name, "scx")) {
         script_ext = TRUE;
     do_script:
-        cr_init(cr, s->opaque, lre_realloc);
+        cr_init(cr, s->mem_opaque, lre_realloc);
         ret = unicode_script(cr, value, script_ext);
         if (ret) {
             cr_free(cr);
@@ -661,7 +652,7 @@ static int parse_unicode_property(REParseState *s, CharRange *cr,
                 goto out_of_memory;
         }
     } else if (!strcmp(name, "General_Category") || !strcmp(name, "gc")) {
-        cr_init(cr, s->opaque, lre_realloc);
+        cr_init(cr, s->mem_opaque, lre_realloc);
         ret = unicode_general_category(cr, value);
         if (ret) {
             cr_free(cr);
@@ -671,7 +662,7 @@ static int parse_unicode_property(REParseState *s, CharRange *cr,
                 goto out_of_memory;
         }
     } else if (value[0] == '\0') {
-        cr_init(cr, s->opaque, lre_realloc);
+        cr_init(cr, s->mem_opaque, lre_realloc);
         ret = unicode_general_category(cr, name);
         if (ret == -1) {
             cr_free(cr);
@@ -701,7 +692,7 @@ static int parse_unicode_property(REParseState *s, CharRange *cr,
     *pp = p;
     return 0;
  out_of_memory:
-    return re_parse_out_of_memory(s);
+    return re_parse_error(s, "out of memory");
 }
 #endif /* CONFIG_ALL_UNICODE */
 
@@ -864,7 +855,7 @@ static int re_parse_char_class(REParseState *s, const uint8_t **pp)
     CharRange cr1_s, *cr1 = &cr1_s;
     BOOL invert;
     
-    cr_init(cr, s->opaque, lre_realloc);
+    cr_init(cr, s->mem_opaque, lre_realloc);
     p = *pp;
     p++;    /* skip '[' */
     invert = FALSE;
@@ -936,7 +927,7 @@ static int re_parse_char_class(REParseState *s, const uint8_t **pp)
     *pp = p;
     return 0;
  memory_error:
-    re_parse_out_of_memory(s);
+    re_parse_error(s, "out of memory");
  fail:
     cr_free(cr);
     return -1;
@@ -1147,13 +1138,9 @@ static int re_parse_captures(REParseState *s, int *phas_named_captures,
                         }
                     }
                     capture_index++;
-                    if (capture_index >= CAPTURE_COUNT_MAX)
-                        goto done;
                 }
             } else {
                 capture_index++;
-                if (capture_index >= CAPTURE_COUNT_MAX)
-                    goto done;
             }
             break;
         case '\\':
@@ -1167,7 +1154,6 @@ static int re_parse_captures(REParseState *s, int *phas_named_captures,
             break;
         }
     }
- done:
     if (capture_name)
         return -1;
     else
@@ -1243,27 +1229,14 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
             re_emit_op(s, REOP_prev);
         break;
     case '{':
-        if (s->is_utf16) {
-            return re_parse_error(s, "syntax error");
-        } else if (!is_digit(p[1])) {
-            /* Annex B: we accept '{' not followed by digits as a
-               normal atom */
+        /* As an extension (see ES6 annex B), we accept '{' not
+           followed by digits as a normal atom */
+        if (!isdigit(p[1])) {
+            if (s->is_utf16)
+                goto invalid_quant_count;
             goto parse_class_atom;
-        } else {
-            const uint8_t *p1 = p + 1;
-            /* Annex B: error if it is like a repetition count */
-            parse_digits(&p1, TRUE);
-            if (*p1 == ',') {
-                p1++;
-                if (is_digit(*p1)) {
-                    parse_digits(&p1, TRUE);
-                }
-            }
-            if (*p1 != '}') {
-                goto parse_class_atom;
-            }
         }
-        /* fall thru */
+        /* fall tru */
     case '*':
     case '+':
     case '?':
@@ -1308,8 +1281,6 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                     return -1;
                 re_emit_op(s, REOP_match);
                 /* jump after the 'match' after the lookahead is successful */
-                if (dbuf_error(&s->byte_code))
-                    return -1;
                 put_u32(s->byte_code.buf + pos, s->byte_code.size - (pos + 4));
             } else if (p[2] == '<') {
                 p += 3;
@@ -1403,7 +1374,7 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
             p += 2;
             c = 0;
             if (s->is_utf16) {
-                if (is_digit(*p)) {
+                if (isdigit(*p)) {
                     return re_parse_error(s, "invalid decimal escape in regular expression");
                 }
             } else {
@@ -1416,13 +1387,20 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                 }
             }
             goto normal_char;
-        case '1': case '2': case '3': case '4':
-        case '5': case '6': case '7': case '8':
-        case '9': 
+
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+        case '8':
+        case '9':
             {
                 const uint8_t *q = ++p;
                 
-                c = parse_digits(&p, FALSE);
+                c = parse_digits(&p);
                 if (c < 0 || (c >= s->capture_count && c >= re_count_captures(s))) {
                     if (!s->is_utf16) {
                         /* Annex B.1.4: accept legacy octal */
@@ -1442,7 +1420,7 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                         }
                         goto normal_char;
                     }
-                    return re_parse_error(s, "back reference out of range in regular expression");
+                    return re_parse_error(s, "back reference out of range in reguar expression");
                 }
             emit_back_reference:
                 last_atom_start = s->byte_code.size;
@@ -1519,38 +1497,32 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
             quant_max = 1;
             goto quantifier;
         case '{':
-            {
-                const uint8_t *p1 = p;
-                /* As an extension (see ES6 annex B), we accept '{' not
-                   followed by digits as a normal atom */
-                if (!is_digit(p[1])) {
-                    if (s->is_utf16)
-                        goto invalid_quant_count;
-                    break;
-                }
+            /* As an extension (see ES6 annex B), we accept '{' not
+               followed by digits as a normal atom */
+            if (!isdigit(p[1])) {
+                if (s->is_utf16)
+                    goto invalid_quant_count;
+                break;
+            }
+            p++;
+            quant_min = parse_digits(&p);
+            if (quant_min < 0) {
+            invalid_quant_count:
+                return re_parse_error(s, "invalid repetition count");
+            }
+            quant_max = quant_min;
+            if (*p == ',') {
                 p++;
-                quant_min = parse_digits(&p, TRUE);
-                quant_max = quant_min;
-                if (*p == ',') {
-                    p++;
-                    if (is_digit(*p)) {
-                        quant_max = parse_digits(&p, TRUE);
-                        if (quant_max < quant_min) {
-                        invalid_quant_count:
-                            return re_parse_error(s, "invalid repetition count");
-                        }
-                    } else {
-                        quant_max = INT32_MAX; /* infinity */
-                    }
-                }
-                if (*p != '}' && !s->is_utf16) {
-                    /* Annex B: normal atom if invalid '{' syntax */
-                    p = p1;
-                    break;
+                if (isdigit(*p)) {
+                    quant_max = parse_digits(&p);
+                    if (quant_max < 0 || quant_max < quant_min)
+                        goto invalid_quant_count;
+                } else {
+                    quant_max = INT32_MAX; /* infinity */
                 }
-                if (re_parse_expect(s, &p, '}'))
-                    return -1;
             }
+            if (re_parse_expect(s, &p, '}'))
+                return -1;
         quantifier:
             greedy = TRUE;
             if (*p == '?') {
@@ -1565,15 +1537,12 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                 
                 if (quant_max > 0) {
                     /* specific optimization for simple quantifiers */
-                    if (dbuf_error(&s->byte_code))
-                        goto out_of_memory;
                     len = re_is_simple_quantifier(s->byte_code.buf + last_atom_start,
                                                  s->byte_code.size - last_atom_start);
                     if (len > 0) {
                         re_emit_op(s, REOP_match);
                         
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 17))
-                            goto out_of_memory;
+                        dbuf_insert(&s->byte_code, last_atom_start, 17);
                         pos = last_atom_start;
                         s->byte_code.buf[pos++] = REOP_simple_greedy_quant;
                         put_u32(&s->byte_code.buf[pos],
@@ -1589,8 +1558,6 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                     }
                 }
                 
-                if (dbuf_error(&s->byte_code))
-                    goto out_of_memory;
                 add_zero_advance_check = (re_check_advance(s->byte_code.buf + last_atom_start,
                                                            s->byte_code.size - last_atom_start) == 0);
             } else {
@@ -1604,8 +1571,7 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                     /* need to reset the capture in case the atom is
                        not executed */
                     if (last_capture_count != s->capture_count) {
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 3))
-                            goto out_of_memory;
+                        dbuf_insert(&s->byte_code, last_atom_start, 3);
                         s->byte_code.buf[last_atom_start++] = REOP_save_reset;
                         s->byte_code.buf[last_atom_start++] = last_capture_count;
                         s->byte_code.buf[last_atom_start++] = s->capture_count - 1;
@@ -1613,14 +1579,12 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                     if (quant_max == 0) {
                         s->byte_code.size = last_atom_start;
                     } else if (quant_max == 1) {
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))
-                            goto out_of_memory;
+                        dbuf_insert(&s->byte_code, last_atom_start, 5);
                         s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
                             greedy;
                         put_u32(s->byte_code.buf + last_atom_start + 1, len);
                     } else if (quant_max == INT32_MAX) {
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 5 + add_zero_advance_check))
-                            goto out_of_memory;
+                        dbuf_insert(&s->byte_code, last_atom_start, 5 + add_zero_advance_check);
                         s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
                             greedy;
                         put_u32(s->byte_code.buf + last_atom_start + 1,
@@ -1636,8 +1600,7 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                             re_emit_goto(s, REOP_goto, last_atom_start);
                         }
                     } else {
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 10))
-                            goto out_of_memory;
+                        dbuf_insert(&s->byte_code, last_atom_start, 10);
                         pos = last_atom_start;
                         s->byte_code.buf[pos++] = REOP_push_i32;
                         put_u32(s->byte_code.buf + pos, quant_max);
@@ -1655,8 +1618,7 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
                     if (quant_min == 1) {
                         /* nothing to add */
                     } else {
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))
-                            goto out_of_memory;
+                        dbuf_insert(&s->byte_code, last_atom_start, 5);
                         s->byte_code.buf[last_atom_start] = REOP_push_i32;
                         put_u32(s->byte_code.buf + last_atom_start + 1,
                                 quant_min);
@@ -1697,8 +1659,6 @@ static int re_parse_term(REParseState *s, BOOL is_backward_dir)
  done:
     s->buf_ptr = p;
     return 0;
- out_of_memory:
-    return re_parse_out_of_memory(s);
 }
 
 static int re_parse_alternative(REParseState *s, BOOL is_backward_dir)
@@ -1739,9 +1699,6 @@ static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir)
 {
     int start, len, pos;
 
-    if (lre_check_stack_overflow(s->opaque, 0))
-        return re_parse_error(s, "stack overflow");
-    
     start = s->byte_code.size;
     if (re_parse_alternative(s, is_backward_dir))
         return -1;
@@ -1751,9 +1708,7 @@ static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir)
         len = s->byte_code.size - start;
 
         /* insert a split before the first alternative */
-        if (dbuf_insert(&s->byte_code, start, 5)) {
-            return re_parse_out_of_memory(s);
-        }
+        dbuf_insert(&s->byte_code, start, 5);
         s->byte_code.buf[start] = REOP_split_next_first;
         put_u32(s->byte_code.buf + start + 1, len + 5);
 
@@ -1770,7 +1725,7 @@ static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir)
 }
 
 /* the control flow is recursive so the analysis can be linear */
-static int compute_stack_size(const uint8_t *bc_buf, int bc_buf_len)
+static int re_compute_stack_size(const uint8_t *bc_buf, int bc_buf_len)
 {
     int stack_size, stack_size_max, pos, opcode, len;
     uint32_t val;
@@ -1827,7 +1782,7 @@ uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
     BOOL is_sticky;
     
     memset(s, 0, sizeof(*s));
-    s->opaque = opaque;
+    s->mem_opaque = opaque;
     s->buf_ptr = (const uint8_t *)buf;
     s->buf_end = s->buf_ptr + buf_len;
     s->buf_start = s->buf_ptr;
@@ -1878,11 +1833,11 @@ uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
     }
 
     if (dbuf_error(&s->byte_code)) {
-        re_parse_out_of_memory(s);
+        re_parse_error(s, "out of memory");
         goto error;
     }
     
-    stack_size = compute_stack_size(s->byte_code.buf, s->byte_code.size);
+    stack_size = re_compute_stack_size(s->byte_code.buf, s->byte_code.size);
     if (stack_size < 0) {
         re_parse_error(s, "too many imbricated quantifiers");
         goto error;
@@ -2544,17 +2499,6 @@ int lre_get_flags(const uint8_t *bc_buf)
     return bc_buf[RE_HEADER_FLAGS];
 }
 
-/* Return NULL if no group names. Otherwise, return a pointer to
-   'capture_count - 1' zero terminated UTF-8 strings. */
-const char *lre_get_groupnames(const uint8_t *bc_buf)
-{
-    uint32_t re_bytecode_len;
-    if ((lre_get_flags(bc_buf) & LRE_FLAG_NAMED_GROUPS) == 0)
-        return NULL;
-    re_bytecode_len = get_u32(bc_buf + 3);
-    return (const char *)(bc_buf + 7 + re_bytecode_len);
-}
-
 #ifdef TEST
 
 BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size)
diff --git a/libregexp.h b/libregexp.h
index 9aedb7e..cd0b24f 100644
--- a/libregexp.h
+++ b/libregexp.h
@@ -44,7 +44,6 @@ uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
                      void *opaque);
 int lre_get_capture_count(const uint8_t *bc_buf);
 int lre_get_flags(const uint8_t *bc_buf);
-const char *lre_get_groupnames(const uint8_t *bc_buf);
 int lre_exec(uint8_t **capture,
              const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,
              int cbuf_type, void *opaque);
diff --git a/libunicode-table.h b/libunicode-table.h
index 0ef2113..521f2f3 100644
--- a/libunicode-table.h
+++ b/libunicode-table.h
@@ -3,7 +3,7 @@
 
 #include <stdint.h>
 
-static const uint32_t case_conv_table1[361] = {
+static const uint32_t case_conv_table1[359] = {
     0x00209a30, 0x00309a00, 0x005a8173, 0x00601730,
     0x006c0730, 0x006f81b3, 0x00701700, 0x007c0700,
     0x007f8100, 0x00803040, 0x009801c3, 0x00988190,
@@ -86,18 +86,17 @@ static const uint32_t case_conv_table1[361] = {
     0x53cb1440, 0x53d50130, 0x53d58130, 0x53d60130,
     0x53d68130, 0x53d70130, 0x53d80130, 0x53d88130,
     0x53d90130, 0x53d98131, 0x53da0c40, 0x53e10240,
-    0x53e20131, 0x53e28130, 0x53e30130, 0x53e38440,
-    0x53fa8240, 0x55a98101, 0x55b85020, 0x7d8001b2,
-    0x7d8081b2, 0x7d8101b2, 0x7d8181da, 0x7d8201da,
-    0x7d8281b3, 0x7d8301b3, 0x7d8981bb, 0x7d8a01bb,
-    0x7d8a81bb, 0x7d8b01bc, 0x7d8b81bb, 0x7f909a31,
-    0x7fa09a01, 0x82002831, 0x82142801, 0x82582431,
-    0x826c2401, 0x86403331, 0x86603301, 0x8c502031,
-    0x8c602001, 0xb7202031, 0xb7302001, 0xf4802231,
-    0xf4912201,
+    0x53e20131, 0x53e28130, 0x53e30130, 0x55a98101,
+    0x55b85020, 0x7d8001b2, 0x7d8081b2, 0x7d8101b2,
+    0x7d8181da, 0x7d8201da, 0x7d8281b3, 0x7d8301b3,
+    0x7d8981bb, 0x7d8a01bb, 0x7d8a81bb, 0x7d8b01bc,
+    0x7d8b81bb, 0x7f909a31, 0x7fa09a01, 0x82002831,
+    0x82142801, 0x82582431, 0x826c2401, 0x86403331,
+    0x86603301, 0x8c502031, 0x8c602001, 0xb7202031,
+    0xb7302001, 0xf4802231, 0xf4912201,
 };
 
-static const uint8_t case_conv_table2[361] = {
+static const uint8_t case_conv_table2[359] = {
     0x01, 0x00, 0x9c, 0x06, 0x07, 0x4d, 0x03, 0x04,
     0x10, 0x00, 0x8f, 0x0b, 0x00, 0x00, 0x11, 0x00,
     0x08, 0x00, 0x53, 0x4a, 0x51, 0x00, 0x52, 0x00,
@@ -119,7 +118,7 @@ static const uint8_t case_conv_table2[361] = {
     0x33, 0x95, 0x00, 0x8e, 0x00, 0x74, 0x99, 0x98,
     0x97, 0x96, 0x00, 0x00, 0x9e, 0x00, 0x9c, 0x00,
     0xa1, 0xa0, 0x15, 0x2e, 0x2f, 0x30, 0xb4, 0xb5,
-    0x4e, 0xaa, 0xa9, 0x12, 0x14, 0x1e, 0x21, 0x22,
+    0x4c, 0xaa, 0xa9, 0x12, 0x14, 0x1e, 0x21, 0x22,
     0x22, 0x2a, 0x34, 0x35, 0xa6, 0xa7, 0x36, 0x1f,
     0x4a, 0x00, 0x00, 0x97, 0x01, 0x5a, 0xda, 0x1d,
     0x36, 0x05, 0x00, 0xc4, 0xc3, 0xc6, 0xc5, 0xc8,
@@ -138,12 +137,11 @@ static const uint8_t case_conv_table2[361] = {
     0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0xa3, 0xa4,
     0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00,
     0x00, 0x5a, 0x00, 0x48, 0x00, 0x5b, 0x56, 0x58,
-    0x60, 0x5e, 0x70, 0x69, 0x6f, 0x4d, 0x00, 0x00,
-    0x3b, 0x67, 0xb8, 0x00, 0x00, 0x45, 0xa8, 0x8a,
-    0x8b, 0x8c, 0xab, 0xac, 0x58, 0x58, 0xaf, 0x94,
-    0xb0, 0x6f, 0xb2, 0x5c, 0x5b, 0x5e, 0x5d, 0x60,
-    0x5f, 0x62, 0x61, 0x64, 0x63, 0x66, 0x65, 0x68,
-    0x67,
+    0x60, 0x5e, 0x70, 0x69, 0x6f, 0x4b, 0x00, 0x00,
+    0x3b, 0x67, 0xb8, 0x45, 0xa8, 0x8a, 0x8b, 0x8c,
+    0xab, 0xac, 0x58, 0x58, 0xaf, 0x94, 0xb0, 0x6f,
+    0xb2, 0x5a, 0x59, 0x5c, 0x5b, 0x5e, 0x5d, 0x60,
+    0x5f, 0x62, 0x61, 0x64, 0x63, 0x66, 0x65,
 };
 
 static const uint16_t case_conv_ext[58] = {
@@ -172,7 +170,7 @@ static const uint8_t unicode_prop_Cased1_table[172] = {
     0x26, 0x01, 0x01, 0x86, 0xe5, 0x80, 0x60, 0x79,
     0xb6, 0x81, 0x40, 0x91, 0x81, 0xbd, 0x88, 0x94,
     0x05, 0x80, 0x98, 0x80, 0xc7, 0x82, 0x43, 0x34,
-    0xa2, 0x06, 0x80, 0x8c, 0x61, 0x28, 0x96, 0xd4,
+    0xa2, 0x06, 0x80, 0x8b, 0x61, 0x28, 0x97, 0xd4,
     0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b,
     0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80,
     0x9b, 0x03, 0x04, 0x00, 0x16, 0x80, 0x41, 0x53,
@@ -188,109 +186,107 @@ static const uint8_t unicode_prop_Cased1_index[18] = {
     0xf1, 0x01,
 };
 
-static const uint8_t unicode_prop_Case_Ignorable_table[692] = {
+static const uint8_t unicode_prop_Case_Ignorable_table[678] = {
     0xa6, 0x05, 0x80, 0x8a, 0x80, 0xa2, 0x00, 0x80,
     0xc6, 0x03, 0x00, 0x03, 0x01, 0x81, 0x41, 0xf6,
     0x40, 0xbf, 0x19, 0x18, 0x88, 0x08, 0x80, 0x40,
-    0xfa, 0x86, 0x40, 0xce, 0x04, 0x80, 0xb0, 0xac,
-    0x00, 0x01, 0x01, 0x00, 0xab, 0x80, 0x8a, 0x85,
-    0x89, 0x8a, 0x00, 0xa2, 0x80, 0x89, 0x94, 0x8f,
-    0x80, 0xe4, 0x38, 0x89, 0x03, 0xa0, 0x00, 0x80,
-    0x9d, 0x9a, 0xda, 0x8a, 0xb9, 0x8a, 0x18, 0x08,
-    0x97, 0x97, 0xaa, 0x82, 0xf6, 0xaf, 0xb6, 0x00,
-    0x03, 0x3b, 0x02, 0x86, 0x89, 0x81, 0x8c, 0x80,
-    0x8e, 0x80, 0xb9, 0x03, 0x1f, 0x80, 0x93, 0x81,
-    0x99, 0x01, 0x81, 0xb8, 0x03, 0x0b, 0x09, 0x12,
-    0x80, 0x9d, 0x0a, 0x80, 0x8a, 0x81, 0xb8, 0x03,
-    0x20, 0x0b, 0x80, 0x93, 0x81, 0x95, 0x28, 0x80,
-    0xb9, 0x01, 0x00, 0x1f, 0x06, 0x81, 0x8a, 0x81,
-    0x9d, 0x80, 0xbc, 0x80, 0x8b, 0x80, 0xb1, 0x02,
-    0x80, 0xb8, 0x14, 0x10, 0x1e, 0x81, 0x8a, 0x81,
-    0x9c, 0x80, 0xb9, 0x01, 0x05, 0x04, 0x81, 0x93,
-    0x81, 0x9b, 0x81, 0xb8, 0x0b, 0x1f, 0x80, 0x93,
-    0x81, 0x9c, 0x80, 0xc7, 0x06, 0x10, 0x80, 0xd9,
-    0x01, 0x86, 0x8a, 0x88, 0xe1, 0x01, 0x88, 0x88,
-    0x00, 0x85, 0xc9, 0x81, 0x9a, 0x00, 0x00, 0x80,
-    0xb6, 0x8d, 0x04, 0x01, 0x84, 0x8a, 0x80, 0xa3,
-    0x88, 0x80, 0xe5, 0x18, 0x28, 0x09, 0x81, 0x98,
-    0x0b, 0x82, 0x8f, 0x83, 0x8c, 0x01, 0x0d, 0x80,
-    0x8e, 0x80, 0xdd, 0x80, 0x42, 0x5f, 0x82, 0x43,
-    0xb1, 0x82, 0x9c, 0x82, 0x9c, 0x81, 0x9d, 0x81,
-    0xbf, 0x08, 0x37, 0x01, 0x8a, 0x10, 0x20, 0xac,
-    0x83, 0xb3, 0x80, 0xc0, 0x81, 0xa1, 0x80, 0xf5,
-    0x13, 0x81, 0x88, 0x05, 0x82, 0x40, 0xda, 0x09,
-    0x80, 0xb9, 0x00, 0x30, 0x00, 0x01, 0x3d, 0x89,
-    0x08, 0xa6, 0x07, 0x90, 0xbe, 0x83, 0xaf, 0x00,
-    0x20, 0x04, 0x80, 0xa7, 0x88, 0x8b, 0x81, 0x9f,
-    0x19, 0x08, 0x82, 0xb7, 0x00, 0x0a, 0x00, 0x82,
-    0xb9, 0x39, 0x81, 0xbf, 0x85, 0xd1, 0x10, 0x8c,
-    0x06, 0x18, 0x28, 0x11, 0xb1, 0xbe, 0x8c, 0x80,
-    0xa1, 0xde, 0x04, 0x41, 0xbc, 0x00, 0x82, 0x8a,
-    0x82, 0x8c, 0x82, 0x8c, 0x82, 0x8c, 0x81, 0x8b,
-    0x27, 0x81, 0x89, 0x01, 0x01, 0x84, 0xb0, 0x20,
-    0x89, 0x00, 0x8c, 0x80, 0x8f, 0x8c, 0xb2, 0xa0,
-    0x4b, 0x8a, 0x81, 0xf0, 0x82, 0xfc, 0x80, 0x8e,
-    0x80, 0xdf, 0x9f, 0xae, 0x80, 0x41, 0xd4, 0x80,
-    0xa3, 0x1a, 0x24, 0x80, 0xdc, 0x85, 0xdc, 0x82,
-    0x60, 0x6f, 0x15, 0x80, 0x44, 0xe1, 0x85, 0x41,
-    0x0d, 0x80, 0xe1, 0x18, 0x89, 0x00, 0x9b, 0x83,
-    0xcf, 0x81, 0x8d, 0xa1, 0xcd, 0x80, 0x96, 0x82,
-    0xec, 0x0f, 0x02, 0x03, 0x80, 0x98, 0x0c, 0x80,
-    0x40, 0x96, 0x81, 0x99, 0x91, 0x8c, 0x80, 0xa5,
-    0x87, 0x98, 0x8a, 0xad, 0x82, 0xaf, 0x01, 0x19,
-    0x81, 0x90, 0x80, 0x94, 0x81, 0xc1, 0x29, 0x09,
-    0x81, 0x8b, 0x07, 0x80, 0xa2, 0x80, 0x8a, 0x80,
-    0xb2, 0x00, 0x11, 0x0c, 0x08, 0x80, 0x9a, 0x80,
-    0x8d, 0x0c, 0x08, 0x80, 0xe3, 0x84, 0x88, 0x82,
-    0xf8, 0x01, 0x03, 0x80, 0x60, 0x4f, 0x2f, 0x80,
-    0x40, 0x92, 0x8f, 0x42, 0x3d, 0x8f, 0x10, 0x8b,
-    0x8f, 0xa1, 0x01, 0x80, 0x40, 0xa8, 0x06, 0x05,
-    0x80, 0x8a, 0x80, 0xa2, 0x00, 0x80, 0xae, 0x80,
-    0xac, 0x81, 0xc2, 0x80, 0x94, 0x82, 0x42, 0x00,
-    0x80, 0x40, 0xe1, 0x80, 0x40, 0x94, 0x84, 0x46,
-    0x85, 0x10, 0x0c, 0x83, 0xa7, 0x13, 0x80, 0x40,
-    0xa4, 0x81, 0x42, 0x3c, 0x83, 0x41, 0x82, 0x81,
-    0x40, 0x98, 0x8a, 0x40, 0xaf, 0x80, 0xb5, 0x8e,
+    0xfa, 0x86, 0x40, 0xce, 0x80, 0xb6, 0xac, 0x00,
+    0x01, 0x01, 0x00, 0xab, 0x80, 0x8a, 0x85, 0x89,
+    0x8a, 0x00, 0xa2, 0x80, 0x89, 0x94, 0x8f, 0x80,
+    0xe4, 0x38, 0x89, 0x03, 0xa0, 0x00, 0x80, 0x9d,
+    0x9a, 0xda, 0x8a, 0xb9, 0x8a, 0x18, 0x08, 0x97,
+    0x97, 0xaa, 0x82, 0xf6, 0xaf, 0xb6, 0x00, 0x03,
+    0x3b, 0x02, 0x86, 0x89, 0x81, 0x8c, 0x80, 0x8e,
+    0x80, 0xb9, 0x03, 0x1f, 0x80, 0x93, 0x81, 0x99,
+    0x01, 0x81, 0xb8, 0x03, 0x0b, 0x09, 0x12, 0x80,
+    0x9d, 0x0a, 0x80, 0x8a, 0x81, 0xb8, 0x03, 0x20,
+    0x0b, 0x80, 0x93, 0x81, 0x95, 0x28, 0x80, 0xb9,
+    0x01, 0x00, 0x1f, 0x07, 0x80, 0x8a, 0x81, 0x9d,
+    0x80, 0xbc, 0x80, 0x8b, 0x80, 0xb1, 0x02, 0x80,
+    0xb8, 0x14, 0x10, 0x1e, 0x81, 0x8a, 0x81, 0x9c,
+    0x80, 0xb9, 0x01, 0x05, 0x04, 0x81, 0x93, 0x81,
+    0x9b, 0x81, 0xb8, 0x0b, 0x1f, 0x80, 0x93, 0x81,
+    0xe5, 0x06, 0x10, 0x80, 0xd9, 0x01, 0x86, 0x8a,
+    0x88, 0xe1, 0x01, 0x88, 0x88, 0x00, 0x85, 0xc9,
+    0x81, 0x9a, 0x00, 0x00, 0x80, 0xb6, 0x8d, 0x04,
+    0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88, 0x80, 0xe5,
+    0x18, 0x28, 0x09, 0x81, 0x98, 0x0b, 0x82, 0x8f,
+    0x83, 0x8c, 0x01, 0x0d, 0x80, 0x8e, 0x80, 0xdd,
+    0x80, 0x42, 0x5f, 0x82, 0x43, 0xb1, 0x82, 0x9c,
+    0x82, 0x9c, 0x81, 0x9d, 0x81, 0xbf, 0x08, 0x37,
+    0x01, 0x8a, 0x10, 0x20, 0xac, 0x83, 0xb3, 0x80,
+    0xc0, 0x81, 0xa1, 0x80, 0xf5, 0x13, 0x81, 0x88,
+    0x05, 0x82, 0x40, 0xda, 0x09, 0x80, 0xb9, 0x00,
+    0x30, 0x00, 0x01, 0x3d, 0x89, 0x08, 0xa6, 0x07,
+    0x8e, 0xc0, 0x83, 0xaf, 0x00, 0x20, 0x04, 0x80,
+    0xa7, 0x88, 0x8b, 0x81, 0x9f, 0x19, 0x08, 0x82,
+    0xb7, 0x00, 0x0a, 0x00, 0x82, 0xb9, 0x39, 0x81,
+    0xbf, 0x85, 0xd1, 0x10, 0x8c, 0x06, 0x18, 0x28,
+    0x11, 0xb1, 0xbe, 0x8c, 0x80, 0xa1, 0xde, 0x04,
+    0x41, 0xbc, 0x00, 0x82, 0x8a, 0x82, 0x8c, 0x82,
+    0x8c, 0x82, 0x8c, 0x81, 0x8b, 0x27, 0x81, 0x89,
+    0x01, 0x01, 0x84, 0xb0, 0x20, 0x89, 0x00, 0x8c,
+    0x80, 0x8f, 0x8c, 0xb2, 0xa0, 0x4b, 0x8a, 0x81,
+    0xf0, 0x82, 0xfc, 0x80, 0x8e, 0x80, 0xdf, 0x9f,
+    0xae, 0x80, 0x41, 0xd4, 0x80, 0xa3, 0x1a, 0x24,
+    0x80, 0xdc, 0x85, 0xdc, 0x82, 0x60, 0x6f, 0x15,
+    0x80, 0x44, 0xe1, 0x85, 0x41, 0x0d, 0x80, 0xe1,
+    0x18, 0x89, 0x00, 0x9b, 0x83, 0xcf, 0x81, 0x8d,
+    0xa1, 0xcd, 0x80, 0x96, 0x82, 0xec, 0x0f, 0x02,
+    0x03, 0x80, 0x98, 0x81, 0x40, 0x9c, 0x81, 0x99,
+    0x91, 0x8c, 0x80, 0xa5, 0x87, 0x98, 0x8a, 0xad,
+    0x82, 0xaf, 0x01, 0x19, 0x81, 0x90, 0x80, 0x94,
+    0x81, 0xc1, 0x29, 0x09, 0x81, 0x8b, 0x07, 0x80,
+    0xa2, 0x80, 0x8a, 0x80, 0xb2, 0x00, 0x11, 0x0c,
+    0x08, 0x80, 0x9a, 0x80, 0x8d, 0x0c, 0x08, 0x80,
+    0xe3, 0x84, 0x40, 0x84, 0x01, 0x03, 0x80, 0x60,
+    0x4f, 0x2f, 0x80, 0x40, 0x92, 0x8f, 0x42, 0x3d,
+    0x8f, 0x10, 0x8b, 0x8f, 0xa1, 0x01, 0x80, 0x40,
+    0xa8, 0x06, 0x05, 0x80, 0x8a, 0x80, 0xa2, 0x00,
+    0x80, 0xae, 0x80, 0xac, 0x81, 0xc2, 0x80, 0x94,
+    0x82, 0x42, 0x00, 0x80, 0x40, 0xe1, 0x80, 0x40,
+    0x94, 0x84, 0x46, 0x85, 0x10, 0x0c, 0x83, 0xa7,
+    0x13, 0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x83,
+    0x42, 0x1d, 0x8a, 0x40, 0xaf, 0x80, 0xb5, 0x8e,
     0xb7, 0x82, 0xb0, 0x19, 0x09, 0x80, 0x8e, 0x80,
     0xb1, 0x82, 0xa3, 0x20, 0x87, 0xbd, 0x80, 0x8b,
-    0x81, 0xb3, 0x88, 0x89, 0x19, 0x80, 0xde, 0x11,
-    0x00, 0x0d, 0x80, 0x40, 0x9f, 0x02, 0x87, 0x94,
-    0x81, 0xb8, 0x0a, 0x80, 0xa4, 0x32, 0x84, 0x40,
-    0xc2, 0x39, 0x10, 0x80, 0x96, 0x80, 0xd3, 0x28,
-    0x03, 0x08, 0x81, 0x40, 0xed, 0x1d, 0x08, 0x81,
-    0x9a, 0x81, 0xd4, 0x39, 0x00, 0x81, 0xe9, 0x00,
-    0x01, 0x28, 0x80, 0xe4, 0x11, 0x18, 0x84, 0x41,
-    0x02, 0x88, 0x01, 0x40, 0xff, 0x08, 0x03, 0x80,
-    0x40, 0x8f, 0x19, 0x0b, 0x80, 0x9f, 0x89, 0xa7,
-    0x29, 0x1f, 0x80, 0x88, 0x29, 0x82, 0xad, 0x8c,
-    0x01, 0x41, 0x95, 0x30, 0x28, 0x80, 0xd1, 0x95,
-    0x0e, 0x01, 0x01, 0xf9, 0x2a, 0x00, 0x08, 0x30,
-    0x80, 0xc7, 0x0a, 0x00, 0x80, 0x41, 0x5a, 0x81,
-    0x55, 0x3a, 0x88, 0x60, 0x36, 0xb6, 0x84, 0xba,
-    0x86, 0x88, 0x83, 0x44, 0x0a, 0x80, 0xbe, 0x90,
-    0xbf, 0x08, 0x81, 0x60, 0x4c, 0xb7, 0x08, 0x83,
-    0x54, 0xc2, 0x82, 0x88, 0x8f, 0x0e, 0x9d, 0x83,
-    0x40, 0x93, 0x82, 0x47, 0xba, 0xb6, 0x83, 0xb1,
-    0x38, 0x8d, 0x80, 0x95, 0x20, 0x8e, 0x45, 0x4f,
-    0x30, 0x90, 0x0e, 0x01, 0x04, 0x41, 0x04, 0x8d,
-    0x41, 0xad, 0x83, 0x45, 0xdf, 0x86, 0xec, 0x87,
-    0x4a, 0xae, 0x84, 0x6c, 0x0c, 0x00, 0x80, 0x9d,
-    0xdf, 0xff, 0x40, 0xef,
+    0x81, 0xb3, 0x88, 0x89, 0x83, 0xe1, 0x11, 0x00,
+    0x0d, 0x80, 0x40, 0x9f, 0x02, 0x87, 0x94, 0x81,
+    0xb8, 0x0a, 0x80, 0xa4, 0x32, 0x84, 0x40, 0xc2,
+    0x39, 0x10, 0x80, 0x96, 0x80, 0xd3, 0x28, 0x03,
+    0x08, 0x81, 0x40, 0xed, 0x1d, 0x08, 0x81, 0x9a,
+    0x81, 0xd4, 0x39, 0x00, 0x81, 0xe9, 0x00, 0x01,
+    0x28, 0x80, 0xe4, 0x11, 0x18, 0x84, 0x41, 0x02,
+    0x88, 0x01, 0x41, 0x98, 0x19, 0x0b, 0x80, 0x9f,
+    0x89, 0xa7, 0x29, 0x1f, 0x80, 0x88, 0x29, 0x82,
+    0xad, 0x8c, 0x01, 0x41, 0x95, 0x30, 0x28, 0x80,
+    0xd1, 0x95, 0x0e, 0x01, 0x01, 0xf9, 0x2a, 0x00,
+    0x08, 0x30, 0x80, 0xc7, 0x0a, 0x00, 0x80, 0x41,
+    0x5a, 0x81, 0x55, 0x3a, 0x88, 0x60, 0x36, 0xb6,
+    0x84, 0xba, 0x86, 0x88, 0x83, 0x44, 0x0a, 0x80,
+    0xbe, 0x90, 0xbf, 0x08, 0x80, 0x60, 0x4c, 0xb8,
+    0x08, 0x83, 0x54, 0xc2, 0x82, 0x88, 0x8f, 0x0e,
+    0x9d, 0x83, 0x40, 0x93, 0x82, 0x47, 0xba, 0xb6,
+    0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20, 0x8e,
+    0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04, 0x41,
+    0x04, 0x8d, 0x41, 0xad, 0x83, 0x45, 0xdf, 0x86,
+    0xec, 0x87, 0x4a, 0xae, 0x84, 0x6c, 0x0c, 0x00,
+    0x80, 0x9d, 0xdf, 0xff, 0x40, 0xef,
 };
 
 static const uint8_t unicode_prop_Case_Ignorable_index[66] = {
-    0xbe, 0x05, 0x00, 0xfe, 0x07, 0x00, 0x52, 0x0a,
-    0x20, 0x05, 0x0c, 0x20, 0x3b, 0x0e, 0x40, 0x61,
-    0x10, 0x40, 0x0f, 0x18, 0x20, 0x43, 0x1b, 0x60,
-    0x79, 0x1d, 0x00, 0xf1, 0x20, 0x00, 0x0d, 0xa6,
-    0x40, 0x2e, 0xa9, 0x20, 0xde, 0xaa, 0x00, 0x0f,
-    0xff, 0x20, 0xe7, 0x0a, 0x41, 0x82, 0x11, 0x21,
-    0xc4, 0x14, 0x61, 0x44, 0x19, 0x01, 0x48, 0x1d,
-    0x21, 0xa4, 0xbc, 0x01, 0x3e, 0xe1, 0x01, 0xf0,
+    0xc0, 0x05, 0x00, 0x2e, 0x08, 0x20, 0x52, 0x0a,
+    0x00, 0x05, 0x0c, 0x00, 0x4f, 0x0e, 0x20, 0x75,
+    0x10, 0x20, 0x44, 0x18, 0x00, 0x43, 0x1b, 0x00,
+    0x00, 0x1e, 0x00, 0x7e, 0x2c, 0x00, 0x7e, 0xa6,
+    0x40, 0x83, 0xa9, 0x20, 0xf7, 0xaa, 0x00, 0x41,
+    0xff, 0x20, 0x28, 0x0d, 0x01, 0x3f, 0x12, 0x41,
+    0xde, 0x15, 0x21, 0x5c, 0x1a, 0x01, 0xf5, 0x6a,
+    0x21, 0x37, 0xda, 0x01, 0x02, 0x00, 0x2e, 0xf0,
     0x01, 0x0e,
 };
 
-static const uint8_t unicode_prop_ID_Start_table[1045] = {
+static const uint8_t unicode_prop_ID_Start_table[1024] = {
     0xc0, 0x99, 0x85, 0x99, 0xae, 0x80, 0x89, 0x03,
     0x04, 0x96, 0x80, 0x9e, 0x80, 0x41, 0xc9, 0x83,
     0x8b, 0x8d, 0x26, 0x00, 0x80, 0x40, 0x80, 0x20,
@@ -301,146 +297,142 @@ static const uint8_t unicode_prop_ID_Start_table[1045] = {
     0x89, 0x11, 0x80, 0x8f, 0x00, 0x9d, 0x9c, 0xd8,
     0x8a, 0x80, 0x97, 0xa0, 0x88, 0x0b, 0x04, 0x95,
     0x18, 0x88, 0x02, 0x80, 0x96, 0x98, 0x86, 0x8a,
-    0xb4, 0x94, 0x80, 0x91, 0xbb, 0xb5, 0x10, 0x91,
-    0x06, 0x89, 0x8e, 0x8f, 0x1f, 0x09, 0x81, 0x95,
-    0x06, 0x00, 0x13, 0x10, 0x8f, 0x80, 0x8c, 0x08,
-    0x82, 0x8d, 0x81, 0x89, 0x07, 0x2b, 0x09, 0x95,
-    0x06, 0x01, 0x01, 0x01, 0x9e, 0x18, 0x80, 0x92,
-    0x82, 0x8f, 0x88, 0x02, 0x80, 0x95, 0x06, 0x01,
-    0x04, 0x10, 0x91, 0x80, 0x8e, 0x81, 0x96, 0x80,
-    0x8a, 0x39, 0x09, 0x95, 0x06, 0x01, 0x04, 0x10,
-    0x9d, 0x08, 0x82, 0x8e, 0x80, 0x90, 0x00, 0x2a,
-    0x10, 0x1a, 0x08, 0x00, 0x0a, 0x0a, 0x12, 0x8b,
-    0x95, 0x80, 0xb3, 0x38, 0x10, 0x96, 0x80, 0x8f,
-    0x10, 0x99, 0x14, 0x81, 0x9d, 0x03, 0x38, 0x10,
-    0x96, 0x80, 0x89, 0x04, 0x10, 0x9f, 0x00, 0x81,
-    0x8e, 0x81, 0x90, 0x88, 0x02, 0x80, 0xa8, 0x08,
-    0x8f, 0x04, 0x17, 0x82, 0x97, 0x2c, 0x91, 0x82,
-    0x97, 0x80, 0x88, 0x00, 0x0e, 0xb9, 0xaf, 0x01,
-    0x8b, 0x86, 0xb9, 0x08, 0x00, 0x20, 0x97, 0x00,
-    0x80, 0x89, 0x01, 0x88, 0x01, 0x20, 0x80, 0x94,
-    0x83, 0x9f, 0x80, 0xbe, 0x38, 0xa3, 0x9a, 0x84,
-    0xf2, 0xaa, 0x93, 0x80, 0x8f, 0x2b, 0x1a, 0x02,
-    0x0e, 0x13, 0x8c, 0x8b, 0x80, 0x90, 0xa5, 0x00,
-    0x20, 0x81, 0xaa, 0x80, 0x41, 0x4c, 0x03, 0x0e,
-    0x00, 0x03, 0x81, 0xa8, 0x03, 0x81, 0xa0, 0x03,
-    0x0e, 0x00, 0x03, 0x81, 0x8e, 0x80, 0xb8, 0x03,
-    0x81, 0xc2, 0xa4, 0x8f, 0x8f, 0xd5, 0x0d, 0x82,
-    0x42, 0x6b, 0x81, 0x90, 0x80, 0x99, 0x84, 0xca,
-    0x82, 0x8a, 0x86, 0x8c, 0x03, 0x8d, 0x91, 0x8d,
-    0x91, 0x8d, 0x8c, 0x02, 0x8e, 0xb3, 0xa2, 0x03,
-    0x80, 0xc2, 0xd8, 0x86, 0xa8, 0x00, 0x84, 0xc5,
-    0x89, 0x9e, 0xb0, 0x9d, 0x0c, 0x8a, 0xab, 0x83,
-    0x99, 0xb5, 0x96, 0x88, 0xb4, 0xd1, 0x80, 0xdc,
-    0xae, 0x90, 0x86, 0xb6, 0x9d, 0x8c, 0x81, 0x89,
-    0xab, 0x99, 0xa3, 0xa8, 0x82, 0x89, 0xa3, 0x81,
-    0x88, 0x86, 0xaa, 0x0a, 0xa8, 0x18, 0x28, 0x0a,
-    0x04, 0x40, 0xbf, 0xbf, 0x41, 0x15, 0x0d, 0x81,
-    0xa5, 0x0d, 0x0f, 0x00, 0x00, 0x00, 0x80, 0x9e,
-    0x81, 0xb4, 0x06, 0x00, 0x12, 0x06, 0x13, 0x0d,
-    0x83, 0x8c, 0x22, 0x06, 0xf3, 0x80, 0x8c, 0x80,
-    0x8f, 0x8c, 0xe4, 0x03, 0x01, 0x89, 0x00, 0x0d,
-    0x28, 0x00, 0x00, 0x80, 0x8f, 0x0b, 0x24, 0x18,
-    0x90, 0xa8, 0x4a, 0x76, 0xae, 0x80, 0xae, 0x80,
-    0x40, 0x84, 0x2b, 0x11, 0x8b, 0xa5, 0x00, 0x20,
-    0x81, 0xb7, 0x30, 0x8f, 0x96, 0x88, 0x30, 0x30,
-    0x30, 0x30, 0x30, 0x30, 0x30, 0x86, 0x42, 0x25,
-    0x82, 0x98, 0x88, 0x34, 0x0c, 0x83, 0xd5, 0x1c,
-    0x80, 0xd9, 0x03, 0x84, 0xaa, 0x80, 0xdd, 0x90,
-    0x9f, 0xaf, 0x8f, 0x41, 0xff, 0x59, 0xbf, 0xbf,
-    0x60, 0x51, 0xfc, 0x82, 0x44, 0x8c, 0xc2, 0xad,
-    0x81, 0x41, 0x0c, 0x82, 0x8f, 0x89, 0x81, 0x93,
-    0xae, 0x8f, 0x9e, 0x81, 0xcf, 0xa6, 0x88, 0x81,
-    0xe6, 0x81, 0xb4, 0x81, 0x88, 0xa9, 0x8c, 0x02,
-    0x03, 0x80, 0x96, 0x9c, 0xb3, 0x8d, 0xb1, 0xbd,
-    0x2a, 0x00, 0x81, 0x8a, 0x9b, 0x89, 0x96, 0x98,
-    0x9c, 0x86, 0xae, 0x9b, 0x80, 0x8f, 0x20, 0x89,
-    0x89, 0x20, 0xa8, 0x96, 0x10, 0x87, 0x93, 0x96,
-    0x10, 0x82, 0xb1, 0x00, 0x11, 0x0c, 0x08, 0x00,
-    0x97, 0x11, 0x8a, 0x32, 0x8b, 0x29, 0x29, 0x85,
-    0x88, 0x30, 0x30, 0xaa, 0x80, 0x8d, 0x85, 0xf2,
-    0x9c, 0x60, 0x2b, 0xa3, 0x8b, 0x96, 0x83, 0xb0,
-    0x60, 0x21, 0x03, 0x41, 0x6d, 0x81, 0xe9, 0xa5,
-    0x86, 0x8b, 0x24, 0x00, 0x89, 0x80, 0x8c, 0x04,
-    0x00, 0x01, 0x01, 0x80, 0xeb, 0xa0, 0x41, 0x6a,
-    0x91, 0xbf, 0x81, 0xb5, 0xa7, 0x8b, 0xf3, 0x20,
-    0x40, 0x86, 0xa3, 0x99, 0x85, 0x99, 0x8a, 0xd8,
-    0x15, 0x0d, 0x0d, 0x0a, 0xa2, 0x8b, 0x80, 0x99,
-    0x80, 0x92, 0x01, 0x80, 0x8e, 0x81, 0x8d, 0xa1,
-    0xfa, 0xc4, 0xb4, 0x41, 0x0a, 0x9c, 0x82, 0xb0,
-    0xae, 0x9f, 0x8c, 0x9d, 0x84, 0xa5, 0x89, 0x9d,
-    0x81, 0xa3, 0x1f, 0x04, 0xa9, 0x40, 0x9d, 0x91,
-    0xa3, 0x83, 0xa3, 0x83, 0xa7, 0x87, 0xb3, 0x40,
-    0x9b, 0x41, 0x36, 0x88, 0x95, 0x89, 0x87, 0x40,
-    0x97, 0x29, 0x00, 0xab, 0x01, 0x10, 0x81, 0x96,
-    0x89, 0x96, 0x88, 0x9e, 0xc0, 0x92, 0x01, 0x89,
-    0x95, 0x89, 0x99, 0xc5, 0xb7, 0x29, 0xbf, 0x80,
-    0x8e, 0x18, 0x10, 0x9c, 0xa9, 0x9c, 0x82, 0x9c,
-    0xa2, 0x38, 0x9b, 0x9a, 0xb5, 0x89, 0x95, 0x89,
-    0x92, 0x8c, 0x91, 0xed, 0xc8, 0xb6, 0xb2, 0x8c,
-    0xb2, 0x8c, 0xa3, 0x41, 0x5b, 0xa9, 0x29, 0xcd,
-    0x9c, 0x89, 0x07, 0x95, 0xe9, 0x94, 0x9a, 0x96,
-    0x8b, 0xb4, 0xca, 0xac, 0x9f, 0x98, 0x99, 0xa3,
-    0x9c, 0x01, 0x07, 0xa2, 0x10, 0x8b, 0xaf, 0x8d,
-    0x83, 0x94, 0x00, 0x80, 0xa2, 0x91, 0x80, 0x98,
-    0xd3, 0x30, 0x00, 0x18, 0x8e, 0x80, 0x89, 0x86,
-    0xae, 0xa5, 0x39, 0x09, 0x95, 0x06, 0x01, 0x04,
-    0x10, 0x91, 0x80, 0x8b, 0x84, 0x40, 0x9d, 0xb4,
-    0x91, 0x83, 0x93, 0x82, 0x9d, 0xaf, 0x93, 0x08,
-    0x80, 0x40, 0xb7, 0xae, 0xa8, 0x83, 0xa3, 0xaf,
-    0x93, 0x80, 0xba, 0xaa, 0x8c, 0x80, 0xc6, 0x9a,
-    0x40, 0xe4, 0xab, 0xf3, 0xbf, 0x9e, 0x39, 0x01,
-    0x38, 0x08, 0x97, 0x8e, 0x00, 0x80, 0xdd, 0x39,
-    0xa6, 0x8f, 0x00, 0x80, 0x9b, 0x80, 0x89, 0xa7,
-    0x30, 0x94, 0x80, 0x8a, 0xad, 0x92, 0x80, 0xa1,
-    0xb8, 0x41, 0x06, 0x88, 0x80, 0xa4, 0x90, 0x80,
-    0xb0, 0x9d, 0xef, 0x30, 0x08, 0xa5, 0x94, 0x80,
-    0x98, 0x28, 0x08, 0x9f, 0x8d, 0x80, 0x41, 0x46,
-    0x92, 0x40, 0xbc, 0x80, 0xce, 0x43, 0x99, 0xe5,
-    0xee, 0x90, 0x40, 0xc3, 0x4a, 0xbb, 0x44, 0x2e,
-    0x4f, 0xd0, 0x42, 0x46, 0x60, 0x21, 0xb8, 0x42,
-    0x38, 0x86, 0x9e, 0xf0, 0x9d, 0x91, 0xaf, 0x8f,
-    0x83, 0x9e, 0x94, 0x84, 0x92, 0x42, 0xaf, 0xbf,
-    0xff, 0xca, 0x20, 0xc1, 0x8c, 0xbf, 0x08, 0x80,
-    0x9b, 0x57, 0xf7, 0x87, 0x44, 0xd5, 0xa9, 0x88,
-    0x60, 0x22, 0xf6, 0x41, 0x1e, 0xb0, 0x82, 0x90,
-    0x1f, 0x41, 0x8b, 0x49, 0x03, 0xea, 0x84, 0x8c,
-    0x82, 0x88, 0x86, 0x89, 0x57, 0x65, 0xd4, 0x80,
-    0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00,
-    0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b,
-    0x03, 0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81,
-    0x98, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
-    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
-    0x9e, 0x80, 0x98, 0x07, 0x49, 0x33, 0xac, 0x89,
-    0x86, 0x8f, 0x80, 0x41, 0x70, 0xab, 0x45, 0x13,
-    0x40, 0xc4, 0xba, 0xc3, 0x30, 0x44, 0xb3, 0x18,
-    0x9a, 0x01, 0x00, 0x08, 0x80, 0x89, 0x03, 0x00,
-    0x00, 0x28, 0x18, 0x00, 0x00, 0x02, 0x01, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b,
-    0x06, 0x03, 0x03, 0x00, 0x80, 0x89, 0x80, 0x90,
-    0x22, 0x04, 0x80, 0x90, 0x51, 0x43, 0x60, 0xa6,
-    0xdd, 0xa1, 0x50, 0x34, 0x8a, 0x40, 0xdd, 0x81,
-    0x56, 0x81, 0x8d, 0x5d, 0x30, 0x4c, 0x1e, 0x42,
-    0x1d, 0x45, 0xe1, 0x53, 0x4a,
+    0xb4, 0x94, 0x07, 0xc5, 0xb5, 0x10, 0x91, 0x06,
+    0x89, 0x8e, 0x8f, 0x1f, 0x09, 0x81, 0x95, 0x06,
+    0x00, 0x13, 0x10, 0x8f, 0x80, 0x8c, 0x08, 0x82,
+    0x8d, 0x81, 0x89, 0x07, 0x2b, 0x09, 0x95, 0x06,
+    0x01, 0x01, 0x01, 0x9e, 0x18, 0x80, 0x92, 0x82,
+    0x8f, 0x88, 0x02, 0x80, 0x95, 0x06, 0x01, 0x04,
+    0x10, 0x91, 0x80, 0x8e, 0x81, 0x96, 0x80, 0x8a,
+    0x39, 0x09, 0x95, 0x06, 0x01, 0x04, 0x10, 0x9d,
+    0x08, 0x82, 0x8e, 0x80, 0x90, 0x00, 0x2a, 0x10,
+    0x1a, 0x08, 0x00, 0x0a, 0x0a, 0x12, 0x8b, 0x95,
+    0x80, 0xb3, 0x38, 0x10, 0x96, 0x80, 0x8f, 0x10,
+    0x99, 0x14, 0x81, 0x9d, 0x03, 0x38, 0x10, 0x96,
+    0x80, 0x89, 0x04, 0x10, 0x9f, 0x00, 0x81, 0x8e,
+    0x81, 0x91, 0x38, 0x10, 0xa8, 0x08, 0x8f, 0x04,
+    0x17, 0x82, 0x97, 0x2c, 0x91, 0x82, 0x97, 0x80,
+    0x88, 0x00, 0x0e, 0xb9, 0xaf, 0x01, 0x8b, 0x86,
+    0xb9, 0x08, 0x00, 0x20, 0x97, 0x00, 0x80, 0x89,
+    0x01, 0x88, 0x01, 0x20, 0x80, 0x94, 0x83, 0x9f,
+    0x80, 0xbe, 0x38, 0xa3, 0x9a, 0x84, 0xf2, 0xaa,
+    0x93, 0x80, 0x8f, 0x2b, 0x1a, 0x02, 0x0e, 0x13,
+    0x8c, 0x8b, 0x80, 0x90, 0xa5, 0x00, 0x20, 0x81,
+    0xaa, 0x80, 0x41, 0x4c, 0x03, 0x0e, 0x00, 0x03,
+    0x81, 0xa8, 0x03, 0x81, 0xa0, 0x03, 0x0e, 0x00,
+    0x03, 0x81, 0x8e, 0x80, 0xb8, 0x03, 0x81, 0xc2,
+    0xa4, 0x8f, 0x8f, 0xd5, 0x0d, 0x82, 0x42, 0x6b,
+    0x81, 0x90, 0x80, 0x99, 0x84, 0xca, 0x82, 0x8a,
+    0x86, 0x8c, 0x03, 0x8d, 0x91, 0x8d, 0x91, 0x8d,
+    0x8c, 0x02, 0x8e, 0xb3, 0xa2, 0x03, 0x80, 0xc2,
+    0xd8, 0x86, 0xa8, 0x00, 0x84, 0xc5, 0x89, 0x9e,
+    0xb0, 0x9d, 0x0c, 0x8a, 0xab, 0x83, 0x99, 0xb5,
+    0x96, 0x88, 0xb4, 0xd1, 0x80, 0xdc, 0xae, 0x90,
+    0x86, 0xb6, 0x9d, 0x8c, 0x81, 0x89, 0xab, 0x99,
+    0xa3, 0xa8, 0x82, 0x89, 0xa3, 0x81, 0x88, 0x86,
+    0xaa, 0x0a, 0xa8, 0x18, 0x28, 0x0a, 0x04, 0x40,
+    0xbf, 0xbf, 0x41, 0x15, 0x0d, 0x81, 0xa5, 0x0d,
+    0x0f, 0x00, 0x00, 0x00, 0x80, 0x9e, 0x81, 0xb4,
+    0x06, 0x00, 0x12, 0x06, 0x13, 0x0d, 0x83, 0x8c,
+    0x22, 0x06, 0xf3, 0x80, 0x8c, 0x80, 0x8f, 0x8c,
+    0xe4, 0x03, 0x01, 0x89, 0x00, 0x0d, 0x28, 0x00,
+    0x00, 0x80, 0x8f, 0x0b, 0x24, 0x18, 0x90, 0xa8,
+    0x4a, 0x76, 0xae, 0x80, 0xae, 0x80, 0x40, 0x84,
+    0x2b, 0x11, 0x8b, 0xa5, 0x00, 0x20, 0x81, 0xb7,
+    0x30, 0x8f, 0x96, 0x88, 0x30, 0x30, 0x30, 0x30,
+    0x30, 0x30, 0x30, 0x86, 0x42, 0x25, 0x82, 0x98,
+    0x88, 0x34, 0x0c, 0x83, 0xd5, 0x1c, 0x80, 0xd9,
+    0x03, 0x84, 0xaa, 0x80, 0xdd, 0x90, 0x9a, 0xb4,
+    0x8f, 0x41, 0xff, 0x59, 0xb5, 0xc9, 0x60, 0x51,
+    0xef, 0x8f, 0x44, 0x8c, 0xc2, 0xad, 0x81, 0x41,
+    0x0c, 0x82, 0x8f, 0x89, 0x81, 0x93, 0xae, 0x8f,
+    0x9e, 0x81, 0xcf, 0xa6, 0x88, 0x81, 0xe6, 0x81,
+    0xb4, 0x0c, 0xaf, 0x8a, 0x02, 0x03, 0x80, 0x96,
+    0x9c, 0xb3, 0x8d, 0xb1, 0xbd, 0x2a, 0x00, 0x81,
+    0x8a, 0x9b, 0x89, 0x96, 0x98, 0x9c, 0x86, 0xae,
+    0x9b, 0x80, 0x8f, 0x20, 0x89, 0x89, 0x20, 0xa8,
+    0x96, 0x10, 0x87, 0x93, 0x96, 0x10, 0x82, 0xb1,
+    0x00, 0x11, 0x0c, 0x08, 0x00, 0x97, 0x11, 0x8a,
+    0x32, 0x8b, 0x29, 0x29, 0x85, 0x88, 0x30, 0x30,
+    0xaa, 0x80, 0x8b, 0x87, 0xf2, 0x9c, 0x60, 0x2b,
+    0xa3, 0x8b, 0x96, 0x83, 0xb0, 0x60, 0x21, 0x03,
+    0x41, 0x6d, 0x81, 0xe9, 0xa5, 0x86, 0x8b, 0x24,
+    0x00, 0x89, 0x80, 0x8c, 0x04, 0x00, 0x01, 0x01,
+    0x80, 0xeb, 0xa0, 0x41, 0x6a, 0x91, 0xbf, 0x81,
+    0xb5, 0xa7, 0x8b, 0xf3, 0x20, 0x40, 0x86, 0xa3,
+    0x99, 0x85, 0x99, 0x8a, 0xd8, 0x15, 0x0d, 0x0d,
+    0x0a, 0xa2, 0x8b, 0x80, 0x99, 0x80, 0x92, 0x01,
+    0x80, 0x8e, 0x81, 0x8d, 0xa1, 0xfa, 0xc4, 0xb4,
+    0x41, 0x0a, 0x9c, 0x82, 0xb0, 0xae, 0x9f, 0x8c,
+    0x9d, 0x84, 0xa5, 0x89, 0x9d, 0x81, 0xa3, 0x1f,
+    0x04, 0xa9, 0x40, 0x9d, 0x91, 0xa3, 0x83, 0xa3,
+    0x83, 0xa7, 0x87, 0xb3, 0x40, 0x9b, 0x41, 0x36,
+    0x88, 0x95, 0x89, 0x87, 0x40, 0x97, 0x29, 0x00,
+    0xab, 0x01, 0x10, 0x81, 0x96, 0x89, 0x96, 0x88,
+    0x9e, 0xc0, 0x92, 0x01, 0x89, 0x95, 0x89, 0x99,
+    0xc5, 0xb7, 0x29, 0xbf, 0x80, 0x8e, 0x18, 0x10,
+    0x9c, 0xa9, 0x9c, 0x82, 0x9c, 0xa2, 0x38, 0x9b,
+    0x9a, 0xb5, 0x89, 0x95, 0x89, 0x92, 0x8c, 0x91,
+    0xed, 0xc8, 0xb6, 0xb2, 0x8c, 0xb2, 0x8c, 0xa3,
+    0x41, 0xdb, 0x9c, 0x89, 0x07, 0x95, 0x40, 0x99,
+    0x96, 0x8b, 0xb4, 0xca, 0xac, 0x9f, 0x98, 0x99,
+    0xa3, 0x9c, 0x80, 0x8a, 0xa2, 0x10, 0x8b, 0xaf,
+    0x8d, 0x83, 0x94, 0x00, 0x80, 0xa2, 0x91, 0x80,
+    0x98, 0xd3, 0x30, 0x00, 0x18, 0x8e, 0x80, 0x89,
+    0x86, 0xae, 0xa5, 0x39, 0x09, 0x95, 0x06, 0x01,
+    0x04, 0x10, 0x91, 0x80, 0x8b, 0x84, 0x40, 0x9d,
+    0xb4, 0x91, 0x83, 0x93, 0x80, 0x9f, 0xaf, 0x93,
+    0x08, 0x80, 0x40, 0xb7, 0xae, 0xa8, 0x83, 0xa3,
+    0xaf, 0x93, 0x80, 0xba, 0xaa, 0x8c, 0x80, 0xc6,
+    0x9a, 0x40, 0xe4, 0xab, 0xf3, 0xbf, 0x9e, 0x80,
+    0x40, 0x9f, 0x39, 0xa6, 0x8f, 0x00, 0x80, 0x9b,
+    0x80, 0x89, 0xa7, 0x30, 0x94, 0x80, 0x8a, 0xad,
+    0x92, 0x80, 0xa1, 0xb8, 0x41, 0x06, 0x88, 0x80,
+    0xa4, 0x90, 0x80, 0xb0, 0x9d, 0xef, 0x30, 0x08,
+    0xa5, 0x94, 0x80, 0x98, 0x28, 0x08, 0x9f, 0x8d,
+    0x80, 0x41, 0x46, 0x92, 0x41, 0x0c, 0x43, 0x99,
+    0xe5, 0xee, 0x90, 0x40, 0xc3, 0x4a, 0xbb, 0x44,
+    0x2e, 0x4f, 0xd0, 0x42, 0x46, 0x60, 0x21, 0xb8,
+    0x42, 0x38, 0x86, 0x9e, 0xf0, 0x9d, 0x91, 0xaf,
+    0x8f, 0x83, 0x9e, 0x94, 0x84, 0x92, 0x42, 0xaf,
+    0xbf, 0xff, 0xca, 0x20, 0xc1, 0x8c, 0xbf, 0x08,
+    0x80, 0x9b, 0x57, 0xf7, 0x87, 0x42, 0xf2, 0x60,
+    0x25, 0x0c, 0x41, 0x1e, 0xb0, 0x82, 0x90, 0x1f,
+    0x41, 0x8b, 0x49, 0x03, 0xea, 0x84, 0x8c, 0x82,
+    0x88, 0x86, 0x89, 0x57, 0x65, 0xd4, 0x80, 0xc6,
+    0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00, 0x06,
+    0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b, 0x03,
+    0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81, 0x98,
+    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80, 0x9e,
+    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80, 0x9e,
+    0x80, 0x98, 0x07, 0x49, 0x33, 0xac, 0x89, 0x86,
+    0x8f, 0x80, 0x41, 0x70, 0xab, 0x45, 0x13, 0x40,
+    0xc4, 0xba, 0xc3, 0x30, 0x44, 0xb3, 0x18, 0x9a,
+    0x01, 0x00, 0x08, 0x80, 0x89, 0x03, 0x00, 0x00,
+    0x28, 0x18, 0x00, 0x00, 0x02, 0x01, 0x00, 0x08,
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x06,
+    0x03, 0x03, 0x00, 0x80, 0x89, 0x80, 0x90, 0x22,
+    0x04, 0x80, 0x90, 0x51, 0x43, 0x60, 0xa6, 0xd6,
+    0xa8, 0x50, 0x34, 0x8a, 0x40, 0xdd, 0x81, 0x56,
+    0x81, 0x8d, 0x5d, 0x30, 0x4c, 0x1e, 0x42, 0x1d,
 };
 
-static const uint8_t unicode_prop_ID_Start_index[99] = {
-    0xf6, 0x03, 0x20, 0xa6, 0x07, 0x00, 0xa9, 0x09,
-    0x00, 0xb4, 0x0a, 0x00, 0xba, 0x0b, 0x00, 0x3e,
-    0x0d, 0x00, 0xe0, 0x0e, 0x20, 0x57, 0x12, 0x00,
-    0xeb, 0x16, 0x00, 0xca, 0x19, 0x20, 0xc0, 0x1d,
-    0x60, 0x80, 0x20, 0x00, 0x2e, 0x2d, 0x00, 0xc0,
-    0x31, 0x20, 0x89, 0xa7, 0x20, 0xf0, 0xa9, 0x00,
-    0xe3, 0xab, 0x00, 0x3e, 0xfd, 0x00, 0xfb, 0x00,
-    0x21, 0x37, 0x07, 0x61, 0x01, 0x0a, 0x01, 0x1d,
-    0x0f, 0x21, 0x2c, 0x12, 0x01, 0xc8, 0x14, 0x21,
-    0xd1, 0x19, 0x21, 0x47, 0x1d, 0x01, 0x39, 0x6a,
-    0x21, 0x09, 0x8d, 0x01, 0xbc, 0xd4, 0x01, 0xa9,
-    0xd7, 0x21, 0x3a, 0xee, 0x01, 0xde, 0xa6, 0x22,
-    0x4b, 0x13, 0x03,
+static const uint8_t unicode_prop_ID_Start_index[96] = {
+    0xf6, 0x03, 0x20, 0xa6, 0x07, 0x00, 0xb1, 0x09,
+    0x00, 0xba, 0x0a, 0x00, 0xd1, 0x0b, 0x20, 0x62,
+    0x0d, 0x40, 0x01, 0x0f, 0x20, 0x5e, 0x12, 0x00,
+    0xf9, 0x16, 0x00, 0x17, 0x1a, 0x20, 0xc0, 0x1d,
+    0x20, 0x9d, 0x20, 0x00, 0x68, 0x2d, 0x00, 0x00,
+    0x32, 0x20, 0xc0, 0xa7, 0x20, 0x29, 0xaa, 0x00,
+    0xa4, 0xd7, 0x20, 0xc8, 0xfd, 0x20, 0x75, 0x01,
+    0x01, 0x37, 0x07, 0x01, 0x36, 0x0a, 0x21, 0xf7,
+    0x0f, 0x21, 0xa9, 0x12, 0x01, 0x30, 0x16, 0x21,
+    0x8a, 0x1a, 0x01, 0x9a, 0x23, 0x01, 0x80, 0x6e,
+    0x21, 0x89, 0xbc, 0x21, 0xc1, 0xd6, 0x01, 0xc5,
+    0xe8, 0x21, 0x73, 0xee, 0x01, 0x1e, 0xfa, 0x02,
 };
 
-static const uint8_t unicode_prop_ID_Continue1_table[626] = {
+static const uint8_t unicode_prop_ID_Continue1_table[607] = {
     0xaf, 0x89, 0xa4, 0x80, 0xd6, 0x80, 0x42, 0x47,
     0xef, 0x96, 0x80, 0x40, 0xfa, 0x84, 0x41, 0x08,
     0xac, 0x00, 0x01, 0x01, 0x00, 0xc7, 0x8a, 0xaf,
@@ -453,14 +445,14 @@ static const uint8_t unicode_prop_ID_Continue1_table[626] = {
     0x09, 0x89, 0x8d, 0x01, 0x82, 0xb7, 0x00, 0x23,
     0x09, 0x12, 0x80, 0x93, 0x8b, 0x10, 0x8a, 0x82,
     0xb7, 0x00, 0x38, 0x10, 0x82, 0x93, 0x09, 0x89,
-    0x89, 0x28, 0x82, 0xb7, 0x00, 0x31, 0x09, 0x16,
-    0x82, 0x89, 0x09, 0x89, 0x91, 0x80, 0xba, 0x22,
+    0x89, 0x28, 0x82, 0xb7, 0x00, 0x31, 0x09, 0x17,
+    0x81, 0x89, 0x09, 0x89, 0x91, 0x80, 0xba, 0x22,
     0x10, 0x83, 0x88, 0x80, 0x8d, 0x89, 0x8f, 0x84,
     0xb8, 0x30, 0x10, 0x1e, 0x81, 0x8a, 0x09, 0x89,
     0x90, 0x82, 0xb7, 0x00, 0x30, 0x10, 0x1e, 0x81,
     0x8a, 0x09, 0x89, 0x8f, 0x83, 0xb6, 0x08, 0x30,
-    0x10, 0x83, 0x88, 0x80, 0x89, 0x09, 0x89, 0x90,
-    0x82, 0xc5, 0x03, 0x28, 0x00, 0x3d, 0x89, 0x09,
+    0x10, 0x83, 0x88, 0x80, 0x89, 0x09, 0x89, 0x91,
+    0x81, 0xc5, 0x03, 0x28, 0x00, 0x3d, 0x89, 0x09,
     0xbc, 0x01, 0x86, 0x8b, 0x38, 0x89, 0xd6, 0x01,
     0x88, 0x8a, 0x29, 0x89, 0xbd, 0x0d, 0x89, 0x8a,
     0x00, 0x00, 0x03, 0x81, 0xb0, 0x93, 0x01, 0x84,
@@ -472,70 +464,67 @@ static const uint8_t unicode_prop_ID_Continue1_table[626] = {
     0x89, 0x40, 0x8e, 0x80, 0xf5, 0x8b, 0x83, 0x8b,
     0x89, 0x89, 0xff, 0x8a, 0xbb, 0x84, 0xb8, 0x89,
     0x80, 0x9c, 0x81, 0x8a, 0x85, 0x89, 0x95, 0x8d,
-    0x01, 0xbe, 0x84, 0xae, 0x90, 0x8a, 0x89, 0x90,
-    0x88, 0x8b, 0x82, 0x9d, 0x8c, 0x81, 0x89, 0xab,
-    0x8d, 0xaf, 0x93, 0x87, 0x89, 0x85, 0x89, 0xf5,
-    0x10, 0x94, 0x18, 0x28, 0x0a, 0x40, 0xc5, 0xb9,
-    0x04, 0x42, 0x3e, 0x81, 0x92, 0x80, 0xfa, 0x8c,
-    0x18, 0x82, 0x8b, 0x4b, 0xfd, 0x82, 0x40, 0x8c,
-    0x80, 0xdf, 0x9f, 0x42, 0x29, 0x85, 0xe8, 0x81,
-    0x60, 0x75, 0x84, 0x89, 0xc4, 0x03, 0x89, 0x9f,
-    0x81, 0xcf, 0x81, 0x41, 0x0f, 0x02, 0x03, 0x80,
-    0x96, 0x23, 0x80, 0xd2, 0x81, 0xb1, 0x91, 0x89,
-    0x89, 0x85, 0x91, 0x8c, 0x8a, 0x9b, 0x87, 0x98,
-    0x8c, 0xab, 0x83, 0xae, 0x8d, 0x8e, 0x89, 0x8a,
-    0x80, 0x89, 0x89, 0xae, 0x8d, 0x8b, 0x07, 0x09,
-    0x89, 0xa0, 0x82, 0xb1, 0x00, 0x11, 0x0c, 0x08,
-    0x80, 0xa8, 0x24, 0x81, 0x40, 0xeb, 0x38, 0x09,
-    0x89, 0x60, 0x4f, 0x23, 0x80, 0x42, 0xe0, 0x8f,
-    0x8f, 0x8f, 0x11, 0x97, 0x82, 0x40, 0xbf, 0x89,
-    0xa4, 0x80, 0x42, 0xbc, 0x80, 0x40, 0xe1, 0x80,
-    0x40, 0x94, 0x84, 0x41, 0x24, 0x89, 0x45, 0x56,
-    0x10, 0x0c, 0x83, 0xa7, 0x13, 0x80, 0x40, 0xa4,
-    0x81, 0x42, 0x3c, 0x1f, 0x89, 0x41, 0x70, 0x81,
-    0x40, 0x98, 0x8a, 0x40, 0xae, 0x82, 0xb4, 0x8e,
-    0x9e, 0x89, 0x8e, 0x83, 0xac, 0x8a, 0xb4, 0x89,
-    0x2a, 0xa3, 0x8d, 0x80, 0x89, 0x21, 0xab, 0x80,
-    0x8b, 0x82, 0xaf, 0x8d, 0x3b, 0x80, 0x8b, 0xd1,
-    0x8b, 0x28, 0x40, 0x9f, 0x8b, 0x84, 0x89, 0x2b,
-    0xb6, 0x08, 0x31, 0x09, 0x82, 0x88, 0x80, 0x89,
-    0x09, 0x32, 0x84, 0x40, 0xbf, 0x91, 0x88, 0x89,
-    0x18, 0xd0, 0x93, 0x8b, 0x89, 0x40, 0xd4, 0x31,
-    0x88, 0x9a, 0x81, 0xd1, 0x90, 0x8e, 0x89, 0xd0,
-    0x8c, 0x87, 0x89, 0xd2, 0x8e, 0x83, 0x89, 0x40,
-    0xf1, 0x8e, 0x40, 0xa4, 0x89, 0xc5, 0x28, 0x09,
-    0x18, 0x00, 0x81, 0x8b, 0x89, 0xf6, 0x31, 0x32,
-    0x80, 0x9b, 0x89, 0xa7, 0x30, 0x1f, 0x80, 0x88,
-    0x8a, 0xad, 0x8f, 0x41, 0x94, 0x38, 0x87, 0x8f,
-    0x89, 0xb7, 0x95, 0x80, 0x8d, 0xf9, 0x2a, 0x00,
-    0x08, 0x30, 0x07, 0x89, 0xaf, 0x20, 0x08, 0x27,
-    0x89, 0x41, 0x48, 0x83, 0x60, 0x4b, 0x68, 0x89,
-    0x40, 0x85, 0x84, 0xba, 0x86, 0x98, 0x89, 0x43,
-    0xf4, 0x00, 0xb6, 0x33, 0xd0, 0x80, 0x8a, 0x81,
-    0x60, 0x4c, 0xaa, 0x81, 0x54, 0xc5, 0x22, 0x2f,
+    0xc1, 0x84, 0xae, 0x90, 0x8a, 0x89, 0x90, 0x88,
+    0x8b, 0x82, 0x9d, 0x8c, 0x81, 0x89, 0xab, 0x8d,
+    0xaf, 0x93, 0x87, 0x89, 0x85, 0x89, 0xf5, 0x10,
+    0x94, 0x18, 0x28, 0x0a, 0x40, 0xc5, 0xb9, 0x04,
+    0x42, 0x3e, 0x81, 0x92, 0x80, 0xfa, 0x8c, 0x18,
+    0x82, 0x8b, 0x4b, 0xfd, 0x82, 0x40, 0x8c, 0x80,
+    0xdf, 0x9f, 0x42, 0x29, 0x85, 0xe8, 0x81, 0x60,
+    0x75, 0x84, 0x89, 0xc4, 0x03, 0x89, 0x9f, 0x81,
+    0xcf, 0x81, 0x41, 0x0f, 0x02, 0x03, 0x80, 0x96,
+    0x84, 0xd7, 0x81, 0xb1, 0x91, 0x89, 0x89, 0x85,
+    0x91, 0x8c, 0x8a, 0x9b, 0x87, 0x98, 0x8c, 0xab,
+    0x83, 0xae, 0x8d, 0x8e, 0x89, 0x8a, 0x80, 0x89,
+    0x89, 0xae, 0x8d, 0x8b, 0x07, 0x09, 0x89, 0xa0,
+    0x82, 0xb1, 0x00, 0x11, 0x0c, 0x08, 0x80, 0xa8,
+    0x24, 0x81, 0x40, 0xeb, 0x38, 0x09, 0x89, 0x60,
+    0x4f, 0x23, 0x80, 0x42, 0xe0, 0x8f, 0x8f, 0x8f,
+    0x11, 0x97, 0x82, 0x40, 0xbf, 0x89, 0xa4, 0x80,
+    0x42, 0xbc, 0x80, 0x40, 0xe1, 0x80, 0x40, 0x94,
+    0x84, 0x41, 0x24, 0x89, 0x45, 0x56, 0x10, 0x0c,
+    0x83, 0xa7, 0x13, 0x80, 0x40, 0xa4, 0x81, 0x42,
+    0x3c, 0x1f, 0x89, 0x42, 0x0b, 0x8a, 0x40, 0xae,
+    0x82, 0xb4, 0x8e, 0x9e, 0x89, 0x8e, 0x83, 0xac,
+    0x8a, 0xb4, 0x89, 0x2a, 0xa3, 0x8d, 0x80, 0x89,
+    0x21, 0xab, 0x80, 0x8b, 0x82, 0xaf, 0x8d, 0x3b,
+    0x82, 0x89, 0xd1, 0x8b, 0x28, 0x40, 0x9f, 0x8b,
+    0x84, 0x89, 0x2b, 0xb6, 0x08, 0x31, 0x09, 0x82,
+    0x88, 0x80, 0x89, 0x09, 0x32, 0x84, 0x40, 0xbf,
+    0x91, 0x88, 0x89, 0x18, 0xd0, 0x93, 0x8b, 0x89,
+    0x40, 0xd4, 0x31, 0x88, 0x9a, 0x81, 0xd1, 0x90,
+    0x8e, 0x89, 0xd0, 0x8c, 0x87, 0x89, 0xd2, 0x8e,
+    0x83, 0x89, 0x40, 0xf1, 0x8e, 0x40, 0xa4, 0x89,
+    0x40, 0xe6, 0x31, 0x32, 0x80, 0x9b, 0x89, 0xa7,
+    0x30, 0x1f, 0x80, 0x88, 0x8a, 0xad, 0x8f, 0x41,
+    0x94, 0x38, 0x87, 0x8f, 0x89, 0xb7, 0x95, 0x80,
+    0x8d, 0xf9, 0x2a, 0x00, 0x08, 0x30, 0x07, 0x89,
+    0xaf, 0x20, 0x08, 0x27, 0x89, 0x41, 0x48, 0x83,
+    0x60, 0x4b, 0x68, 0x89, 0x40, 0x85, 0x84, 0xba,
+    0x86, 0x98, 0x89, 0x43, 0xf4, 0x00, 0xb6, 0x33,
+    0x60, 0x4d, 0x09, 0x81, 0x54, 0xc5, 0x22, 0x2f,
     0x39, 0x86, 0x9d, 0x83, 0x40, 0x93, 0x82, 0x45,
     0x88, 0xb1, 0x41, 0xff, 0xb6, 0x83, 0xb1, 0x38,
     0x8d, 0x80, 0x95, 0x20, 0x8e, 0x45, 0x4f, 0x30,
     0x90, 0x0e, 0x01, 0x04, 0x41, 0x04, 0x86, 0x88,
     0x89, 0x41, 0xa1, 0x8d, 0x45, 0xd5, 0x86, 0xec,
-    0x34, 0x89, 0x52, 0x95, 0x89, 0x6c, 0x05, 0x05,
-    0x40, 0xef,
+    0x34, 0x89, 0x6c, 0x17, 0xa5, 0x40, 0xef,
 };
 
-static const uint8_t unicode_prop_ID_Continue1_index[60] = {
+static const uint8_t unicode_prop_ID_Continue1_index[57] = {
     0xfa, 0x06, 0x00, 0x84, 0x09, 0x00, 0xf0, 0x0a,
     0x00, 0x70, 0x0c, 0x00, 0xf4, 0x0d, 0x00, 0x4a,
-    0x10, 0x20, 0x1a, 0x18, 0x20, 0x74, 0x1b, 0x20,
-    0xdd, 0x20, 0x00, 0x0c, 0xa8, 0x00, 0x5a, 0xaa,
-    0x20, 0x1a, 0xff, 0x00, 0xad, 0x0e, 0x01, 0x38,
-    0x12, 0x21, 0xc1, 0x15, 0x21, 0xe5, 0x19, 0x21,
-    0xaa, 0x1d, 0x21, 0x8c, 0xd1, 0x41, 0x4a, 0xe1,
-    0x21, 0xf0, 0x01, 0x0e,
+    0x10, 0x20, 0x1a, 0x18, 0x20, 0x74, 0x1b, 0x00,
+    0xe2, 0x20, 0x00, 0x28, 0xa8, 0x20, 0x7e, 0xaa,
+    0x20, 0x40, 0xff, 0x00, 0x03, 0x10, 0x21, 0xeb,
+    0x12, 0x01, 0x41, 0x16, 0x01, 0x40, 0x1c, 0x61,
+    0x37, 0x6b, 0x21, 0x76, 0xda, 0x01, 0xf0, 0x01,
+    0x0e,
 };
 
 #ifdef CONFIG_ALL_UNICODE
 
-static const uint8_t unicode_cc_table[851] = {
+static const uint8_t unicode_cc_table[831] = {
     0xb2, 0xcf, 0xd4, 0x00, 0xe8, 0x03, 0xdc, 0x00,
     0xe8, 0x00, 0xd8, 0x04, 0xdc, 0x01, 0xca, 0x03,
     0xdc, 0x01, 0xca, 0x0a, 0xdc, 0x04, 0x01, 0x03,
@@ -585,81 +574,77 @@ static const uint8_t unicode_cc_table[851] = {
     0x9a, 0x00, 0xe4, 0xb0, 0x5e, 0x00, 0xde, 0xc0,
     0x00, 0xdc, 0xb0, 0xaa, 0xc0, 0x00, 0xdc, 0xb0,
     0x16, 0x00, 0x09, 0x93, 0xc7, 0x81, 0x00, 0xdc,
-    0xaf, 0xc4, 0x05, 0xdc, 0xc1, 0x00, 0xdc, 0x80,
-    0x01, 0xdc, 0xb0, 0x42, 0x00, 0x07, 0x8e, 0x00,
-    0x09, 0xa5, 0xc0, 0x00, 0xdc, 0xc6, 0xb0, 0x05,
-    0x01, 0x09, 0xb0, 0x09, 0x00, 0x07, 0x8a, 0x01,
-    0x09, 0xb0, 0x12, 0x00, 0x07, 0xb0, 0x67, 0xc2,
-    0x41, 0x00, 0x04, 0xdc, 0xc1, 0x03, 0xdc, 0xc0,
-    0x41, 0x00, 0x05, 0x01, 0x83, 0x00, 0xdc, 0x85,
-    0xc0, 0x82, 0xc1, 0xb0, 0x95, 0xc1, 0x00, 0xdc,
-    0xc6, 0x00, 0xdc, 0xc1, 0x00, 0xea, 0x00, 0xd6,
-    0x00, 0xdc, 0x00, 0xca, 0xe4, 0x00, 0xe8, 0x01,
-    0xe4, 0x00, 0xdc, 0x80, 0xc0, 0x00, 0xe9, 0x00,
-    0xdc, 0xc0, 0x00, 0xdc, 0xb2, 0x9f, 0xc1, 0x01,
-    0x01, 0xc3, 0x02, 0x01, 0xc1, 0x83, 0xc0, 0x82,
-    0x01, 0x01, 0xc0, 0x00, 0xdc, 0xc0, 0x01, 0x01,
-    0x03, 0xdc, 0xc0, 0xb8, 0x03, 0xcd, 0xc2, 0xb0,
-    0x5c, 0x00, 0x09, 0xb0, 0x2f, 0xdf, 0xb1, 0xf9,
-    0x00, 0xda, 0x00, 0xe4, 0x00, 0xe8, 0x00, 0xde,
-    0x01, 0xe0, 0xb0, 0x38, 0x01, 0x08, 0xb8, 0x6d,
-    0xa3, 0xc0, 0x83, 0xc9, 0x9f, 0xc1, 0xb0, 0x1f,
-    0xc1, 0xb0, 0xe3, 0x00, 0x09, 0xa4, 0x00, 0x09,
-    0xb0, 0x66, 0x00, 0x09, 0x9a, 0xd1, 0xb0, 0x08,
-    0x02, 0xdc, 0xa4, 0x00, 0x09, 0xb0, 0x2e, 0x00,
-    0x07, 0x8b, 0x00, 0x09, 0xb0, 0xbe, 0xc0, 0x80,
-    0xc1, 0x00, 0xdc, 0x81, 0xc1, 0x84, 0xc1, 0x80,
-    0xc0, 0xb0, 0x03, 0x00, 0x09, 0xb0, 0xc5, 0x00,
-    0x09, 0xb8, 0x46, 0xff, 0x00, 0x1a, 0xb2, 0xd0,
-    0xc6, 0x06, 0xdc, 0xc1, 0xb3, 0x9c, 0x00, 0xdc,
-    0xb0, 0xb1, 0x00, 0xdc, 0xb0, 0x64, 0xc4, 0xb6,
-    0x61, 0x00, 0xdc, 0x80, 0xc0, 0xa7, 0xc0, 0x00,
-    0x01, 0x00, 0xdc, 0x83, 0x00, 0x09, 0xb0, 0x74,
-    0xc0, 0x00, 0xdc, 0xb2, 0x0c, 0xc3, 0xb1, 0x52,
-    0xc1, 0xb0, 0x68, 0x01, 0xdc, 0xc2, 0x00, 0xdc,
-    0xc0, 0x03, 0xdc, 0xb0, 0xc4, 0x00, 0x09, 0xb0,
-    0x07, 0x00, 0x09, 0xb0, 0x08, 0x00, 0x09, 0x00,
-    0x07, 0xb0, 0x14, 0xc2, 0xaf, 0x01, 0x09, 0xb0,
-    0x0d, 0x00, 0x07, 0xb0, 0x1b, 0x00, 0x09, 0x88,
-    0x00, 0x07, 0xb0, 0x39, 0x00, 0x09, 0x00, 0x07,
-    0xb0, 0x81, 0x00, 0x07, 0x00, 0x09, 0xb0, 0x1f,
-    0x01, 0x07, 0x8f, 0x00, 0x09, 0x97, 0xc6, 0x82,
-    0xc4, 0xb0, 0x9c, 0x00, 0x09, 0x82, 0x00, 0x07,
-    0x96, 0xc0, 0xb0, 0x32, 0x00, 0x09, 0x00, 0x07,
-    0xb0, 0xca, 0x00, 0x09, 0x00, 0x07, 0xb0, 0x4d,
-    0x00, 0x09, 0xb0, 0x45, 0x00, 0x09, 0x00, 0x07,
-    0xb0, 0x42, 0x00, 0x09, 0xb0, 0xdc, 0x00, 0x09,
-    0x00, 0x07, 0xb0, 0xd1, 0x01, 0x09, 0x83, 0x00,
-    0x07, 0xb0, 0x6b, 0x00, 0x09, 0xb0, 0x22, 0x00,
+    0xaf, 0xc4, 0x05, 0xdc, 0xc1, 0x00, 0xdc, 0xb0,
+    0x45, 0x00, 0x07, 0x8e, 0x00, 0x09, 0xa5, 0xc0,
+    0x00, 0xdc, 0xc6, 0xb0, 0x05, 0x01, 0x09, 0xb0,
+    0x09, 0x00, 0x07, 0x8a, 0x01, 0x09, 0xb0, 0x12,
+    0x00, 0x07, 0xb0, 0x67, 0xc2, 0x41, 0x00, 0x04,
+    0xdc, 0xc1, 0x03, 0xdc, 0xc0, 0x41, 0x00, 0x05,
+    0x01, 0x83, 0x00, 0xdc, 0x85, 0xc0, 0x82, 0xc1,
+    0xb0, 0x95, 0xc1, 0x00, 0xdc, 0xc6, 0x00, 0xdc,
+    0xc1, 0x00, 0xea, 0x00, 0xd6, 0x00, 0xdc, 0x00,
+    0xca, 0xe4, 0x00, 0xe8, 0x01, 0xe4, 0x00, 0xdc,
+    0x80, 0xc0, 0x00, 0xe9, 0x00, 0xdc, 0xc0, 0x00,
+    0xdc, 0xb2, 0x9f, 0xc1, 0x01, 0x01, 0xc3, 0x02,
+    0x01, 0xc1, 0x83, 0xc0, 0x82, 0x01, 0x01, 0xc0,
+    0x00, 0xdc, 0xc0, 0x01, 0x01, 0x03, 0xdc, 0xc0,
+    0xb8, 0x03, 0xcd, 0xc2, 0xb0, 0x5c, 0x00, 0x09,
+    0xb0, 0x2f, 0xdf, 0xb1, 0xf9, 0x00, 0xda, 0x00,
+    0xe4, 0x00, 0xe8, 0x00, 0xde, 0x01, 0xe0, 0xb0,
+    0x38, 0x01, 0x08, 0xb8, 0x6d, 0xa3, 0xc0, 0x83,
+    0xc9, 0x9f, 0xc1, 0xb0, 0x1f, 0xc1, 0xb0, 0xe3,
+    0x00, 0x09, 0xb0, 0x8c, 0x00, 0x09, 0x9a, 0xd1,
+    0xb0, 0x08, 0x02, 0xdc, 0xa4, 0x00, 0x09, 0xb0,
+    0x2e, 0x00, 0x07, 0x8b, 0x00, 0x09, 0xb0, 0xbe,
+    0xc0, 0x80, 0xc1, 0x00, 0xdc, 0x81, 0xc1, 0x84,
+    0xc1, 0x80, 0xc0, 0xb0, 0x03, 0x00, 0x09, 0xb0,
+    0xc5, 0x00, 0x09, 0xb8, 0x46, 0xff, 0x00, 0x1a,
+    0xb2, 0xd0, 0xc6, 0x06, 0xdc, 0xc1, 0xb3, 0x9c,
+    0x00, 0xdc, 0xb0, 0xb1, 0x00, 0xdc, 0xb0, 0x64,
+    0xc4, 0xb6, 0x61, 0x00, 0xdc, 0x80, 0xc0, 0xa7,
+    0xc0, 0x00, 0x01, 0x00, 0xdc, 0x83, 0x00, 0x09,
+    0xb0, 0x74, 0xc0, 0x00, 0xdc, 0xb2, 0x0c, 0xc3,
+    0xb1, 0xed, 0x01, 0xdc, 0xc2, 0x00, 0xdc, 0xc0,
+    0x03, 0xdc, 0xb0, 0xc4, 0x00, 0x09, 0xb0, 0x07,
+    0x00, 0x09, 0xb0, 0x08, 0x00, 0x09, 0x00, 0x07,
+    0xb0, 0x14, 0xc2, 0xaf, 0x01, 0x09, 0xb0, 0x0d,
+    0x00, 0x07, 0xb0, 0x1b, 0x00, 0x09, 0x88, 0x00,
+    0x07, 0xb0, 0x39, 0x00, 0x09, 0x00, 0x07, 0xb0,
+    0x81, 0x00, 0x07, 0x00, 0x09, 0xb0, 0x1f, 0x01,
+    0x07, 0x8f, 0x00, 0x09, 0x97, 0xc6, 0x82, 0xc4,
+    0xb0, 0x9c, 0x00, 0x09, 0x82, 0x00, 0x07, 0x96,
+    0xc0, 0xb0, 0x32, 0x00, 0x09, 0x00, 0x07, 0xb0,
+    0xca, 0x00, 0x09, 0x00, 0x07, 0xb0, 0x4d, 0x00,
+    0x09, 0xb0, 0x45, 0x00, 0x09, 0x00, 0x07, 0xb0,
+    0x42, 0x00, 0x09, 0xb0, 0xdc, 0x00, 0x09, 0x00,
+    0x07, 0xb1, 0x74, 0x00, 0x09, 0xb0, 0x22, 0x00,
     0x09, 0x91, 0x00, 0x09, 0xb0, 0x20, 0x00, 0x09,
     0xb1, 0x74, 0x00, 0x09, 0xb0, 0xd1, 0x00, 0x07,
     0x80, 0x01, 0x09, 0xb0, 0x20, 0x00, 0x09, 0xb8,
-    0x45, 0x27, 0x04, 0x01, 0xb0, 0x0a, 0xc6, 0xb4,
-    0x88, 0x01, 0x06, 0xb8, 0x44, 0x7b, 0x00, 0x01,
-    0xb8, 0x0c, 0x95, 0x01, 0xd8, 0x02, 0x01, 0x82,
-    0x00, 0xe2, 0x04, 0xd8, 0x87, 0x07, 0xdc, 0x81,
-    0xc4, 0x01, 0xdc, 0x9d, 0xc3, 0xb0, 0x63, 0xc2,
-    0xb8, 0x05, 0x8a, 0xc6, 0x80, 0xd0, 0x81, 0xc6,
-    0x80, 0xc1, 0x80, 0xc4, 0xb0, 0xd4, 0xc6, 0xb1,
-    0x84, 0xc3, 0xb5, 0xaf, 0x06, 0xdc, 0xb0, 0x3c,
-    0xc5, 0x00, 0x07,
+    0x45, 0x27, 0x04, 0x01, 0xb0, 0x0a, 0xc6, 0xb8,
+    0x49, 0x36, 0x00, 0x01, 0xb8, 0x0c, 0x95, 0x01,
+    0xd8, 0x02, 0x01, 0x82, 0x00, 0xe2, 0x04, 0xd8,
+    0x87, 0x07, 0xdc, 0x81, 0xc4, 0x01, 0xdc, 0x9d,
+    0xc3, 0xb0, 0x63, 0xc2, 0xb8, 0x05, 0x8a, 0xc6,
+    0x80, 0xd0, 0x81, 0xc6, 0x80, 0xc1, 0x80, 0xc4,
+    0xb0, 0xd4, 0xc6, 0xb1, 0x84, 0xc3, 0xb5, 0xaf,
+    0x06, 0xdc, 0xb0, 0x3c, 0xc5, 0x00, 0x07,
 };
 
-static const uint8_t unicode_cc_index[81] = {
+static const uint8_t unicode_cc_index[78] = {
     0x4d, 0x03, 0x00, 0x97, 0x05, 0x20, 0xc6, 0x05,
     0x00, 0xe7, 0x06, 0x00, 0x45, 0x07, 0x00, 0xe2,
     0x08, 0x00, 0x53, 0x09, 0x00, 0xcd, 0x0b, 0x20,
     0x38, 0x0e, 0x00, 0x73, 0x0f, 0x20, 0x5d, 0x13,
-    0x20, 0x60, 0x1a, 0x20, 0xaa, 0x1b, 0x00, 0xf4,
-    0x1c, 0x00, 0xfe, 0x1d, 0x20, 0x7f, 0x2d, 0x20,
-    0xf0, 0xa6, 0x00, 0xb2, 0xaa, 0x00, 0xfe, 0x01,
-    0x01, 0xab, 0x0e, 0x01, 0x73, 0x11, 0x21, 0x70,
-    0x13, 0x01, 0xb8, 0x16, 0x01, 0x9a, 0x1a, 0x01,
-    0x9f, 0xbc, 0x01, 0x22, 0xe0, 0x01, 0x4b, 0xe9,
-    0x01,
+    0x20, 0x60, 0x1a, 0x20, 0xe6, 0x1b, 0x20, 0xfa,
+    0x1c, 0x00, 0x00, 0x1e, 0x20, 0x80, 0x2d, 0x00,
+    0x06, 0xa8, 0x00, 0xbe, 0xaa, 0x00, 0x76, 0x03,
+    0x01, 0x4d, 0x0f, 0x01, 0xcb, 0x11, 0x21, 0x5e,
+    0x14, 0x01, 0x3b, 0x18, 0x21, 0xf0, 0x6a, 0x41,
+    0xaa, 0xd1, 0x01, 0x4b, 0xe9, 0x01,
 };
 
-static const uint32_t unicode_decomp_table1[690] = {
+static const uint32_t unicode_decomp_table1[687] = {
     0x00280081, 0x002a0097, 0x002a8081, 0x002bc097,
     0x002c8115, 0x002d0097, 0x002d4081, 0x002e0097,
     0x002e4115, 0x002f0199, 0x00302016, 0x00400842,
@@ -786,56 +771,55 @@ static const uint32_t unicode_decomp_table1[690] = {
     0x0cf54119, 0x0cf5c097, 0x0cf6009b, 0x0cf64099,
     0x0cf68217, 0x0cf78119, 0x0cf804a1, 0x0cfa4525,
     0x0cfcc525, 0x0cff4125, 0x0cffc099, 0x29a70103,
-    0x29dc0081, 0x29fe0103, 0x2ad70203, 0x2ada4081,
-    0x3e401482, 0x3e4a7f82, 0x3e6a3f82, 0x3e8aa102,
-    0x3e9b0110, 0x3e9c2f82, 0x3eb3c590, 0x3ec00197,
-    0x3ec0c119, 0x3ec1413f, 0x3ec4c2af, 0x3ec74184,
-    0x3ec804ad, 0x3eca4081, 0x3eca8304, 0x3ecc03a0,
-    0x3ece02a0, 0x3ecf8084, 0x3ed00120, 0x3ed0c120,
-    0x3ed184ae, 0x3ed3c085, 0x3ed4312d, 0x3ef4cbad,
-    0x3efa892f, 0x3eff022d, 0x3f002f2f, 0x3f1782a5,
-    0x3f18c0b1, 0x3f1907af, 0x3f1cffaf, 0x3f3c81a5,
-    0x3f3d64af, 0x3f542031, 0x3f649b31, 0x3f7c0131,
-    0x3f7c83b3, 0x3f7e40b1, 0x3f7e80bd, 0x3f7ec0bb,
-    0x3f7f00b3, 0x3f840503, 0x3f8c01ad, 0x3f8cc315,
-    0x3f8e462d, 0x3f91cc03, 0x3f97c695, 0x3f9c01af,
-    0x3f9d0085, 0x3f9d852f, 0x3fa03aad, 0x3fbd442f,
-    0x3fc06f1f, 0x3fd7c11f, 0x3fd85fad, 0x3fe80081,
-    0x3fe84f1f, 0x3ff0831f, 0x3ff2831f, 0x3ff4831f,
-    0x3ff6819f, 0x3ff80783, 0x44268192, 0x442ac092,
-    0x444b8112, 0x44d2c112, 0x452ec212, 0x456e8112,
-    0x464e0092, 0x74578392, 0x746ec312, 0x75000d1f,
-    0x75068d1f, 0x750d0d1f, 0x7513839f, 0x7515891f,
-    0x751a0d1f, 0x75208d1f, 0x75271015, 0x752f439f,
-    0x7531459f, 0x75340d1f, 0x753a8d1f, 0x75410395,
-    0x7543441f, 0x7545839f, 0x75478d1f, 0x754e0795,
-    0x7552839f, 0x75548d1f, 0x755b0d1f, 0x75618d1f,
-    0x75680d1f, 0x756e8d1f, 0x75750d1f, 0x757b8d1f,
-    0x75820d1f, 0x75888d1f, 0x758f0d1f, 0x75958d1f,
-    0x759c0d1f, 0x75a28d1f, 0x75a90103, 0x75aa089f,
-    0x75ae4081, 0x75ae839f, 0x75b04081, 0x75b08c9f,
-    0x75b6c081, 0x75b7032d, 0x75b8889f, 0x75bcc081,
-    0x75bd039f, 0x75bec081, 0x75bf0c9f, 0x75c54081,
-    0x75c5832d, 0x75c7089f, 0x75cb4081, 0x75cb839f,
-    0x75cd4081, 0x75cd8c9f, 0x75d3c081, 0x75d4032d,
-    0x75d5889f, 0x75d9c081, 0x75da039f, 0x75dbc081,
-    0x75dc0c9f, 0x75e24081, 0x75e2832d, 0x75e4089f,
-    0x75e84081, 0x75e8839f, 0x75ea4081, 0x75ea8c9f,
-    0x75f0c081, 0x75f1042d, 0x75f3851f, 0x75f6051f,
-    0x75f8851f, 0x75fb051f, 0x75fd851f, 0x7b80022d,
-    0x7b814dad, 0x7b884203, 0x7b89c081, 0x7b8a452d,
-    0x7b8d0403, 0x7b908081, 0x7b91dc03, 0x7ba0052d,
-    0x7ba2c8ad, 0x7ba84483, 0x7baac8ad, 0x7c400097,
-    0x7c404521, 0x7c440d25, 0x7c4a8087, 0x7c4ac115,
-    0x7c4b4117, 0x7c4c0d1f, 0x7c528217, 0x7c538099,
-    0x7c53c097, 0x7c5a8197, 0x7c640097, 0x7c80012f,
-    0x7c808081, 0x7c841603, 0x7c9004c1, 0x7c940103,
-    0x7efc051f, 0xbe0001ac, 0xbe00d110, 0xbe0947ac,
-    0xbe0d3910, 0xbe29872c, 0xbe2d022c, 0xbe2e3790,
-    0xbe49ff90, 0xbe69bc10,
+    0x29dc0081, 0x29fe0103, 0x2ad70203, 0x3e401482,
+    0x3e4a7f82, 0x3e6a3f82, 0x3e8aa102, 0x3e9b0110,
+    0x3e9c2f82, 0x3eb3c590, 0x3ec00197, 0x3ec0c119,
+    0x3ec1413f, 0x3ec4c2af, 0x3ec74184, 0x3ec804ad,
+    0x3eca4081, 0x3eca8304, 0x3ecc03a0, 0x3ece02a0,
+    0x3ecf8084, 0x3ed00120, 0x3ed0c120, 0x3ed184ae,
+    0x3ed3c085, 0x3ed4312d, 0x3ef4cbad, 0x3efa892f,
+    0x3eff022d, 0x3f002f2f, 0x3f1782a5, 0x3f18c0b1,
+    0x3f1907af, 0x3f1cffaf, 0x3f3c81a5, 0x3f3d64af,
+    0x3f542031, 0x3f649b31, 0x3f7c0131, 0x3f7c83b3,
+    0x3f7e40b1, 0x3f7e80bd, 0x3f7ec0bb, 0x3f7f00b3,
+    0x3f840503, 0x3f8c01ad, 0x3f8cc315, 0x3f8e462d,
+    0x3f91cc03, 0x3f97c695, 0x3f9c01af, 0x3f9d0085,
+    0x3f9d852f, 0x3fa03aad, 0x3fbd442f, 0x3fc06f1f,
+    0x3fd7c11f, 0x3fd85fad, 0x3fe80081, 0x3fe84f1f,
+    0x3ff0831f, 0x3ff2831f, 0x3ff4831f, 0x3ff6819f,
+    0x3ff80783, 0x44268192, 0x442ac092, 0x444b8112,
+    0x44d2c112, 0x452ec212, 0x456e8112, 0x74578392,
+    0x746ec312, 0x75000d1f, 0x75068d1f, 0x750d0d1f,
+    0x7513839f, 0x7515891f, 0x751a0d1f, 0x75208d1f,
+    0x75271015, 0x752f439f, 0x7531459f, 0x75340d1f,
+    0x753a8d1f, 0x75410395, 0x7543441f, 0x7545839f,
+    0x75478d1f, 0x754e0795, 0x7552839f, 0x75548d1f,
+    0x755b0d1f, 0x75618d1f, 0x75680d1f, 0x756e8d1f,
+    0x75750d1f, 0x757b8d1f, 0x75820d1f, 0x75888d1f,
+    0x758f0d1f, 0x75958d1f, 0x759c0d1f, 0x75a28d1f,
+    0x75a90103, 0x75aa089f, 0x75ae4081, 0x75ae839f,
+    0x75b04081, 0x75b08c9f, 0x75b6c081, 0x75b7032d,
+    0x75b8889f, 0x75bcc081, 0x75bd039f, 0x75bec081,
+    0x75bf0c9f, 0x75c54081, 0x75c5832d, 0x75c7089f,
+    0x75cb4081, 0x75cb839f, 0x75cd4081, 0x75cd8c9f,
+    0x75d3c081, 0x75d4032d, 0x75d5889f, 0x75d9c081,
+    0x75da039f, 0x75dbc081, 0x75dc0c9f, 0x75e24081,
+    0x75e2832d, 0x75e4089f, 0x75e84081, 0x75e8839f,
+    0x75ea4081, 0x75ea8c9f, 0x75f0c081, 0x75f1042d,
+    0x75f3851f, 0x75f6051f, 0x75f8851f, 0x75fb051f,
+    0x75fd851f, 0x7b80022d, 0x7b814dad, 0x7b884203,
+    0x7b89c081, 0x7b8a452d, 0x7b8d0403, 0x7b908081,
+    0x7b91dc03, 0x7ba0052d, 0x7ba2c8ad, 0x7ba84483,
+    0x7baac8ad, 0x7c400097, 0x7c404521, 0x7c440d25,
+    0x7c4a8087, 0x7c4ac115, 0x7c4b4117, 0x7c4c0d1f,
+    0x7c528217, 0x7c538099, 0x7c53c097, 0x7c5a8197,
+    0x7c640097, 0x7c80012f, 0x7c808081, 0x7c841603,
+    0x7c9004c1, 0x7c940103, 0xbe0001ac, 0xbe00d110,
+    0xbe0947ac, 0xbe0d3910, 0xbe29872c, 0xbe2d022c,
+    0xbe2e3790, 0xbe49ff90, 0xbe69bc10,
 };
 
-static const uint16_t unicode_decomp_table2[690] = {
+static const uint16_t unicode_decomp_table2[687] = {
     0x0020, 0x0000, 0x0061, 0x0002, 0x0004, 0x0006, 0x03bc, 0x0008,
     0x000a, 0x000c, 0x0015, 0x0095, 0x00a5, 0x00b9, 0x00c1, 0x00c3,
     0x00c7, 0x00cb, 0x00d1, 0x00d7, 0x00dd, 0x00e0, 0x00e6, 0x00f8,
@@ -899,33 +883,32 @@ static const uint16_t unicode_decomp_table2[690] = {
     0x10f4, 0x1100, 0x1105, 0x1111, 0x1141, 0x1149, 0x114d, 0x1153,
     0x1157, 0x115a, 0x116e, 0x1171, 0x1175, 0x117b, 0x117d, 0x1181,
     0x1184, 0x118c, 0x1192, 0x1196, 0x119c, 0x11a2, 0x11a8, 0x11ab,
-    0xa76f, 0x11af, 0x11b3, 0x028d, 0x11bb, 0x120d, 0x130b, 0x1409,
-    0x148d, 0x1492, 0x1550, 0x1569, 0x156f, 0x1575, 0x157b, 0x1587,
-    0x1593, 0x002b, 0x159e, 0x15b6, 0x15ba, 0x15be, 0x15c2, 0x15c6,
-    0x15ca, 0x15de, 0x15e2, 0x1646, 0x165f, 0x1685, 0x168b, 0x1749,
-    0x174f, 0x1754, 0x1774, 0x1874, 0x187a, 0x190e, 0x19d0, 0x1a74,
-    0x1a7c, 0x1a9a, 0x1a9f, 0x1ab3, 0x1abd, 0x1ac3, 0x1ad7, 0x1adc,
-    0x1ae2, 0x1af0, 0x1b20, 0x1b2d, 0x1b35, 0x1b39, 0x1b4f, 0x1bc6,
-    0x1bd8, 0x1bda, 0x1bdc, 0x3164, 0x1c1d, 0x1c1f, 0x1c21, 0x1c23,
-    0x1c25, 0x1c27, 0x1c45, 0x1c53, 0x1c58, 0x1c61, 0x1c6a, 0x1c7c,
-    0x1c85, 0x1c8a, 0x1caa, 0x1cc5, 0x1cc7, 0x1cc9, 0x1ccb, 0x1ccd,
-    0x1ccf, 0x1cd1, 0x1cd3, 0x1cf3, 0x1cf5, 0x1cf7, 0x1cf9, 0x1cfb,
-    0x1d02, 0x1d04, 0x1d06, 0x1d08, 0x1d17, 0x1d19, 0x1d1b, 0x1d1d,
-    0x1d1f, 0x1d21, 0x1d23, 0x1d25, 0x1d27, 0x1d29, 0x1d2b, 0x1d2d,
-    0x1d2f, 0x1d31, 0x1d33, 0x1d37, 0x03f4, 0x1d39, 0x2207, 0x1d3b,
-    0x2202, 0x1d3d, 0x1d45, 0x03f4, 0x1d47, 0x2207, 0x1d49, 0x2202,
-    0x1d4b, 0x1d53, 0x03f4, 0x1d55, 0x2207, 0x1d57, 0x2202, 0x1d59,
-    0x1d61, 0x03f4, 0x1d63, 0x2207, 0x1d65, 0x2202, 0x1d67, 0x1d6f,
-    0x03f4, 0x1d71, 0x2207, 0x1d73, 0x2202, 0x1d75, 0x1d7f, 0x1d81,
-    0x1d83, 0x1d85, 0x1d87, 0x1d89, 0x1d8f, 0x1dac, 0x062d, 0x1db4,
-    0x1dc0, 0x062c, 0x1dd0, 0x1e40, 0x1e4c, 0x1e5f, 0x1e71, 0x1e84,
-    0x1e86, 0x1e8a, 0x1e90, 0x1e96, 0x1e98, 0x1e9c, 0x1e9e, 0x1ea6,
-    0x1ea9, 0x1eab, 0x1eb1, 0x1eb3, 0x30b5, 0x1eb9, 0x1f11, 0x1f27,
-    0x1f2b, 0x1f2d, 0x1f32, 0x1f7f, 0x1f90, 0x2091, 0x20a1, 0x20a7,
-    0x21a1, 0x22bf,
+    0xa76f, 0x11af, 0x11b3, 0x11bb, 0x120d, 0x130b, 0x1409, 0x148d,
+    0x1492, 0x1550, 0x1569, 0x156f, 0x1575, 0x157b, 0x1587, 0x1593,
+    0x002b, 0x159e, 0x15b6, 0x15ba, 0x15be, 0x15c2, 0x15c6, 0x15ca,
+    0x15de, 0x15e2, 0x1646, 0x165f, 0x1685, 0x168b, 0x1749, 0x174f,
+    0x1754, 0x1774, 0x1874, 0x187a, 0x190e, 0x19d0, 0x1a74, 0x1a7c,
+    0x1a9a, 0x1a9f, 0x1ab3, 0x1abd, 0x1ac3, 0x1ad7, 0x1adc, 0x1ae2,
+    0x1af0, 0x1b20, 0x1b2d, 0x1b35, 0x1b39, 0x1b4f, 0x1bc6, 0x1bd8,
+    0x1bda, 0x1bdc, 0x3164, 0x1c1d, 0x1c1f, 0x1c21, 0x1c23, 0x1c25,
+    0x1c27, 0x1c45, 0x1c53, 0x1c58, 0x1c61, 0x1c6a, 0x1c7c, 0x1c85,
+    0x1ca5, 0x1cc0, 0x1cc2, 0x1cc4, 0x1cc6, 0x1cc8, 0x1cca, 0x1ccc,
+    0x1cce, 0x1cee, 0x1cf0, 0x1cf2, 0x1cf4, 0x1cf6, 0x1cfd, 0x1cff,
+    0x1d01, 0x1d03, 0x1d12, 0x1d14, 0x1d16, 0x1d18, 0x1d1a, 0x1d1c,
+    0x1d1e, 0x1d20, 0x1d22, 0x1d24, 0x1d26, 0x1d28, 0x1d2a, 0x1d2c,
+    0x1d2e, 0x1d32, 0x03f4, 0x1d34, 0x2207, 0x1d36, 0x2202, 0x1d38,
+    0x1d40, 0x03f4, 0x1d42, 0x2207, 0x1d44, 0x2202, 0x1d46, 0x1d4e,
+    0x03f4, 0x1d50, 0x2207, 0x1d52, 0x2202, 0x1d54, 0x1d5c, 0x03f4,
+    0x1d5e, 0x2207, 0x1d60, 0x2202, 0x1d62, 0x1d6a, 0x03f4, 0x1d6c,
+    0x2207, 0x1d6e, 0x2202, 0x1d70, 0x1d7a, 0x1d7c, 0x1d7e, 0x1d80,
+    0x1d82, 0x1d84, 0x1d8a, 0x1da7, 0x062d, 0x1daf, 0x1dbb, 0x062c,
+    0x1dcb, 0x1e3b, 0x1e47, 0x1e5a, 0x1e6c, 0x1e7f, 0x1e81, 0x1e85,
+    0x1e8b, 0x1e91, 0x1e93, 0x1e97, 0x1e99, 0x1ea1, 0x1ea4, 0x1ea6,
+    0x1eac, 0x1eae, 0x30b5, 0x1eb4, 0x1f0c, 0x1f22, 0x1f26, 0x1f2b,
+    0x1f78, 0x1f89, 0x208a, 0x209a, 0x20a0, 0x219a, 0x22b8,
 };
 
-static const uint8_t unicode_decomp_data[9165] = {
+static const uint8_t unicode_decomp_data[9158] = {
     0x20, 0x88, 0x20, 0x84, 0x32, 0x33, 0x20, 0x81,
     0x20, 0xa7, 0x31, 0x6f, 0x31, 0xd0, 0x34, 0x31,
     0xd0, 0x32, 0x33, 0xd0, 0x34, 0x41, 0x80, 0x41,
@@ -1838,243 +1821,242 @@ static const uint8_t unicode_decomp_data[9165] = {
     0x13, 0x55, 0xb9, 0x14, 0xba, 0x14, 0xb9, 0x14,
     0xb0, 0x14, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x14,
     0xbd, 0x14, 0x55, 0x50, 0xb8, 0x15, 0xaf, 0x15,
-    0xb9, 0x15, 0xaf, 0x15, 0x55, 0x35, 0x19, 0x30,
-    0x19, 0x05, 0x57, 0xd1, 0x65, 0xd1, 0x58, 0xd1,
-    0x65, 0xd1, 0x5f, 0xd1, 0x6e, 0xd1, 0x5f, 0xd1,
-    0x6f, 0xd1, 0x5f, 0xd1, 0x70, 0xd1, 0x5f, 0xd1,
-    0x71, 0xd1, 0x5f, 0xd1, 0x72, 0xd1, 0x55, 0x55,
-    0x55, 0x05, 0xb9, 0xd1, 0x65, 0xd1, 0xba, 0xd1,
-    0x65, 0xd1, 0xbb, 0xd1, 0x6e, 0xd1, 0xbc, 0xd1,
-    0x6e, 0xd1, 0xbb, 0xd1, 0x6f, 0xd1, 0xbc, 0xd1,
-    0x6f, 0xd1, 0x55, 0x55, 0x55, 0x41, 0x00, 0x61,
-    0x00, 0x41, 0x00, 0x61, 0x00, 0x69, 0x00, 0x41,
-    0x00, 0x61, 0x00, 0x41, 0x00, 0x43, 0x44, 0x00,
-    0x00, 0x47, 0x00, 0x00, 0x4a, 0x4b, 0x00, 0x00,
-    0x4e, 0x4f, 0x50, 0x51, 0x00, 0x53, 0x54, 0x55,
-    0x56, 0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63,
-    0x64, 0x00, 0x66, 0x68, 0x00, 0x70, 0x00, 0x41,
+    0xb9, 0x15, 0xaf, 0x15, 0x55, 0x57, 0xd1, 0x65,
+    0xd1, 0x58, 0xd1, 0x65, 0xd1, 0x5f, 0xd1, 0x6e,
+    0xd1, 0x5f, 0xd1, 0x6f, 0xd1, 0x5f, 0xd1, 0x70,
+    0xd1, 0x5f, 0xd1, 0x71, 0xd1, 0x5f, 0xd1, 0x72,
+    0xd1, 0x55, 0x55, 0x55, 0x05, 0xb9, 0xd1, 0x65,
+    0xd1, 0xba, 0xd1, 0x65, 0xd1, 0xbb, 0xd1, 0x6e,
+    0xd1, 0xbc, 0xd1, 0x6e, 0xd1, 0xbb, 0xd1, 0x6f,
+    0xd1, 0xbc, 0xd1, 0x6f, 0xd1, 0x55, 0x55, 0x55,
+    0x41, 0x00, 0x61, 0x00, 0x41, 0x00, 0x61, 0x00,
+    0x69, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,
+    0x43, 0x44, 0x00, 0x00, 0x47, 0x00, 0x00, 0x4a,
+    0x4b, 0x00, 0x00, 0x4e, 0x4f, 0x50, 0x51, 0x00,
+    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
+    0x61, 0x62, 0x63, 0x64, 0x00, 0x66, 0x68, 0x00,
+    0x70, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x42,
+    0x00, 0x44, 0x45, 0x46, 0x47, 0x4a, 0x00, 0x53,
     0x00, 0x61, 0x00, 0x41, 0x42, 0x00, 0x44, 0x45,
-    0x46, 0x47, 0x4a, 0x00, 0x53, 0x00, 0x61, 0x00,
-    0x41, 0x42, 0x00, 0x44, 0x45, 0x46, 0x47, 0x00,
-    0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x00, 0x4f, 0x53,
-    0x00, 0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41,
-    0x00, 0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41,
-    0x00, 0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41,
-    0x00, 0x61, 0x00, 0x31, 0x01, 0x37, 0x02, 0x91,
-    0x03, 0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24,
-    0x00, 0x1f, 0x04, 0x20, 0x05, 0x91, 0x03, 0xa3,
-    0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00, 0x1f,
-    0x04, 0x20, 0x05, 0x91, 0x03, 0xa3, 0x03, 0xb1,
-    0x03, 0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04, 0x20,
-    0x05, 0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03, 0xd1,
-    0x03, 0x24, 0x00, 0x1f, 0x04, 0x20, 0x05, 0x91,
-    0x03, 0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24,
-    0x00, 0x1f, 0x04, 0x20, 0x05, 0x0b, 0x0c, 0x30,
-    0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
-    0x00, 0x27, 0x06, 0x00, 0x01, 0x05, 0x08, 0x2a,
-    0x06, 0x1e, 0x08, 0x03, 0x0d, 0x20, 0x19, 0x1a,
-    0x1b, 0x1c, 0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07,
-    0x0a, 0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10,
-    0x44, 0x90, 0x77, 0x45, 0x28, 0x06, 0x2c, 0x06,
-    0x00, 0x00, 0x47, 0x06, 0x33, 0x06, 0x17, 0x10,
-    0x11, 0x12, 0x13, 0x00, 0x06, 0x0e, 0x02, 0x0f,
-    0x34, 0x06, 0x2a, 0x06, 0x2b, 0x06, 0x2e, 0x06,
-    0x00, 0x00, 0x36, 0x06, 0x00, 0x00, 0x3a, 0x06,
-    0x2d, 0x06, 0x00, 0x00, 0x4a, 0x06, 0x00, 0x00,
-    0x44, 0x06, 0x00, 0x00, 0x46, 0x06, 0x33, 0x06,
-    0x39, 0x06, 0x00, 0x00, 0x35, 0x06, 0x42, 0x06,
-    0x00, 0x00, 0x34, 0x06, 0x00, 0x00, 0x00, 0x00,
-    0x2e, 0x06, 0x00, 0x00, 0x36, 0x06, 0x00, 0x00,
-    0x3a, 0x06, 0x00, 0x00, 0xba, 0x06, 0x00, 0x00,
-    0x6f, 0x06, 0x00, 0x00, 0x28, 0x06, 0x2c, 0x06,
-    0x00, 0x00, 0x47, 0x06, 0x00, 0x00, 0x00, 0x00,
-    0x2d, 0x06, 0x37, 0x06, 0x4a, 0x06, 0x43, 0x06,
-    0x00, 0x00, 0x45, 0x06, 0x46, 0x06, 0x33, 0x06,
-    0x39, 0x06, 0x41, 0x06, 0x35, 0x06, 0x42, 0x06,
-    0x00, 0x00, 0x34, 0x06, 0x2a, 0x06, 0x2b, 0x06,
-    0x2e, 0x06, 0x00, 0x00, 0x36, 0x06, 0x38, 0x06,
-    0x3a, 0x06, 0x6e, 0x06, 0x00, 0x00, 0xa1, 0x06,
-    0x27, 0x06, 0x00, 0x01, 0x05, 0x08, 0x20, 0x21,
-    0x0b, 0x06, 0x10, 0x23, 0x2a, 0x06, 0x1a, 0x1b,
+    0x46, 0x47, 0x00, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
+    0x00, 0x4f, 0x53, 0x00, 0x61, 0x00, 0x41, 0x00,
+    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,
+    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,
+    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x31, 0x01,
+    0x37, 0x02, 0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03,
+    0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04, 0x20, 0x05,
+    0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03,
+    0x24, 0x00, 0x1f, 0x04, 0x20, 0x05, 0x91, 0x03,
+    0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00,
+    0x1f, 0x04, 0x20, 0x05, 0x91, 0x03, 0xa3, 0x03,
+    0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04,
+    0x20, 0x05, 0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03,
+    0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04, 0x20, 0x05,
+    0x0b, 0x0c, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00,
+    0x30, 0x00, 0x30, 0x00, 0x27, 0x06, 0x00, 0x01,
+    0x05, 0x08, 0x2a, 0x06, 0x1e, 0x08, 0x03, 0x0d,
+    0x20, 0x19, 0x1a, 0x1b, 0x1c, 0x09, 0x0f, 0x17,
+    0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04, 0x06,
+    0x0c, 0x0e, 0x10, 0x44, 0x90, 0x77, 0x45, 0x28,
+    0x06, 0x2c, 0x06, 0x00, 0x00, 0x47, 0x06, 0x33,
+    0x06, 0x17, 0x10, 0x11, 0x12, 0x13, 0x00, 0x06,
+    0x0e, 0x02, 0x0f, 0x34, 0x06, 0x2a, 0x06, 0x2b,
+    0x06, 0x2e, 0x06, 0x00, 0x00, 0x36, 0x06, 0x00,
+    0x00, 0x3a, 0x06, 0x2d, 0x06, 0x00, 0x00, 0x4a,
+    0x06, 0x00, 0x00, 0x44, 0x06, 0x00, 0x00, 0x46,
+    0x06, 0x33, 0x06, 0x39, 0x06, 0x00, 0x00, 0x35,
+    0x06, 0x42, 0x06, 0x00, 0x00, 0x34, 0x06, 0x00,
+    0x00, 0x00, 0x00, 0x2e, 0x06, 0x00, 0x00, 0x36,
+    0x06, 0x00, 0x00, 0x3a, 0x06, 0x00, 0x00, 0xba,
+    0x06, 0x00, 0x00, 0x6f, 0x06, 0x00, 0x00, 0x28,
+    0x06, 0x2c, 0x06, 0x00, 0x00, 0x47, 0x06, 0x00,
+    0x00, 0x00, 0x00, 0x2d, 0x06, 0x37, 0x06, 0x4a,
+    0x06, 0x43, 0x06, 0x00, 0x00, 0x45, 0x06, 0x46,
+    0x06, 0x33, 0x06, 0x39, 0x06, 0x41, 0x06, 0x35,
+    0x06, 0x42, 0x06, 0x00, 0x00, 0x34, 0x06, 0x2a,
+    0x06, 0x2b, 0x06, 0x2e, 0x06, 0x00, 0x00, 0x36,
+    0x06, 0x38, 0x06, 0x3a, 0x06, 0x6e, 0x06, 0x00,
+    0x00, 0xa1, 0x06, 0x27, 0x06, 0x00, 0x01, 0x05,
+    0x08, 0x20, 0x21, 0x0b, 0x06, 0x10, 0x23, 0x2a,
+    0x06, 0x1a, 0x1b, 0x1c, 0x09, 0x0f, 0x17, 0x0b,
+    0x18, 0x07, 0x0a, 0x00, 0x01, 0x04, 0x06, 0x0c,
+    0x0e, 0x10, 0x28, 0x06, 0x2c, 0x06, 0x2f, 0x06,
+    0x00, 0x00, 0x48, 0x06, 0x32, 0x06, 0x2d, 0x06,
+    0x37, 0x06, 0x4a, 0x06, 0x2a, 0x06, 0x1a, 0x1b,
     0x1c, 0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07, 0x0a,
-    0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10, 0x28,
-    0x06, 0x2c, 0x06, 0x2f, 0x06, 0x00, 0x00, 0x48,
-    0x06, 0x32, 0x06, 0x2d, 0x06, 0x37, 0x06, 0x4a,
-    0x06, 0x2a, 0x06, 0x1a, 0x1b, 0x1c, 0x09, 0x0f,
-    0x17, 0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04,
-    0x06, 0x0c, 0x0e, 0x10, 0x30, 0x2e, 0x30, 0x00,
-    0x2c, 0x00, 0x28, 0x00, 0x41, 0x00, 0x29, 0x00,
-    0x14, 0x30, 0x53, 0x00, 0x15, 0x30, 0x43, 0x52,
-    0x43, 0x44, 0x57, 0x5a, 0x41, 0x00, 0x48, 0x56,
-    0x4d, 0x56, 0x53, 0x44, 0x53, 0x53, 0x50, 0x50,
-    0x56, 0x57, 0x43, 0x4d, 0x43, 0x4d, 0x44, 0x4d,
-    0x52, 0x44, 0x4a, 0x4b, 0x30, 0x30, 0x00, 0x68,
-    0x68, 0x4b, 0x62, 0x57, 0x5b, 0xcc, 0x53, 0xc7,
-    0x30, 0x8c, 0x4e, 0x1a, 0x59, 0xe3, 0x89, 0x29,
-    0x59, 0xa4, 0x4e, 0x20, 0x66, 0x21, 0x71, 0x99,
-    0x65, 0x4d, 0x52, 0x8c, 0x5f, 0x8d, 0x51, 0xb0,
-    0x65, 0x1d, 0x52, 0x42, 0x7d, 0x1f, 0x75, 0xa9,
-    0x8c, 0xf0, 0x58, 0x39, 0x54, 0x14, 0x6f, 0x95,
-    0x62, 0x55, 0x63, 0x00, 0x4e, 0x09, 0x4e, 0x4a,
-    0x90, 0xe6, 0x5d, 0x2d, 0x4e, 0xf3, 0x53, 0x07,
-    0x63, 0x70, 0x8d, 0x53, 0x62, 0x81, 0x79, 0x7a,
-    0x7a, 0x08, 0x54, 0x80, 0x6e, 0x09, 0x67, 0x08,
-    0x67, 0x33, 0x75, 0x72, 0x52, 0xb6, 0x55, 0x4d,
-    0x91, 0x14, 0x30, 0x15, 0x30, 0x2c, 0x67, 0x09,
-    0x4e, 0x8c, 0x4e, 0x89, 0x5b, 0xb9, 0x70, 0x53,
-    0x62, 0xd7, 0x76, 0xdd, 0x52, 0x57, 0x65, 0x97,
-    0x5f, 0xef, 0x53, 0x30, 0x00, 0x38, 0x4e, 0x05,
-    0x00, 0x09, 0x22, 0x01, 0x60, 0x4f, 0xae, 0x4f,
-    0xbb, 0x4f, 0x02, 0x50, 0x7a, 0x50, 0x99, 0x50,
-    0xe7, 0x50, 0xcf, 0x50, 0x9e, 0x34, 0x3a, 0x06,
-    0x4d, 0x51, 0x54, 0x51, 0x64, 0x51, 0x77, 0x51,
-    0x1c, 0x05, 0xb9, 0x34, 0x67, 0x51, 0x8d, 0x51,
-    0x4b, 0x05, 0x97, 0x51, 0xa4, 0x51, 0xcc, 0x4e,
-    0xac, 0x51, 0xb5, 0x51, 0xdf, 0x91, 0xf5, 0x51,
-    0x03, 0x52, 0xdf, 0x34, 0x3b, 0x52, 0x46, 0x52,
-    0x72, 0x52, 0x77, 0x52, 0x15, 0x35, 0x02, 0x00,
-    0x20, 0x80, 0x80, 0x00, 0x08, 0x00, 0x00, 0xc7,
-    0x52, 0x00, 0x02, 0x1d, 0x33, 0x3e, 0x3f, 0x50,
-    0x82, 0x8a, 0x93, 0xac, 0xb6, 0xb8, 0xb8, 0xb8,
-    0x2c, 0x0a, 0x70, 0x70, 0xca, 0x53, 0xdf, 0x53,
-    0x63, 0x0b, 0xeb, 0x53, 0xf1, 0x53, 0x06, 0x54,
-    0x9e, 0x54, 0x38, 0x54, 0x48, 0x54, 0x68, 0x54,
-    0xa2, 0x54, 0xf6, 0x54, 0x10, 0x55, 0x53, 0x55,
-    0x63, 0x55, 0x84, 0x55, 0x84, 0x55, 0x99, 0x55,
-    0xab, 0x55, 0xb3, 0x55, 0xc2, 0x55, 0x16, 0x57,
-    0x06, 0x56, 0x17, 0x57, 0x51, 0x56, 0x74, 0x56,
-    0x07, 0x52, 0xee, 0x58, 0xce, 0x57, 0xf4, 0x57,
-    0x0d, 0x58, 0x8b, 0x57, 0x32, 0x58, 0x31, 0x58,
-    0xac, 0x58, 0xe4, 0x14, 0xf2, 0x58, 0xf7, 0x58,
-    0x06, 0x59, 0x1a, 0x59, 0x22, 0x59, 0x62, 0x59,
-    0xa8, 0x16, 0xea, 0x16, 0xec, 0x59, 0x1b, 0x5a,
-    0x27, 0x5a, 0xd8, 0x59, 0x66, 0x5a, 0xee, 0x36,
-    0xfc, 0x36, 0x08, 0x5b, 0x3e, 0x5b, 0x3e, 0x5b,
-    0xc8, 0x19, 0xc3, 0x5b, 0xd8, 0x5b, 0xe7, 0x5b,
-    0xf3, 0x5b, 0x18, 0x1b, 0xff, 0x5b, 0x06, 0x5c,
-    0x53, 0x5f, 0x22, 0x5c, 0x81, 0x37, 0x60, 0x5c,
-    0x6e, 0x5c, 0xc0, 0x5c, 0x8d, 0x5c, 0xe4, 0x1d,
-    0x43, 0x5d, 0xe6, 0x1d, 0x6e, 0x5d, 0x6b, 0x5d,
-    0x7c, 0x5d, 0xe1, 0x5d, 0xe2, 0x5d, 0x2f, 0x38,
-    0xfd, 0x5d, 0x28, 0x5e, 0x3d, 0x5e, 0x69, 0x5e,
-    0x62, 0x38, 0x83, 0x21, 0x7c, 0x38, 0xb0, 0x5e,
-    0xb3, 0x5e, 0xb6, 0x5e, 0xca, 0x5e, 0x92, 0xa3,
-    0xfe, 0x5e, 0x31, 0x23, 0x31, 0x23, 0x01, 0x82,
-    0x22, 0x5f, 0x22, 0x5f, 0xc7, 0x38, 0xb8, 0x32,
-    0xda, 0x61, 0x62, 0x5f, 0x6b, 0x5f, 0xe3, 0x38,
-    0x9a, 0x5f, 0xcd, 0x5f, 0xd7, 0x5f, 0xf9, 0x5f,
-    0x81, 0x60, 0x3a, 0x39, 0x1c, 0x39, 0x94, 0x60,
-    0xd4, 0x26, 0xc7, 0x60, 0x02, 0x02, 0x00, 0x00,
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0a,
-    0x00, 0x00, 0x02, 0x08, 0x00, 0x80, 0x08, 0x00,
-    0x00, 0x08, 0x80, 0x28, 0x80, 0x02, 0x00, 0x00,
-    0x02, 0x48, 0x61, 0x00, 0x04, 0x06, 0x04, 0x32,
-    0x46, 0x6a, 0x5c, 0x67, 0x96, 0xaa, 0xae, 0xc8,
-    0xd3, 0x5d, 0x62, 0x00, 0x54, 0x77, 0xf3, 0x0c,
-    0x2b, 0x3d, 0x63, 0xfc, 0x62, 0x68, 0x63, 0x83,
-    0x63, 0xe4, 0x63, 0xf1, 0x2b, 0x22, 0x64, 0xc5,
-    0x63, 0xa9, 0x63, 0x2e, 0x3a, 0x69, 0x64, 0x7e,
-    0x64, 0x9d, 0x64, 0x77, 0x64, 0x6c, 0x3a, 0x4f,
-    0x65, 0x6c, 0x65, 0x0a, 0x30, 0xe3, 0x65, 0xf8,
-    0x66, 0x49, 0x66, 0x19, 0x3b, 0x91, 0x66, 0x08,
-    0x3b, 0xe4, 0x3a, 0x92, 0x51, 0x95, 0x51, 0x00,
-    0x67, 0x9c, 0x66, 0xad, 0x80, 0xd9, 0x43, 0x17,
-    0x67, 0x1b, 0x67, 0x21, 0x67, 0x5e, 0x67, 0x53,
-    0x67, 0xc3, 0x33, 0x49, 0x3b, 0xfa, 0x67, 0x85,
-    0x67, 0x52, 0x68, 0x85, 0x68, 0x6d, 0x34, 0x8e,
-    0x68, 0x1f, 0x68, 0x14, 0x69, 0x9d, 0x3b, 0x42,
-    0x69, 0xa3, 0x69, 0xea, 0x69, 0xa8, 0x6a, 0xa3,
-    0x36, 0xdb, 0x6a, 0x18, 0x3c, 0x21, 0x6b, 0xa7,
-    0x38, 0x54, 0x6b, 0x4e, 0x3c, 0x72, 0x6b, 0x9f,
-    0x6b, 0xba, 0x6b, 0xbb, 0x6b, 0x8d, 0x3a, 0x0b,
-    0x1d, 0xfa, 0x3a, 0x4e, 0x6c, 0xbc, 0x3c, 0xbf,
-    0x6c, 0xcd, 0x6c, 0x67, 0x6c, 0x16, 0x6d, 0x3e,
-    0x6d, 0x77, 0x6d, 0x41, 0x6d, 0x69, 0x6d, 0x78,
-    0x6d, 0x85, 0x6d, 0x1e, 0x3d, 0x34, 0x6d, 0x2f,
-    0x6e, 0x6e, 0x6e, 0x33, 0x3d, 0xcb, 0x6e, 0xc7,
-    0x6e, 0xd1, 0x3e, 0xf9, 0x6d, 0x6e, 0x6f, 0x5e,
-    0x3f, 0x8e, 0x3f, 0xc6, 0x6f, 0x39, 0x70, 0x1e,
-    0x70, 0x1b, 0x70, 0x96, 0x3d, 0x4a, 0x70, 0x7d,
-    0x70, 0x77, 0x70, 0xad, 0x70, 0x25, 0x05, 0x45,
-    0x71, 0x63, 0x42, 0x9c, 0x71, 0xab, 0x43, 0x28,
-    0x72, 0x35, 0x72, 0x50, 0x72, 0x08, 0x46, 0x80,
-    0x72, 0x95, 0x72, 0x35, 0x47, 0x02, 0x20, 0x00,
-    0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80,
-    0x00, 0x00, 0x02, 0x02, 0x80, 0x8a, 0x00, 0x00,
-    0x20, 0x00, 0x08, 0x0a, 0x00, 0x80, 0x88, 0x80,
-    0x20, 0x14, 0x48, 0x7a, 0x73, 0x8b, 0x73, 0xac,
-    0x3e, 0xa5, 0x73, 0xb8, 0x3e, 0xb8, 0x3e, 0x47,
-    0x74, 0x5c, 0x74, 0x71, 0x74, 0x85, 0x74, 0xca,
-    0x74, 0x1b, 0x3f, 0x24, 0x75, 0x36, 0x4c, 0x3e,
-    0x75, 0x92, 0x4c, 0x70, 0x75, 0x9f, 0x21, 0x10,
-    0x76, 0xa1, 0x4f, 0xb8, 0x4f, 0x44, 0x50, 0xfc,
-    0x3f, 0x08, 0x40, 0xf4, 0x76, 0xf3, 0x50, 0xf2,
-    0x50, 0x19, 0x51, 0x33, 0x51, 0x1e, 0x77, 0x1f,
-    0x77, 0x1f, 0x77, 0x4a, 0x77, 0x39, 0x40, 0x8b,
-    0x77, 0x46, 0x40, 0x96, 0x40, 0x1d, 0x54, 0x4e,
-    0x78, 0x8c, 0x78, 0xcc, 0x78, 0xe3, 0x40, 0x26,
-    0x56, 0x56, 0x79, 0x9a, 0x56, 0xc5, 0x56, 0x8f,
-    0x79, 0xeb, 0x79, 0x2f, 0x41, 0x40, 0x7a, 0x4a,
-    0x7a, 0x4f, 0x7a, 0x7c, 0x59, 0xa7, 0x5a, 0xa7,
-    0x5a, 0xee, 0x7a, 0x02, 0x42, 0xab, 0x5b, 0xc6,
-    0x7b, 0xc9, 0x7b, 0x27, 0x42, 0x80, 0x5c, 0xd2,
-    0x7c, 0xa0, 0x42, 0xe8, 0x7c, 0xe3, 0x7c, 0x00,
-    0x7d, 0x86, 0x5f, 0x63, 0x7d, 0x01, 0x43, 0xc7,
-    0x7d, 0x02, 0x7e, 0x45, 0x7e, 0x34, 0x43, 0x28,
-    0x62, 0x47, 0x62, 0x59, 0x43, 0xd9, 0x62, 0x7a,
-    0x7f, 0x3e, 0x63, 0x95, 0x7f, 0xfa, 0x7f, 0x05,
-    0x80, 0xda, 0x64, 0x23, 0x65, 0x60, 0x80, 0xa8,
-    0x65, 0x70, 0x80, 0x5f, 0x33, 0xd5, 0x43, 0xb2,
-    0x80, 0x03, 0x81, 0x0b, 0x44, 0x3e, 0x81, 0xb5,
-    0x5a, 0xa7, 0x67, 0xb5, 0x67, 0x93, 0x33, 0x9c,
-    0x33, 0x01, 0x82, 0x04, 0x82, 0x9e, 0x8f, 0x6b,
-    0x44, 0x91, 0x82, 0x8b, 0x82, 0x9d, 0x82, 0xb3,
-    0x52, 0xb1, 0x82, 0xb3, 0x82, 0xbd, 0x82, 0xe6,
-    0x82, 0x3c, 0x6b, 0xe5, 0x82, 0x1d, 0x83, 0x63,
-    0x83, 0xad, 0x83, 0x23, 0x83, 0xbd, 0x83, 0xe7,
-    0x83, 0x57, 0x84, 0x53, 0x83, 0xca, 0x83, 0xcc,
-    0x83, 0xdc, 0x83, 0x36, 0x6c, 0x6b, 0x6d, 0x02,
-    0x00, 0x00, 0x20, 0x22, 0x2a, 0xa0, 0x0a, 0x00,
-    0x20, 0x80, 0x28, 0x00, 0xa8, 0x20, 0x20, 0x00,
-    0x02, 0x80, 0x22, 0x02, 0x8a, 0x08, 0x00, 0xaa,
-    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x28, 0xd5,
-    0x6c, 0x2b, 0x45, 0xf1, 0x84, 0xf3, 0x84, 0x16,
-    0x85, 0xca, 0x73, 0x64, 0x85, 0x2c, 0x6f, 0x5d,
-    0x45, 0x61, 0x45, 0xb1, 0x6f, 0xd2, 0x70, 0x6b,
-    0x45, 0x50, 0x86, 0x5c, 0x86, 0x67, 0x86, 0x69,
-    0x86, 0xa9, 0x86, 0x88, 0x86, 0x0e, 0x87, 0xe2,
-    0x86, 0x79, 0x87, 0x28, 0x87, 0x6b, 0x87, 0x86,
-    0x87, 0xd7, 0x45, 0xe1, 0x87, 0x01, 0x88, 0xf9,
-    0x45, 0x60, 0x88, 0x63, 0x88, 0x67, 0x76, 0xd7,
-    0x88, 0xde, 0x88, 0x35, 0x46, 0xfa, 0x88, 0xbb,
-    0x34, 0xae, 0x78, 0x66, 0x79, 0xbe, 0x46, 0xc7,
-    0x46, 0xa0, 0x8a, 0xed, 0x8a, 0x8a, 0x8b, 0x55,
-    0x8c, 0xa8, 0x7c, 0xab, 0x8c, 0xc1, 0x8c, 0x1b,
-    0x8d, 0x77, 0x8d, 0x2f, 0x7f, 0x04, 0x08, 0xcb,
-    0x8d, 0xbc, 0x8d, 0xf0, 0x8d, 0xde, 0x08, 0xd4,
-    0x8e, 0x38, 0x8f, 0xd2, 0x85, 0xed, 0x85, 0x94,
-    0x90, 0xf1, 0x90, 0x11, 0x91, 0x2e, 0x87, 0x1b,
-    0x91, 0x38, 0x92, 0xd7, 0x92, 0xd8, 0x92, 0x7c,
-    0x92, 0xf9, 0x93, 0x15, 0x94, 0xfa, 0x8b, 0x8b,
-    0x95, 0x95, 0x49, 0xb7, 0x95, 0x77, 0x8d, 0xe6,
-    0x49, 0xc3, 0x96, 0xb2, 0x5d, 0x23, 0x97, 0x45,
-    0x91, 0x1a, 0x92, 0x6e, 0x4a, 0x76, 0x4a, 0xe0,
-    0x97, 0x0a, 0x94, 0xb2, 0x4a, 0x96, 0x94, 0x0b,
-    0x98, 0x0b, 0x98, 0x29, 0x98, 0xb6, 0x95, 0xe2,
-    0x98, 0x33, 0x4b, 0x29, 0x99, 0xa7, 0x99, 0xc2,
-    0x99, 0xfe, 0x99, 0xce, 0x4b, 0x30, 0x9b, 0x12,
-    0x9b, 0x40, 0x9c, 0xfd, 0x9c, 0xce, 0x4c, 0xed,
-    0x4c, 0x67, 0x9d, 0xce, 0xa0, 0xf8, 0x4c, 0x05,
-    0xa1, 0x0e, 0xa2, 0x91, 0xa2, 0xbb, 0x9e, 0x56,
-    0x4d, 0xf9, 0x9e, 0xfe, 0x9e, 0x05, 0x9f, 0x0f,
-    0x9f, 0x16, 0x9f, 0x3b, 0x9f, 0x00, 0xa6, 0x02,
-    0x88, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
-    0x28, 0x00, 0x08, 0xa0, 0x80, 0xa0, 0x80, 0x00,
-    0x80, 0x80, 0x00, 0x0a, 0x88, 0x80, 0x00, 0x80,
-    0x00, 0x20, 0x2a, 0x00, 0x80,
+    0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10, 0x30,
+    0x2e, 0x30, 0x00, 0x2c, 0x00, 0x28, 0x00, 0x41,
+    0x00, 0x29, 0x00, 0x14, 0x30, 0x53, 0x00, 0x15,
+    0x30, 0x43, 0x52, 0x43, 0x44, 0x57, 0x5a, 0x41,
+    0x00, 0x48, 0x56, 0x4d, 0x56, 0x53, 0x44, 0x53,
+    0x53, 0x50, 0x50, 0x56, 0x57, 0x43, 0x4d, 0x43,
+    0x4d, 0x44, 0x4d, 0x52, 0x44, 0x4a, 0x4b, 0x30,
+    0x30, 0x00, 0x68, 0x68, 0x4b, 0x62, 0x57, 0x5b,
+    0xcc, 0x53, 0xc7, 0x30, 0x8c, 0x4e, 0x1a, 0x59,
+    0xe3, 0x89, 0x29, 0x59, 0xa4, 0x4e, 0x20, 0x66,
+    0x21, 0x71, 0x99, 0x65, 0x4d, 0x52, 0x8c, 0x5f,
+    0x8d, 0x51, 0xb0, 0x65, 0x1d, 0x52, 0x42, 0x7d,
+    0x1f, 0x75, 0xa9, 0x8c, 0xf0, 0x58, 0x39, 0x54,
+    0x14, 0x6f, 0x95, 0x62, 0x55, 0x63, 0x00, 0x4e,
+    0x09, 0x4e, 0x4a, 0x90, 0xe6, 0x5d, 0x2d, 0x4e,
+    0xf3, 0x53, 0x07, 0x63, 0x70, 0x8d, 0x53, 0x62,
+    0x81, 0x79, 0x7a, 0x7a, 0x08, 0x54, 0x80, 0x6e,
+    0x09, 0x67, 0x08, 0x67, 0x33, 0x75, 0x72, 0x52,
+    0xb6, 0x55, 0x4d, 0x91, 0x14, 0x30, 0x15, 0x30,
+    0x2c, 0x67, 0x09, 0x4e, 0x8c, 0x4e, 0x89, 0x5b,
+    0xb9, 0x70, 0x53, 0x62, 0xd7, 0x76, 0xdd, 0x52,
+    0x57, 0x65, 0x97, 0x5f, 0xef, 0x53, 0x38, 0x4e,
+    0x05, 0x00, 0x09, 0x22, 0x01, 0x60, 0x4f, 0xae,
+    0x4f, 0xbb, 0x4f, 0x02, 0x50, 0x7a, 0x50, 0x99,
+    0x50, 0xe7, 0x50, 0xcf, 0x50, 0x9e, 0x34, 0x3a,
+    0x06, 0x4d, 0x51, 0x54, 0x51, 0x64, 0x51, 0x77,
+    0x51, 0x1c, 0x05, 0xb9, 0x34, 0x67, 0x51, 0x8d,
+    0x51, 0x4b, 0x05, 0x97, 0x51, 0xa4, 0x51, 0xcc,
+    0x4e, 0xac, 0x51, 0xb5, 0x51, 0xdf, 0x91, 0xf5,
+    0x51, 0x03, 0x52, 0xdf, 0x34, 0x3b, 0x52, 0x46,
+    0x52, 0x72, 0x52, 0x77, 0x52, 0x15, 0x35, 0x02,
+    0x00, 0x20, 0x80, 0x80, 0x00, 0x08, 0x00, 0x00,
+    0xc7, 0x52, 0x00, 0x02, 0x1d, 0x33, 0x3e, 0x3f,
+    0x50, 0x82, 0x8a, 0x93, 0xac, 0xb6, 0xb8, 0xb8,
+    0xb8, 0x2c, 0x0a, 0x70, 0x70, 0xca, 0x53, 0xdf,
+    0x53, 0x63, 0x0b, 0xeb, 0x53, 0xf1, 0x53, 0x06,
+    0x54, 0x9e, 0x54, 0x38, 0x54, 0x48, 0x54, 0x68,
+    0x54, 0xa2, 0x54, 0xf6, 0x54, 0x10, 0x55, 0x53,
+    0x55, 0x63, 0x55, 0x84, 0x55, 0x84, 0x55, 0x99,
+    0x55, 0xab, 0x55, 0xb3, 0x55, 0xc2, 0x55, 0x16,
+    0x57, 0x06, 0x56, 0x17, 0x57, 0x51, 0x56, 0x74,
+    0x56, 0x07, 0x52, 0xee, 0x58, 0xce, 0x57, 0xf4,
+    0x57, 0x0d, 0x58, 0x8b, 0x57, 0x32, 0x58, 0x31,
+    0x58, 0xac, 0x58, 0xe4, 0x14, 0xf2, 0x58, 0xf7,
+    0x58, 0x06, 0x59, 0x1a, 0x59, 0x22, 0x59, 0x62,
+    0x59, 0xa8, 0x16, 0xea, 0x16, 0xec, 0x59, 0x1b,
+    0x5a, 0x27, 0x5a, 0xd8, 0x59, 0x66, 0x5a, 0xee,
+    0x36, 0xfc, 0x36, 0x08, 0x5b, 0x3e, 0x5b, 0x3e,
+    0x5b, 0xc8, 0x19, 0xc3, 0x5b, 0xd8, 0x5b, 0xe7,
+    0x5b, 0xf3, 0x5b, 0x18, 0x1b, 0xff, 0x5b, 0x06,
+    0x5c, 0x53, 0x5f, 0x22, 0x5c, 0x81, 0x37, 0x60,
+    0x5c, 0x6e, 0x5c, 0xc0, 0x5c, 0x8d, 0x5c, 0xe4,
+    0x1d, 0x43, 0x5d, 0xe6, 0x1d, 0x6e, 0x5d, 0x6b,
+    0x5d, 0x7c, 0x5d, 0xe1, 0x5d, 0xe2, 0x5d, 0x2f,
+    0x38, 0xfd, 0x5d, 0x28, 0x5e, 0x3d, 0x5e, 0x69,
+    0x5e, 0x62, 0x38, 0x83, 0x21, 0x7c, 0x38, 0xb0,
+    0x5e, 0xb3, 0x5e, 0xb6, 0x5e, 0xca, 0x5e, 0x92,
+    0xa3, 0xfe, 0x5e, 0x31, 0x23, 0x31, 0x23, 0x01,
+    0x82, 0x22, 0x5f, 0x22, 0x5f, 0xc7, 0x38, 0xb8,
+    0x32, 0xda, 0x61, 0x62, 0x5f, 0x6b, 0x5f, 0xe3,
+    0x38, 0x9a, 0x5f, 0xcd, 0x5f, 0xd7, 0x5f, 0xf9,
+    0x5f, 0x81, 0x60, 0x3a, 0x39, 0x1c, 0x39, 0x94,
+    0x60, 0xd4, 0x26, 0xc7, 0x60, 0x02, 0x02, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
+    0x0a, 0x00, 0x00, 0x02, 0x08, 0x00, 0x80, 0x08,
+    0x00, 0x00, 0x08, 0x80, 0x28, 0x80, 0x02, 0x00,
+    0x00, 0x02, 0x48, 0x61, 0x00, 0x04, 0x06, 0x04,
+    0x32, 0x46, 0x6a, 0x5c, 0x67, 0x96, 0xaa, 0xae,
+    0xc8, 0xd3, 0x5d, 0x62, 0x00, 0x54, 0x77, 0xf3,
+    0x0c, 0x2b, 0x3d, 0x63, 0xfc, 0x62, 0x68, 0x63,
+    0x83, 0x63, 0xe4, 0x63, 0xf1, 0x2b, 0x22, 0x64,
+    0xc5, 0x63, 0xa9, 0x63, 0x2e, 0x3a, 0x69, 0x64,
+    0x7e, 0x64, 0x9d, 0x64, 0x77, 0x64, 0x6c, 0x3a,
+    0x4f, 0x65, 0x6c, 0x65, 0x0a, 0x30, 0xe3, 0x65,
+    0xf8, 0x66, 0x49, 0x66, 0x19, 0x3b, 0x91, 0x66,
+    0x08, 0x3b, 0xe4, 0x3a, 0x92, 0x51, 0x95, 0x51,
+    0x00, 0x67, 0x9c, 0x66, 0xad, 0x80, 0xd9, 0x43,
+    0x17, 0x67, 0x1b, 0x67, 0x21, 0x67, 0x5e, 0x67,
+    0x53, 0x67, 0xc3, 0x33, 0x49, 0x3b, 0xfa, 0x67,
+    0x85, 0x67, 0x52, 0x68, 0x85, 0x68, 0x6d, 0x34,
+    0x8e, 0x68, 0x1f, 0x68, 0x14, 0x69, 0x9d, 0x3b,
+    0x42, 0x69, 0xa3, 0x69, 0xea, 0x69, 0xa8, 0x6a,
+    0xa3, 0x36, 0xdb, 0x6a, 0x18, 0x3c, 0x21, 0x6b,
+    0xa7, 0x38, 0x54, 0x6b, 0x4e, 0x3c, 0x72, 0x6b,
+    0x9f, 0x6b, 0xba, 0x6b, 0xbb, 0x6b, 0x8d, 0x3a,
+    0x0b, 0x1d, 0xfa, 0x3a, 0x4e, 0x6c, 0xbc, 0x3c,
+    0xbf, 0x6c, 0xcd, 0x6c, 0x67, 0x6c, 0x16, 0x6d,
+    0x3e, 0x6d, 0x77, 0x6d, 0x41, 0x6d, 0x69, 0x6d,
+    0x78, 0x6d, 0x85, 0x6d, 0x1e, 0x3d, 0x34, 0x6d,
+    0x2f, 0x6e, 0x6e, 0x6e, 0x33, 0x3d, 0xcb, 0x6e,
+    0xc7, 0x6e, 0xd1, 0x3e, 0xf9, 0x6d, 0x6e, 0x6f,
+    0x5e, 0x3f, 0x8e, 0x3f, 0xc6, 0x6f, 0x39, 0x70,
+    0x1e, 0x70, 0x1b, 0x70, 0x96, 0x3d, 0x4a, 0x70,
+    0x7d, 0x70, 0x77, 0x70, 0xad, 0x70, 0x25, 0x05,
+    0x45, 0x71, 0x63, 0x42, 0x9c, 0x71, 0xab, 0x43,
+    0x28, 0x72, 0x35, 0x72, 0x50, 0x72, 0x08, 0x46,
+    0x80, 0x72, 0x95, 0x72, 0x35, 0x47, 0x02, 0x20,
+    0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08,
+    0x80, 0x00, 0x00, 0x02, 0x02, 0x80, 0x8a, 0x00,
+    0x00, 0x20, 0x00, 0x08, 0x0a, 0x00, 0x80, 0x88,
+    0x80, 0x20, 0x14, 0x48, 0x7a, 0x73, 0x8b, 0x73,
+    0xac, 0x3e, 0xa5, 0x73, 0xb8, 0x3e, 0xb8, 0x3e,
+    0x47, 0x74, 0x5c, 0x74, 0x71, 0x74, 0x85, 0x74,
+    0xca, 0x74, 0x1b, 0x3f, 0x24, 0x75, 0x36, 0x4c,
+    0x3e, 0x75, 0x92, 0x4c, 0x70, 0x75, 0x9f, 0x21,
+    0x10, 0x76, 0xa1, 0x4f, 0xb8, 0x4f, 0x44, 0x50,
+    0xfc, 0x3f, 0x08, 0x40, 0xf4, 0x76, 0xf3, 0x50,
+    0xf2, 0x50, 0x19, 0x51, 0x33, 0x51, 0x1e, 0x77,
+    0x1f, 0x77, 0x1f, 0x77, 0x4a, 0x77, 0x39, 0x40,
+    0x8b, 0x77, 0x46, 0x40, 0x96, 0x40, 0x1d, 0x54,
+    0x4e, 0x78, 0x8c, 0x78, 0xcc, 0x78, 0xe3, 0x40,
+    0x26, 0x56, 0x56, 0x79, 0x9a, 0x56, 0xc5, 0x56,
+    0x8f, 0x79, 0xeb, 0x79, 0x2f, 0x41, 0x40, 0x7a,
+    0x4a, 0x7a, 0x4f, 0x7a, 0x7c, 0x59, 0xa7, 0x5a,
+    0xa7, 0x5a, 0xee, 0x7a, 0x02, 0x42, 0xab, 0x5b,
+    0xc6, 0x7b, 0xc9, 0x7b, 0x27, 0x42, 0x80, 0x5c,
+    0xd2, 0x7c, 0xa0, 0x42, 0xe8, 0x7c, 0xe3, 0x7c,
+    0x00, 0x7d, 0x86, 0x5f, 0x63, 0x7d, 0x01, 0x43,
+    0xc7, 0x7d, 0x02, 0x7e, 0x45, 0x7e, 0x34, 0x43,
+    0x28, 0x62, 0x47, 0x62, 0x59, 0x43, 0xd9, 0x62,
+    0x7a, 0x7f, 0x3e, 0x63, 0x95, 0x7f, 0xfa, 0x7f,
+    0x05, 0x80, 0xda, 0x64, 0x23, 0x65, 0x60, 0x80,
+    0xa8, 0x65, 0x70, 0x80, 0x5f, 0x33, 0xd5, 0x43,
+    0xb2, 0x80, 0x03, 0x81, 0x0b, 0x44, 0x3e, 0x81,
+    0xb5, 0x5a, 0xa7, 0x67, 0xb5, 0x67, 0x93, 0x33,
+    0x9c, 0x33, 0x01, 0x82, 0x04, 0x82, 0x9e, 0x8f,
+    0x6b, 0x44, 0x91, 0x82, 0x8b, 0x82, 0x9d, 0x82,
+    0xb3, 0x52, 0xb1, 0x82, 0xb3, 0x82, 0xbd, 0x82,
+    0xe6, 0x82, 0x3c, 0x6b, 0xe5, 0x82, 0x1d, 0x83,
+    0x63, 0x83, 0xad, 0x83, 0x23, 0x83, 0xbd, 0x83,
+    0xe7, 0x83, 0x57, 0x84, 0x53, 0x83, 0xca, 0x83,
+    0xcc, 0x83, 0xdc, 0x83, 0x36, 0x6c, 0x6b, 0x6d,
+    0x02, 0x00, 0x00, 0x20, 0x22, 0x2a, 0xa0, 0x0a,
+    0x00, 0x20, 0x80, 0x28, 0x00, 0xa8, 0x20, 0x20,
+    0x00, 0x02, 0x80, 0x22, 0x02, 0x8a, 0x08, 0x00,
+    0xaa, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x28,
+    0xd5, 0x6c, 0x2b, 0x45, 0xf1, 0x84, 0xf3, 0x84,
+    0x16, 0x85, 0xca, 0x73, 0x64, 0x85, 0x2c, 0x6f,
+    0x5d, 0x45, 0x61, 0x45, 0xb1, 0x6f, 0xd2, 0x70,
+    0x6b, 0x45, 0x50, 0x86, 0x5c, 0x86, 0x67, 0x86,
+    0x69, 0x86, 0xa9, 0x86, 0x88, 0x86, 0x0e, 0x87,
+    0xe2, 0x86, 0x79, 0x87, 0x28, 0x87, 0x6b, 0x87,
+    0x86, 0x87, 0xd7, 0x45, 0xe1, 0x87, 0x01, 0x88,
+    0xf9, 0x45, 0x60, 0x88, 0x63, 0x88, 0x67, 0x76,
+    0xd7, 0x88, 0xde, 0x88, 0x35, 0x46, 0xfa, 0x88,
+    0xbb, 0x34, 0xae, 0x78, 0x66, 0x79, 0xbe, 0x46,
+    0xc7, 0x46, 0xa0, 0x8a, 0xed, 0x8a, 0x8a, 0x8b,
+    0x55, 0x8c, 0xa8, 0x7c, 0xab, 0x8c, 0xc1, 0x8c,
+    0x1b, 0x8d, 0x77, 0x8d, 0x2f, 0x7f, 0x04, 0x08,
+    0xcb, 0x8d, 0xbc, 0x8d, 0xf0, 0x8d, 0xde, 0x08,
+    0xd4, 0x8e, 0x38, 0x8f, 0xd2, 0x85, 0xed, 0x85,
+    0x94, 0x90, 0xf1, 0x90, 0x11, 0x91, 0x2e, 0x87,
+    0x1b, 0x91, 0x38, 0x92, 0xd7, 0x92, 0xd8, 0x92,
+    0x7c, 0x92, 0xf9, 0x93, 0x15, 0x94, 0xfa, 0x8b,
+    0x8b, 0x95, 0x95, 0x49, 0xb7, 0x95, 0x77, 0x8d,
+    0xe6, 0x49, 0xc3, 0x96, 0xb2, 0x5d, 0x23, 0x97,
+    0x45, 0x91, 0x1a, 0x92, 0x6e, 0x4a, 0x76, 0x4a,
+    0xe0, 0x97, 0x0a, 0x94, 0xb2, 0x4a, 0x96, 0x94,
+    0x0b, 0x98, 0x0b, 0x98, 0x29, 0x98, 0xb6, 0x95,
+    0xe2, 0x98, 0x33, 0x4b, 0x29, 0x99, 0xa7, 0x99,
+    0xc2, 0x99, 0xfe, 0x99, 0xce, 0x4b, 0x30, 0x9b,
+    0x12, 0x9b, 0x40, 0x9c, 0xfd, 0x9c, 0xce, 0x4c,
+    0xed, 0x4c, 0x67, 0x9d, 0xce, 0xa0, 0xf8, 0x4c,
+    0x05, 0xa1, 0x0e, 0xa2, 0x91, 0xa2, 0xbb, 0x9e,
+    0x56, 0x4d, 0xf9, 0x9e, 0xfe, 0x9e, 0x05, 0x9f,
+    0x0f, 0x9f, 0x16, 0x9f, 0x3b, 0x9f, 0x00, 0xa6,
+    0x02, 0x88, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x80,
+    0x00, 0x28, 0x00, 0x08, 0xa0, 0x80, 0xa0, 0x80,
+    0x00, 0x80, 0x80, 0x00, 0x0a, 0x88, 0x80, 0x00,
+    0x80, 0x00, 0x20, 0x2a, 0x00, 0x80,
 };
 
-static const uint16_t unicode_comp_table[945] = {
+static const uint16_t unicode_comp_table[944] = {
     0x4a01, 0x49c0, 0x4a02, 0x0280, 0x0281, 0x0282, 0x0283, 0x02c0,
     0x02c2, 0x0a00, 0x0284, 0x2442, 0x0285, 0x07c0, 0x0980, 0x0982,
     0x2440, 0x2280, 0x02c4, 0x2282, 0x2284, 0x2286, 0x02c6, 0x02c8,
@@ -2191,9 +2173,8 @@ static const uint16_t unicode_comp_table[945] = {
     0x5704, 0x5706, 0x5708, 0x570a, 0x570c, 0x570e, 0x5710, 0x5712,
     0x5714, 0x5716, 0x5740, 0x5742, 0x5744, 0x5780, 0x5781, 0x57c0,
     0x57c1, 0x5800, 0x5801, 0x5840, 0x5841, 0x5880, 0x5881, 0x5900,
-    0x5901, 0x5902, 0x5903, 0x5940, 0x8e80, 0x8e82, 0x8ec0, 0x8f00,
-    0x8f01, 0x8f40, 0x8f41, 0x8f81, 0x8f80, 0x8f83, 0x8fc0, 0x8fc1,
-    0x9000,
+    0x5901, 0x5902, 0x5903, 0x5940, 0x8e40, 0x8e42, 0x8e80, 0x8ec0,
+    0x8ec1, 0x8f00, 0x8f01, 0x8f41, 0x8f40, 0x8f43, 0x8f80, 0x8f81,
 };
 
 typedef enum {
@@ -2279,7 +2260,7 @@ static const char unicode_gc_name_table[] =
     "C,Other"                  "\0"
 ;
 
-static const uint8_t unicode_gc_table[3790] = {
+static const uint8_t unicode_gc_table[3719] = {
     0xfa, 0x18, 0x17, 0x56, 0x0d, 0x56, 0x12, 0x13,
     0x16, 0x0c, 0x16, 0x11, 0x36, 0xe9, 0x02, 0x36,
     0x4c, 0x36, 0xe1, 0x12, 0x12, 0x16, 0x13, 0x0e,
@@ -2323,8 +2304,8 @@ static const uint8_t unicode_gc_table[3790] = {
     0x06, 0x2d, 0xe5, 0x0e, 0x66, 0x04, 0xe6, 0x01,
     0x04, 0x46, 0x04, 0x86, 0x20, 0xf6, 0x07, 0x00,
     0xe5, 0x11, 0x46, 0x20, 0x16, 0x00, 0xe5, 0x03,
-    0xe0, 0x2d, 0xe5, 0x0d, 0x00, 0xe5, 0x0a, 0xe0,
-    0x03, 0xe6, 0x07, 0x1b, 0xe6, 0x18, 0x07, 0xe5,
+    0xe0, 0x2d, 0xe5, 0x0d, 0x00, 0xe5, 0x00, 0xe0,
+    0x0d, 0xe6, 0x07, 0x1b, 0xe6, 0x18, 0x07, 0xe5,
     0x2e, 0x06, 0x07, 0x06, 0x05, 0x47, 0xe6, 0x00,
     0x67, 0x06, 0x27, 0x05, 0xc6, 0xe5, 0x02, 0x26,
     0x36, 0xe9, 0x02, 0x16, 0x04, 0xe5, 0x07, 0x06,
@@ -2347,80 +2328,80 @@ static const uint8_t unicode_gc_table[3790] = {
     0x00, 0x06, 0x27, 0x00, 0xe5, 0x00, 0x20, 0x25,
     0x20, 0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25, 0x00,
     0x85, 0x20, 0x06, 0x05, 0x07, 0x06, 0x07, 0x66,
-    0x20, 0x27, 0x20, 0x27, 0x06, 0xc0, 0x26, 0x07,
-    0x60, 0x25, 0x00, 0x45, 0x26, 0x20, 0xe9, 0x02,
-    0x0f, 0x05, 0xab, 0xe0, 0x02, 0x06, 0x05, 0x00,
-    0xa5, 0x40, 0x45, 0x00, 0x65, 0x40, 0x25, 0x00,
-    0x05, 0x00, 0x25, 0x40, 0x25, 0x40, 0x45, 0x40,
-    0xe5, 0x04, 0x60, 0x27, 0x06, 0x27, 0x40, 0x47,
-    0x00, 0x47, 0x06, 0x20, 0x05, 0xa0, 0x07, 0xe0,
-    0x06, 0xe9, 0x02, 0x4b, 0xaf, 0x0d, 0x0f, 0x80,
-    0x06, 0x47, 0x06, 0xe5, 0x00, 0x00, 0x45, 0x00,
-    0xe5, 0x0f, 0x00, 0xe5, 0x08, 0x40, 0x05, 0x46,
-    0x67, 0x00, 0x46, 0x00, 0x66, 0xc0, 0x26, 0x00,
-    0x45, 0x80, 0x25, 0x26, 0x20, 0xe9, 0x02, 0xc0,
-    0x16, 0xcb, 0x0f, 0x05, 0x06, 0x27, 0x16, 0xe5,
-    0x00, 0x00, 0x45, 0x00, 0xe5, 0x0f, 0x00, 0xe5,
-    0x02, 0x00, 0x85, 0x20, 0x06, 0x05, 0x07, 0x06,
-    0x87, 0x00, 0x06, 0x27, 0x00, 0x27, 0x26, 0xc0,
-    0x27, 0xc0, 0x05, 0x00, 0x25, 0x26, 0x20, 0xe9,
-    0x02, 0x00, 0x25, 0xe0, 0x05, 0x26, 0x27, 0xe5,
-    0x01, 0x00, 0x45, 0x00, 0xe5, 0x21, 0x26, 0x05,
-    0x47, 0x66, 0x00, 0x47, 0x00, 0x47, 0x06, 0x05,
-    0x0f, 0x60, 0x45, 0x07, 0xcb, 0x45, 0x26, 0x20,
-    0xe9, 0x02, 0xeb, 0x01, 0x0f, 0xa5, 0x00, 0x06,
-    0x27, 0x00, 0xe5, 0x0a, 0x40, 0xe5, 0x10, 0x00,
-    0xe5, 0x01, 0x00, 0x05, 0x20, 0xc5, 0x40, 0x06,
-    0x60, 0x47, 0x46, 0x00, 0x06, 0x00, 0xe7, 0x00,
-    0xa0, 0xe9, 0x02, 0x20, 0x27, 0x16, 0xe0, 0x04,
-    0xe5, 0x28, 0x06, 0x25, 0xc6, 0x60, 0x0d, 0xa5,
-    0x04, 0xe6, 0x00, 0x16, 0xe9, 0x02, 0x36, 0xe0,
-    0x1d, 0x25, 0x00, 0x05, 0x00, 0x85, 0x00, 0xe5,
-    0x10, 0x00, 0x05, 0x00, 0xe5, 0x02, 0x06, 0x25,
-    0xe6, 0x01, 0x05, 0x20, 0x85, 0x00, 0x04, 0x00,
-    0xa6, 0x20, 0xe9, 0x02, 0x20, 0x65, 0xe0, 0x18,
-    0x05, 0x4f, 0xf6, 0x07, 0x0f, 0x16, 0x4f, 0x26,
-    0xaf, 0xe9, 0x02, 0xeb, 0x02, 0x0f, 0x06, 0x0f,
-    0x06, 0x0f, 0x06, 0x12, 0x13, 0x12, 0x13, 0x27,
-    0xe5, 0x00, 0x00, 0xe5, 0x1c, 0x60, 0xe6, 0x06,
-    0x07, 0x86, 0x16, 0x26, 0x85, 0xe6, 0x03, 0x00,
-    0xe6, 0x1c, 0x00, 0xef, 0x00, 0x06, 0xaf, 0x00,
-    0x2f, 0x96, 0x6f, 0x36, 0xe0, 0x1d, 0xe5, 0x23,
-    0x27, 0x66, 0x07, 0xa6, 0x07, 0x26, 0x27, 0x26,
-    0x05, 0xe9, 0x02, 0xb6, 0xa5, 0x27, 0x26, 0x65,
-    0x46, 0x05, 0x47, 0x25, 0xc7, 0x45, 0x66, 0xe5,
-    0x05, 0x06, 0x27, 0x26, 0xa7, 0x06, 0x05, 0x07,
-    0xe9, 0x02, 0x47, 0x06, 0x2f, 0xe1, 0x1e, 0x00,
-    0x01, 0x80, 0x01, 0x20, 0xe2, 0x23, 0x16, 0x04,
-    0x42, 0xe5, 0x80, 0xc1, 0x00, 0x65, 0x20, 0xc5,
-    0x00, 0x05, 0x00, 0x65, 0x20, 0xe5, 0x21, 0x00,
-    0x65, 0x20, 0xe5, 0x19, 0x00, 0x65, 0x20, 0xc5,
-    0x00, 0x05, 0x00, 0x65, 0x20, 0xe5, 0x07, 0x00,
-    0xe5, 0x31, 0x00, 0x65, 0x20, 0xe5, 0x3b, 0x20,
-    0x46, 0xf6, 0x01, 0xeb, 0x0c, 0x40, 0xe5, 0x08,
-    0xef, 0x02, 0xa0, 0xe1, 0x4e, 0x20, 0xa2, 0x20,
-    0x11, 0xe5, 0x81, 0xe4, 0x0f, 0x16, 0xe5, 0x09,
-    0x17, 0xe5, 0x12, 0x12, 0x13, 0x40, 0xe5, 0x43,
-    0x56, 0x4a, 0xe5, 0x00, 0xc0, 0xe5, 0x05, 0x00,
-    0x65, 0x46, 0xe0, 0x03, 0xe5, 0x0a, 0x46, 0x36,
-    0xe0, 0x01, 0xe5, 0x0a, 0x26, 0xe0, 0x04, 0xe5,
-    0x05, 0x00, 0x45, 0x00, 0x26, 0xe0, 0x04, 0xe5,
-    0x2c, 0x26, 0x07, 0xc6, 0xe7, 0x00, 0x06, 0x27,
-    0xe6, 0x03, 0x56, 0x04, 0x56, 0x0d, 0x05, 0x06,
-    0x20, 0xe9, 0x02, 0xa0, 0xeb, 0x02, 0xa0, 0xb6,
-    0x11, 0x76, 0x46, 0x1b, 0x00, 0xe9, 0x02, 0xa0,
-    0xe5, 0x1b, 0x04, 0xe5, 0x2d, 0xc0, 0x85, 0x26,
-    0xe5, 0x1a, 0x06, 0x05, 0x80, 0xe5, 0x3e, 0xe0,
-    0x02, 0xe5, 0x17, 0x00, 0x46, 0x67, 0x26, 0x47,
-    0x60, 0x27, 0x06, 0xa7, 0x46, 0x60, 0x0f, 0x40,
-    0x36, 0xe9, 0x02, 0xe5, 0x16, 0x20, 0x85, 0xe0,
-    0x03, 0xe5, 0x24, 0x60, 0xe5, 0x12, 0xa0, 0xe9,
-    0x02, 0x0b, 0x40, 0xef, 0x1a, 0xe5, 0x0f, 0x26,
-    0x27, 0x06, 0x20, 0x36, 0xe5, 0x2d, 0x07, 0x06,
-    0x07, 0xc6, 0x00, 0x06, 0x07, 0x06, 0x27, 0xe6,
-    0x00, 0xa7, 0xe6, 0x02, 0x20, 0x06, 0xe9, 0x02,
-    0xa0, 0xe9, 0x02, 0xa0, 0xd6, 0x04, 0xb6, 0x20,
-    0xe6, 0x06, 0x08, 0x26, 0xe0, 0x37, 0x66, 0x07,
+    0x20, 0x27, 0x20, 0x27, 0x06, 0xe0, 0x00, 0x06,
+    0x07, 0x60, 0x25, 0x00, 0x45, 0x26, 0x20, 0xe9,
+    0x02, 0x0f, 0x05, 0xab, 0xe0, 0x02, 0x06, 0x05,
+    0x00, 0xa5, 0x40, 0x45, 0x00, 0x65, 0x40, 0x25,
+    0x00, 0x05, 0x00, 0x25, 0x40, 0x25, 0x40, 0x45,
+    0x40, 0xe5, 0x04, 0x60, 0x27, 0x06, 0x27, 0x40,
+    0x47, 0x00, 0x47, 0x06, 0x20, 0x05, 0xa0, 0x07,
+    0xe0, 0x06, 0xe9, 0x02, 0x4b, 0xaf, 0x0d, 0x0f,
+    0x80, 0x06, 0x47, 0x06, 0xe5, 0x00, 0x00, 0x45,
+    0x00, 0xe5, 0x0f, 0x00, 0xe5, 0x08, 0x40, 0x05,
+    0x46, 0x67, 0x00, 0x46, 0x00, 0x66, 0xc0, 0x26,
+    0x00, 0x45, 0x80, 0x25, 0x26, 0x20, 0xe9, 0x02,
+    0xc0, 0x16, 0xcb, 0x0f, 0x05, 0x06, 0x27, 0x16,
+    0xe5, 0x00, 0x00, 0x45, 0x00, 0xe5, 0x0f, 0x00,
+    0xe5, 0x02, 0x00, 0x85, 0x20, 0x06, 0x05, 0x07,
+    0x06, 0x87, 0x00, 0x06, 0x27, 0x00, 0x27, 0x26,
+    0xc0, 0x27, 0xc0, 0x05, 0x00, 0x25, 0x26, 0x20,
+    0xe9, 0x02, 0x00, 0x25, 0xe0, 0x05, 0x26, 0x27,
+    0x00, 0xe5, 0x00, 0x00, 0x45, 0x00, 0xe5, 0x21,
+    0x26, 0x05, 0x47, 0x66, 0x00, 0x47, 0x00, 0x47,
+    0x06, 0x05, 0x0f, 0x60, 0x45, 0x07, 0xcb, 0x45,
+    0x26, 0x20, 0xe9, 0x02, 0xeb, 0x01, 0x0f, 0xa5,
+    0x20, 0x27, 0x00, 0xe5, 0x0a, 0x40, 0xe5, 0x10,
+    0x00, 0xe5, 0x01, 0x00, 0x05, 0x20, 0xc5, 0x40,
+    0x06, 0x60, 0x47, 0x46, 0x00, 0x06, 0x00, 0xe7,
+    0x00, 0xa0, 0xe9, 0x02, 0x20, 0x27, 0x16, 0xe0,
+    0x04, 0xe5, 0x28, 0x06, 0x25, 0xc6, 0x60, 0x0d,
+    0xa5, 0x04, 0xe6, 0x00, 0x16, 0xe9, 0x02, 0x36,
+    0xe0, 0x1d, 0x25, 0x00, 0x05, 0x00, 0x85, 0x00,
+    0xe5, 0x10, 0x00, 0x05, 0x00, 0xe5, 0x02, 0x06,
+    0x25, 0xe6, 0x01, 0x05, 0x20, 0x85, 0x00, 0x04,
+    0x00, 0xa6, 0x20, 0xe9, 0x02, 0x20, 0x65, 0xe0,
+    0x18, 0x05, 0x4f, 0xf6, 0x07, 0x0f, 0x16, 0x4f,
+    0x26, 0xaf, 0xe9, 0x02, 0xeb, 0x02, 0x0f, 0x06,
+    0x0f, 0x06, 0x0f, 0x06, 0x12, 0x13, 0x12, 0x13,
+    0x27, 0xe5, 0x00, 0x00, 0xe5, 0x1c, 0x60, 0xe6,
+    0x06, 0x07, 0x86, 0x16, 0x26, 0x85, 0xe6, 0x03,
+    0x00, 0xe6, 0x1c, 0x00, 0xef, 0x00, 0x06, 0xaf,
+    0x00, 0x2f, 0x96, 0x6f, 0x36, 0xe0, 0x1d, 0xe5,
+    0x23, 0x27, 0x66, 0x07, 0xa6, 0x07, 0x26, 0x27,
+    0x26, 0x05, 0xe9, 0x02, 0xb6, 0xa5, 0x27, 0x26,
+    0x65, 0x46, 0x05, 0x47, 0x25, 0xc7, 0x45, 0x66,
+    0xe5, 0x05, 0x06, 0x27, 0x26, 0xa7, 0x06, 0x05,
+    0x07, 0xe9, 0x02, 0x47, 0x06, 0x2f, 0xe1, 0x1e,
+    0x00, 0x01, 0x80, 0x01, 0x20, 0xe2, 0x23, 0x16,
+    0x04, 0x42, 0xe5, 0x80, 0xc1, 0x00, 0x65, 0x20,
+    0xc5, 0x00, 0x05, 0x00, 0x65, 0x20, 0xe5, 0x21,
+    0x00, 0x65, 0x20, 0xe5, 0x19, 0x00, 0x65, 0x20,
+    0xc5, 0x00, 0x05, 0x00, 0x65, 0x20, 0xe5, 0x07,
+    0x00, 0xe5, 0x31, 0x00, 0x65, 0x20, 0xe5, 0x3b,
+    0x20, 0x46, 0xf6, 0x01, 0xeb, 0x0c, 0x40, 0xe5,
+    0x08, 0xef, 0x02, 0xa0, 0xe1, 0x4e, 0x20, 0xa2,
+    0x20, 0x11, 0xe5, 0x81, 0xe4, 0x0f, 0x16, 0xe5,
+    0x09, 0x17, 0xe5, 0x12, 0x12, 0x13, 0x40, 0xe5,
+    0x43, 0x56, 0x4a, 0xe5, 0x00, 0xc0, 0xe5, 0x05,
+    0x00, 0x65, 0x46, 0xe0, 0x03, 0xe5, 0x0a, 0x46,
+    0x36, 0xe0, 0x01, 0xe5, 0x0a, 0x26, 0xe0, 0x04,
+    0xe5, 0x05, 0x00, 0x45, 0x00, 0x26, 0xe0, 0x04,
+    0xe5, 0x2c, 0x26, 0x07, 0xc6, 0xe7, 0x00, 0x06,
+    0x27, 0xe6, 0x03, 0x56, 0x04, 0x56, 0x0d, 0x05,
+    0x06, 0x20, 0xe9, 0x02, 0xa0, 0xeb, 0x02, 0xa0,
+    0xb6, 0x11, 0x76, 0x46, 0x1b, 0x00, 0xe9, 0x02,
+    0xa0, 0xe5, 0x1b, 0x04, 0xe5, 0x2d, 0xc0, 0x85,
+    0x26, 0xe5, 0x1a, 0x06, 0x05, 0x80, 0xe5, 0x3e,
+    0xe0, 0x02, 0xe5, 0x17, 0x00, 0x46, 0x67, 0x26,
+    0x47, 0x60, 0x27, 0x06, 0xa7, 0x46, 0x60, 0x0f,
+    0x40, 0x36, 0xe9, 0x02, 0xe5, 0x16, 0x20, 0x85,
+    0xe0, 0x03, 0xe5, 0x24, 0x60, 0xe5, 0x12, 0xa0,
+    0xe9, 0x02, 0x0b, 0x40, 0xef, 0x1a, 0xe5, 0x0f,
+    0x26, 0x27, 0x06, 0x20, 0x36, 0xe5, 0x2d, 0x07,
+    0x06, 0x07, 0xc6, 0x00, 0x06, 0x07, 0x06, 0x27,
+    0xe6, 0x00, 0xa7, 0xe6, 0x02, 0x20, 0x06, 0xe9,
+    0x02, 0xa0, 0xe9, 0x02, 0xa0, 0xd6, 0x04, 0xb6,
+    0x20, 0xe6, 0x06, 0x08, 0xe0, 0x39, 0x66, 0x07,
     0xe5, 0x27, 0x06, 0x07, 0x86, 0x07, 0x06, 0x87,
     0x06, 0x27, 0xc5, 0x60, 0xe9, 0x02, 0xd6, 0xef,
     0x02, 0xe6, 0x01, 0xef, 0x01, 0x40, 0x26, 0x07,
@@ -2480,7 +2461,7 @@ static const uint8_t unicode_gc_table[3790] = {
     0x13, 0x12, 0x13, 0x12, 0x13, 0xec, 0x37, 0x12,
     0x13, 0x12, 0x13, 0xec, 0x18, 0x12, 0x13, 0xec,
     0x80, 0x7a, 0xef, 0x28, 0xec, 0x0d, 0x2f, 0xac,
-    0xef, 0x1f, 0x20, 0xef, 0x18, 0x00, 0xef, 0x61,
+    0xef, 0x1f, 0x20, 0xef, 0x18, 0x20, 0xef, 0x60,
     0xe1, 0x27, 0x00, 0xe2, 0x27, 0x00, 0x5f, 0x21,
     0x22, 0xdf, 0x41, 0x02, 0x3f, 0x02, 0x3f, 0x82,
     0x24, 0x41, 0x02, 0xff, 0x5a, 0x02, 0xaf, 0x7f,
@@ -2494,266 +2475,257 @@ static const uint8_t unicode_gc_table[3790] = {
     0x11, 0x36, 0x11, 0x16, 0x14, 0x15, 0x36, 0x14,
     0x15, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
     0x13, 0x96, 0x04, 0xf6, 0x02, 0x31, 0x76, 0x11,
-    0x16, 0x12, 0xf6, 0x05, 0x2f, 0x16, 0xe0, 0x25,
-    0xef, 0x12, 0x00, 0xef, 0x51, 0xe0, 0x04, 0xef,
-    0x80, 0x4e, 0xe0, 0x12, 0xef, 0x04, 0x60, 0x17,
-    0x56, 0x0f, 0x04, 0x05, 0x0a, 0x12, 0x13, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x2f,
-    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
-    0x11, 0x12, 0x33, 0x0f, 0xea, 0x01, 0x66, 0x27,
-    0x11, 0x84, 0x2f, 0x4a, 0x04, 0x05, 0x16, 0x2f,
-    0x00, 0xe5, 0x4e, 0x20, 0x26, 0x2e, 0x24, 0x05,
-    0x11, 0xe5, 0x52, 0x16, 0x44, 0x05, 0x80, 0xe5,
-    0x23, 0x00, 0xe5, 0x56, 0x00, 0x2f, 0x6b, 0xef,
-    0x02, 0xe5, 0x18, 0xef, 0x1c, 0xe0, 0x04, 0xe5,
-    0x08, 0xef, 0x17, 0x00, 0xeb, 0x02, 0xef, 0x16,
-    0xeb, 0x00, 0x0f, 0xeb, 0x07, 0xef, 0x18, 0xeb,
-    0x02, 0xef, 0x1f, 0xeb, 0x07, 0xef, 0x80, 0xb8,
-    0xe5, 0x99, 0x38, 0xef, 0x38, 0xe5, 0xc0, 0x11,
-    0x75, 0x40, 0xe5, 0x0d, 0x04, 0xe5, 0x83, 0xef,
-    0x40, 0xef, 0x2f, 0xe0, 0x01, 0xe5, 0x20, 0xa4,
-    0x36, 0xe5, 0x80, 0x84, 0x04, 0x56, 0xe5, 0x08,
-    0xe9, 0x02, 0x25, 0xe0, 0x0c, 0xff, 0x26, 0x05,
-    0x06, 0x48, 0x16, 0xe6, 0x02, 0x16, 0x04, 0xff,
-    0x14, 0x24, 0x26, 0xe5, 0x3e, 0xea, 0x02, 0x26,
-    0xb6, 0xe0, 0x00, 0xee, 0x0f, 0xe4, 0x01, 0x2e,
-    0xff, 0x06, 0x22, 0xff, 0x36, 0x04, 0xe2, 0x00,
-    0x9f, 0xff, 0x02, 0x04, 0x2e, 0x7f, 0x05, 0x7f,
-    0x22, 0xff, 0x0d, 0x61, 0x02, 0x81, 0x02, 0xff,
-    0x02, 0x20, 0x5f, 0x41, 0x02, 0x3f, 0xe0, 0x22,
-    0x3f, 0x05, 0x24, 0x02, 0xc5, 0x06, 0x45, 0x06,
-    0x65, 0x06, 0xe5, 0x0f, 0x27, 0x26, 0x07, 0x6f,
-    0x06, 0x40, 0xab, 0x2f, 0x0d, 0x0f, 0xa0, 0xe5,
-    0x2c, 0x76, 0xe0, 0x00, 0x27, 0xe5, 0x2a, 0xe7,
-    0x08, 0x26, 0xe0, 0x00, 0x36, 0xe9, 0x02, 0xa0,
-    0xe6, 0x0a, 0xa5, 0x56, 0x05, 0x16, 0x25, 0x06,
-    0xe9, 0x02, 0xe5, 0x14, 0xe6, 0x00, 0x36, 0xe5,
-    0x0f, 0xe6, 0x03, 0x27, 0xe0, 0x03, 0x16, 0xe5,
-    0x15, 0x40, 0x46, 0x07, 0xe5, 0x27, 0x06, 0x27,
-    0x66, 0x27, 0x26, 0x47, 0xf6, 0x05, 0x00, 0x04,
-    0xe9, 0x02, 0x60, 0x36, 0x85, 0x06, 0x04, 0xe5,
-    0x01, 0xe9, 0x02, 0x85, 0x00, 0xe5, 0x21, 0xa6,
-    0x27, 0x26, 0x27, 0x26, 0xe0, 0x01, 0x45, 0x06,
-    0xe5, 0x00, 0x06, 0x07, 0x20, 0xe9, 0x02, 0x20,
-    0x76, 0xe5, 0x08, 0x04, 0xa5, 0x4f, 0x05, 0x07,
-    0x06, 0x07, 0xe5, 0x2a, 0x06, 0x05, 0x46, 0x25,
-    0x26, 0x85, 0x26, 0x05, 0x06, 0x05, 0xe0, 0x10,
-    0x25, 0x04, 0x36, 0xe5, 0x03, 0x07, 0x26, 0x27,
-    0x36, 0x05, 0x24, 0x07, 0x06, 0xe0, 0x02, 0xa5,
-    0x20, 0xa5, 0x20, 0xa5, 0xe0, 0x01, 0xc5, 0x00,
-    0xc5, 0x00, 0xe2, 0x23, 0x0e, 0x64, 0xe2, 0x01,
-    0x04, 0x2e, 0x60, 0xe2, 0x48, 0xe5, 0x1b, 0x27,
-    0x06, 0x27, 0x06, 0x27, 0x16, 0x07, 0x06, 0x20,
-    0xe9, 0x02, 0xa0, 0xe5, 0xab, 0x1c, 0xe0, 0x04,
-    0xe5, 0x0f, 0x60, 0xe5, 0x29, 0x60, 0xfc, 0x87,
-    0x78, 0xfd, 0x98, 0x78, 0xe5, 0x80, 0xe6, 0x20,
-    0xe5, 0x62, 0xe0, 0x1e, 0xc2, 0xe0, 0x04, 0x82,
-    0x80, 0x05, 0x06, 0xe5, 0x02, 0x0c, 0xe5, 0x05,
-    0x00, 0x85, 0x00, 0x05, 0x00, 0x25, 0x00, 0x25,
-    0x00, 0xe5, 0x64, 0xee, 0x08, 0xe0, 0x09, 0xe5,
-    0x80, 0xe3, 0x13, 0x12, 0xe0, 0x08, 0xe5, 0x38,
-    0x20, 0xe5, 0x2e, 0xe0, 0x20, 0xe5, 0x04, 0x0d,
-    0x0f, 0x20, 0xe6, 0x08, 0xd6, 0x12, 0x13, 0x16,
-    0xa0, 0xe6, 0x08, 0x16, 0x31, 0x30, 0x12, 0x13,
-    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
-    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x36, 0x12,
-    0x13, 0x76, 0x50, 0x56, 0x00, 0x76, 0x11, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x56, 0x0c, 0x11,
-    0x4c, 0x00, 0x16, 0x0d, 0x36, 0x60, 0x85, 0x00,
-    0xe5, 0x7f, 0x20, 0x1b, 0x00, 0x56, 0x0d, 0x56,
-    0x12, 0x13, 0x16, 0x0c, 0x16, 0x11, 0x36, 0xe9,
-    0x02, 0x36, 0x4c, 0x36, 0xe1, 0x12, 0x12, 0x16,
-    0x13, 0x0e, 0x10, 0x0e, 0xe2, 0x12, 0x12, 0x0c,
-    0x13, 0x0c, 0x12, 0x13, 0x16, 0x12, 0x13, 0x36,
-    0xe5, 0x02, 0x04, 0xe5, 0x25, 0x24, 0xe5, 0x17,
-    0x40, 0xa5, 0x20, 0xa5, 0x20, 0xa5, 0x20, 0x45,
-    0x40, 0x2d, 0x0c, 0x0e, 0x0f, 0x2d, 0x00, 0x0f,
-    0x6c, 0x2f, 0xe0, 0x02, 0x5b, 0x2f, 0x20, 0xe5,
-    0x04, 0x00, 0xe5, 0x12, 0x00, 0xe5, 0x0b, 0x00,
-    0x25, 0x00, 0xe5, 0x07, 0x20, 0xe5, 0x06, 0xe0,
-    0x1a, 0xe5, 0x73, 0x80, 0x56, 0x60, 0xeb, 0x25,
-    0x40, 0xef, 0x01, 0xea, 0x2d, 0x6b, 0xef, 0x09,
-    0x2b, 0x4f, 0x00, 0xef, 0x05, 0x40, 0x0f, 0xe0,
-    0x27, 0xef, 0x25, 0x06, 0xe0, 0x7a, 0xe5, 0x15,
-    0x40, 0xe5, 0x29, 0xe0, 0x07, 0x06, 0xeb, 0x13,
-    0x60, 0xe5, 0x18, 0x6b, 0xe0, 0x01, 0xe5, 0x0c,
-    0x0a, 0xe5, 0x00, 0x0a, 0x80, 0xe5, 0x1e, 0x86,
-    0x80, 0xe5, 0x16, 0x00, 0x16, 0xe5, 0x1c, 0x60,
-    0xe5, 0x00, 0x16, 0x8a, 0xe0, 0x22, 0xe1, 0x20,
-    0xe2, 0x20, 0xe5, 0x46, 0x20, 0xe9, 0x02, 0xa0,
-    0xe1, 0x1c, 0x60, 0xe2, 0x1c, 0x60, 0xe5, 0x20,
-    0xe0, 0x00, 0xe5, 0x2c, 0xe0, 0x03, 0x16, 0xe0,
-    0x80, 0x08, 0xe5, 0x80, 0xaf, 0xe0, 0x01, 0xe5,
-    0x0e, 0xe0, 0x02, 0xe5, 0x00, 0xe0, 0x80, 0x10,
-    0xa5, 0x20, 0x05, 0x00, 0xe5, 0x24, 0x00, 0x25,
-    0x40, 0x05, 0x20, 0xe5, 0x0f, 0x00, 0x16, 0xeb,
-    0x00, 0xe5, 0x0f, 0x2f, 0xcb, 0xe5, 0x17, 0xe0,
-    0x00, 0xeb, 0x01, 0xe0, 0x28, 0xe5, 0x0b, 0x00,
-    0x25, 0x80, 0x8b, 0xe5, 0x0e, 0xab, 0x40, 0x16,
-    0xe5, 0x12, 0x80, 0x16, 0xe0, 0x38, 0xe5, 0x30,
-    0x60, 0x2b, 0x25, 0xeb, 0x08, 0x20, 0xeb, 0x26,
-    0x05, 0x46, 0x00, 0x26, 0x80, 0x66, 0x65, 0x00,
-    0x45, 0x00, 0xe5, 0x15, 0x20, 0x46, 0x60, 0x06,
-    0xeb, 0x01, 0xc0, 0xf6, 0x01, 0xc0, 0xe5, 0x15,
-    0x2b, 0x16, 0xe5, 0x15, 0x4b, 0xe0, 0x18, 0xe5,
-    0x00, 0x0f, 0xe5, 0x14, 0x26, 0x60, 0x8b, 0xd6,
-    0xe0, 0x01, 0xe5, 0x2e, 0x40, 0xd6, 0xe5, 0x0e,
-    0x20, 0xeb, 0x00, 0xe5, 0x0b, 0x80, 0xeb, 0x00,
-    0xe5, 0x0a, 0xc0, 0x76, 0xe0, 0x04, 0xcb, 0xe0,
-    0x48, 0xe5, 0x41, 0xe0, 0x2f, 0xe1, 0x2b, 0xe0,
-    0x05, 0xe2, 0x2b, 0xc0, 0xab, 0xe5, 0x1c, 0x66,
-    0xe0, 0x00, 0xe9, 0x02, 0xe0, 0x80, 0x9e, 0xeb,
-    0x17, 0x00, 0xe5, 0x22, 0x00, 0x26, 0x11, 0x20,
-    0x25, 0xe0, 0x46, 0xe5, 0x15, 0xeb, 0x02, 0x05,
-    0xe0, 0x00, 0xe5, 0x0e, 0xe6, 0x03, 0x6b, 0x96,
-    0xe0, 0x4e, 0xe5, 0x0d, 0xcb, 0xe0, 0x0c, 0xe5,
+    0x16, 0x12, 0xf6, 0x05, 0xe0, 0x28, 0xef, 0x12,
+    0x00, 0xef, 0x51, 0xe0, 0x04, 0xef, 0x80, 0x4e,
+    0xe0, 0x12, 0xef, 0x04, 0x60, 0x17, 0x56, 0x0f,
+    0x04, 0x05, 0x0a, 0x12, 0x13, 0x12, 0x13, 0x12,
+    0x13, 0x12, 0x13, 0x12, 0x13, 0x2f, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x11, 0x12,
+    0x33, 0x0f, 0xea, 0x01, 0x66, 0x27, 0x11, 0x84,
+    0x2f, 0x4a, 0x04, 0x05, 0x16, 0x2f, 0x00, 0xe5,
+    0x4e, 0x20, 0x26, 0x2e, 0x24, 0x05, 0x11, 0xe5,
+    0x52, 0x16, 0x44, 0x05, 0x80, 0xe5, 0x23, 0x00,
+    0xe5, 0x56, 0x00, 0x2f, 0x6b, 0xef, 0x02, 0xe5,
+    0x13, 0x80, 0xef, 0x1c, 0xe0, 0x04, 0xe5, 0x08,
+    0xef, 0x17, 0x00, 0xeb, 0x02, 0xef, 0x16, 0xeb,
+    0x00, 0x0f, 0xeb, 0x07, 0xef, 0x18, 0xeb, 0x02,
+    0xef, 0x1f, 0xeb, 0x07, 0xef, 0x80, 0xb8, 0xe5,
+    0x99, 0x2e, 0xe0, 0x02, 0xef, 0x38, 0xe5, 0xc0,
+    0x11, 0x68, 0xe0, 0x08, 0xe5, 0x0d, 0x04, 0xe5,
+    0x83, 0xef, 0x40, 0xef, 0x2f, 0xe0, 0x01, 0xe5,
+    0x20, 0xa4, 0x36, 0xe5, 0x80, 0x84, 0x04, 0x56,
+    0xe5, 0x08, 0xe9, 0x02, 0x25, 0xe0, 0x0c, 0xff,
+    0x26, 0x05, 0x06, 0x48, 0x16, 0xe6, 0x02, 0x16,
+    0x04, 0xff, 0x14, 0x24, 0x26, 0xe5, 0x3e, 0xea,
+    0x02, 0x26, 0xb6, 0xe0, 0x00, 0xee, 0x0f, 0xe4,
+    0x01, 0x2e, 0xff, 0x06, 0x22, 0xff, 0x36, 0x04,
+    0xe2, 0x00, 0x9f, 0xff, 0x02, 0x04, 0x2e, 0x7f,
+    0x05, 0x7f, 0x22, 0xff, 0x0d, 0x61, 0x02, 0x81,
+    0x02, 0xff, 0x02, 0x20, 0x5f, 0x21, 0xe0, 0x28,
+    0x05, 0x24, 0x02, 0xc5, 0x06, 0x45, 0x06, 0x65,
+    0x06, 0xe5, 0x0f, 0x27, 0x26, 0x07, 0x6f, 0x60,
+    0xab, 0x2f, 0x0d, 0x0f, 0xa0, 0xe5, 0x2c, 0x76,
+    0xe0, 0x00, 0x27, 0xe5, 0x2a, 0xe7, 0x08, 0x26,
+    0xe0, 0x00, 0x36, 0xe9, 0x02, 0xa0, 0xe6, 0x0a,
+    0xa5, 0x56, 0x05, 0x16, 0x25, 0x06, 0xe9, 0x02,
+    0xe5, 0x14, 0xe6, 0x00, 0x36, 0xe5, 0x0f, 0xe6,
+    0x03, 0x27, 0xe0, 0x03, 0x16, 0xe5, 0x15, 0x40,
+    0x46, 0x07, 0xe5, 0x27, 0x06, 0x27, 0x66, 0x27,
+    0x26, 0x47, 0xf6, 0x05, 0x00, 0x04, 0xe9, 0x02,
+    0x60, 0x36, 0x85, 0x06, 0x04, 0xe5, 0x01, 0xe9,
+    0x02, 0x85, 0x00, 0xe5, 0x21, 0xa6, 0x27, 0x26,
+    0x27, 0x26, 0xe0, 0x01, 0x45, 0x06, 0xe5, 0x00,
+    0x06, 0x07, 0x20, 0xe9, 0x02, 0x20, 0x76, 0xe5,
+    0x08, 0x04, 0xa5, 0x4f, 0x05, 0x07, 0x06, 0x07,
+    0xe5, 0x2a, 0x06, 0x05, 0x46, 0x25, 0x26, 0x85,
+    0x26, 0x05, 0x06, 0x05, 0xe0, 0x10, 0x25, 0x04,
+    0x36, 0xe5, 0x03, 0x07, 0x26, 0x27, 0x36, 0x05,
+    0x24, 0x07, 0x06, 0xe0, 0x02, 0xa5, 0x20, 0xa5,
+    0x20, 0xa5, 0xe0, 0x01, 0xc5, 0x00, 0xc5, 0x00,
+    0xe2, 0x23, 0x0e, 0x64, 0xe2, 0x00, 0xe0, 0x00,
+    0xe2, 0x48, 0xe5, 0x1b, 0x27, 0x06, 0x27, 0x06,
+    0x27, 0x16, 0x07, 0x06, 0x20, 0xe9, 0x02, 0xa0,
+    0xe5, 0xab, 0x1c, 0xe0, 0x04, 0xe5, 0x0f, 0x60,
+    0xe5, 0x29, 0x60, 0xfc, 0x87, 0x78, 0xfd, 0x98,
+    0x78, 0xe5, 0x80, 0xe6, 0x20, 0xe5, 0x62, 0xe0,
+    0x1e, 0xc2, 0xe0, 0x04, 0x82, 0x80, 0x05, 0x06,
+    0xe5, 0x02, 0x0c, 0xe5, 0x05, 0x00, 0x85, 0x00,
+    0x05, 0x00, 0x25, 0x00, 0x25, 0x00, 0xe5, 0x64,
+    0xee, 0x08, 0xe0, 0x09, 0xe5, 0x80, 0xe3, 0x13,
+    0x12, 0xe0, 0x08, 0xe5, 0x38, 0x20, 0xe5, 0x2e,
+    0xe0, 0x20, 0xe5, 0x04, 0x0d, 0x0f, 0x20, 0xe6,
+    0x08, 0xd6, 0x12, 0x13, 0x16, 0xa0, 0xe6, 0x08,
+    0x16, 0x31, 0x30, 0x12, 0x13, 0x12, 0x13, 0x12,
+    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
+    0x13, 0x12, 0x13, 0x36, 0x12, 0x13, 0x76, 0x50,
+    0x56, 0x00, 0x76, 0x11, 0x12, 0x13, 0x12, 0x13,
+    0x12, 0x13, 0x56, 0x0c, 0x11, 0x4c, 0x00, 0x16,
+    0x0d, 0x36, 0x60, 0x85, 0x00, 0xe5, 0x7f, 0x20,
+    0x1b, 0x00, 0x56, 0x0d, 0x56, 0x12, 0x13, 0x16,
+    0x0c, 0x16, 0x11, 0x36, 0xe9, 0x02, 0x36, 0x4c,
+    0x36, 0xe1, 0x12, 0x12, 0x16, 0x13, 0x0e, 0x10,
+    0x0e, 0xe2, 0x12, 0x12, 0x0c, 0x13, 0x0c, 0x12,
+    0x13, 0x16, 0x12, 0x13, 0x36, 0xe5, 0x02, 0x04,
+    0xe5, 0x25, 0x24, 0xe5, 0x17, 0x40, 0xa5, 0x20,
+    0xa5, 0x20, 0xa5, 0x20, 0x45, 0x40, 0x2d, 0x0c,
+    0x0e, 0x0f, 0x2d, 0x00, 0x0f, 0x6c, 0x2f, 0xe0,
+    0x02, 0x5b, 0x2f, 0x20, 0xe5, 0x04, 0x00, 0xe5,
+    0x12, 0x00, 0xe5, 0x0b, 0x00, 0x25, 0x00, 0xe5,
+    0x07, 0x20, 0xe5, 0x06, 0xe0, 0x1a, 0xe5, 0x73,
+    0x80, 0x56, 0x60, 0xeb, 0x25, 0x40, 0xef, 0x01,
+    0xea, 0x2d, 0x6b, 0xef, 0x09, 0x2b, 0x4f, 0x00,
+    0xef, 0x04, 0x60, 0x0f, 0xe0, 0x27, 0xef, 0x25,
+    0x06, 0xe0, 0x7a, 0xe5, 0x15, 0x40, 0xe5, 0x29,
+    0xe0, 0x07, 0x06, 0xeb, 0x13, 0x60, 0xe5, 0x18,
+    0x6b, 0xe0, 0x01, 0xe5, 0x0c, 0x0a, 0xe5, 0x00,
+    0x0a, 0x80, 0xe5, 0x1e, 0x86, 0x80, 0xe5, 0x16,
+    0x00, 0x16, 0xe5, 0x1c, 0x60, 0xe5, 0x00, 0x16,
+    0x8a, 0xe0, 0x22, 0xe1, 0x20, 0xe2, 0x20, 0xe5,
+    0x46, 0x20, 0xe9, 0x02, 0xa0, 0xe1, 0x1c, 0x60,
+    0xe2, 0x1c, 0x60, 0xe5, 0x20, 0xe0, 0x00, 0xe5,
+    0x2c, 0xe0, 0x03, 0x16, 0xe0, 0x80, 0x08, 0xe5,
+    0x80, 0xaf, 0xe0, 0x01, 0xe5, 0x0e, 0xe0, 0x02,
+    0xe5, 0x00, 0xe0, 0x80, 0x10, 0xa5, 0x20, 0x05,
+    0x00, 0xe5, 0x24, 0x00, 0x25, 0x40, 0x05, 0x20,
+    0xe5, 0x0f, 0x00, 0x16, 0xeb, 0x00, 0xe5, 0x0f,
+    0x2f, 0xcb, 0xe5, 0x17, 0xe0, 0x00, 0xeb, 0x01,
+    0xe0, 0x28, 0xe5, 0x0b, 0x00, 0x25, 0x80, 0x8b,
+    0xe5, 0x0e, 0xab, 0x40, 0x16, 0xe5, 0x12, 0x80,
+    0x16, 0xe0, 0x38, 0xe5, 0x30, 0x60, 0x2b, 0x25,
+    0xeb, 0x08, 0x20, 0xeb, 0x26, 0x05, 0x46, 0x00,
+    0x26, 0x80, 0x66, 0x65, 0x00, 0x45, 0x00, 0xe5,
+    0x15, 0x20, 0x46, 0x60, 0x06, 0xeb, 0x01, 0xc0,
+    0xf6, 0x01, 0xc0, 0xe5, 0x15, 0x2b, 0x16, 0xe5,
+    0x15, 0x4b, 0xe0, 0x18, 0xe5, 0x00, 0x0f, 0xe5,
+    0x14, 0x26, 0x60, 0x8b, 0xd6, 0xe0, 0x01, 0xe5,
+    0x2e, 0x40, 0xd6, 0xe5, 0x0e, 0x20, 0xeb, 0x00,
+    0xe5, 0x0b, 0x80, 0xeb, 0x00, 0xe5, 0x0a, 0xc0,
+    0x76, 0xe0, 0x04, 0xcb, 0xe0, 0x48, 0xe5, 0x41,
+    0xe0, 0x2f, 0xe1, 0x2b, 0xe0, 0x05, 0xe2, 0x2b,
+    0xc0, 0xab, 0xe5, 0x1c, 0x66, 0xe0, 0x00, 0xe9,
+    0x02, 0xe0, 0x80, 0x9e, 0xeb, 0x17, 0xe0, 0x79,
+    0xe5, 0x15, 0xeb, 0x02, 0x05, 0xe0, 0x00, 0xe5,
+    0x0e, 0xe6, 0x03, 0x6b, 0x96, 0xe0, 0x7e, 0xe5,
     0x0f, 0xe0, 0x01, 0x07, 0x06, 0x07, 0xe5, 0x2d,
     0xe6, 0x07, 0xd6, 0x60, 0xeb, 0x0c, 0xe9, 0x02,
     0xe0, 0x07, 0x46, 0x07, 0xe5, 0x25, 0x47, 0x66,
     0x27, 0x26, 0x36, 0x1b, 0x76, 0xe0, 0x03, 0x1b,
     0x20, 0xe5, 0x11, 0xc0, 0xe9, 0x02, 0xa0, 0x46,
     0xe5, 0x1c, 0x86, 0x07, 0xe6, 0x00, 0x00, 0xe9,
-    0x02, 0x76, 0x05, 0x27, 0x05, 0xe0, 0x00, 0xe5,
-    0x1b, 0x06, 0x36, 0x05, 0xe0, 0x01, 0x26, 0x07,
-    0xe5, 0x28, 0x47, 0xe6, 0x01, 0x27, 0x65, 0x76,
-    0x66, 0x16, 0x07, 0x06, 0xe9, 0x02, 0x05, 0x16,
-    0x05, 0x56, 0x00, 0xeb, 0x0c, 0xe0, 0x03, 0xe5,
-    0x0a, 0x00, 0xe5, 0x11, 0x47, 0x46, 0x27, 0x06,
-    0x07, 0x26, 0xb6, 0x06, 0xe0, 0x39, 0xc5, 0x00,
-    0x05, 0x00, 0x65, 0x00, 0xe5, 0x07, 0x00, 0xe5,
-    0x02, 0x16, 0xa0, 0xe5, 0x27, 0x06, 0x47, 0xe6,
-    0x00, 0x80, 0xe9, 0x02, 0xa0, 0x26, 0x27, 0x00,
-    0xe5, 0x00, 0x20, 0x25, 0x20, 0xe5, 0x0e, 0x00,
-    0xc5, 0x00, 0x25, 0x00, 0x85, 0x00, 0x26, 0x05,
-    0x27, 0x06, 0x67, 0x20, 0x27, 0x20, 0x47, 0x20,
-    0x05, 0xa0, 0x07, 0x80, 0x85, 0x27, 0x20, 0xc6,
-    0x40, 0x86, 0xe0, 0x80, 0x03, 0xe5, 0x2d, 0x47,
-    0xe6, 0x00, 0x27, 0x46, 0x07, 0x06, 0x65, 0x96,
-    0xe9, 0x02, 0x36, 0x00, 0x16, 0x06, 0x45, 0xe0,
-    0x16, 0xe5, 0x28, 0x47, 0xa6, 0x07, 0x06, 0x67,
-    0x26, 0x07, 0x26, 0x25, 0x16, 0x05, 0xe0, 0x00,
-    0xe9, 0x02, 0xe0, 0x80, 0x1e, 0xe5, 0x27, 0x47,
-    0x66, 0x20, 0x67, 0x26, 0x07, 0x26, 0xf6, 0x0f,
-    0x65, 0x26, 0xe0, 0x1a, 0xe5, 0x28, 0x47, 0xe6,
-    0x00, 0x27, 0x06, 0x07, 0x26, 0x56, 0x05, 0xe0,
-    0x03, 0xe9, 0x02, 0xa0, 0xf6, 0x05, 0xe0, 0x0b,
-    0xe5, 0x23, 0x06, 0x07, 0x06, 0x27, 0xa6, 0x07,
-    0x06, 0x05, 0xc0, 0xe9, 0x02, 0xe0, 0x2e, 0xe5,
-    0x13, 0x20, 0x46, 0x27, 0x66, 0x07, 0x86, 0x60,
-    0xe9, 0x02, 0x2b, 0x56, 0x0f, 0xe0, 0x80, 0x38,
-    0xe5, 0x24, 0x47, 0xe6, 0x01, 0x07, 0x26, 0x16,
-    0xe0, 0x5c, 0xe1, 0x18, 0xe2, 0x18, 0xe9, 0x02,
-    0xeb, 0x01, 0xe0, 0x04, 0xe5, 0x00, 0x20, 0x05,
-    0x20, 0xe5, 0x00, 0x00, 0x25, 0x00, 0xe5, 0x10,
-    0xa7, 0x00, 0x27, 0x20, 0x26, 0x07, 0x06, 0x05,
-    0x07, 0x05, 0x07, 0x06, 0x56, 0xe0, 0x01, 0xe9,
-    0x02, 0xe0, 0x3e, 0xe5, 0x00, 0x20, 0xe5, 0x1f,
-    0x47, 0x66, 0x20, 0x26, 0x67, 0x06, 0x05, 0x16,
-    0x05, 0x07, 0xe0, 0x13, 0x05, 0xe6, 0x02, 0xe5,
-    0x20, 0xa6, 0x07, 0x05, 0x66, 0xf6, 0x00, 0x06,
-    0xe0, 0x00, 0x05, 0xa6, 0x27, 0x46, 0xe5, 0x26,
-    0xe6, 0x05, 0x07, 0x26, 0x56, 0x05, 0x96, 0xe0,
-    0x15, 0xe5, 0x31, 0xe0, 0x80, 0x7f, 0xe5, 0x01,
-    0x00, 0xe5, 0x1d, 0x07, 0xc6, 0x00, 0xa6, 0x07,
-    0x06, 0x05, 0x96, 0xe0, 0x02, 0xe9, 0x02, 0xeb,
-    0x0b, 0x40, 0x36, 0xe5, 0x16, 0x20, 0xe6, 0x0e,
-    0x00, 0x07, 0xc6, 0x07, 0x26, 0x07, 0x26, 0xe0,
-    0x41, 0xc5, 0x00, 0x25, 0x00, 0xe5, 0x1e, 0xa6,
-    0x40, 0x06, 0x00, 0x26, 0x00, 0xc6, 0x05, 0x06,
-    0xe0, 0x00, 0xe9, 0x02, 0xa0, 0xa5, 0x00, 0x25,
-    0x00, 0xe5, 0x18, 0x87, 0x00, 0x26, 0x00, 0x27,
-    0x06, 0x07, 0x06, 0x05, 0xc0, 0xe9, 0x02, 0xe0,
-    0x80, 0xae, 0xe5, 0x0b, 0x26, 0x27, 0x36, 0xe0,
-    0x80, 0x2f, 0x05, 0xe0, 0x07, 0xeb, 0x0d, 0xef,
-    0x00, 0x6d, 0xef, 0x09, 0xe0, 0x05, 0x16, 0xe5,
-    0x83, 0x12, 0xe0, 0x5e, 0xea, 0x67, 0x00, 0x96,
-    0xe0, 0x03, 0xe5, 0x80, 0x3c, 0xe0, 0x8a, 0x34,
-    0xe5, 0x83, 0xa7, 0x00, 0xfb, 0x01, 0xe0, 0x8f,
-    0x3f, 0xe5, 0x81, 0xbf, 0xe0, 0xa1, 0x31, 0xe5,
-    0x81, 0xb1, 0xc0, 0xe5, 0x17, 0x00, 0xe9, 0x02,
-    0x60, 0x36, 0xe0, 0x58, 0xe5, 0x16, 0x20, 0x86,
-    0x16, 0xe0, 0x02, 0xe5, 0x28, 0xc6, 0x96, 0x6f,
-    0x64, 0x16, 0x0f, 0xe0, 0x02, 0xe9, 0x02, 0x00,
-    0xcb, 0x00, 0xe5, 0x0d, 0x80, 0xe5, 0x0b, 0xe0,
-    0x82, 0x28, 0xe1, 0x18, 0xe2, 0x18, 0xeb, 0x0f,
-    0x76, 0xe0, 0x5d, 0xe5, 0x43, 0x60, 0x06, 0x05,
-    0xe7, 0x2f, 0xc0, 0x66, 0xe4, 0x05, 0xe0, 0x38,
-    0x24, 0x16, 0x04, 0x06, 0xe0, 0x03, 0x27, 0xe0,
-    0x06, 0xe5, 0x97, 0x70, 0xe0, 0x00, 0xe5, 0x84,
-    0x4e, 0xe0, 0x22, 0xe5, 0x01, 0xe0, 0xa2, 0x6f,
-    0xe5, 0x80, 0x97, 0xe0, 0x29, 0x45, 0xe0, 0x09,
-    0x65, 0xe0, 0x00, 0xe5, 0x81, 0x04, 0xe0, 0x88,
-    0x7c, 0xe5, 0x63, 0x80, 0xe5, 0x05, 0x40, 0xe5,
-    0x01, 0xc0, 0xe5, 0x02, 0x20, 0x0f, 0x26, 0x16,
-    0x7b, 0xe0, 0x92, 0xd4, 0xef, 0x80, 0x6e, 0xe0,
-    0x02, 0xef, 0x1f, 0x20, 0xef, 0x34, 0x27, 0x46,
-    0x4f, 0xa7, 0xfb, 0x00, 0xe6, 0x00, 0x2f, 0xc6,
-    0xef, 0x16, 0x66, 0xef, 0x33, 0xe0, 0x0f, 0xef,
-    0x3a, 0x46, 0x0f, 0xe0, 0x80, 0x12, 0xeb, 0x0c,
-    0xe0, 0x04, 0xef, 0x4f, 0xe0, 0x01, 0xeb, 0x11,
-    0xe0, 0x7f, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
-    0xc2, 0x00, 0xe2, 0x0a, 0xe1, 0x12, 0xe2, 0x12,
-    0x01, 0x00, 0x21, 0x20, 0x01, 0x20, 0x21, 0x20,
-    0x61, 0x00, 0xe1, 0x00, 0x62, 0x00, 0x02, 0x00,
-    0xc2, 0x00, 0xe2, 0x03, 0xe1, 0x12, 0xe2, 0x12,
-    0x21, 0x00, 0x61, 0x20, 0xe1, 0x00, 0x00, 0xc1,
-    0x00, 0xe2, 0x12, 0x21, 0x00, 0x61, 0x00, 0x81,
-    0x00, 0x01, 0x40, 0xc1, 0x00, 0xe2, 0x12, 0xe1,
-    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1,
-    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1,
-    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x14, 0x20,
+    0x02, 0x76, 0x05, 0x27, 0xe0, 0x01, 0xe5, 0x1b,
+    0x06, 0x36, 0x05, 0xe0, 0x01, 0x26, 0x07, 0xe5,
+    0x28, 0x47, 0xe6, 0x01, 0x27, 0x65, 0x76, 0x66,
+    0x16, 0x20, 0xe9, 0x02, 0x05, 0x16, 0x05, 0x56,
+    0x00, 0xeb, 0x0c, 0xe0, 0x03, 0xe5, 0x0a, 0x00,
+    0xe5, 0x11, 0x47, 0x46, 0x27, 0x06, 0x07, 0x26,
+    0xb6, 0x06, 0xe0, 0x39, 0xc5, 0x00, 0x05, 0x00,
+    0x65, 0x00, 0xe5, 0x07, 0x00, 0xe5, 0x02, 0x16,
+    0xa0, 0xe5, 0x27, 0x06, 0x47, 0xe6, 0x00, 0x80,
+    0xe9, 0x02, 0xa0, 0x26, 0x27, 0x00, 0xe5, 0x00,
+    0x20, 0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5, 0x00,
+    0x25, 0x00, 0x85, 0x00, 0x26, 0x05, 0x27, 0x06,
+    0x67, 0x20, 0x27, 0x20, 0x47, 0x20, 0x05, 0xa0,
+    0x07, 0x80, 0x85, 0x27, 0x20, 0xc6, 0x40, 0x86,
+    0xe0, 0x80, 0x03, 0xe5, 0x2d, 0x47, 0xe6, 0x00,
+    0x27, 0x46, 0x07, 0x06, 0x65, 0x96, 0xe9, 0x02,
+    0x00, 0x16, 0x00, 0x16, 0x06, 0x05, 0xe0, 0x18,
+    0xe5, 0x28, 0x47, 0xa6, 0x07, 0x06, 0x67, 0x26,
+    0x07, 0x26, 0x25, 0x16, 0x05, 0xe0, 0x00, 0xe9,
+    0x02, 0xe0, 0x80, 0x1e, 0xe5, 0x27, 0x47, 0x66,
+    0x20, 0x67, 0x26, 0x07, 0x26, 0xf6, 0x0f, 0x65,
+    0x26, 0xe0, 0x1a, 0xe5, 0x28, 0x47, 0xe6, 0x00,
+    0x27, 0x06, 0x07, 0x26, 0x56, 0x05, 0xe0, 0x03,
+    0xe9, 0x02, 0xa0, 0xf6, 0x05, 0xe0, 0x0b, 0xe5,
+    0x23, 0x06, 0x07, 0x06, 0x27, 0xa6, 0x07, 0x06,
+    0x05, 0xc0, 0xe9, 0x02, 0xe0, 0x2e, 0xe5, 0x13,
+    0x20, 0x46, 0x27, 0x66, 0x07, 0x86, 0x60, 0xe9,
+    0x02, 0x2b, 0x56, 0x0f, 0xe0, 0x80, 0x38, 0xe5,
+    0x24, 0x47, 0xe6, 0x01, 0x07, 0x26, 0x16, 0xe0,
+    0x5c, 0xe1, 0x18, 0xe2, 0x18, 0xe9, 0x02, 0xeb,
+    0x01, 0xe0, 0x04, 0x05, 0xe0, 0x80, 0x18, 0xe5,
+    0x00, 0x20, 0xe5, 0x1f, 0x47, 0x66, 0x20, 0x26,
+    0x67, 0x06, 0x05, 0x16, 0x05, 0x07, 0xe0, 0x13,
+    0x05, 0xe6, 0x02, 0xe5, 0x20, 0xa6, 0x07, 0x05,
+    0x66, 0xf6, 0x00, 0x06, 0xe0, 0x00, 0x05, 0xa6,
+    0x27, 0x46, 0xe5, 0x26, 0xe6, 0x05, 0x07, 0x26,
+    0x56, 0x05, 0x96, 0xe0, 0x15, 0xe5, 0x31, 0xe0,
+    0x80, 0x7f, 0xe5, 0x01, 0x00, 0xe5, 0x1d, 0x07,
+    0xc6, 0x00, 0xa6, 0x07, 0x06, 0x05, 0x96, 0xe0,
+    0x02, 0xe9, 0x02, 0xeb, 0x0b, 0x40, 0x36, 0xe5,
+    0x16, 0x20, 0xe6, 0x0e, 0x00, 0x07, 0xc6, 0x07,
+    0x26, 0x07, 0x26, 0xe0, 0x41, 0xc5, 0x00, 0x25,
+    0x00, 0xe5, 0x1e, 0xa6, 0x40, 0x06, 0x00, 0x26,
+    0x00, 0xc6, 0x05, 0x06, 0xe0, 0x00, 0xe9, 0x02,
+    0xa0, 0xa5, 0x00, 0x25, 0x00, 0xe5, 0x18, 0x87,
+    0x00, 0x26, 0x00, 0x27, 0x06, 0x07, 0x06, 0x05,
+    0xc0, 0xe9, 0x02, 0xe0, 0x80, 0xae, 0xe5, 0x0b,
+    0x26, 0x27, 0x36, 0xe0, 0x80, 0x3f, 0xeb, 0x0d,
+    0xef, 0x00, 0x6d, 0xef, 0x09, 0xe0, 0x05, 0x16,
+    0xe5, 0x83, 0x12, 0xe0, 0x5e, 0xea, 0x67, 0x00,
+    0x96, 0xe0, 0x03, 0xe5, 0x80, 0x3c, 0xe0, 0x8a,
+    0x34, 0xe5, 0x83, 0xa7, 0x00, 0xfb, 0x01, 0xe0,
+    0x8f, 0x3f, 0xe5, 0x81, 0xbf, 0xe0, 0xa1, 0x31,
+    0xe5, 0x81, 0xb1, 0xc0, 0xe5, 0x17, 0x00, 0xe9,
+    0x02, 0x60, 0x36, 0xe0, 0x58, 0xe5, 0x16, 0x20,
+    0x86, 0x16, 0xe0, 0x02, 0xe5, 0x28, 0xc6, 0x96,
+    0x6f, 0x64, 0x16, 0x0f, 0xe0, 0x02, 0xe9, 0x02,
+    0x00, 0xcb, 0x00, 0xe5, 0x0d, 0x80, 0xe5, 0x0b,
+    0xe0, 0x82, 0x28, 0xe1, 0x18, 0xe2, 0x18, 0xeb,
+    0x0f, 0x76, 0xe0, 0x5d, 0xe5, 0x43, 0x60, 0x06,
+    0x05, 0xe7, 0x2f, 0xc0, 0x66, 0xe4, 0x05, 0xe0,
+    0x38, 0x24, 0x16, 0x04, 0xe0, 0x14, 0xe5, 0x97,
+    0x70, 0xe0, 0x00, 0xe5, 0x82, 0x6b, 0xe0, 0xa4,
+    0x85, 0xe5, 0x80, 0x97, 0xe0, 0x29, 0x45, 0xe0,
+    0x09, 0x65, 0xe0, 0x00, 0xe5, 0x81, 0x04, 0xe0,
+    0x88, 0x7c, 0xe5, 0x63, 0x80, 0xe5, 0x05, 0x40,
+    0xe5, 0x01, 0xc0, 0xe5, 0x02, 0x20, 0x0f, 0x26,
+    0x16, 0x7b, 0xe0, 0x92, 0xd4, 0xef, 0x80, 0x6e,
+    0xe0, 0x02, 0xef, 0x1f, 0x20, 0xef, 0x34, 0x27,
+    0x46, 0x4f, 0xa7, 0xfb, 0x00, 0xe6, 0x00, 0x2f,
+    0xc6, 0xef, 0x16, 0x66, 0xef, 0x33, 0xe0, 0x0f,
+    0xef, 0x3a, 0x46, 0x0f, 0xe0, 0x80, 0x12, 0xeb,
+    0x0c, 0xe0, 0x04, 0xef, 0x4f, 0xe0, 0x01, 0xeb,
+    0x11, 0xe0, 0x7f, 0xe1, 0x12, 0xe2, 0x12, 0xe1,
+    0x12, 0xc2, 0x00, 0xe2, 0x0a, 0xe1, 0x12, 0xe2,
+    0x12, 0x01, 0x00, 0x21, 0x20, 0x01, 0x20, 0x21,
+    0x20, 0x61, 0x00, 0xe1, 0x00, 0x62, 0x00, 0x02,
+    0x00, 0xc2, 0x00, 0xe2, 0x03, 0xe1, 0x12, 0xe2,
+    0x12, 0x21, 0x00, 0x61, 0x20, 0xe1, 0x00, 0x00,
+    0xc1, 0x00, 0xe2, 0x12, 0x21, 0x00, 0x61, 0x00,
+    0x81, 0x00, 0x01, 0x40, 0xc1, 0x00, 0xe2, 0x12,
+    0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12,
+    0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12,
+    0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x14,
+    0x20, 0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2,
     0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1,
     0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11,
     0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11, 0x0c,
-    0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11, 0x0c, 0xe2,
-    0x11, 0x0c, 0xa2, 0x3f, 0x20, 0xe9, 0x2a, 0xef,
-    0x81, 0x78, 0xe6, 0x2f, 0x6f, 0xe6, 0x2a, 0xef,
-    0x00, 0x06, 0xef, 0x06, 0x06, 0x2f, 0x96, 0xe0,
-    0x07, 0x86, 0x00, 0xe6, 0x07, 0xe0, 0x84, 0xc8,
-    0xc6, 0x00, 0xe6, 0x09, 0x20, 0xc6, 0x00, 0x26,
-    0x00, 0x86, 0xe0, 0x80, 0x4d, 0xe5, 0x25, 0x40,
-    0xc6, 0xc4, 0x20, 0xe9, 0x02, 0x60, 0x05, 0x0f,
-    0xe0, 0x80, 0xe8, 0xe5, 0x24, 0x66, 0xe9, 0x02,
-    0x80, 0x0d, 0xe0, 0x84, 0x78, 0xe5, 0x80, 0x3d,
-    0x20, 0xeb, 0x01, 0xc6, 0xe0, 0x21, 0xe1, 0x1a,
-    0xe2, 0x1a, 0xc6, 0x04, 0x60, 0xe9, 0x02, 0x60,
-    0x36, 0xe0, 0x82, 0x89, 0xeb, 0x33, 0x0f, 0x4b,
-    0x0d, 0x6b, 0xe0, 0x44, 0xeb, 0x25, 0x0f, 0xeb,
-    0x07, 0xe0, 0x80, 0x3a, 0x65, 0x00, 0xe5, 0x13,
-    0x00, 0x25, 0x00, 0x05, 0x20, 0x05, 0x00, 0xe5,
-    0x02, 0x00, 0x65, 0x00, 0x05, 0x00, 0x05, 0xa0,
-    0x05, 0x60, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00,
-    0x45, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05, 0x00,
-    0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00,
-    0x25, 0x00, 0x05, 0x20, 0x65, 0x00, 0xc5, 0x00,
-    0x65, 0x00, 0x65, 0x00, 0x05, 0x00, 0xe5, 0x02,
-    0x00, 0xe5, 0x09, 0x80, 0x45, 0x00, 0x85, 0x00,
-    0xe5, 0x09, 0xe0, 0x2c, 0x2c, 0xe0, 0x80, 0x86,
-    0xef, 0x24, 0x60, 0xef, 0x5c, 0xe0, 0x04, 0xef,
-    0x07, 0x20, 0xef, 0x07, 0x00, 0xef, 0x07, 0x00,
-    0xef, 0x1d, 0xe0, 0x02, 0xeb, 0x05, 0xef, 0x80,
-    0x19, 0xe0, 0x30, 0xef, 0x15, 0xe0, 0x05, 0xef,
-    0x24, 0x60, 0xef, 0x01, 0xc0, 0x2f, 0xe0, 0x06,
-    0xaf, 0xe0, 0x80, 0x12, 0xef, 0x80, 0x73, 0x8e,
-    0xef, 0x82, 0x50, 0xe0, 0x00, 0xef, 0x05, 0x40,
-    0xef, 0x05, 0x40, 0xef, 0x6c, 0xe0, 0x04, 0xef,
-    0x51, 0xc0, 0xef, 0x04, 0xe0, 0x0c, 0xef, 0x04,
-    0x60, 0xef, 0x30, 0xe0, 0x00, 0xef, 0x02, 0xa0,
-    0xef, 0x20, 0xe0, 0x00, 0xef, 0x16, 0x20, 0x2f,
-    0xe0, 0x46, 0xef, 0x71, 0x00, 0xef, 0x4a, 0x00,
-    0xef, 0x7f, 0xe0, 0x04, 0xef, 0x06, 0x20, 0x8f,
-    0x40, 0x4f, 0x80, 0xcf, 0xe0, 0x01, 0xef, 0x11,
-    0xc0, 0xcf, 0xe0, 0x01, 0x4f, 0xe0, 0x05, 0xcf,
-    0xe0, 0x21, 0xef, 0x80, 0x0b, 0x00, 0xef, 0x2f,
-    0xe0, 0x1d, 0xe9, 0x02, 0xe0, 0x83, 0x7e, 0xe5,
-    0xc0, 0x66, 0x56, 0xe0, 0x1a, 0xe5, 0x8f, 0xad,
-    0xe0, 0x03, 0xe5, 0x80, 0x56, 0x20, 0xe5, 0x95,
-    0xfa, 0xe0, 0x06, 0xe5, 0x9c, 0xa9, 0xe0, 0x8b,
-    0x97, 0xe5, 0x81, 0x96, 0xe0, 0x85, 0x5a, 0xe5,
-    0x92, 0xc3, 0xe0, 0xca, 0xac, 0x2e, 0x1b, 0xe0,
-    0x16, 0xfb, 0x58, 0xe0, 0x78, 0xe6, 0x80, 0x68,
-    0xe0, 0xc0, 0xbd, 0x88, 0xfd, 0xc0, 0xbf, 0x76,
-    0x20, 0xfd, 0xc0, 0xbf, 0x76, 0x20,
+    0xe2, 0x11, 0x0c, 0xa2, 0x3f, 0x20, 0xe9, 0x2a,
+    0xef, 0x81, 0x78, 0xe6, 0x2f, 0x6f, 0xe6, 0x2a,
+    0xef, 0x00, 0x06, 0xef, 0x06, 0x06, 0x2f, 0x96,
+    0xe0, 0x07, 0x86, 0x00, 0xe6, 0x07, 0xe0, 0x84,
+    0xc8, 0xc6, 0x00, 0xe6, 0x09, 0x20, 0xc6, 0x00,
+    0x26, 0x00, 0x86, 0xe0, 0x80, 0x4d, 0xe5, 0x25,
+    0x40, 0xc6, 0xc4, 0x20, 0xe9, 0x02, 0x60, 0x05,
+    0x0f, 0xe0, 0x80, 0xe8, 0xe5, 0x24, 0x66, 0xe9,
+    0x02, 0x80, 0x0d, 0xe0, 0x84, 0x78, 0xe5, 0x80,
+    0x3d, 0x20, 0xeb, 0x01, 0xc6, 0xe0, 0x21, 0xe1,
+    0x1a, 0xe2, 0x1a, 0xc6, 0x04, 0x60, 0xe9, 0x02,
+    0x60, 0x36, 0xe0, 0x82, 0x89, 0xeb, 0x33, 0x0f,
+    0x4b, 0x0d, 0x6b, 0xe0, 0x44, 0xeb, 0x25, 0x0f,
+    0xeb, 0x07, 0xe0, 0x80, 0x3a, 0x65, 0x00, 0xe5,
+    0x13, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05, 0x00,
+    0xe5, 0x02, 0x00, 0x65, 0x00, 0x05, 0x00, 0x05,
+    0xa0, 0x05, 0x60, 0x05, 0x00, 0x05, 0x00, 0x05,
+    0x00, 0x45, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05,
+    0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05,
+    0x00, 0x25, 0x00, 0x05, 0x20, 0x65, 0x00, 0xc5,
+    0x00, 0x65, 0x00, 0x65, 0x00, 0x05, 0x00, 0xe5,
+    0x02, 0x00, 0xe5, 0x09, 0x80, 0x45, 0x00, 0x85,
+    0x00, 0xe5, 0x09, 0xe0, 0x2c, 0x2c, 0xe0, 0x80,
+    0x86, 0xef, 0x24, 0x60, 0xef, 0x5c, 0xe0, 0x04,
+    0xef, 0x07, 0x20, 0xef, 0x07, 0x00, 0xef, 0x07,
+    0x00, 0xef, 0x1d, 0xe0, 0x02, 0xeb, 0x05, 0x40,
+    0xef, 0x55, 0x40, 0xef, 0x35, 0xe0, 0x31, 0xef,
+    0x15, 0xe0, 0x05, 0xef, 0x24, 0x60, 0xef, 0x01,
+    0xc0, 0x2f, 0xe0, 0x06, 0xaf, 0xe0, 0x80, 0x12,
+    0xef, 0x80, 0x73, 0x8e, 0xef, 0x82, 0x4e, 0xe0,
+    0x02, 0xef, 0x05, 0x40, 0xef, 0x03, 0x80, 0xef,
+    0x6c, 0xe0, 0x04, 0xef, 0x51, 0xc0, 0xef, 0x04,
+    0xe0, 0x0c, 0xef, 0x04, 0x60, 0xef, 0x30, 0xe0,
+    0x00, 0xef, 0x02, 0xa0, 0xef, 0x20, 0xe0, 0x00,
+    0xef, 0x16, 0xe0, 0x4a, 0xef, 0x04, 0x00, 0xef,
+    0x5d, 0x00, 0x6f, 0x40, 0xef, 0x21, 0x20, 0xaf,
+    0x40, 0xef, 0x15, 0x20, 0xef, 0x7f, 0xe0, 0x04,
+    0xef, 0x06, 0x20, 0x6f, 0x60, 0x4f, 0x80, 0x4f,
+    0xe0, 0x05, 0xaf, 0xe0, 0x84, 0xe2, 0xe5, 0xc0,
+    0x66, 0x4f, 0xe0, 0x21, 0xe5, 0x8f, 0xad, 0xe0,
+    0x03, 0xe5, 0x80, 0x56, 0x20, 0xe5, 0x95, 0xfa,
+    0xe0, 0x06, 0xe5, 0x9c, 0xa9, 0xe0, 0x8b, 0x97,
+    0xe5, 0x81, 0x96, 0xe0, 0xca, 0xc5, 0x5b, 0x1b,
+    0xe0, 0x16, 0xfb, 0x58, 0xe0, 0x78, 0xe6, 0x80,
+    0x68, 0xe0, 0xc0, 0xbd, 0x88, 0xfd, 0xc0, 0xbf,
+    0x76, 0x20, 0xfd, 0xc0, 0xbf, 0x76, 0x20,
 };
 
 typedef enum {
@@ -2781,7 +2753,6 @@ typedef enum {
     UNICODE_SCRIPT_Chakma,
     UNICODE_SCRIPT_Cham,
     UNICODE_SCRIPT_Cherokee,
-    UNICODE_SCRIPT_Chorasmian,
     UNICODE_SCRIPT_Common,
     UNICODE_SCRIPT_Coptic,
     UNICODE_SCRIPT_Cuneiform,
@@ -2789,7 +2760,6 @@ typedef enum {
     UNICODE_SCRIPT_Cyrillic,
     UNICODE_SCRIPT_Deseret,
     UNICODE_SCRIPT_Devanagari,
-    UNICODE_SCRIPT_Dives_Akuru,
     UNICODE_SCRIPT_Dogra,
     UNICODE_SCRIPT_Duployan,
     UNICODE_SCRIPT_Egyptian_Hieroglyphs,
@@ -2823,7 +2793,6 @@ typedef enum {
     UNICODE_SCRIPT_Kharoshthi,
     UNICODE_SCRIPT_Khmer,
     UNICODE_SCRIPT_Khojki,
-    UNICODE_SCRIPT_Khitan_Small_Script,
     UNICODE_SCRIPT_Khudawadi,
     UNICODE_SCRIPT_Lao,
     UNICODE_SCRIPT_Latin,
@@ -2911,7 +2880,6 @@ typedef enum {
     UNICODE_SCRIPT_Vai,
     UNICODE_SCRIPT_Wancho,
     UNICODE_SCRIPT_Warang_Citi,
-    UNICODE_SCRIPT_Yezidi,
     UNICODE_SCRIPT_Yi,
     UNICODE_SCRIPT_Zanabazar_Square,
     UNICODE_SCRIPT_COUNT,
@@ -2941,7 +2909,6 @@ static const char unicode_script_name_table[] =
     "Chakma,Cakm"                 "\0"
     "Cham,Cham"                   "\0"
     "Cherokee,Cher"               "\0"
-    "Chorasmian,Chrs"             "\0"
     "Common,Zyyy"                 "\0"
     "Coptic,Copt,Qaac"            "\0"
     "Cuneiform,Xsux"              "\0"
@@ -2949,7 +2916,6 @@ static const char unicode_script_name_table[] =
     "Cyrillic,Cyrl"               "\0"
     "Deseret,Dsrt"                "\0"
     "Devanagari,Deva"             "\0"
-    "Dives_Akuru,Diak"            "\0"
     "Dogra,Dogr"                  "\0"
     "Duployan,Dupl"               "\0"
     "Egyptian_Hieroglyphs,Egyp"   "\0"
@@ -2983,7 +2949,6 @@ static const char unicode_script_name_table[] =
     "Kharoshthi,Khar"             "\0"
     "Khmer,Khmr"                  "\0"
     "Khojki,Khoj"                 "\0"
-    "Khitan_Small_Script,Kits"    "\0"
     "Khudawadi,Sind"              "\0"
     "Lao,Laoo"                    "\0"
     "Latin,Latn"                  "\0"
@@ -3071,442 +3036,434 @@ static const char unicode_script_name_table[] =
     "Vai,Vaii"                    "\0"
     "Wancho,Wcho"                 "\0"
     "Warang_Citi,Wara"            "\0"
-    "Yezidi,Yezi"                 "\0"
     "Yi,Yiii"                     "\0"
     "Zanabazar_Square,Zanb"       "\0"
 ;
 
-static const uint8_t unicode_script_table[2609] = {
-    0xc0, 0x19, 0x99, 0x45, 0x85, 0x19, 0x99, 0x45,
-    0xae, 0x19, 0x80, 0x45, 0x8e, 0x19, 0x80, 0x45,
-    0x84, 0x19, 0x96, 0x45, 0x80, 0x19, 0x9e, 0x45,
-    0x80, 0x19, 0xe1, 0x60, 0x45, 0xa6, 0x19, 0x84,
-    0x45, 0x84, 0x19, 0x81, 0x0d, 0x93, 0x19, 0xe0,
-    0x0f, 0x37, 0x83, 0x2b, 0x80, 0x19, 0x82, 0x2b,
-    0x01, 0x83, 0x2b, 0x80, 0x19, 0x80, 0x2b, 0x03,
-    0x80, 0x2b, 0x80, 0x19, 0x80, 0x2b, 0x80, 0x19,
-    0x82, 0x2b, 0x00, 0x80, 0x2b, 0x00, 0x93, 0x2b,
-    0x00, 0xbe, 0x2b, 0x8d, 0x1a, 0x8f, 0x2b, 0xe0,
-    0x24, 0x1d, 0x81, 0x37, 0xe0, 0x48, 0x1d, 0x00,
-    0xa5, 0x05, 0x01, 0xb1, 0x05, 0x01, 0x82, 0x05,
-    0x00, 0xb6, 0x34, 0x07, 0x9a, 0x34, 0x03, 0x85,
-    0x34, 0x0a, 0x84, 0x04, 0x80, 0x19, 0x85, 0x04,
-    0x80, 0x19, 0x8d, 0x04, 0x80, 0x19, 0x80, 0x04,
-    0x00, 0x80, 0x04, 0x80, 0x19, 0x9f, 0x04, 0x80,
-    0x19, 0x89, 0x04, 0x8a, 0x37, 0x99, 0x04, 0x80,
-    0x37, 0xe0, 0x0b, 0x04, 0x80, 0x19, 0xa1, 0x04,
-    0x8d, 0x87, 0x00, 0xbb, 0x87, 0x01, 0x82, 0x87,
-    0xaf, 0x04, 0xb1, 0x91, 0x0d, 0xba, 0x63, 0x01,
-    0x82, 0x63, 0xad, 0x7b, 0x01, 0x8e, 0x7b, 0x00,
-    0x9b, 0x50, 0x01, 0x80, 0x50, 0x00, 0x8a, 0x87,
-    0x34, 0x94, 0x04, 0x00, 0x91, 0x04, 0x0a, 0x8e,
-    0x04, 0x80, 0x19, 0x9c, 0x04, 0xd0, 0x1f, 0x83,
-    0x37, 0x8e, 0x1f, 0x81, 0x19, 0x99, 0x1f, 0x83,
-    0x0b, 0x00, 0x87, 0x0b, 0x01, 0x81, 0x0b, 0x01,
-    0x95, 0x0b, 0x00, 0x86, 0x0b, 0x00, 0x80, 0x0b,
-    0x02, 0x83, 0x0b, 0x01, 0x88, 0x0b, 0x01, 0x81,
-    0x0b, 0x01, 0x83, 0x0b, 0x07, 0x80, 0x0b, 0x03,
-    0x81, 0x0b, 0x00, 0x84, 0x0b, 0x01, 0x98, 0x0b,
-    0x01, 0x82, 0x2e, 0x00, 0x85, 0x2e, 0x03, 0x81,
-    0x2e, 0x01, 0x95, 0x2e, 0x00, 0x86, 0x2e, 0x00,
-    0x81, 0x2e, 0x00, 0x81, 0x2e, 0x00, 0x81, 0x2e,
-    0x01, 0x80, 0x2e, 0x00, 0x84, 0x2e, 0x03, 0x81,
-    0x2e, 0x01, 0x82, 0x2e, 0x02, 0x80, 0x2e, 0x06,
-    0x83, 0x2e, 0x00, 0x80, 0x2e, 0x06, 0x90, 0x2e,
-    0x09, 0x82, 0x2c, 0x00, 0x88, 0x2c, 0x00, 0x82,
-    0x2c, 0x00, 0x95, 0x2c, 0x00, 0x86, 0x2c, 0x00,
-    0x81, 0x2c, 0x00, 0x84, 0x2c, 0x01, 0x89, 0x2c,
-    0x00, 0x82, 0x2c, 0x00, 0x82, 0x2c, 0x01, 0x80,
-    0x2c, 0x0e, 0x83, 0x2c, 0x01, 0x8b, 0x2c, 0x06,
-    0x86, 0x2c, 0x00, 0x82, 0x70, 0x00, 0x87, 0x70,
-    0x01, 0x81, 0x70, 0x01, 0x95, 0x70, 0x00, 0x86,
-    0x70, 0x00, 0x81, 0x70, 0x00, 0x84, 0x70, 0x01,
-    0x88, 0x70, 0x01, 0x81, 0x70, 0x01, 0x82, 0x70,
-    0x06, 0x82, 0x70, 0x03, 0x81, 0x70, 0x00, 0x84,
-    0x70, 0x01, 0x91, 0x70, 0x09, 0x81, 0x8e, 0x00,
-    0x85, 0x8e, 0x02, 0x82, 0x8e, 0x00, 0x83, 0x8e,
-    0x02, 0x81, 0x8e, 0x00, 0x80, 0x8e, 0x00, 0x81,
-    0x8e, 0x02, 0x81, 0x8e, 0x02, 0x82, 0x8e, 0x02,
-    0x8b, 0x8e, 0x03, 0x84, 0x8e, 0x02, 0x82, 0x8e,
-    0x00, 0x83, 0x8e, 0x01, 0x80, 0x8e, 0x05, 0x80,
-    0x8e, 0x0d, 0x94, 0x8e, 0x04, 0x8c, 0x90, 0x00,
-    0x82, 0x90, 0x00, 0x96, 0x90, 0x00, 0x8f, 0x90,
-    0x02, 0x87, 0x90, 0x00, 0x82, 0x90, 0x00, 0x83,
-    0x90, 0x06, 0x81, 0x90, 0x00, 0x82, 0x90, 0x04,
-    0x83, 0x90, 0x01, 0x89, 0x90, 0x06, 0x88, 0x90,
-    0x8c, 0x3c, 0x00, 0x82, 0x3c, 0x00, 0x96, 0x3c,
-    0x00, 0x89, 0x3c, 0x00, 0x84, 0x3c, 0x01, 0x88,
-    0x3c, 0x00, 0x82, 0x3c, 0x00, 0x83, 0x3c, 0x06,
-    0x81, 0x3c, 0x06, 0x80, 0x3c, 0x00, 0x83, 0x3c,
-    0x01, 0x89, 0x3c, 0x00, 0x81, 0x3c, 0x0c, 0x8c,
-    0x4f, 0x00, 0x82, 0x4f, 0x00, 0xb2, 0x4f, 0x00,
-    0x82, 0x4f, 0x00, 0x85, 0x4f, 0x03, 0x8f, 0x4f,
-    0x01, 0x99, 0x4f, 0x00, 0x82, 0x81, 0x00, 0x91,
-    0x81, 0x02, 0x97, 0x81, 0x00, 0x88, 0x81, 0x00,
-    0x80, 0x81, 0x01, 0x86, 0x81, 0x02, 0x80, 0x81,
-    0x03, 0x85, 0x81, 0x00, 0x80, 0x81, 0x00, 0x87,
-    0x81, 0x05, 0x89, 0x81, 0x01, 0x82, 0x81, 0x0b,
-    0xb9, 0x92, 0x03, 0x80, 0x19, 0x9b, 0x92, 0x24,
-    0x81, 0x44, 0x00, 0x80, 0x44, 0x00, 0x84, 0x44,
-    0x00, 0x97, 0x44, 0x00, 0x80, 0x44, 0x00, 0x96,
-    0x44, 0x01, 0x84, 0x44, 0x00, 0x80, 0x44, 0x00,
-    0x85, 0x44, 0x01, 0x89, 0x44, 0x01, 0x83, 0x44,
-    0x1f, 0xc7, 0x93, 0x00, 0xa3, 0x93, 0x03, 0xa6,
-    0x93, 0x00, 0xa3, 0x93, 0x00, 0x8e, 0x93, 0x00,
-    0x86, 0x93, 0x83, 0x19, 0x81, 0x93, 0x24, 0xe0,
-    0x3f, 0x5e, 0xa5, 0x27, 0x00, 0x80, 0x27, 0x04,
-    0x80, 0x27, 0x01, 0xaa, 0x27, 0x80, 0x19, 0x83,
-    0x27, 0xe0, 0x9f, 0x30, 0xc8, 0x26, 0x00, 0x83,
-    0x26, 0x01, 0x86, 0x26, 0x00, 0x80, 0x26, 0x00,
-    0x83, 0x26, 0x01, 0xa8, 0x26, 0x00, 0x83, 0x26,
-    0x01, 0xa0, 0x26, 0x00, 0x83, 0x26, 0x01, 0x86,
-    0x26, 0x00, 0x80, 0x26, 0x00, 0x83, 0x26, 0x01,
-    0x8e, 0x26, 0x00, 0xb8, 0x26, 0x00, 0x83, 0x26,
-    0x01, 0xc2, 0x26, 0x01, 0x9f, 0x26, 0x02, 0x99,
-    0x26, 0x05, 0xd5, 0x17, 0x01, 0x85, 0x17, 0x01,
-    0xe2, 0x1f, 0x12, 0x9c, 0x66, 0x02, 0xca, 0x7a,
-    0x82, 0x19, 0x8a, 0x7a, 0x06, 0x8c, 0x88, 0x00,
-    0x86, 0x88, 0x0a, 0x94, 0x32, 0x81, 0x19, 0x08,
-    0x93, 0x11, 0x0b, 0x8c, 0x89, 0x00, 0x82, 0x89,
-    0x00, 0x81, 0x89, 0x0b, 0xdd, 0x40, 0x01, 0x89,
-    0x40, 0x05, 0x89, 0x40, 0x05, 0x81, 0x5b, 0x81,
-    0x19, 0x80, 0x5b, 0x80, 0x19, 0x88, 0x5b, 0x00,
-    0x89, 0x5b, 0x05, 0xd8, 0x5b, 0x06, 0xaa, 0x5b,
-    0x04, 0xc5, 0x12, 0x09, 0x9e, 0x47, 0x00, 0x8b,
-    0x47, 0x03, 0x8b, 0x47, 0x03, 0x80, 0x47, 0x02,
-    0x8b, 0x47, 0x9d, 0x8a, 0x01, 0x84, 0x8a, 0x0a,
-    0xab, 0x61, 0x03, 0x99, 0x61, 0x05, 0x8a, 0x61,
-    0x02, 0x81, 0x61, 0x9f, 0x40, 0x9b, 0x10, 0x01,
-    0x81, 0x10, 0xbe, 0x8b, 0x00, 0x9c, 0x8b, 0x01,
-    0x8a, 0x8b, 0x05, 0x89, 0x8b, 0x05, 0x8d, 0x8b,
-    0x01, 0x90, 0x37, 0x3e, 0xcb, 0x07, 0x03, 0xac,
-    0x07, 0x02, 0xbf, 0x85, 0xb3, 0x0a, 0x07, 0x83,
-    0x0a, 0xb7, 0x46, 0x02, 0x8e, 0x46, 0x02, 0x82,
-    0x46, 0xaf, 0x67, 0x88, 0x1d, 0x06, 0xaa, 0x27,
-    0x01, 0x82, 0x27, 0x87, 0x85, 0x07, 0x82, 0x37,
-    0x80, 0x19, 0x8c, 0x37, 0x80, 0x19, 0x86, 0x37,
-    0x83, 0x19, 0x80, 0x37, 0x85, 0x19, 0x80, 0x37,
-    0x82, 0x19, 0x81, 0x37, 0x80, 0x19, 0x04, 0xa5,
-    0x45, 0x84, 0x2b, 0x80, 0x1d, 0xb0, 0x45, 0x84,
-    0x2b, 0x83, 0x45, 0x84, 0x2b, 0x8c, 0x45, 0x80,
-    0x1d, 0xc5, 0x45, 0x80, 0x2b, 0xb9, 0x37, 0x00,
-    0x84, 0x37, 0xe0, 0x9f, 0x45, 0x95, 0x2b, 0x01,
-    0x85, 0x2b, 0x01, 0xa5, 0x2b, 0x01, 0x85, 0x2b,
-    0x01, 0x87, 0x2b, 0x00, 0x80, 0x2b, 0x00, 0x80,
-    0x2b, 0x00, 0x80, 0x2b, 0x00, 0x9e, 0x2b, 0x01,
-    0xb4, 0x2b, 0x00, 0x8e, 0x2b, 0x00, 0x8d, 0x2b,
-    0x01, 0x85, 0x2b, 0x00, 0x92, 0x2b, 0x01, 0x82,
-    0x2b, 0x00, 0x88, 0x2b, 0x00, 0x8b, 0x19, 0x81,
-    0x37, 0xd6, 0x19, 0x00, 0x8a, 0x19, 0x80, 0x45,
-    0x01, 0x8a, 0x19, 0x80, 0x45, 0x8e, 0x19, 0x00,
-    0x8c, 0x45, 0x02, 0x9f, 0x19, 0x0f, 0xa0, 0x37,
-    0x0e, 0xa5, 0x19, 0x80, 0x2b, 0x82, 0x19, 0x81,
-    0x45, 0x85, 0x19, 0x80, 0x45, 0x9a, 0x19, 0x80,
-    0x45, 0x90, 0x19, 0xa8, 0x45, 0x82, 0x19, 0x03,
-    0xe2, 0x36, 0x19, 0x18, 0x8a, 0x19, 0x14, 0xe3,
-    0x3f, 0x19, 0xe0, 0x9f, 0x0f, 0xe2, 0x13, 0x19,
-    0x01, 0x9f, 0x19, 0x00, 0xe0, 0x08, 0x19, 0xae,
-    0x28, 0x00, 0xae, 0x28, 0x00, 0x9f, 0x45, 0xe0,
-    0x13, 0x1a, 0x04, 0x86, 0x1a, 0xa5, 0x27, 0x00,
-    0x80, 0x27, 0x04, 0x80, 0x27, 0x01, 0xb7, 0x94,
-    0x06, 0x81, 0x94, 0x0d, 0x80, 0x94, 0x96, 0x26,
-    0x08, 0x86, 0x26, 0x00, 0x86, 0x26, 0x00, 0x86,
-    0x26, 0x00, 0x86, 0x26, 0x00, 0x86, 0x26, 0x00,
-    0x86, 0x26, 0x00, 0x86, 0x26, 0x00, 0x86, 0x26,
-    0x00, 0x9f, 0x1d, 0xd2, 0x19, 0x2c, 0x99, 0x2f,
-    0x00, 0xd8, 0x2f, 0x0b, 0xe0, 0x75, 0x2f, 0x19,
-    0x8b, 0x19, 0x03, 0x84, 0x19, 0x80, 0x2f, 0x80,
-    0x19, 0x80, 0x2f, 0x98, 0x19, 0x88, 0x2f, 0x83,
-    0x37, 0x81, 0x30, 0x87, 0x19, 0x83, 0x2f, 0x83,
-    0x19, 0x00, 0xd5, 0x35, 0x01, 0x81, 0x37, 0x81,
-    0x19, 0x82, 0x35, 0x80, 0x19, 0xd9, 0x3d, 0x81,
-    0x19, 0x82, 0x3d, 0x04, 0xaa, 0x0d, 0x00, 0xdd,
-    0x30, 0x00, 0x8f, 0x19, 0x9f, 0x0d, 0xa3, 0x19,
-    0x0b, 0x8f, 0x3d, 0x9e, 0x30, 0x00, 0xbf, 0x19,
-    0x9e, 0x30, 0xd0, 0x19, 0xae, 0x3d, 0x80, 0x19,
-    0xd7, 0x3d, 0xe0, 0x47, 0x19, 0xf0, 0x09, 0x5f,
-    0x2f, 0xbf, 0x19, 0xf0, 0x41, 0x9c, 0x2f, 0x02,
-    0xe4, 0x2c, 0x9b, 0x02, 0xb6, 0x9b, 0x08, 0xaf,
-    0x4a, 0xe0, 0xcb, 0x97, 0x13, 0xdf, 0x1d, 0xd7,
-    0x08, 0x07, 0xa1, 0x19, 0xe0, 0x05, 0x45, 0x82,
-    0x19, 0xb4, 0x45, 0x01, 0x88, 0x45, 0x29, 0x8a,
-    0x45, 0xac, 0x86, 0x02, 0x89, 0x19, 0x05, 0xb7,
-    0x76, 0x07, 0xc5, 0x7c, 0x07, 0x8b, 0x7c, 0x05,
-    0x9f, 0x1f, 0xad, 0x3e, 0x80, 0x19, 0x80, 0x3e,
-    0xa3, 0x79, 0x0a, 0x80, 0x79, 0x9c, 0x30, 0x02,
-    0xcd, 0x3a, 0x00, 0x80, 0x19, 0x89, 0x3a, 0x03,
-    0x81, 0x3a, 0x9e, 0x5e, 0x00, 0xb6, 0x16, 0x08,
-    0x8d, 0x16, 0x01, 0x89, 0x16, 0x01, 0x83, 0x16,
-    0x9f, 0x5e, 0xc2, 0x8c, 0x17, 0x84, 0x8c, 0x96,
-    0x55, 0x09, 0x85, 0x26, 0x01, 0x85, 0x26, 0x01,
-    0x85, 0x26, 0x08, 0x86, 0x26, 0x00, 0x86, 0x26,
-    0x00, 0xaa, 0x45, 0x80, 0x19, 0x88, 0x45, 0x80,
-    0x2b, 0x83, 0x45, 0x81, 0x19, 0x03, 0xcf, 0x17,
-    0xad, 0x55, 0x01, 0x89, 0x55, 0x05, 0xf0, 0x1b,
-    0x43, 0x30, 0x0b, 0x96, 0x30, 0x03, 0xb0, 0x30,
-    0x70, 0x10, 0xa3, 0xe1, 0x0d, 0x2f, 0x01, 0xe0,
-    0x09, 0x2f, 0x25, 0x86, 0x45, 0x0b, 0x84, 0x05,
-    0x04, 0x99, 0x34, 0x00, 0x84, 0x34, 0x00, 0x80,
-    0x34, 0x00, 0x81, 0x34, 0x00, 0x81, 0x34, 0x00,
-    0x89, 0x34, 0xe0, 0x11, 0x04, 0x10, 0xe1, 0x0a,
-    0x04, 0x81, 0x19, 0x0f, 0xbf, 0x04, 0x01, 0xb5,
-    0x04, 0x27, 0x8d, 0x04, 0x01, 0x8f, 0x37, 0x89,
-    0x19, 0x05, 0x8d, 0x37, 0x81, 0x1d, 0xa2, 0x19,
-    0x00, 0x92, 0x19, 0x00, 0x83, 0x19, 0x03, 0x84,
-    0x04, 0x00, 0xe0, 0x26, 0x04, 0x01, 0x80, 0x19,
-    0x00, 0x9f, 0x19, 0x99, 0x45, 0x85, 0x19, 0x99,
-    0x45, 0x8a, 0x19, 0x89, 0x3d, 0x80, 0x19, 0xac,
-    0x3d, 0x81, 0x19, 0x9e, 0x30, 0x02, 0x85, 0x30,
-    0x01, 0x85, 0x30, 0x01, 0x85, 0x30, 0x01, 0x82,
-    0x30, 0x02, 0x86, 0x19, 0x00, 0x86, 0x19, 0x09,
-    0x84, 0x19, 0x01, 0x8b, 0x49, 0x00, 0x99, 0x49,
-    0x00, 0x92, 0x49, 0x00, 0x81, 0x49, 0x00, 0x8e,
-    0x49, 0x01, 0x8d, 0x49, 0x21, 0xe0, 0x1a, 0x49,
-    0x04, 0x82, 0x19, 0x03, 0xac, 0x19, 0x02, 0x88,
-    0x19, 0xce, 0x2b, 0x00, 0x8c, 0x19, 0x02, 0x80,
-    0x2b, 0x2e, 0xac, 0x19, 0x80, 0x37, 0x60, 0x21,
-    0x9c, 0x4b, 0x02, 0xb0, 0x13, 0x0e, 0x80, 0x37,
-    0x9a, 0x19, 0x03, 0xa3, 0x69, 0x08, 0x82, 0x69,
-    0x9a, 0x29, 0x04, 0xaa, 0x6b, 0x04, 0x9d, 0x96,
-    0x00, 0x80, 0x96, 0xa3, 0x6c, 0x03, 0x8d, 0x6c,
-    0x29, 0xcf, 0x1e, 0xaf, 0x7e, 0x9d, 0x72, 0x01,
-    0x89, 0x72, 0x05, 0xa3, 0x71, 0x03, 0xa3, 0x71,
-    0x03, 0xa7, 0x24, 0x07, 0xb3, 0x14, 0x0a, 0x80,
-    0x14, 0x60, 0x2f, 0xe0, 0xd6, 0x48, 0x08, 0x95,
-    0x48, 0x09, 0x87, 0x48, 0x60, 0x37, 0x85, 0x1c,
-    0x01, 0x80, 0x1c, 0x00, 0xab, 0x1c, 0x00, 0x81,
-    0x1c, 0x02, 0x80, 0x1c, 0x01, 0x80, 0x1c, 0x95,
-    0x36, 0x00, 0x88, 0x36, 0x9f, 0x74, 0x9e, 0x5f,
-    0x07, 0x88, 0x5f, 0x2f, 0x92, 0x33, 0x00, 0x81,
-    0x33, 0x04, 0x84, 0x33, 0x9b, 0x77, 0x02, 0x80,
-    0x77, 0x99, 0x4c, 0x04, 0x80, 0x4c, 0x3f, 0x9f,
-    0x58, 0x97, 0x57, 0x03, 0x93, 0x57, 0x01, 0xad,
-    0x57, 0x83, 0x3f, 0x00, 0x81, 0x3f, 0x04, 0x87,
-    0x3f, 0x00, 0x82, 0x3f, 0x00, 0x9c, 0x3f, 0x01,
-    0x82, 0x3f, 0x03, 0x89, 0x3f, 0x06, 0x88, 0x3f,
-    0x06, 0x9f, 0x6e, 0x9f, 0x6a, 0x1f, 0xa6, 0x51,
-    0x03, 0x8b, 0x51, 0x08, 0xb5, 0x06, 0x02, 0x86,
-    0x06, 0x95, 0x39, 0x01, 0x87, 0x39, 0x92, 0x38,
-    0x04, 0x87, 0x38, 0x91, 0x78, 0x06, 0x83, 0x78,
-    0x0b, 0x86, 0x78, 0x4f, 0xc8, 0x6f, 0x36, 0xb2,
-    0x68, 0x0c, 0xb2, 0x68, 0x06, 0x85, 0x68, 0xa7,
-    0x31, 0x07, 0x89, 0x31, 0x60, 0xc5, 0x9e, 0x04,
-    0x00, 0xa9, 0x9a, 0x00, 0x82, 0x9a, 0x01, 0x81,
-    0x9a, 0x4d, 0xa7, 0x6d, 0x07, 0xa9, 0x82, 0x55,
-    0x9b, 0x18, 0x13, 0x96, 0x25, 0x08, 0xcd, 0x0e,
-    0x03, 0x9d, 0x0e, 0x0e, 0x80, 0x0e, 0xc1, 0x3b,
-    0x0a, 0x80, 0x3b, 0x01, 0x98, 0x83, 0x06, 0x89,
-    0x83, 0x05, 0xb4, 0x15, 0x00, 0x91, 0x15, 0x07,
-    0xa6, 0x4e, 0x08, 0xdf, 0x7d, 0x00, 0x93, 0x81,
-    0x0a, 0x91, 0x41, 0x00, 0xab, 0x41, 0x40, 0x86,
-    0x5d, 0x00, 0x80, 0x5d, 0x00, 0x83, 0x5d, 0x00,
-    0x8e, 0x5d, 0x00, 0x8a, 0x5d, 0x05, 0xba, 0x43,
-    0x04, 0x89, 0x43, 0x05, 0x83, 0x2a, 0x00, 0x87,
-    0x2a, 0x01, 0x81, 0x2a, 0x01, 0x95, 0x2a, 0x00,
-    0x86, 0x2a, 0x00, 0x81, 0x2a, 0x00, 0x84, 0x2a,
-    0x00, 0x80, 0x37, 0x88, 0x2a, 0x01, 0x81, 0x2a,
-    0x01, 0x82, 0x2a, 0x01, 0x80, 0x2a, 0x05, 0x80,
-    0x2a, 0x04, 0x86, 0x2a, 0x01, 0x86, 0x2a, 0x02,
-    0x84, 0x2a, 0x60, 0x2a, 0xdb, 0x62, 0x00, 0x84,
-    0x62, 0x1d, 0xc7, 0x95, 0x07, 0x89, 0x95, 0x60,
-    0x45, 0xb5, 0x7f, 0x01, 0xa5, 0x7f, 0x21, 0xc4,
-    0x5a, 0x0a, 0x89, 0x5a, 0x05, 0x8c, 0x5b, 0x12,
-    0xb8, 0x8d, 0x06, 0x89, 0x8d, 0x35, 0x9a, 0x02,
-    0x01, 0x8e, 0x02, 0x03, 0x8f, 0x02, 0x60, 0x5f,
-    0xbb, 0x21, 0x60, 0x03, 0xd2, 0x99, 0x0b, 0x80,
-    0x99, 0x86, 0x20, 0x01, 0x80, 0x20, 0x01, 0x87,
-    0x20, 0x00, 0x81, 0x20, 0x00, 0x9d, 0x20, 0x00,
-    0x81, 0x20, 0x01, 0x8b, 0x20, 0x08, 0x89, 0x20,
-    0x45, 0x87, 0x60, 0x01, 0xad, 0x60, 0x01, 0x8a,
-    0x60, 0x1a, 0xc7, 0x9c, 0x07, 0xd2, 0x84, 0x1c,
-    0xb8, 0x75, 0x60, 0xa6, 0x88, 0x0c, 0x00, 0xac,
-    0x0c, 0x00, 0x8d, 0x0c, 0x09, 0x9c, 0x0c, 0x02,
-    0x9f, 0x52, 0x01, 0x95, 0x52, 0x00, 0x8d, 0x52,
-    0x48, 0x86, 0x53, 0x00, 0x81, 0x53, 0x00, 0xab,
-    0x53, 0x02, 0x80, 0x53, 0x00, 0x81, 0x53, 0x00,
-    0x88, 0x53, 0x07, 0x89, 0x53, 0x05, 0x85, 0x2d,
-    0x00, 0x81, 0x2d, 0x00, 0xa4, 0x2d, 0x00, 0x81,
-    0x2d, 0x00, 0x85, 0x2d, 0x06, 0x89, 0x2d, 0x60,
-    0xd5, 0x98, 0x4d, 0x60, 0x56, 0x80, 0x4a, 0x0e,
-    0xb1, 0x8e, 0x0c, 0x80, 0x8e, 0xe3, 0x39, 0x1b,
-    0x60, 0x05, 0xe0, 0x0e, 0x1b, 0x00, 0x84, 0x1b,
-    0x0a, 0xe0, 0x63, 0x1b, 0x6a, 0x5b, 0xe3, 0xce,
-    0x23, 0x00, 0x88, 0x23, 0x6f, 0x66, 0xe1, 0xe6,
-    0x03, 0x70, 0x11, 0x58, 0xe1, 0xd8, 0x08, 0x06,
-    0x9e, 0x5c, 0x00, 0x89, 0x5c, 0x03, 0x81, 0x5c,
-    0x5f, 0x9d, 0x09, 0x01, 0x85, 0x09, 0x09, 0xc5,
-    0x73, 0x09, 0x89, 0x73, 0x00, 0x86, 0x73, 0x00,
-    0x94, 0x73, 0x04, 0x92, 0x73, 0x62, 0x4f, 0xda,
-    0x54, 0x60, 0x04, 0xca, 0x59, 0x03, 0xb8, 0x59,
-    0x06, 0x90, 0x59, 0x3f, 0x80, 0x8f, 0x80, 0x64,
-    0x81, 0x19, 0x80, 0x42, 0x0a, 0x81, 0x2f, 0x0d,
-    0xf0, 0x07, 0x97, 0x8f, 0x07, 0xe2, 0x9f, 0x8f,
-    0xe1, 0x75, 0x42, 0x29, 0x88, 0x8f, 0x70, 0x12,
-    0x96, 0x80, 0x3d, 0xe0, 0xbd, 0x35, 0x30, 0x82,
-    0x35, 0x10, 0x83, 0x3d, 0x07, 0xe1, 0x2b, 0x64,
-    0x68, 0xa3, 0xe0, 0x0a, 0x22, 0x04, 0x8c, 0x22,
-    0x02, 0x88, 0x22, 0x06, 0x89, 0x22, 0x01, 0x83,
-    0x22, 0x83, 0x19, 0x70, 0x02, 0xfb, 0xe0, 0x95,
-    0x19, 0x09, 0xa6, 0x19, 0x01, 0xbd, 0x19, 0x82,
-    0x37, 0x90, 0x19, 0x87, 0x37, 0x81, 0x19, 0x86,
-    0x37, 0x9d, 0x19, 0x83, 0x37, 0xba, 0x19, 0x16,
-    0xc5, 0x2b, 0x60, 0x39, 0x93, 0x19, 0x0b, 0xd6,
-    0x19, 0x08, 0x98, 0x19, 0x60, 0x26, 0xd4, 0x19,
-    0x00, 0xc6, 0x19, 0x00, 0x81, 0x19, 0x01, 0x80,
-    0x19, 0x01, 0x81, 0x19, 0x01, 0x83, 0x19, 0x00,
-    0x8b, 0x19, 0x00, 0x80, 0x19, 0x00, 0x86, 0x19,
-    0x00, 0xc0, 0x19, 0x00, 0x83, 0x19, 0x01, 0x87,
-    0x19, 0x00, 0x86, 0x19, 0x00, 0x9b, 0x19, 0x00,
-    0x83, 0x19, 0x00, 0x84, 0x19, 0x00, 0x80, 0x19,
-    0x02, 0x86, 0x19, 0x00, 0xe0, 0xf3, 0x19, 0x01,
-    0xe0, 0xc3, 0x19, 0x01, 0xb1, 0x19, 0xe2, 0x2b,
-    0x80, 0x0e, 0x84, 0x80, 0x00, 0x8e, 0x80, 0x64,
-    0xef, 0x86, 0x28, 0x00, 0x90, 0x28, 0x01, 0x86,
-    0x28, 0x00, 0x81, 0x28, 0x00, 0x84, 0x28, 0x60,
-    0x74, 0xac, 0x65, 0x02, 0x8d, 0x65, 0x01, 0x89,
-    0x65, 0x03, 0x81, 0x65, 0x61, 0x0f, 0xb9, 0x98,
-    0x04, 0x80, 0x98, 0x64, 0x9f, 0xe0, 0x64, 0x56,
-    0x01, 0x8f, 0x56, 0x28, 0xcb, 0x01, 0x03, 0x89,
-    0x01, 0x03, 0x81, 0x01, 0x62, 0xb0, 0xc3, 0x19,
-    0x4b, 0xbc, 0x19, 0x60, 0x61, 0x83, 0x04, 0x00,
-    0x9a, 0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04,
-    0x01, 0x80, 0x04, 0x00, 0x89, 0x04, 0x00, 0x83,
-    0x04, 0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x05,
-    0x80, 0x04, 0x03, 0x80, 0x04, 0x00, 0x80, 0x04,
-    0x00, 0x80, 0x04, 0x00, 0x82, 0x04, 0x00, 0x81,
-    0x04, 0x00, 0x80, 0x04, 0x01, 0x80, 0x04, 0x00,
-    0x80, 0x04, 0x00, 0x80, 0x04, 0x00, 0x80, 0x04,
-    0x00, 0x80, 0x04, 0x00, 0x81, 0x04, 0x00, 0x80,
-    0x04, 0x01, 0x83, 0x04, 0x00, 0x86, 0x04, 0x00,
-    0x83, 0x04, 0x00, 0x83, 0x04, 0x00, 0x80, 0x04,
-    0x00, 0x89, 0x04, 0x00, 0x90, 0x04, 0x04, 0x82,
-    0x04, 0x00, 0x84, 0x04, 0x00, 0x90, 0x04, 0x33,
-    0x81, 0x04, 0x60, 0xad, 0xab, 0x19, 0x03, 0xe0,
-    0x03, 0x19, 0x0b, 0x8e, 0x19, 0x01, 0x8e, 0x19,
-    0x00, 0x8e, 0x19, 0x00, 0xa4, 0x19, 0x09, 0xe0,
-    0x4d, 0x19, 0x37, 0x99, 0x19, 0x80, 0x35, 0x81,
-    0x19, 0x0c, 0xab, 0x19, 0x03, 0x88, 0x19, 0x06,
-    0x81, 0x19, 0x0d, 0x85, 0x19, 0x60, 0x39, 0xe3,
-    0x77, 0x19, 0x07, 0x8c, 0x19, 0x02, 0x8c, 0x19,
-    0x02, 0xe0, 0x13, 0x19, 0x0b, 0xd8, 0x19, 0x06,
-    0x8b, 0x19, 0x13, 0x8b, 0x19, 0x03, 0xb7, 0x19,
-    0x07, 0x89, 0x19, 0x05, 0xa7, 0x19, 0x07, 0x9d,
-    0x19, 0x01, 0x81, 0x19, 0x4d, 0xe0, 0x18, 0x19,
-    0x00, 0xd1, 0x19, 0x00, 0xe0, 0x26, 0x19, 0x0b,
-    0x8d, 0x19, 0x01, 0x84, 0x19, 0x02, 0x82, 0x19,
-    0x04, 0x86, 0x19, 0x08, 0x98, 0x19, 0x06, 0x86,
-    0x19, 0x08, 0x82, 0x19, 0x0c, 0x86, 0x19, 0x28,
-    0xe0, 0x32, 0x19, 0x00, 0xb6, 0x19, 0x24, 0x89,
-    0x19, 0x63, 0xa5, 0xf0, 0x96, 0x7d, 0x2f, 0x21,
-    0xef, 0xd4, 0x2f, 0x0a, 0xe0, 0x7d, 0x2f, 0x01,
-    0xf0, 0x06, 0x21, 0x2f, 0x0d, 0xf0, 0x0c, 0xd0,
-    0x2f, 0x6b, 0xbe, 0xe1, 0xbd, 0x2f, 0x65, 0x81,
-    0xf0, 0x02, 0xea, 0x2f, 0x7a, 0xdc, 0x55, 0x80,
-    0x19, 0x1d, 0xdf, 0x19, 0x60, 0x1f, 0xe0, 0x8f,
-    0x37,
+static const uint8_t unicode_script_table[2565] = {
+    0xc0, 0x18, 0x99, 0x42, 0x85, 0x18, 0x99, 0x42,
+    0xae, 0x18, 0x80, 0x42, 0x8e, 0x18, 0x80, 0x42,
+    0x84, 0x18, 0x96, 0x42, 0x80, 0x18, 0x9e, 0x42,
+    0x80, 0x18, 0xe1, 0x60, 0x42, 0xa6, 0x18, 0x84,
+    0x42, 0x84, 0x18, 0x81, 0x0d, 0x93, 0x18, 0xe0,
+    0x0f, 0x35, 0x83, 0x29, 0x80, 0x18, 0x82, 0x29,
+    0x01, 0x83, 0x29, 0x80, 0x18, 0x80, 0x29, 0x03,
+    0x80, 0x29, 0x80, 0x18, 0x80, 0x29, 0x80, 0x18,
+    0x82, 0x29, 0x00, 0x80, 0x29, 0x00, 0x93, 0x29,
+    0x00, 0xbe, 0x29, 0x8d, 0x19, 0x8f, 0x29, 0xe0,
+    0x24, 0x1c, 0x81, 0x35, 0xe0, 0x48, 0x1c, 0x00,
+    0xa5, 0x05, 0x01, 0xaf, 0x05, 0x80, 0x18, 0x80,
+    0x05, 0x01, 0x82, 0x05, 0x00, 0xb6, 0x32, 0x07,
+    0x9a, 0x32, 0x03, 0x85, 0x32, 0x0a, 0x84, 0x04,
+    0x80, 0x18, 0x85, 0x04, 0x80, 0x18, 0x8d, 0x04,
+    0x80, 0x18, 0x80, 0x04, 0x00, 0x80, 0x04, 0x80,
+    0x18, 0x9f, 0x04, 0x80, 0x18, 0x89, 0x04, 0x8a,
+    0x35, 0x99, 0x04, 0x80, 0x35, 0xe0, 0x0b, 0x04,
+    0x80, 0x18, 0xa1, 0x04, 0x8d, 0x84, 0x00, 0xbb,
+    0x84, 0x01, 0x82, 0x84, 0xaf, 0x04, 0xb1, 0x8e,
+    0x0d, 0xba, 0x60, 0x01, 0x82, 0x60, 0xad, 0x78,
+    0x01, 0x8e, 0x78, 0x00, 0x9b, 0x4d, 0x01, 0x80,
+    0x4d, 0x00, 0x8a, 0x84, 0x34, 0x94, 0x04, 0x00,
+    0x87, 0x04, 0x14, 0x8e, 0x04, 0x80, 0x18, 0x9c,
+    0x04, 0xd0, 0x1e, 0x83, 0x35, 0x8e, 0x1e, 0x81,
+    0x18, 0x99, 0x1e, 0x83, 0x0b, 0x00, 0x87, 0x0b,
+    0x01, 0x81, 0x0b, 0x01, 0x95, 0x0b, 0x00, 0x86,
+    0x0b, 0x00, 0x80, 0x0b, 0x02, 0x83, 0x0b, 0x01,
+    0x88, 0x0b, 0x01, 0x81, 0x0b, 0x01, 0x83, 0x0b,
+    0x07, 0x80, 0x0b, 0x03, 0x81, 0x0b, 0x00, 0x84,
+    0x0b, 0x01, 0x98, 0x0b, 0x01, 0x82, 0x2c, 0x00,
+    0x85, 0x2c, 0x03, 0x81, 0x2c, 0x01, 0x95, 0x2c,
+    0x00, 0x86, 0x2c, 0x00, 0x81, 0x2c, 0x00, 0x81,
+    0x2c, 0x00, 0x81, 0x2c, 0x01, 0x80, 0x2c, 0x00,
+    0x84, 0x2c, 0x03, 0x81, 0x2c, 0x01, 0x82, 0x2c,
+    0x02, 0x80, 0x2c, 0x06, 0x83, 0x2c, 0x00, 0x80,
+    0x2c, 0x06, 0x90, 0x2c, 0x09, 0x82, 0x2a, 0x00,
+    0x88, 0x2a, 0x00, 0x82, 0x2a, 0x00, 0x95, 0x2a,
+    0x00, 0x86, 0x2a, 0x00, 0x81, 0x2a, 0x00, 0x84,
+    0x2a, 0x01, 0x89, 0x2a, 0x00, 0x82, 0x2a, 0x00,
+    0x82, 0x2a, 0x01, 0x80, 0x2a, 0x0e, 0x83, 0x2a,
+    0x01, 0x8b, 0x2a, 0x06, 0x86, 0x2a, 0x00, 0x82,
+    0x6d, 0x00, 0x87, 0x6d, 0x01, 0x81, 0x6d, 0x01,
+    0x95, 0x6d, 0x00, 0x86, 0x6d, 0x00, 0x81, 0x6d,
+    0x00, 0x84, 0x6d, 0x01, 0x88, 0x6d, 0x01, 0x81,
+    0x6d, 0x01, 0x82, 0x6d, 0x07, 0x81, 0x6d, 0x03,
+    0x81, 0x6d, 0x00, 0x84, 0x6d, 0x01, 0x91, 0x6d,
+    0x09, 0x81, 0x8b, 0x00, 0x85, 0x8b, 0x02, 0x82,
+    0x8b, 0x00, 0x83, 0x8b, 0x02, 0x81, 0x8b, 0x00,
+    0x80, 0x8b, 0x00, 0x81, 0x8b, 0x02, 0x81, 0x8b,
+    0x02, 0x82, 0x8b, 0x02, 0x8b, 0x8b, 0x03, 0x84,
+    0x8b, 0x02, 0x82, 0x8b, 0x00, 0x83, 0x8b, 0x01,
+    0x80, 0x8b, 0x05, 0x80, 0x8b, 0x0d, 0x94, 0x8b,
+    0x04, 0x8c, 0x8d, 0x00, 0x82, 0x8d, 0x00, 0x96,
+    0x8d, 0x00, 0x8f, 0x8d, 0x02, 0x87, 0x8d, 0x00,
+    0x82, 0x8d, 0x00, 0x83, 0x8d, 0x06, 0x81, 0x8d,
+    0x00, 0x82, 0x8d, 0x04, 0x83, 0x8d, 0x01, 0x89,
+    0x8d, 0x06, 0x88, 0x8d, 0x8c, 0x3a, 0x00, 0x82,
+    0x3a, 0x00, 0x96, 0x3a, 0x00, 0x89, 0x3a, 0x00,
+    0x84, 0x3a, 0x01, 0x88, 0x3a, 0x00, 0x82, 0x3a,
+    0x00, 0x83, 0x3a, 0x06, 0x81, 0x3a, 0x06, 0x80,
+    0x3a, 0x00, 0x83, 0x3a, 0x01, 0x89, 0x3a, 0x00,
+    0x81, 0x3a, 0x0c, 0x83, 0x4c, 0x00, 0x87, 0x4c,
+    0x00, 0x82, 0x4c, 0x00, 0xb2, 0x4c, 0x00, 0x82,
+    0x4c, 0x00, 0x85, 0x4c, 0x03, 0x8f, 0x4c, 0x01,
+    0x99, 0x4c, 0x01, 0x81, 0x7e, 0x00, 0x91, 0x7e,
+    0x02, 0x97, 0x7e, 0x00, 0x88, 0x7e, 0x00, 0x80,
+    0x7e, 0x01, 0x86, 0x7e, 0x02, 0x80, 0x7e, 0x03,
+    0x85, 0x7e, 0x00, 0x80, 0x7e, 0x00, 0x87, 0x7e,
+    0x05, 0x89, 0x7e, 0x01, 0x82, 0x7e, 0x0b, 0xb9,
+    0x8f, 0x03, 0x80, 0x18, 0x9b, 0x8f, 0x24, 0x81,
+    0x41, 0x00, 0x80, 0x41, 0x00, 0x84, 0x41, 0x00,
+    0x97, 0x41, 0x00, 0x80, 0x41, 0x00, 0x96, 0x41,
+    0x01, 0x84, 0x41, 0x00, 0x80, 0x41, 0x00, 0x85,
+    0x41, 0x01, 0x89, 0x41, 0x01, 0x83, 0x41, 0x1f,
+    0xc7, 0x90, 0x00, 0xa3, 0x90, 0x03, 0xa6, 0x90,
+    0x00, 0xa3, 0x90, 0x00, 0x8e, 0x90, 0x00, 0x86,
+    0x90, 0x83, 0x18, 0x81, 0x90, 0x24, 0xe0, 0x3f,
+    0x5b, 0xa5, 0x25, 0x00, 0x80, 0x25, 0x04, 0x80,
+    0x25, 0x01, 0xaa, 0x25, 0x80, 0x18, 0x83, 0x25,
+    0xe0, 0x9f, 0x2e, 0xc8, 0x24, 0x00, 0x83, 0x24,
+    0x01, 0x86, 0x24, 0x00, 0x80, 0x24, 0x00, 0x83,
+    0x24, 0x01, 0xa8, 0x24, 0x00, 0x83, 0x24, 0x01,
+    0xa0, 0x24, 0x00, 0x83, 0x24, 0x01, 0x86, 0x24,
+    0x00, 0x80, 0x24, 0x00, 0x83, 0x24, 0x01, 0x8e,
+    0x24, 0x00, 0xb8, 0x24, 0x00, 0x83, 0x24, 0x01,
+    0xc2, 0x24, 0x01, 0x9f, 0x24, 0x02, 0x99, 0x24,
+    0x05, 0xd5, 0x17, 0x01, 0x85, 0x17, 0x01, 0xe2,
+    0x1f, 0x12, 0x9c, 0x63, 0x02, 0xca, 0x77, 0x82,
+    0x18, 0x8a, 0x77, 0x06, 0x8c, 0x85, 0x00, 0x86,
+    0x85, 0x0a, 0x94, 0x30, 0x81, 0x18, 0x08, 0x93,
+    0x11, 0x0b, 0x8c, 0x86, 0x00, 0x82, 0x86, 0x00,
+    0x81, 0x86, 0x0b, 0xdd, 0x3e, 0x01, 0x89, 0x3e,
+    0x05, 0x89, 0x3e, 0x05, 0x81, 0x58, 0x81, 0x18,
+    0x80, 0x58, 0x80, 0x18, 0x88, 0x58, 0x00, 0x89,
+    0x58, 0x05, 0xd8, 0x58, 0x06, 0xaa, 0x58, 0x04,
+    0xc5, 0x12, 0x09, 0x9e, 0x44, 0x00, 0x8b, 0x44,
+    0x03, 0x8b, 0x44, 0x03, 0x80, 0x44, 0x02, 0x8b,
+    0x44, 0x9d, 0x87, 0x01, 0x84, 0x87, 0x0a, 0xab,
+    0x5e, 0x03, 0x99, 0x5e, 0x05, 0x8a, 0x5e, 0x02,
+    0x81, 0x5e, 0x9f, 0x3e, 0x9b, 0x10, 0x01, 0x81,
+    0x10, 0xbe, 0x88, 0x00, 0x9c, 0x88, 0x01, 0x8a,
+    0x88, 0x05, 0x89, 0x88, 0x05, 0x8d, 0x88, 0x01,
+    0x8e, 0x35, 0x40, 0xcb, 0x07, 0x03, 0xac, 0x07,
+    0x02, 0xbf, 0x82, 0xb3, 0x0a, 0x07, 0x83, 0x0a,
+    0xb7, 0x43, 0x02, 0x8e, 0x43, 0x02, 0x82, 0x43,
+    0xaf, 0x64, 0x88, 0x1c, 0x06, 0xaa, 0x25, 0x01,
+    0x82, 0x25, 0x87, 0x82, 0x07, 0x82, 0x35, 0x80,
+    0x18, 0x8c, 0x35, 0x80, 0x18, 0x86, 0x35, 0x83,
+    0x18, 0x80, 0x35, 0x85, 0x18, 0x80, 0x35, 0x82,
+    0x18, 0x81, 0x35, 0x80, 0x18, 0x04, 0xa5, 0x42,
+    0x84, 0x29, 0x80, 0x1c, 0xb0, 0x42, 0x84, 0x29,
+    0x83, 0x42, 0x84, 0x29, 0x8c, 0x42, 0x80, 0x1c,
+    0xc5, 0x42, 0x80, 0x29, 0xb9, 0x35, 0x00, 0x84,
+    0x35, 0xe0, 0x9f, 0x42, 0x95, 0x29, 0x01, 0x85,
+    0x29, 0x01, 0xa5, 0x29, 0x01, 0x85, 0x29, 0x01,
+    0x87, 0x29, 0x00, 0x80, 0x29, 0x00, 0x80, 0x29,
+    0x00, 0x80, 0x29, 0x00, 0x9e, 0x29, 0x01, 0xb4,
+    0x29, 0x00, 0x8e, 0x29, 0x00, 0x8d, 0x29, 0x01,
+    0x85, 0x29, 0x00, 0x92, 0x29, 0x01, 0x82, 0x29,
+    0x00, 0x88, 0x29, 0x00, 0x8b, 0x18, 0x81, 0x35,
+    0xd6, 0x18, 0x00, 0x8a, 0x18, 0x80, 0x42, 0x01,
+    0x8a, 0x18, 0x80, 0x42, 0x8e, 0x18, 0x00, 0x8c,
+    0x42, 0x02, 0x9f, 0x18, 0x0f, 0xa0, 0x35, 0x0e,
+    0xa5, 0x18, 0x80, 0x29, 0x82, 0x18, 0x81, 0x42,
+    0x85, 0x18, 0x80, 0x42, 0x9a, 0x18, 0x80, 0x42,
+    0x90, 0x18, 0xa8, 0x42, 0x82, 0x18, 0x03, 0xe2,
+    0x36, 0x18, 0x18, 0x8a, 0x18, 0x14, 0xe3, 0x3f,
+    0x18, 0xe0, 0x9f, 0x0f, 0xe2, 0x13, 0x18, 0x01,
+    0x9f, 0x18, 0x01, 0xe0, 0x07, 0x18, 0xae, 0x26,
+    0x00, 0xae, 0x26, 0x00, 0x9f, 0x42, 0xe0, 0x13,
+    0x19, 0x04, 0x86, 0x19, 0xa5, 0x25, 0x00, 0x80,
+    0x25, 0x04, 0x80, 0x25, 0x01, 0xb7, 0x91, 0x06,
+    0x81, 0x91, 0x0d, 0x80, 0x91, 0x96, 0x24, 0x08,
+    0x86, 0x24, 0x00, 0x86, 0x24, 0x00, 0x86, 0x24,
+    0x00, 0x86, 0x24, 0x00, 0x86, 0x24, 0x00, 0x86,
+    0x24, 0x00, 0x86, 0x24, 0x00, 0x86, 0x24, 0x00,
+    0x9f, 0x1c, 0xcf, 0x18, 0x2f, 0x99, 0x2d, 0x00,
+    0xd8, 0x2d, 0x0b, 0xe0, 0x75, 0x2d, 0x19, 0x8b,
+    0x18, 0x03, 0x84, 0x18, 0x80, 0x2d, 0x80, 0x18,
+    0x80, 0x2d, 0x98, 0x18, 0x88, 0x2d, 0x83, 0x35,
+    0x81, 0x2e, 0x87, 0x18, 0x83, 0x2d, 0x83, 0x18,
+    0x00, 0xd5, 0x33, 0x01, 0x81, 0x35, 0x81, 0x18,
+    0x82, 0x33, 0x80, 0x18, 0xd9, 0x3b, 0x81, 0x18,
+    0x82, 0x3b, 0x04, 0xaa, 0x0d, 0x00, 0xdd, 0x2e,
+    0x00, 0x8f, 0x18, 0x9a, 0x0d, 0x04, 0xa3, 0x18,
+    0x0b, 0x8f, 0x3b, 0x9e, 0x2e, 0x00, 0xbf, 0x18,
+    0x9e, 0x2e, 0xd0, 0x18, 0xae, 0x3b, 0x80, 0x18,
+    0xd7, 0x3b, 0xe0, 0x47, 0x18, 0xf0, 0x09, 0x55,
+    0x2d, 0x09, 0xbf, 0x18, 0xf0, 0x41, 0x8f, 0x2d,
+    0x0f, 0xe4, 0x2c, 0x97, 0x02, 0xb6, 0x97, 0x08,
+    0xaf, 0x47, 0xe0, 0xcb, 0x94, 0x13, 0xdf, 0x1c,
+    0xd7, 0x08, 0x07, 0xa1, 0x18, 0xe0, 0x05, 0x42,
+    0x82, 0x18, 0xb4, 0x42, 0x01, 0x84, 0x42, 0x2f,
+    0x88, 0x42, 0xab, 0x83, 0x03, 0x89, 0x18, 0x05,
+    0xb7, 0x73, 0x07, 0xc5, 0x79, 0x07, 0x8b, 0x79,
+    0x05, 0x9f, 0x1e, 0xad, 0x3c, 0x80, 0x18, 0x80,
+    0x3c, 0xa3, 0x76, 0x0a, 0x80, 0x76, 0x9c, 0x2e,
+    0x02, 0xcd, 0x38, 0x00, 0x80, 0x18, 0x89, 0x38,
+    0x03, 0x81, 0x38, 0x9e, 0x5b, 0x00, 0xb6, 0x16,
+    0x08, 0x8d, 0x16, 0x01, 0x89, 0x16, 0x01, 0x83,
+    0x16, 0x9f, 0x5b, 0xc2, 0x89, 0x17, 0x84, 0x89,
+    0x96, 0x52, 0x09, 0x85, 0x24, 0x01, 0x85, 0x24,
+    0x01, 0x85, 0x24, 0x08, 0x86, 0x24, 0x00, 0x86,
+    0x24, 0x00, 0xaa, 0x42, 0x80, 0x18, 0x88, 0x42,
+    0x80, 0x29, 0x81, 0x42, 0x07, 0xcf, 0x17, 0xad,
+    0x52, 0x01, 0x89, 0x52, 0x05, 0xf0, 0x1b, 0x43,
+    0x2e, 0x0b, 0x96, 0x2e, 0x03, 0xb0, 0x2e, 0x70,
+    0x10, 0xa3, 0xe1, 0x0d, 0x2d, 0x01, 0xe0, 0x09,
+    0x2d, 0x25, 0x86, 0x42, 0x0b, 0x84, 0x05, 0x04,
+    0x99, 0x32, 0x00, 0x84, 0x32, 0x00, 0x80, 0x32,
+    0x00, 0x81, 0x32, 0x00, 0x81, 0x32, 0x00, 0x89,
+    0x32, 0xe0, 0x11, 0x04, 0x10, 0xe1, 0x0a, 0x04,
+    0x81, 0x18, 0x0f, 0xbf, 0x04, 0x01, 0xb5, 0x04,
+    0x27, 0x8d, 0x04, 0x01, 0x8f, 0x35, 0x89, 0x18,
+    0x05, 0x8d, 0x35, 0x81, 0x1c, 0xa2, 0x18, 0x00,
+    0x92, 0x18, 0x00, 0x83, 0x18, 0x03, 0x84, 0x04,
+    0x00, 0xe0, 0x26, 0x04, 0x01, 0x80, 0x18, 0x00,
+    0x9f, 0x18, 0x99, 0x42, 0x85, 0x18, 0x99, 0x42,
+    0x8a, 0x18, 0x89, 0x3b, 0x80, 0x18, 0xac, 0x3b,
+    0x81, 0x18, 0x9e, 0x2e, 0x02, 0x85, 0x2e, 0x01,
+    0x85, 0x2e, 0x01, 0x85, 0x2e, 0x01, 0x82, 0x2e,
+    0x02, 0x86, 0x18, 0x00, 0x86, 0x18, 0x09, 0x84,
+    0x18, 0x01, 0x8b, 0x46, 0x00, 0x99, 0x46, 0x00,
+    0x92, 0x46, 0x00, 0x81, 0x46, 0x00, 0x8e, 0x46,
+    0x01, 0x8d, 0x46, 0x21, 0xe0, 0x1a, 0x46, 0x04,
+    0x82, 0x18, 0x03, 0xac, 0x18, 0x02, 0x88, 0x18,
+    0xce, 0x29, 0x00, 0x8b, 0x18, 0x03, 0x80, 0x29,
+    0x2e, 0xac, 0x18, 0x80, 0x35, 0x60, 0x21, 0x9c,
+    0x48, 0x02, 0xb0, 0x13, 0x0e, 0x80, 0x35, 0x9a,
+    0x18, 0x03, 0xa3, 0x66, 0x08, 0x82, 0x66, 0x9a,
+    0x27, 0x04, 0xaa, 0x68, 0x04, 0x9d, 0x93, 0x00,
+    0x80, 0x93, 0xa3, 0x69, 0x03, 0x8d, 0x69, 0x29,
+    0xcf, 0x1d, 0xaf, 0x7b, 0x9d, 0x6f, 0x01, 0x89,
+    0x6f, 0x05, 0xa3, 0x6e, 0x03, 0xa3, 0x6e, 0x03,
+    0xa7, 0x22, 0x07, 0xb3, 0x14, 0x0a, 0x80, 0x14,
+    0x60, 0x2f, 0xe0, 0xd6, 0x45, 0x08, 0x95, 0x45,
+    0x09, 0x87, 0x45, 0x60, 0x37, 0x85, 0x1b, 0x01,
+    0x80, 0x1b, 0x00, 0xab, 0x1b, 0x00, 0x81, 0x1b,
+    0x02, 0x80, 0x1b, 0x01, 0x80, 0x1b, 0x95, 0x34,
+    0x00, 0x88, 0x34, 0x9f, 0x71, 0x9e, 0x5c, 0x07,
+    0x88, 0x5c, 0x2f, 0x92, 0x31, 0x00, 0x81, 0x31,
+    0x04, 0x84, 0x31, 0x9b, 0x74, 0x02, 0x80, 0x74,
+    0x99, 0x49, 0x04, 0x80, 0x49, 0x3f, 0x9f, 0x55,
+    0x97, 0x54, 0x03, 0x93, 0x54, 0x01, 0xad, 0x54,
+    0x83, 0x3d, 0x00, 0x81, 0x3d, 0x04, 0x87, 0x3d,
+    0x00, 0x82, 0x3d, 0x00, 0x9c, 0x3d, 0x01, 0x82,
+    0x3d, 0x03, 0x89, 0x3d, 0x06, 0x88, 0x3d, 0x06,
+    0x9f, 0x6b, 0x9f, 0x67, 0x1f, 0xa6, 0x4e, 0x03,
+    0x8b, 0x4e, 0x08, 0xb5, 0x06, 0x02, 0x86, 0x06,
+    0x95, 0x37, 0x01, 0x87, 0x37, 0x92, 0x36, 0x04,
+    0x87, 0x36, 0x91, 0x75, 0x06, 0x83, 0x75, 0x0b,
+    0x86, 0x75, 0x4f, 0xc8, 0x6c, 0x36, 0xb2, 0x65,
+    0x0c, 0xb2, 0x65, 0x06, 0x85, 0x65, 0xa7, 0x2f,
+    0x07, 0x89, 0x2f, 0x60, 0xc5, 0x9e, 0x04, 0x60,
+    0x20, 0xa7, 0x6a, 0x07, 0xa9, 0x7f, 0x60, 0x25,
+    0x96, 0x23, 0x08, 0xcd, 0x0e, 0x03, 0x9d, 0x0e,
+    0x0e, 0x80, 0x0e, 0xc1, 0x39, 0x0a, 0x80, 0x39,
+    0x01, 0x98, 0x80, 0x06, 0x89, 0x80, 0x05, 0xb4,
+    0x15, 0x00, 0x90, 0x15, 0x08, 0xa6, 0x4b, 0x08,
+    0xcd, 0x7a, 0x01, 0x8f, 0x7a, 0x00, 0x93, 0x7e,
+    0x0a, 0x91, 0x3f, 0x00, 0xab, 0x3f, 0x40, 0x86,
+    0x5a, 0x00, 0x80, 0x5a, 0x00, 0x83, 0x5a, 0x00,
+    0x8e, 0x5a, 0x00, 0x8a, 0x5a, 0x05, 0xba, 0x40,
+    0x04, 0x89, 0x40, 0x05, 0x83, 0x28, 0x00, 0x87,
+    0x28, 0x01, 0x81, 0x28, 0x01, 0x95, 0x28, 0x00,
+    0x86, 0x28, 0x00, 0x81, 0x28, 0x00, 0x84, 0x28,
+    0x00, 0x80, 0x35, 0x88, 0x28, 0x01, 0x81, 0x28,
+    0x01, 0x82, 0x28, 0x01, 0x80, 0x28, 0x05, 0x80,
+    0x28, 0x04, 0x86, 0x28, 0x01, 0x86, 0x28, 0x02,
+    0x84, 0x28, 0x60, 0x2a, 0xd9, 0x5f, 0x00, 0x80,
+    0x5f, 0x00, 0x82, 0x5f, 0x1f, 0xc7, 0x92, 0x07,
+    0x89, 0x92, 0x60, 0x45, 0xb5, 0x7c, 0x01, 0xa5,
+    0x7c, 0x21, 0xc4, 0x57, 0x0a, 0x89, 0x57, 0x05,
+    0x8c, 0x58, 0x12, 0xb8, 0x8a, 0x06, 0x89, 0x8a,
+    0x35, 0x9a, 0x02, 0x01, 0x8e, 0x02, 0x03, 0x8f,
+    0x02, 0x60, 0x5f, 0xbb, 0x1f, 0x60, 0x03, 0xd2,
+    0x96, 0x0b, 0x80, 0x96, 0x60, 0x3f, 0x87, 0x5d,
+    0x01, 0xad, 0x5d, 0x01, 0x8a, 0x5d, 0x1a, 0xc7,
+    0x98, 0x07, 0xd2, 0x81, 0x1c, 0xb8, 0x72, 0x60,
+    0xa6, 0x88, 0x0c, 0x00, 0xac, 0x0c, 0x00, 0x8d,
+    0x0c, 0x09, 0x9c, 0x0c, 0x02, 0x9f, 0x4f, 0x01,
+    0x95, 0x4f, 0x00, 0x8d, 0x4f, 0x48, 0x86, 0x50,
+    0x00, 0x81, 0x50, 0x00, 0xab, 0x50, 0x02, 0x80,
+    0x50, 0x00, 0x81, 0x50, 0x00, 0x88, 0x50, 0x07,
+    0x89, 0x50, 0x05, 0x85, 0x2b, 0x00, 0x81, 0x2b,
+    0x00, 0xa4, 0x2b, 0x00, 0x81, 0x2b, 0x00, 0x85,
+    0x2b, 0x06, 0x89, 0x2b, 0x60, 0xd5, 0x98, 0x4a,
+    0x60, 0x66, 0xb1, 0x8b, 0x0c, 0x80, 0x8b, 0xe3,
+    0x39, 0x1a, 0x60, 0x05, 0xe0, 0x0e, 0x1a, 0x00,
+    0x84, 0x1a, 0x0a, 0xe0, 0x63, 0x1a, 0x6a, 0x5b,
+    0xe3, 0xce, 0x21, 0x00, 0x88, 0x21, 0x6f, 0x66,
+    0xe1, 0xe6, 0x03, 0x70, 0x11, 0x58, 0xe1, 0xd8,
+    0x08, 0x06, 0x9e, 0x59, 0x00, 0x89, 0x59, 0x03,
+    0x81, 0x59, 0x5f, 0x9d, 0x09, 0x01, 0x85, 0x09,
+    0x09, 0xc5, 0x70, 0x09, 0x89, 0x70, 0x00, 0x86,
+    0x70, 0x00, 0x94, 0x70, 0x04, 0x92, 0x70, 0x62,
+    0x4f, 0xda, 0x51, 0x60, 0x04, 0xca, 0x56, 0x03,
+    0xb8, 0x56, 0x06, 0x90, 0x56, 0x3f, 0x80, 0x8c,
+    0x80, 0x61, 0x81, 0x18, 0x1b, 0xf0, 0x07, 0x97,
+    0x8c, 0x07, 0xe2, 0x92, 0x8c, 0x70, 0x14, 0xac,
+    0x80, 0x3b, 0xe0, 0xbd, 0x33, 0x30, 0x82, 0x33,
+    0x10, 0x83, 0x3b, 0x07, 0xe1, 0x2b, 0x61, 0x68,
+    0xa3, 0xe0, 0x0a, 0x20, 0x04, 0x8c, 0x20, 0x02,
+    0x88, 0x20, 0x06, 0x89, 0x20, 0x01, 0x83, 0x20,
+    0x83, 0x18, 0x70, 0x02, 0xfb, 0xe0, 0x95, 0x18,
+    0x09, 0xa6, 0x18, 0x01, 0xbd, 0x18, 0x82, 0x35,
+    0x90, 0x18, 0x87, 0x35, 0x81, 0x18, 0x86, 0x35,
+    0x9d, 0x18, 0x83, 0x35, 0xba, 0x18, 0x16, 0xc5,
+    0x29, 0x60, 0x39, 0x93, 0x18, 0x0b, 0xd6, 0x18,
+    0x08, 0x98, 0x18, 0x60, 0x26, 0xd4, 0x18, 0x00,
+    0xc6, 0x18, 0x00, 0x81, 0x18, 0x01, 0x80, 0x18,
+    0x01, 0x81, 0x18, 0x01, 0x83, 0x18, 0x00, 0x8b,
+    0x18, 0x00, 0x80, 0x18, 0x00, 0x86, 0x18, 0x00,
+    0xc0, 0x18, 0x00, 0x83, 0x18, 0x01, 0x87, 0x18,
+    0x00, 0x86, 0x18, 0x00, 0x9b, 0x18, 0x00, 0x83,
+    0x18, 0x00, 0x84, 0x18, 0x00, 0x80, 0x18, 0x02,
+    0x86, 0x18, 0x00, 0xe0, 0xf3, 0x18, 0x01, 0xe0,
+    0xc3, 0x18, 0x01, 0xb1, 0x18, 0xe2, 0x2b, 0x7d,
+    0x0e, 0x84, 0x7d, 0x00, 0x8e, 0x7d, 0x64, 0xef,
+    0x86, 0x26, 0x00, 0x90, 0x26, 0x01, 0x86, 0x26,
+    0x00, 0x81, 0x26, 0x00, 0x84, 0x26, 0x60, 0x74,
+    0xac, 0x62, 0x02, 0x8d, 0x62, 0x01, 0x89, 0x62,
+    0x03, 0x81, 0x62, 0x61, 0x0f, 0xb9, 0x95, 0x04,
+    0x80, 0x95, 0x64, 0x9f, 0xe0, 0x64, 0x53, 0x01,
+    0x8f, 0x53, 0x28, 0xcb, 0x01, 0x03, 0x89, 0x01,
+    0x03, 0x81, 0x01, 0x62, 0xb0, 0xc3, 0x18, 0x4b,
+    0xbc, 0x18, 0x60, 0x61, 0x83, 0x04, 0x00, 0x9a,
+    0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04, 0x01,
+    0x80, 0x04, 0x00, 0x89, 0x04, 0x00, 0x83, 0x04,
+    0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x05, 0x80,
+    0x04, 0x03, 0x80, 0x04, 0x00, 0x80, 0x04, 0x00,
+    0x80, 0x04, 0x00, 0x82, 0x04, 0x00, 0x81, 0x04,
+    0x00, 0x80, 0x04, 0x01, 0x80, 0x04, 0x00, 0x80,
+    0x04, 0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x00,
+    0x80, 0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04,
+    0x01, 0x83, 0x04, 0x00, 0x86, 0x04, 0x00, 0x83,
+    0x04, 0x00, 0x83, 0x04, 0x00, 0x80, 0x04, 0x00,
+    0x89, 0x04, 0x00, 0x90, 0x04, 0x04, 0x82, 0x04,
+    0x00, 0x84, 0x04, 0x00, 0x90, 0x04, 0x33, 0x81,
+    0x04, 0x60, 0xad, 0xab, 0x18, 0x03, 0xe0, 0x03,
+    0x18, 0x0b, 0x8e, 0x18, 0x01, 0x8e, 0x18, 0x00,
+    0x8e, 0x18, 0x00, 0xa4, 0x18, 0x09, 0x8c, 0x18,
+    0x02, 0xdc, 0x18, 0x02, 0xbc, 0x18, 0x38, 0x99,
+    0x18, 0x80, 0x33, 0x81, 0x18, 0x0c, 0xab, 0x18,
+    0x03, 0x88, 0x18, 0x06, 0x81, 0x18, 0x0d, 0x85,
+    0x18, 0x60, 0x39, 0xe3, 0x75, 0x18, 0x09, 0x8c,
+    0x18, 0x02, 0x8a, 0x18, 0x04, 0xe0, 0x13, 0x18,
+    0x0b, 0xd8, 0x18, 0x06, 0x8b, 0x18, 0x13, 0x8b,
+    0x18, 0x03, 0xb7, 0x18, 0x07, 0x89, 0x18, 0x05,
+    0xa7, 0x18, 0x07, 0x9d, 0x18, 0x51, 0x8b, 0x18,
+    0x00, 0xe0, 0x04, 0x18, 0x00, 0x83, 0x18, 0x02,
+    0xa8, 0x18, 0x01, 0x85, 0x18, 0x02, 0x9c, 0x18,
+    0x01, 0xe0, 0x26, 0x18, 0x0b, 0x8d, 0x18, 0x01,
+    0x83, 0x18, 0x03, 0x82, 0x18, 0x04, 0x82, 0x18,
+    0x0c, 0x85, 0x18, 0x65, 0x09, 0xf0, 0x96, 0x76,
+    0x2d, 0x28, 0xef, 0xd4, 0x2d, 0x0a, 0xe0, 0x7d,
+    0x2d, 0x01, 0xf0, 0x06, 0x21, 0x2d, 0x0d, 0xf0,
+    0x0c, 0xd0, 0x2d, 0x6b, 0xbe, 0xe1, 0xbd, 0x2d,
+    0x7a, 0xf5, 0x82, 0x80, 0x18, 0x1d, 0xdf, 0x18,
+    0x60, 0x1f, 0xe0, 0x8f, 0x35,
 };
 
-static const uint8_t unicode_script_ext_table[799] = {
-    0x82, 0xc1, 0x00, 0x00, 0x01, 0x2b, 0x01, 0x00,
-    0x00, 0x01, 0x2b, 0x1c, 0x00, 0x0c, 0x01, 0x45,
-    0x80, 0x92, 0x00, 0x00, 0x02, 0x1d, 0x6b, 0x00,
-    0x02, 0x1d, 0x28, 0x01, 0x02, 0x1d, 0x45, 0x00,
-    0x02, 0x1d, 0x28, 0x81, 0x03, 0x00, 0x00, 0x05,
-    0x04, 0x31, 0x87, 0x91, 0x9a, 0x0d, 0x00, 0x00,
-    0x05, 0x04, 0x31, 0x87, 0x91, 0x9a, 0x00, 0x03,
-    0x04, 0x87, 0x91, 0x01, 0x00, 0x00, 0x05, 0x04,
-    0x31, 0x87, 0x91, 0x9a, 0x1f, 0x00, 0x00, 0x08,
-    0x01, 0x04, 0x50, 0x51, 0x78, 0x31, 0x82, 0x87,
-    0x09, 0x00, 0x0a, 0x02, 0x04, 0x87, 0x09, 0x00,
-    0x09, 0x03, 0x04, 0x91, 0x9a, 0x05, 0x00, 0x00,
-    0x02, 0x04, 0x87, 0x62, 0x00, 0x00, 0x02, 0x04,
-    0x31, 0x81, 0xfb, 0x00, 0x00, 0x0d, 0x0b, 0x1f,
-    0x2a, 0x2c, 0x2e, 0x3c, 0x45, 0x4f, 0x70, 0x7d,
-    0x8e, 0x90, 0x95, 0x00, 0x0c, 0x0b, 0x1f, 0x2a,
-    0x2c, 0x2e, 0x3c, 0x45, 0x4f, 0x70, 0x8e, 0x90,
-    0x95, 0x10, 0x00, 0x00, 0x14, 0x0b, 0x1f, 0x21,
-    0x2d, 0x53, 0x2a, 0x2c, 0x2e, 0x3c, 0x4e, 0x4f,
-    0x60, 0x70, 0x43, 0x81, 0x86, 0x8d, 0x8e, 0x90,
-    0x95, 0x00, 0x15, 0x0b, 0x1f, 0x21, 0x2d, 0x53,
-    0x2a, 0x2c, 0x2e, 0x3c, 0x47, 0x4e, 0x4f, 0x60,
-    0x70, 0x43, 0x81, 0x86, 0x8d, 0x8e, 0x90, 0x95,
-    0x09, 0x04, 0x1f, 0x21, 0x3b, 0x4e, 0x75, 0x00,
-    0x09, 0x03, 0x0b, 0x15, 0x86, 0x75, 0x00, 0x09,
-    0x02, 0x2e, 0x5d, 0x75, 0x00, 0x09, 0x02, 0x2c,
-    0x41, 0x80, 0x75, 0x00, 0x0d, 0x02, 0x2a, 0x8e,
-    0x80, 0x71, 0x00, 0x09, 0x02, 0x3c, 0x60, 0x82,
-    0xcf, 0x00, 0x09, 0x03, 0x15, 0x5e, 0x8a, 0x80,
-    0x30, 0x00, 0x00, 0x02, 0x27, 0x45, 0x85, 0xb8,
-    0x00, 0x01, 0x04, 0x11, 0x32, 0x89, 0x88, 0x80,
-    0x4a, 0x00, 0x01, 0x02, 0x5b, 0x76, 0x00, 0x00,
-    0x00, 0x02, 0x5b, 0x76, 0x84, 0x49, 0x00, 0x00,
-    0x04, 0x0b, 0x1f, 0x2a, 0x3c, 0x00, 0x01, 0x1f,
-    0x00, 0x04, 0x0b, 0x1f, 0x2a, 0x3c, 0x00, 0x02,
-    0x1f, 0x2a, 0x00, 0x01, 0x1f, 0x01, 0x02, 0x0b,
-    0x1f, 0x00, 0x02, 0x1f, 0x7d, 0x00, 0x02, 0x0b,
-    0x1f, 0x00, 0x02, 0x1f, 0x7d, 0x00, 0x06, 0x1f,
-    0x3c, 0x4f, 0x70, 0x8e, 0x90, 0x00, 0x01, 0x1f,
-    0x01, 0x02, 0x1f, 0x7d, 0x01, 0x01, 0x1f, 0x00,
-    0x02, 0x1f, 0x7d, 0x00, 0x02, 0x0b, 0x1f, 0x06,
-    0x01, 0x1f, 0x00, 0x02, 0x1f, 0x60, 0x00, 0x02,
-    0x0b, 0x1f, 0x01, 0x01, 0x1f, 0x00, 0x02, 0x0b,
-    0x1f, 0x03, 0x01, 0x1f, 0x00, 0x08, 0x0b, 0x1f,
-    0x2a, 0x3c, 0x60, 0x70, 0x90, 0x95, 0x00, 0x02,
-    0x1f, 0x2a, 0x00, 0x03, 0x1f, 0x2a, 0x3c, 0x01,
-    0x02, 0x0b, 0x1f, 0x00, 0x01, 0x0b, 0x01, 0x02,
-    0x1f, 0x2a, 0x00, 0x01, 0x60, 0x80, 0x44, 0x00,
-    0x01, 0x01, 0x2b, 0x35, 0x00, 0x00, 0x02, 0x1d,
-    0x87, 0x81, 0xb5, 0x00, 0x00, 0x02, 0x45, 0x5b,
-    0x80, 0x3f, 0x00, 0x00, 0x03, 0x1f, 0x2a, 0x45,
-    0x8c, 0xd1, 0x00, 0x00, 0x02, 0x1d, 0x28, 0x81,
-    0x3c, 0x00, 0x01, 0x06, 0x0d, 0x30, 0x2f, 0x35,
-    0x3d, 0x9b, 0x00, 0x05, 0x0d, 0x30, 0x2f, 0x35,
-    0x3d, 0x01, 0x00, 0x00, 0x01, 0x2f, 0x00, 0x00,
-    0x09, 0x06, 0x0d, 0x30, 0x2f, 0x35, 0x3d, 0x9b,
-    0x00, 0x00, 0x00, 0x05, 0x0d, 0x30, 0x2f, 0x35,
-    0x3d, 0x07, 0x06, 0x0d, 0x30, 0x2f, 0x35, 0x3d,
-    0x9b, 0x03, 0x05, 0x0d, 0x30, 0x2f, 0x35, 0x3d,
-    0x09, 0x00, 0x03, 0x02, 0x0d, 0x2f, 0x01, 0x00,
-    0x00, 0x05, 0x0d, 0x30, 0x2f, 0x35, 0x3d, 0x04,
-    0x02, 0x35, 0x3d, 0x00, 0x00, 0x00, 0x05, 0x0d,
-    0x30, 0x2f, 0x35, 0x3d, 0x03, 0x00, 0x01, 0x03,
-    0x2f, 0x35, 0x3d, 0x01, 0x01, 0x2f, 0x58, 0x00,
-    0x03, 0x02, 0x35, 0x3d, 0x02, 0x00, 0x00, 0x02,
-    0x35, 0x3d, 0x59, 0x00, 0x00, 0x06, 0x0d, 0x30,
-    0x2f, 0x35, 0x3d, 0x9b, 0x00, 0x02, 0x35, 0x3d,
-    0x80, 0x12, 0x00, 0x0f, 0x01, 0x2f, 0x1f, 0x00,
-    0x23, 0x01, 0x2f, 0x3b, 0x00, 0x27, 0x01, 0x2f,
-    0x37, 0x00, 0x30, 0x01, 0x2f, 0x0e, 0x00, 0x0b,
-    0x01, 0x2f, 0x32, 0x00, 0x00, 0x01, 0x2f, 0x57,
-    0x00, 0x18, 0x01, 0x2f, 0x09, 0x00, 0x04, 0x01,
-    0x2f, 0x5f, 0x00, 0x1e, 0x01, 0x2f, 0xc0, 0x31,
-    0xef, 0x00, 0x00, 0x02, 0x1d, 0x28, 0x80, 0x0f,
-    0x00, 0x07, 0x02, 0x2f, 0x45, 0x80, 0xa7, 0x00,
-    0x02, 0x0e, 0x1f, 0x21, 0x2c, 0x2e, 0x41, 0x3c,
-    0x3b, 0x4e, 0x4f, 0x5a, 0x60, 0x43, 0x8d, 0x95,
-    0x02, 0x0d, 0x1f, 0x21, 0x2c, 0x2e, 0x41, 0x3c,
-    0x3b, 0x4e, 0x5a, 0x60, 0x43, 0x8d, 0x95, 0x03,
-    0x0b, 0x1f, 0x21, 0x2c, 0x2e, 0x41, 0x3b, 0x4e,
-    0x5a, 0x43, 0x8d, 0x95, 0x80, 0x36, 0x00, 0x00,
-    0x02, 0x0b, 0x1f, 0x00, 0x00, 0x00, 0x02, 0x1f,
-    0x8e, 0x39, 0x00, 0x00, 0x03, 0x3e, 0x45, 0x5e,
-    0x80, 0x1f, 0x00, 0x00, 0x02, 0x10, 0x3a, 0xc0,
-    0x13, 0xa1, 0x00, 0x00, 0x02, 0x04, 0x91, 0x09,
-    0x00, 0x00, 0x02, 0x04, 0x91, 0x46, 0x00, 0x01,
-    0x05, 0x0d, 0x30, 0x2f, 0x35, 0x3d, 0x80, 0x99,
-    0x00, 0x04, 0x06, 0x0d, 0x30, 0x2f, 0x35, 0x3d,
-    0x9b, 0x09, 0x00, 0x00, 0x02, 0x35, 0x3d, 0x2c,
-    0x00, 0x01, 0x02, 0x35, 0x3d, 0x80, 0xdf, 0x00,
-    0x02, 0x02, 0x1c, 0x49, 0x03, 0x00, 0x2c, 0x03,
-    0x1c, 0x48, 0x49, 0x02, 0x00, 0x08, 0x02, 0x1c,
-    0x49, 0x81, 0x1f, 0x00, 0x1b, 0x02, 0x04, 0x1a,
-    0x8f, 0x84, 0x00, 0x00, 0x02, 0x2a, 0x8e, 0x00,
-    0x00, 0x00, 0x02, 0x2a, 0x8e, 0x36, 0x00, 0x01,
-    0x02, 0x2a, 0x8e, 0x8c, 0x12, 0x00, 0x01, 0x02,
-    0x2a, 0x8e, 0x00, 0x00, 0x00, 0x02, 0x2a, 0x8e,
-    0xc0, 0x5c, 0x4b, 0x00, 0x03, 0x01, 0x22, 0x96,
-    0x3b, 0x00, 0x11, 0x01, 0x2f, 0x9e, 0x5d, 0x00,
-    0x01, 0x01, 0x2f, 0xce, 0xcd, 0x2d, 0x00,
+static const uint8_t unicode_script_ext_table[789] = {
+    0x82, 0xc1, 0x00, 0x00, 0x01, 0x29, 0x01, 0x00,
+    0x00, 0x01, 0x29, 0x1c, 0x00, 0x0c, 0x01, 0x42,
+    0x80, 0x92, 0x00, 0x00, 0x02, 0x1c, 0x68, 0x00,
+    0x02, 0x1c, 0x26, 0x01, 0x02, 0x1c, 0x42, 0x00,
+    0x02, 0x1c, 0x26, 0x80, 0x80, 0x00, 0x00, 0x02,
+    0x05, 0x25, 0x80, 0x01, 0x00, 0x00, 0x04, 0x04,
+    0x2f, 0x84, 0x8e, 0x0d, 0x00, 0x00, 0x04, 0x04,
+    0x2f, 0x84, 0x8e, 0x00, 0x03, 0x04, 0x84, 0x8e,
+    0x01, 0x00, 0x00, 0x04, 0x04, 0x2f, 0x84, 0x8e,
+    0x1f, 0x00, 0x00, 0x08, 0x01, 0x04, 0x4d, 0x4e,
+    0x75, 0x2f, 0x7f, 0x84, 0x09, 0x00, 0x0a, 0x02,
+    0x04, 0x84, 0x09, 0x00, 0x09, 0x02, 0x04, 0x8e,
+    0x05, 0x00, 0x00, 0x02, 0x04, 0x84, 0x62, 0x00,
+    0x00, 0x02, 0x04, 0x2f, 0x81, 0xfb, 0x00, 0x00,
+    0x0d, 0x0b, 0x1e, 0x28, 0x2a, 0x2c, 0x3a, 0x42,
+    0x4c, 0x6d, 0x7a, 0x8b, 0x8d, 0x92, 0x00, 0x0c,
+    0x0b, 0x1e, 0x28, 0x2a, 0x2c, 0x3a, 0x42, 0x4c,
+    0x6d, 0x8b, 0x8d, 0x92, 0x10, 0x00, 0x00, 0x14,
+    0x0b, 0x1e, 0x1f, 0x2b, 0x50, 0x28, 0x2a, 0x2c,
+    0x3a, 0x4b, 0x4c, 0x5d, 0x6d, 0x40, 0x7e, 0x83,
+    0x8a, 0x8b, 0x8d, 0x92, 0x00, 0x15, 0x0b, 0x1e,
+    0x1f, 0x2b, 0x50, 0x28, 0x2a, 0x2c, 0x3a, 0x44,
+    0x4b, 0x4c, 0x5d, 0x6d, 0x40, 0x7e, 0x83, 0x8a,
+    0x8b, 0x8d, 0x92, 0x09, 0x04, 0x1e, 0x1f, 0x39,
+    0x4b, 0x75, 0x00, 0x09, 0x03, 0x0b, 0x15, 0x83,
+    0x75, 0x00, 0x09, 0x02, 0x2c, 0x5a, 0x75, 0x00,
+    0x09, 0x02, 0x2a, 0x3f, 0x80, 0x75, 0x00, 0x0d,
+    0x02, 0x28, 0x8b, 0x80, 0x71, 0x00, 0x09, 0x02,
+    0x3a, 0x5d, 0x82, 0xcf, 0x00, 0x09, 0x03, 0x15,
+    0x5b, 0x87, 0x80, 0x30, 0x00, 0x00, 0x02, 0x25,
+    0x42, 0x85, 0xb8, 0x00, 0x01, 0x04, 0x11, 0x30,
+    0x86, 0x85, 0x80, 0x4a, 0x00, 0x01, 0x02, 0x58,
+    0x73, 0x00, 0x00, 0x00, 0x02, 0x58, 0x73, 0x84,
+    0x49, 0x00, 0x00, 0x04, 0x0b, 0x1e, 0x28, 0x3a,
+    0x00, 0x01, 0x1e, 0x00, 0x04, 0x0b, 0x1e, 0x28,
+    0x3a, 0x00, 0x02, 0x1e, 0x28, 0x00, 0x01, 0x1e,
+    0x01, 0x02, 0x0b, 0x1e, 0x00, 0x02, 0x1e, 0x7a,
+    0x00, 0x02, 0x0b, 0x1e, 0x00, 0x02, 0x1e, 0x7a,
+    0x00, 0x06, 0x1e, 0x3a, 0x4c, 0x6d, 0x8b, 0x8d,
+    0x00, 0x01, 0x1e, 0x01, 0x02, 0x1e, 0x7a, 0x01,
+    0x01, 0x1e, 0x00, 0x02, 0x1e, 0x7a, 0x00, 0x02,
+    0x0b, 0x1e, 0x06, 0x01, 0x1e, 0x00, 0x02, 0x1e,
+    0x5d, 0x00, 0x02, 0x0b, 0x1e, 0x01, 0x01, 0x1e,
+    0x00, 0x02, 0x0b, 0x1e, 0x03, 0x01, 0x1e, 0x00,
+    0x08, 0x0b, 0x1e, 0x28, 0x3a, 0x5d, 0x6d, 0x8d,
+    0x92, 0x00, 0x02, 0x1e, 0x28, 0x00, 0x03, 0x1e,
+    0x28, 0x3a, 0x01, 0x02, 0x0b, 0x1e, 0x00, 0x01,
+    0x0b, 0x01, 0x02, 0x1e, 0x28, 0x00, 0x01, 0x5d,
+    0x80, 0x44, 0x00, 0x01, 0x01, 0x29, 0x81, 0xec,
+    0x00, 0x00, 0x02, 0x42, 0x58, 0x80, 0x3f, 0x00,
+    0x00, 0x03, 0x1e, 0x28, 0x42, 0x8c, 0xd1, 0x00,
+    0x00, 0x02, 0x1c, 0x26, 0x81, 0x3c, 0x00, 0x01,
+    0x06, 0x0d, 0x2e, 0x2d, 0x33, 0x3b, 0x97, 0x00,
+    0x05, 0x0d, 0x2e, 0x2d, 0x33, 0x3b, 0x01, 0x00,
+    0x00, 0x01, 0x2d, 0x00, 0x00, 0x09, 0x06, 0x0d,
+    0x2e, 0x2d, 0x33, 0x3b, 0x97, 0x00, 0x00, 0x00,
+    0x05, 0x0d, 0x2e, 0x2d, 0x33, 0x3b, 0x07, 0x06,
+    0x0d, 0x2e, 0x2d, 0x33, 0x3b, 0x97, 0x03, 0x05,
+    0x0d, 0x2e, 0x2d, 0x33, 0x3b, 0x09, 0x00, 0x03,
+    0x02, 0x0d, 0x2d, 0x01, 0x00, 0x00, 0x05, 0x0d,
+    0x2e, 0x2d, 0x33, 0x3b, 0x04, 0x02, 0x33, 0x3b,
+    0x00, 0x00, 0x00, 0x05, 0x0d, 0x2e, 0x2d, 0x33,
+    0x3b, 0x03, 0x00, 0x01, 0x03, 0x2d, 0x33, 0x3b,
+    0x01, 0x01, 0x2d, 0x58, 0x00, 0x03, 0x02, 0x33,
+    0x3b, 0x02, 0x00, 0x00, 0x02, 0x33, 0x3b, 0x59,
+    0x00, 0x00, 0x06, 0x0d, 0x2e, 0x2d, 0x33, 0x3b,
+    0x97, 0x00, 0x02, 0x33, 0x3b, 0x80, 0x12, 0x00,
+    0x0f, 0x01, 0x2d, 0x1f, 0x00, 0x23, 0x01, 0x2d,
+    0x3b, 0x00, 0x27, 0x01, 0x2d, 0x37, 0x00, 0x30,
+    0x01, 0x2d, 0x0e, 0x00, 0x0b, 0x01, 0x2d, 0x32,
+    0x00, 0x00, 0x01, 0x2d, 0x57, 0x00, 0x18, 0x01,
+    0x2d, 0x09, 0x00, 0x04, 0x01, 0x2d, 0x5f, 0x00,
+    0x1e, 0x01, 0x2d, 0xc0, 0x31, 0xef, 0x00, 0x00,
+    0x02, 0x1c, 0x26, 0x81, 0x3f, 0x00, 0x02, 0x0e,
+    0x1e, 0x1f, 0x2a, 0x2c, 0x3f, 0x3a, 0x39, 0x4b,
+    0x4c, 0x57, 0x5d, 0x40, 0x8a, 0x92, 0x02, 0x0d,
+    0x1e, 0x1f, 0x2a, 0x2c, 0x3f, 0x3a, 0x39, 0x4b,
+    0x57, 0x5d, 0x40, 0x8a, 0x92, 0x03, 0x0b, 0x1e,
+    0x1f, 0x2a, 0x2c, 0x3f, 0x39, 0x4b, 0x57, 0x40,
+    0x8a, 0x92, 0x80, 0x36, 0x00, 0x00, 0x02, 0x0b,
+    0x1e, 0x00, 0x00, 0x00, 0x02, 0x1e, 0x8b, 0x39,
+    0x00, 0x00, 0x03, 0x3c, 0x42, 0x5b, 0x80, 0x1f,
+    0x00, 0x00, 0x02, 0x10, 0x38, 0xc0, 0x13, 0xa1,
+    0x00, 0x00, 0x02, 0x04, 0x8e, 0x09, 0x00, 0x00,
+    0x02, 0x04, 0x8e, 0x46, 0x00, 0x01, 0x05, 0x0d,
+    0x2e, 0x2d, 0x33, 0x3b, 0x80, 0x99, 0x00, 0x04,
+    0x06, 0x0d, 0x2e, 0x2d, 0x33, 0x3b, 0x97, 0x09,
+    0x00, 0x00, 0x02, 0x33, 0x3b, 0x2c, 0x00, 0x01,
+    0x02, 0x33, 0x3b, 0x80, 0xdf, 0x00, 0x02, 0x02,
+    0x1b, 0x46, 0x03, 0x00, 0x2c, 0x03, 0x1b, 0x45,
+    0x46, 0x02, 0x00, 0x08, 0x02, 0x1b, 0x46, 0x81,
+    0x1f, 0x00, 0x1b, 0x02, 0x04, 0x19, 0x8f, 0x84,
+    0x00, 0x00, 0x02, 0x28, 0x8b, 0x00, 0x00, 0x00,
+    0x02, 0x28, 0x8b, 0x36, 0x00, 0x01, 0x02, 0x28,
+    0x8b, 0x8c, 0x12, 0x00, 0x01, 0x02, 0x28, 0x8b,
+    0x00, 0x00, 0x00, 0x02, 0x28, 0x8b, 0xc0, 0x5c,
+    0x4b, 0x00, 0x03, 0x01, 0x20, 0x96, 0x3b, 0x00,
+    0x11, 0x01, 0x2d, 0x9e, 0x5d, 0x00, 0x01, 0x01,
+    0x2d, 0xce, 0xcd, 0x2d, 0x00,
 };
 
 static const uint8_t unicode_prop_Hyphen_table[28] = {
@@ -3544,7 +3501,7 @@ static const uint8_t unicode_prop_Other_Math_table[200] = {
     0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,
 };
 
-static const uint8_t unicode_prop_Other_Alphabetic_table[411] = {
+static const uint8_t unicode_prop_Other_Alphabetic_table[396] = {
     0x43, 0x44, 0x80, 0x42, 0x69, 0x8d, 0x00, 0x01,
     0x01, 0x00, 0xc7, 0x8a, 0xaf, 0x8c, 0x06, 0x8f,
     0x80, 0xe4, 0x33, 0x19, 0x0b, 0x80, 0xa2, 0x80,
@@ -3560,7 +3517,7 @@ static const uint8_t unicode_prop_Other_Alphabetic_table[411] = {
     0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9c, 0x82,
     0xb9, 0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9b,
     0x83, 0xb9, 0x30, 0x10, 0x82, 0x89, 0x80, 0x89,
-    0x81, 0x9c, 0x82, 0xca, 0x28, 0x00, 0x87, 0x91,
+    0x81, 0x9d, 0x81, 0xca, 0x28, 0x00, 0x87, 0x91,
     0x81, 0xbc, 0x01, 0x86, 0x91, 0x80, 0xe2, 0x01,
     0x28, 0x81, 0x8f, 0x80, 0x40, 0xa2, 0x90, 0x8a,
     0x8a, 0x80, 0xa3, 0xed, 0x8b, 0x00, 0x0b, 0x96,
@@ -3568,35 +3525,33 @@ static const uint8_t unicode_prop_Other_Alphabetic_table[411] = {
     0x89, 0x83, 0x46, 0x73, 0x81, 0x9d, 0x81, 0x9d,
     0x81, 0x9d, 0x81, 0xc1, 0x92, 0x40, 0xbb, 0x81,
     0xa1, 0x80, 0xf5, 0x8b, 0x83, 0x88, 0x40, 0xdd,
-    0x84, 0xb8, 0x89, 0x81, 0x93, 0xc9, 0x81, 0xbe,
-    0x84, 0xaf, 0x8e, 0xbb, 0x82, 0x9d, 0x88, 0x09,
-    0xb8, 0x8a, 0xb1, 0x92, 0x41, 0xaf, 0x8d, 0x46,
-    0xc0, 0xb3, 0x48, 0xf5, 0x9f, 0x60, 0x78, 0x73,
-    0x87, 0xa1, 0x81, 0x41, 0x61, 0x07, 0x80, 0x96,
-    0x84, 0xd7, 0x81, 0xb1, 0x8f, 0x00, 0xb8, 0x80,
-    0xa5, 0x84, 0x9b, 0x8b, 0xac, 0x83, 0xaf, 0x8b,
-    0xa4, 0x80, 0xc2, 0x8d, 0x8b, 0x07, 0x81, 0xac,
-    0x82, 0xb1, 0x00, 0x11, 0x0c, 0x80, 0xab, 0x24,
-    0x80, 0x40, 0xec, 0x87, 0x60, 0x4f, 0x32, 0x80,
-    0x48, 0x56, 0x84, 0x46, 0x85, 0x10, 0x0c, 0x83,
-    0x43, 0x13, 0x83, 0x41, 0x82, 0x81, 0x41, 0x52,
-    0x82, 0xb4, 0x8d, 0xbb, 0x80, 0xac, 0x88, 0xc6,
-    0x82, 0xa3, 0x8b, 0x91, 0x81, 0xb8, 0x82, 0xaf,
-    0x8c, 0x8d, 0x81, 0xdb, 0x88, 0x08, 0x28, 0x40,
-    0x9f, 0x89, 0x96, 0x83, 0xb9, 0x31, 0x09, 0x81,
-    0x89, 0x80, 0x89, 0x81, 0x40, 0xd0, 0x8c, 0x02,
-    0xe9, 0x91, 0x40, 0xec, 0x31, 0x86, 0x9c, 0x81,
-    0xd1, 0x8e, 0x00, 0xe9, 0x8a, 0xe6, 0x8d, 0x41,
-    0x00, 0x8c, 0x40, 0xf6, 0x28, 0x09, 0x0a, 0x00,
-    0x80, 0x40, 0x8d, 0x31, 0x2b, 0x80, 0x9b, 0x89,
-    0xa9, 0x20, 0x83, 0x91, 0x8a, 0xad, 0x8d, 0x41,
-    0x96, 0x38, 0x86, 0xd2, 0x95, 0x80, 0x8d, 0xf9,
-    0x2a, 0x00, 0x08, 0x10, 0x02, 0x80, 0xc1, 0x20,
-    0x08, 0x83, 0x41, 0x5b, 0x83, 0x60, 0x50, 0x57,
-    0x00, 0xb6, 0x33, 0xdc, 0x81, 0x60, 0x4c, 0xab,
-    0x80, 0x60, 0x23, 0x60, 0x30, 0x90, 0x0e, 0x01,
-    0x04, 0x49, 0x1b, 0x80, 0x47, 0xe7, 0x99, 0x85,
-    0x99, 0x85, 0x99,
+    0x84, 0xb8, 0x89, 0x81, 0x93, 0x40, 0x8a, 0x84,
+    0xaf, 0x8e, 0xbb, 0x82, 0x9d, 0x88, 0x09, 0xb8,
+    0x8a, 0xb1, 0x92, 0x41, 0xaf, 0x8d, 0x46, 0xc0,
+    0xb3, 0x48, 0xf5, 0x9f, 0x60, 0x78, 0x73, 0x87,
+    0xa1, 0x81, 0x41, 0x61, 0x07, 0x80, 0x96, 0x84,
+    0xd7, 0x81, 0xb1, 0x8f, 0x00, 0xb8, 0x80, 0xa5,
+    0x84, 0x9b, 0x8b, 0xac, 0x83, 0xaf, 0x8b, 0xa4,
+    0x80, 0xc2, 0x8d, 0x8b, 0x07, 0x81, 0xac, 0x82,
+    0xb1, 0x00, 0x11, 0x0c, 0x80, 0xab, 0x24, 0x80,
+    0x40, 0xec, 0x87, 0x60, 0x4f, 0x32, 0x80, 0x48,
+    0x56, 0x84, 0x46, 0x85, 0x10, 0x0c, 0x83, 0x43,
+    0x13, 0x83, 0x42, 0xd7, 0x82, 0xb4, 0x8d, 0xbb,
+    0x80, 0xac, 0x88, 0xc6, 0x82, 0xa3, 0x8b, 0x91,
+    0x81, 0xb8, 0x82, 0xaf, 0x8c, 0xeb, 0x88, 0x08,
+    0x28, 0x40, 0x9f, 0x89, 0x96, 0x83, 0xb9, 0x31,
+    0x09, 0x81, 0x89, 0x80, 0x89, 0x81, 0x40, 0xd0,
+    0x8c, 0x02, 0xe9, 0x91, 0x40, 0xec, 0x31, 0x86,
+    0x9c, 0x81, 0xd1, 0x8e, 0x00, 0xe9, 0x8a, 0xe6,
+    0x8d, 0x41, 0x00, 0x8c, 0x41, 0x97, 0x31, 0x2b,
+    0x80, 0x9b, 0x89, 0xa9, 0x20, 0x83, 0x91, 0x8a,
+    0xad, 0x8d, 0x41, 0x96, 0x38, 0x86, 0xd2, 0x95,
+    0x80, 0x8d, 0xf9, 0x2a, 0x00, 0x08, 0x10, 0x02,
+    0x80, 0xc1, 0x20, 0x08, 0x83, 0x41, 0x5b, 0x83,
+    0x60, 0x50, 0x57, 0x00, 0xb6, 0x33, 0x60, 0x4d,
+    0x0a, 0x80, 0x60, 0x23, 0x60, 0x30, 0x90, 0x0e,
+    0x01, 0x04, 0x49, 0x1b, 0x80, 0x47, 0xe7, 0x99,
+    0x85, 0x99, 0x85, 0x99,
 };
 
 static const uint8_t unicode_prop_Other_Lowercase_table[51] = {
@@ -3614,16 +3569,15 @@ static const uint8_t unicode_prop_Other_Uppercase_table[15] = {
     0xcc, 0x5f, 0x99, 0x85, 0x99, 0x85, 0x99,
 };
 
-static const uint8_t unicode_prop_Other_Grapheme_Extend_table[65] = {
+static const uint8_t unicode_prop_Other_Grapheme_Extend_table[62] = {
     0x49, 0xbd, 0x80, 0x97, 0x80, 0x41, 0x65, 0x80,
     0x97, 0x80, 0xe5, 0x80, 0x97, 0x80, 0x40, 0xe9,
     0x80, 0x91, 0x81, 0xe6, 0x80, 0x97, 0x80, 0xf6,
     0x80, 0x8e, 0x80, 0x4d, 0x54, 0x80, 0x44, 0xd5,
     0x80, 0x50, 0x20, 0x81, 0x60, 0xcf, 0x6d, 0x81,
     0x53, 0x9d, 0x80, 0x97, 0x80, 0x41, 0x57, 0x80,
-    0x8b, 0x80, 0x40, 0xf0, 0x80, 0x43, 0x7f, 0x80,
-    0x60, 0xb8, 0x33, 0x07, 0x84, 0x6c, 0x2e, 0xac,
-    0xdf,
+    0x8b, 0x80, 0x40, 0xf0, 0x80, 0x60, 0xbb, 0xb4,
+    0x07, 0x84, 0x6c, 0x2e, 0xac, 0xdf,
 };
 
 static const uint8_t unicode_prop_Other_Default_Ignorable_Code_Point_table[32] = {
@@ -3676,7 +3630,7 @@ static const uint8_t unicode_prop_Changes_When_Casefolded1_table[33] = {
     0x84,
 };
 
-static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[441] = {
+static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[436] = {
     0x40, 0x9f, 0x06, 0x00, 0x01, 0x00, 0x01, 0x12,
     0x10, 0x82, 0x9f, 0x80, 0xcf, 0x01, 0x80, 0x8b,
     0x07, 0x80, 0xfb, 0x01, 0x01, 0x80, 0xa5, 0x80,
@@ -3709,30 +3663,29 @@ static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[441] = {
     0x80, 0xde, 0x80, 0xb0, 0xdd, 0x82, 0x8d, 0xdf,
     0x9e, 0x80, 0xa7, 0x87, 0xae, 0x80, 0x41, 0x7f,
     0x60, 0x72, 0x9b, 0x81, 0x40, 0xd1, 0x80, 0x40,
-    0x86, 0x81, 0x43, 0x61, 0x83, 0x88, 0x80, 0x60,
-    0x4d, 0x95, 0x41, 0x0d, 0x08, 0x00, 0x81, 0x89,
-    0x00, 0x00, 0x09, 0x82, 0xc3, 0x81, 0xe9, 0xa5,
-    0x86, 0x8b, 0x24, 0x00, 0x97, 0x04, 0x00, 0x01,
-    0x01, 0x80, 0xeb, 0xa0, 0x41, 0x6a, 0x91, 0xbf,
-    0x81, 0xb5, 0xa7, 0x8c, 0x82, 0x99, 0x95, 0x94,
-    0x81, 0x8b, 0x80, 0x92, 0x03, 0x1a, 0x00, 0x80,
-    0x40, 0x86, 0x08, 0x80, 0x9f, 0x99, 0x40, 0x83,
-    0x15, 0x0d, 0x0d, 0x0a, 0x16, 0x06, 0x80, 0x88,
-    0x60, 0xbc, 0xa6, 0x83, 0x54, 0xb9, 0x86, 0x8d,
-    0x87, 0xbf, 0x85, 0x42, 0x3e, 0xd4, 0x80, 0xc6,
-    0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00, 0x06,
-    0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b, 0x03,
-    0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81, 0x41,
-    0x23, 0x81, 0xb1, 0x55, 0xff, 0x18, 0x9a, 0x01,
-    0x00, 0x08, 0x80, 0x89, 0x03, 0x00, 0x00, 0x28,
-    0x18, 0x00, 0x00, 0x02, 0x01, 0x00, 0x08, 0x00,
-    0x00, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x06, 0x03,
-    0x03, 0x00, 0x80, 0x89, 0x80, 0x90, 0x22, 0x04,
-    0x80, 0x90, 0x42, 0x43, 0x8a, 0x84, 0x9e, 0x80,
-    0x9f, 0x99, 0x82, 0xa2, 0x80, 0xee, 0x82, 0x8c,
-    0xab, 0x83, 0x88, 0x31, 0x49, 0x9d, 0x89, 0x60,
-    0xfc, 0x05, 0x42, 0x1d, 0x6b, 0x05, 0xe1, 0x4f,
-    0xff,
+    0x86, 0x81, 0x43, 0x61, 0x83, 0x60, 0x4d, 0x9f,
+    0x41, 0x0d, 0x08, 0x00, 0x81, 0x89, 0x00, 0x00,
+    0x09, 0x82, 0xc3, 0x81, 0xe9, 0xa5, 0x86, 0x8b,
+    0x24, 0x00, 0x97, 0x04, 0x00, 0x01, 0x01, 0x80,
+    0xeb, 0xa0, 0x41, 0x6a, 0x91, 0xbf, 0x81, 0xb5,
+    0xa7, 0x8c, 0x82, 0x99, 0x95, 0x94, 0x81, 0x8b,
+    0x80, 0x92, 0x03, 0x1a, 0x00, 0x80, 0x40, 0x86,
+    0x08, 0x80, 0x9f, 0x99, 0x40, 0x83, 0x15, 0x0d,
+    0x0d, 0x0a, 0x16, 0x06, 0x80, 0x88, 0x60, 0xbc,
+    0xa6, 0x83, 0x54, 0xb9, 0x86, 0x8d, 0x87, 0xbf,
+    0x85, 0x42, 0x3e, 0xd4, 0x80, 0xc6, 0x01, 0x08,
+    0x09, 0x0b, 0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0,
+    0x03, 0x0f, 0x06, 0x80, 0x9b, 0x03, 0x04, 0x00,
+    0x16, 0x80, 0x41, 0x53, 0x81, 0x41, 0x23, 0x81,
+    0xb1, 0x55, 0xff, 0x18, 0x9a, 0x01, 0x00, 0x08,
+    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,
+    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
+    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,
+    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,
+    0x42, 0x43, 0x8a, 0x84, 0x9e, 0x80, 0x9f, 0x99,
+    0x82, 0xa2, 0x80, 0xee, 0x82, 0x8c, 0xab, 0x83,
+    0x88, 0x31, 0x61, 0x05, 0xad, 0x42, 0x1d, 0x6b,
+    0x05, 0xe1, 0x4f, 0xff,
 };
 
 static const uint8_t unicode_prop_ASCII_Hex_Digit_table[5] = {
@@ -3744,14 +3697,14 @@ static const uint8_t unicode_prop_Bidi_Control_table[10] = {
     0xb6, 0x83,
 };
 
-static const uint8_t unicode_prop_Dash_table[53] = {
+static const uint8_t unicode_prop_Dash_table[50] = {
     0xac, 0x80, 0x45, 0x5b, 0x80, 0xb2, 0x80, 0x4e,
     0x40, 0x80, 0x44, 0x04, 0x80, 0x48, 0x08, 0x85,
     0xbc, 0x80, 0xa6, 0x80, 0x8e, 0x80, 0x41, 0x85,
     0x80, 0x4c, 0x03, 0x01, 0x80, 0x9e, 0x0b, 0x80,
     0x41, 0xda, 0x80, 0x92, 0x80, 0xee, 0x80, 0x60,
     0xcd, 0x8f, 0x81, 0xa4, 0x80, 0x89, 0x80, 0x40,
-    0xa8, 0x80, 0x4f, 0x9e, 0x80,
+    0xa8, 0x80,
 };
 
 static const uint8_t unicode_prop_Deprecated_table[23] = {
@@ -3760,7 +3713,7 @@ static const uint8_t unicode_prop_Deprecated_table[23] = {
     0x42, 0xb8, 0x81, 0x6d, 0xdc, 0xd5, 0x80,
 };
 
-static const uint8_t unicode_prop_Diacritic_table[358] = {
+static const uint8_t unicode_prop_Diacritic_table[350] = {
     0xdd, 0x00, 0x80, 0xc6, 0x05, 0x03, 0x01, 0x81,
     0x41, 0xf6, 0x40, 0x9e, 0x07, 0x25, 0x90, 0x0b,
     0x80, 0x88, 0x81, 0x40, 0xfc, 0x84, 0x40, 0xd0,
@@ -3770,57 +3723,55 @@ static const uint8_t unicode_prop_Diacritic_table[358] = {
     0x81, 0x40, 0xc8, 0x9b, 0xbc, 0x80, 0x8f, 0x02,
     0x83, 0x9b, 0x80, 0xc9, 0x80, 0x8f, 0x80, 0xed,
     0x80, 0x8f, 0x80, 0xed, 0x80, 0x8f, 0x80, 0xae,
-    0x82, 0xbb, 0x80, 0x8f, 0x06, 0x80, 0xf6, 0x80,
-    0xfe, 0x80, 0xed, 0x80, 0x8f, 0x80, 0xec, 0x81,
-    0x8f, 0x80, 0xfb, 0x80, 0xfb, 0x28, 0x80, 0xea,
-    0x80, 0x8c, 0x84, 0xca, 0x81, 0x9a, 0x00, 0x00,
-    0x03, 0x81, 0xc1, 0x10, 0x81, 0xbd, 0x80, 0xef,
-    0x00, 0x81, 0xa7, 0x0b, 0x84, 0x98, 0x30, 0x80,
-    0x89, 0x81, 0x42, 0xc0, 0x82, 0x44, 0x68, 0x8a,
-    0x88, 0x80, 0x41, 0x5a, 0x82, 0x41, 0x38, 0x39,
-    0x80, 0xaf, 0x8d, 0xf5, 0x80, 0x8e, 0x80, 0xa5,
-    0x88, 0xb5, 0x81, 0x40, 0x89, 0x81, 0xbf, 0x85,
-    0xd1, 0x98, 0x18, 0x28, 0x0a, 0xb1, 0xbe, 0xd8,
-    0x8b, 0xa4, 0x22, 0x82, 0x41, 0xbc, 0x00, 0x82,
-    0x8a, 0x82, 0x8c, 0x82, 0x8c, 0x82, 0x8c, 0x81,
-    0x4c, 0xef, 0x82, 0x41, 0x3c, 0x80, 0x41, 0xf9,
-    0x85, 0xe8, 0x83, 0xde, 0x80, 0x60, 0x75, 0x71,
-    0x80, 0x8b, 0x08, 0x80, 0x9b, 0x81, 0xd1, 0x81,
-    0x8d, 0xa1, 0xe5, 0x82, 0xec, 0x81, 0x40, 0xc9,
-    0x80, 0x9a, 0x91, 0xb8, 0x83, 0xa3, 0x80, 0xde,
-    0x80, 0x8b, 0x80, 0xa3, 0x80, 0x40, 0x94, 0x82,
-    0xc0, 0x83, 0xb2, 0x80, 0xe3, 0x84, 0x88, 0x82,
-    0xff, 0x81, 0x60, 0x4f, 0x2f, 0x80, 0x43, 0x00,
-    0x8f, 0x41, 0x0d, 0x00, 0x80, 0xae, 0x80, 0xac,
-    0x81, 0xc2, 0x80, 0x42, 0xfb, 0x80, 0x48, 0x03,
-    0x81, 0x42, 0x3a, 0x85, 0x42, 0x1d, 0x8a, 0x41,
-    0x67, 0x81, 0xf7, 0x81, 0xbd, 0x80, 0xcb, 0x80,
-    0x88, 0x82, 0xe7, 0x81, 0x40, 0xb1, 0x81, 0xd0,
-    0x80, 0x8f, 0x80, 0x97, 0x32, 0x84, 0x40, 0xcc,
-    0x02, 0x80, 0xfa, 0x81, 0x40, 0xfa, 0x81, 0xfd,
-    0x80, 0xf5, 0x81, 0xf2, 0x80, 0x41, 0x0c, 0x81,
-    0x41, 0x01, 0x0b, 0x80, 0x40, 0x9b, 0x80, 0xd2,
-    0x80, 0x91, 0x80, 0xd0, 0x80, 0x41, 0xa4, 0x80,
-    0x41, 0x01, 0x00, 0x81, 0xd0, 0x80, 0x60, 0x4d,
-    0x57, 0x84, 0xba, 0x86, 0x44, 0x57, 0x90, 0xcf,
-    0x81, 0x60, 0x61, 0x74, 0x12, 0x2f, 0x39, 0x86,
+    0x82, 0xbb, 0x80, 0x8f, 0x80, 0xfe, 0x80, 0xfe,
+    0x80, 0xed, 0x80, 0x8f, 0x80, 0xec, 0x81, 0x8f,
+    0x80, 0xfb, 0x80, 0xfb, 0x28, 0x80, 0xea, 0x80,
+    0x8c, 0x84, 0xca, 0x81, 0x9a, 0x00, 0x00, 0x03,
+    0x81, 0xc1, 0x10, 0x81, 0xbd, 0x80, 0xef, 0x00,
+    0x81, 0xa7, 0x0b, 0x84, 0x98, 0x30, 0x80, 0x89,
+    0x81, 0x42, 0xc0, 0x82, 0x44, 0x68, 0x8a, 0x88,
+    0x80, 0x41, 0x5a, 0x82, 0x41, 0x38, 0x39, 0x80,
+    0xaf, 0x8d, 0xf5, 0x80, 0x8e, 0x80, 0xa5, 0x88,
+    0xb5, 0x81, 0x40, 0x89, 0x81, 0xbf, 0x85, 0xd1,
+    0x98, 0x18, 0x28, 0x0a, 0xb1, 0xbe, 0xd8, 0x8b,
+    0xa4, 0x22, 0x82, 0x41, 0xbc, 0x00, 0x82, 0x8a,
+    0x82, 0x8c, 0x82, 0x8c, 0x82, 0x8c, 0x81, 0x4c,
+    0xef, 0x82, 0x41, 0x3c, 0x80, 0x41, 0xf9, 0x85,
+    0xe8, 0x83, 0xde, 0x80, 0x60, 0x75, 0x71, 0x80,
+    0x8b, 0x08, 0x80, 0x9b, 0x81, 0xd1, 0x81, 0x8d,
+    0xa1, 0xe5, 0x82, 0xec, 0x81, 0x40, 0xc9, 0x80,
+    0x9a, 0x91, 0xb8, 0x83, 0xa3, 0x80, 0xde, 0x80,
+    0x8b, 0x80, 0xa3, 0x80, 0x40, 0x94, 0x82, 0xc0,
+    0x83, 0xb2, 0x80, 0xe3, 0x84, 0x40, 0x8b, 0x81,
+    0x60, 0x4f, 0x2f, 0x80, 0x43, 0x00, 0x8f, 0x41,
+    0x0d, 0x00, 0x80, 0xae, 0x80, 0xac, 0x81, 0xc2,
+    0x80, 0x42, 0xfb, 0x80, 0x48, 0x03, 0x81, 0x42,
+    0x3a, 0x85, 0x42, 0x1d, 0x8a, 0x41, 0x67, 0x81,
+    0xf7, 0x81, 0xbd, 0x80, 0xcb, 0x80, 0x88, 0x82,
+    0xe7, 0x81, 0x40, 0xb1, 0x81, 0xd0, 0x80, 0x8f,
+    0x80, 0x97, 0x32, 0x84, 0x40, 0xcc, 0x02, 0x80,
+    0xfa, 0x81, 0x40, 0xfa, 0x81, 0xfd, 0x80, 0xf5,
+    0x81, 0xf2, 0x80, 0x41, 0x0c, 0x81, 0x41, 0xa4,
+    0x80, 0xd2, 0x80, 0x91, 0x80, 0xd0, 0x80, 0x41,
+    0xa4, 0x80, 0x41, 0x01, 0x00, 0x81, 0xd0, 0x80,
+    0x60, 0x4d, 0x57, 0x84, 0xba, 0x86, 0x44, 0x57,
+    0x90, 0x60, 0x61, 0xc6, 0x12, 0x2f, 0x39, 0x86,
     0x9d, 0x83, 0x4f, 0x81, 0x86, 0x41, 0xb4, 0x83,
     0x45, 0xdf, 0x86, 0xec, 0x10, 0x82,
 };
 
-static const uint8_t unicode_prop_Extender_table[89] = {
+static const uint8_t unicode_prop_Extender_table[86] = {
     0x40, 0xb6, 0x80, 0x42, 0x17, 0x81, 0x43, 0x6d,
-    0x80, 0x41, 0xb8, 0x80, 0x43, 0x59, 0x80, 0x42,
-    0xef, 0x80, 0xfe, 0x80, 0x49, 0x42, 0x80, 0xb7,
-    0x80, 0x42, 0x62, 0x80, 0x41, 0x8d, 0x80, 0xc3,
-    0x80, 0x53, 0x88, 0x80, 0xaa, 0x84, 0xe6, 0x81,
-    0xdc, 0x82, 0x60, 0x6f, 0x15, 0x80, 0x45, 0xf5,
-    0x80, 0x43, 0xc1, 0x80, 0x95, 0x80, 0x40, 0x88,
-    0x80, 0xeb, 0x80, 0x94, 0x81, 0x60, 0x54, 0x7a,
-    0x80, 0x53, 0xeb, 0x80, 0x42, 0x67, 0x82, 0x44,
-    0xce, 0x80, 0x60, 0x50, 0xa8, 0x81, 0x44, 0x9b,
-    0x08, 0x80, 0x60, 0x71, 0x57, 0x81, 0x48, 0x05,
-    0x82,
+    0x80, 0x41, 0xb8, 0x80, 0x46, 0x4a, 0x80, 0xfe,
+    0x80, 0x49, 0x42, 0x80, 0xb7, 0x80, 0x42, 0x62,
+    0x80, 0x41, 0x8d, 0x80, 0xc3, 0x80, 0x53, 0x88,
+    0x80, 0xaa, 0x84, 0xe6, 0x81, 0xdc, 0x82, 0x60,
+    0x6f, 0x15, 0x80, 0x45, 0xf5, 0x80, 0x43, 0xc1,
+    0x80, 0x95, 0x80, 0x40, 0x88, 0x80, 0xeb, 0x80,
+    0x94, 0x81, 0x60, 0x54, 0x7a, 0x80, 0x53, 0xeb,
+    0x80, 0x42, 0x67, 0x82, 0x44, 0xce, 0x80, 0x60,
+    0x50, 0xa8, 0x81, 0x44, 0x9b, 0x08, 0x80, 0x60,
+    0x71, 0x57, 0x81, 0x48, 0x05, 0x82,
 };
 
 static const uint8_t unicode_prop_Hex_Digit_table[12] = {
@@ -3836,16 +3787,15 @@ static const uint8_t unicode_prop_IDS_Trinary_Operator_table[4] = {
     0x60, 0x2f, 0xf1, 0x81,
 };
 
-static const uint8_t unicode_prop_Ideographic_table[66] = {
+static const uint8_t unicode_prop_Ideographic_table[58] = {
     0x60, 0x30, 0x05, 0x81, 0x98, 0x88, 0x8d, 0x82,
-    0x43, 0xc4, 0x59, 0xbf, 0xbf, 0x60, 0x51, 0xfc,
-    0x60, 0x59, 0x02, 0x41, 0x6d, 0x81, 0xe9, 0x60,
-    0x75, 0x09, 0x80, 0x9a, 0x57, 0xf7, 0x87, 0x44,
-    0xd5, 0xa9, 0x88, 0x60, 0x24, 0x66, 0x41, 0x8b,
-    0x60, 0x4d, 0x03, 0x60, 0xa6, 0xdd, 0xa1, 0x50,
-    0x34, 0x8a, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d,
-    0x5d, 0x30, 0x4c, 0x1e, 0x42, 0x1d, 0x45, 0xe1,
-    0x53, 0x4a,
+    0x43, 0xc4, 0x59, 0xb5, 0xc9, 0x60, 0x51, 0xef,
+    0x60, 0x59, 0x0f, 0x41, 0x6d, 0x81, 0xe9, 0x60,
+    0x75, 0x25, 0x57, 0xf7, 0x87, 0x42, 0xf2, 0x60,
+    0x26, 0x7c, 0x41, 0x8b, 0x60, 0x4d, 0x03, 0x60,
+    0xa6, 0xd6, 0xa8, 0x50, 0x34, 0x8a, 0x40, 0xdd,
+    0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x4c, 0x1e,
+    0x42, 0x1d,
 };
 
 static const uint8_t unicode_prop_Join_Control_table[4] = {
@@ -3901,7 +3851,7 @@ static const uint8_t unicode_prop_Regional_Indicator_table[4] = {
     0x61, 0xf1, 0xe5, 0x99,
 };
 
-static const uint8_t unicode_prop_Sentence_Terminal_table[188] = {
+static const uint8_t unicode_prop_Sentence_Terminal_table[184] = {
     0xa0, 0x80, 0x8b, 0x80, 0x8f, 0x80, 0x45, 0x48,
     0x80, 0x40, 0x93, 0x81, 0x40, 0xb3, 0x80, 0xaa,
     0x82, 0x40, 0xf5, 0x80, 0xbc, 0x00, 0x02, 0x81,
@@ -3921,11 +3871,10 @@ static const uint8_t unicode_prop_Sentence_Terminal_table[188] = {
     0x82, 0x40, 0x80, 0x0d, 0x80, 0x8f, 0x81, 0xd7,
     0x08, 0x81, 0xeb, 0x80, 0x41, 0xa0, 0x81, 0x41,
     0x74, 0x0c, 0x8e, 0xe8, 0x81, 0x40, 0xf8, 0x82,
-    0x42, 0x04, 0x00, 0x80, 0x40, 0xfa, 0x81, 0xd6,
-    0x81, 0x41, 0xa3, 0x81, 0x42, 0xb3, 0x81, 0x60,
-    0x4b, 0x74, 0x81, 0x40, 0x84, 0x80, 0xc0, 0x81,
-    0x8a, 0x80, 0x43, 0x52, 0x80, 0x60, 0x4e, 0x05,
-    0x80, 0x5d, 0xe7, 0x80,
+    0x43, 0x02, 0x81, 0xd6, 0x81, 0x41, 0xa3, 0x81,
+    0x42, 0xb3, 0x81, 0x60, 0x4b, 0x74, 0x81, 0x40,
+    0x84, 0x80, 0xc0, 0x81, 0x8a, 0x80, 0x43, 0x52,
+    0x80, 0x60, 0x4e, 0x05, 0x80, 0x5d, 0xe7, 0x80,
 };
 
 static const uint8_t unicode_prop_Soft_Dotted_table[71] = {
@@ -3940,7 +3889,7 @@ static const uint8_t unicode_prop_Soft_Dotted_table[71] = {
     0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81,
 };
 
-static const uint8_t unicode_prop_Terminal_Punctuation_table[241] = {
+static const uint8_t unicode_prop_Terminal_Punctuation_table[237] = {
     0xa0, 0x80, 0x89, 0x00, 0x80, 0x8a, 0x0a, 0x80,
     0x43, 0x3d, 0x07, 0x80, 0x42, 0x00, 0x80, 0xb8,
     0x80, 0xc7, 0x80, 0x8d, 0x01, 0x81, 0x40, 0xb3,
@@ -3964,23 +3913,21 @@ static const uint8_t unicode_prop_Terminal_Punctuation_table[241] = {
     0x85, 0xc3, 0x85, 0xd8, 0x83, 0x43, 0xb7, 0x84,
     0x40, 0xec, 0x86, 0xef, 0x83, 0xfe, 0x82, 0x40,
     0x80, 0x0d, 0x80, 0x8f, 0x81, 0xd7, 0x84, 0xeb,
-    0x80, 0x41, 0xa0, 0x82, 0x8b, 0x81, 0x41, 0x65,
-    0x1a, 0x8e, 0xe8, 0x81, 0x40, 0xf8, 0x82, 0x42,
-    0x04, 0x00, 0x80, 0x40, 0xfa, 0x81, 0xd6, 0x0b,
-    0x81, 0x41, 0x9d, 0x82, 0xac, 0x80, 0x42, 0x84,
-    0x81, 0x45, 0x76, 0x84, 0x60, 0x45, 0xf8, 0x81,
-    0x40, 0x84, 0x80, 0xc0, 0x82, 0x89, 0x80, 0x43,
-    0x51, 0x81, 0x60, 0x4e, 0x05, 0x80, 0x5d, 0xe6,
-    0x83,
+    0x80, 0x41, 0xa0, 0x82, 0x8c, 0x80, 0x41, 0x65,
+    0x1a, 0x8e, 0xe8, 0x81, 0x40, 0xf8, 0x82, 0x43,
+    0x02, 0x81, 0xd6, 0x0b, 0x81, 0x41, 0x9d, 0x82,
+    0xac, 0x80, 0x42, 0x84, 0x81, 0x45, 0x76, 0x84,
+    0x60, 0x45, 0xf8, 0x81, 0x40, 0x84, 0x80, 0xc0,
+    0x82, 0x89, 0x80, 0x43, 0x51, 0x81, 0x60, 0x4e,
+    0x05, 0x80, 0x5d, 0xe6, 0x83,
 };
 
-static const uint8_t unicode_prop_Unified_Ideograph_table[42] = {
-    0x60, 0x33, 0xff, 0x59, 0xbf, 0xbf, 0x60, 0x51,
-    0xfc, 0x60, 0x5a, 0x10, 0x08, 0x00, 0x81, 0x89,
+static const uint8_t unicode_prop_Unified_Ideograph_table[38] = {
+    0x60, 0x33, 0xff, 0x59, 0xb5, 0xc9, 0x60, 0x51,
+    0xef, 0x60, 0x5a, 0x1d, 0x08, 0x00, 0x81, 0x89,
     0x00, 0x00, 0x09, 0x82, 0x61, 0x05, 0xd5, 0x60,
-    0xa6, 0xdd, 0xa1, 0x50, 0x34, 0x8a, 0x40, 0xdd,
-    0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x54, 0x1e,
-    0x53, 0x4a,
+    0xa6, 0xd6, 0xa8, 0x50, 0x34, 0x8a, 0x40, 0xdd,
+    0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30,
 };
 
 static const uint8_t unicode_prop_Variation_Selector_table[12] = {
@@ -4019,7 +3966,7 @@ static const uint8_t unicode_prop_Bidi_Mirrored_table[171] = {
     0x80, 0xb8, 0x80,
 };
 
-static const uint8_t unicode_prop_Emoji_table[238] = {
+static const uint8_t unicode_prop_Emoji_table[236] = {
     0xa2, 0x05, 0x04, 0x89, 0xee, 0x03, 0x80, 0x5f,
     0x8c, 0x80, 0x8b, 0x80, 0x40, 0xd7, 0x80, 0x95,
     0x80, 0xd9, 0x85, 0x8e, 0x81, 0x41, 0x6e, 0x81,
@@ -4029,27 +3976,27 @@ static const uint8_t unicode_prop_Emoji_table[238] = {
     0x09, 0x03, 0x01, 0x00, 0x09, 0x02, 0x02, 0x0f,
     0x14, 0x00, 0x04, 0x8b, 0x8a, 0x09, 0x00, 0x08,
     0x80, 0x91, 0x01, 0x81, 0x91, 0x28, 0x00, 0x0a,
-    0x0c, 0x01, 0x0b, 0x81, 0x8a, 0x0c, 0x09, 0x04,
-    0x08, 0x00, 0x81, 0x93, 0x0c, 0x28, 0x19, 0x03,
-    0x01, 0x01, 0x28, 0x01, 0x00, 0x00, 0x05, 0x02,
-    0x05, 0x80, 0x89, 0x81, 0x8e, 0x01, 0x03, 0x00,
-    0x03, 0x10, 0x80, 0x8a, 0x81, 0xaf, 0x82, 0x88,
-    0x80, 0x8d, 0x80, 0x8d, 0x80, 0x41, 0x73, 0x81,
-    0x41, 0xce, 0x82, 0x92, 0x81, 0xb2, 0x03, 0x80,
-    0x44, 0xd9, 0x80, 0x8b, 0x80, 0x42, 0x58, 0x00,
-    0x80, 0x61, 0xbd, 0x69, 0x80, 0x40, 0xc9, 0x80,
-    0x40, 0x9f, 0x81, 0x8b, 0x81, 0x8d, 0x01, 0x89,
-    0xca, 0x99, 0x01, 0x96, 0x80, 0x93, 0x01, 0x88,
-    0x94, 0x81, 0x40, 0xad, 0xa1, 0x81, 0xef, 0x09,
-    0x02, 0x81, 0xd2, 0x0a, 0x80, 0x41, 0x06, 0x80,
-    0xbe, 0x8a, 0x28, 0x97, 0x31, 0x0f, 0x8b, 0x01,
-    0x19, 0x03, 0x81, 0x8c, 0x09, 0x07, 0x81, 0x88,
-    0x04, 0x82, 0x8b, 0x17, 0x11, 0x00, 0x03, 0x05,
-    0x02, 0x05, 0xd5, 0xaf, 0xc5, 0x27, 0x0a, 0x3d,
-    0x10, 0x01, 0x10, 0x81, 0x89, 0x40, 0xe2, 0x8b,
-    0x41, 0x1f, 0xae, 0x80, 0x89, 0x80, 0xb1, 0x80,
-    0xd1, 0x80, 0xb2, 0xef, 0x22, 0x14, 0x86, 0x88,
-    0x98, 0x36, 0x88, 0x82, 0x8c, 0x86,
+    0x0f, 0x0b, 0x81, 0x8a, 0x0c, 0x09, 0x04, 0x08,
+    0x00, 0x81, 0x93, 0x0c, 0x28, 0x19, 0x03, 0x01,
+    0x01, 0x28, 0x01, 0x00, 0x00, 0x05, 0x02, 0x05,
+    0x80, 0x89, 0x81, 0x8e, 0x01, 0x03, 0x00, 0x03,
+    0x10, 0x80, 0x8a, 0x81, 0xaf, 0x82, 0x88, 0x80,
+    0x8d, 0x80, 0x8d, 0x80, 0x41, 0x73, 0x81, 0x41,
+    0xce, 0x82, 0x92, 0x81, 0xb2, 0x03, 0x80, 0x44,
+    0xd9, 0x80, 0x8b, 0x80, 0x42, 0x58, 0x00, 0x80,
+    0x61, 0xbd, 0x69, 0x80, 0x40, 0xc9, 0x80, 0x40,
+    0x9f, 0x81, 0x8b, 0x81, 0x8d, 0x01, 0x89, 0xca,
+    0x99, 0x01, 0x96, 0x80, 0x93, 0x01, 0x88, 0x94,
+    0x81, 0x40, 0xad, 0xa1, 0x81, 0xef, 0x09, 0x02,
+    0x81, 0xd2, 0x0a, 0x80, 0x41, 0x06, 0x80, 0xbe,
+    0x8a, 0x28, 0x97, 0x31, 0x0f, 0x8b, 0x01, 0x19,
+    0x03, 0x81, 0x8c, 0x09, 0x07, 0x81, 0x88, 0x04,
+    0x82, 0x8b, 0x17, 0x11, 0x00, 0x03, 0x05, 0x02,
+    0x05, 0xd5, 0xaf, 0xc5, 0x27, 0x08, 0x89, 0x2a,
+    0x00, 0x0a, 0x01, 0x87, 0x40, 0xe4, 0x8b, 0x41,
+    0x20, 0xad, 0x80, 0x89, 0x80, 0xaa, 0x03, 0x82,
+    0xa8, 0x0d, 0x82, 0x9c, 0x81, 0xb2, 0xef, 0x1b,
+    0x14, 0x82, 0x8c, 0x85,
 };
 
 static const uint8_t unicode_prop_Emoji_Component_table[28] = {
@@ -4063,19 +4010,18 @@ static const uint8_t unicode_prop_Emoji_Modifier_table[4] = {
     0x61, 0xf3, 0xfa, 0x84,
 };
 
-static const uint8_t unicode_prop_Emoji_Modifier_Base_table[66] = {
+static const uint8_t unicode_prop_Emoji_Modifier_Base_table[63] = {
     0x60, 0x26, 0x1c, 0x80, 0x40, 0xda, 0x80, 0x8f,
     0x83, 0x61, 0xcc, 0x76, 0x80, 0xbb, 0x11, 0x01,
     0x82, 0xf4, 0x09, 0x8a, 0x94, 0x92, 0x10, 0x1a,
     0x02, 0x30, 0x00, 0x97, 0x80, 0x40, 0xc8, 0x0b,
     0x80, 0x94, 0x03, 0x81, 0x40, 0xad, 0x12, 0x84,
     0xd2, 0x80, 0x8f, 0x82, 0x88, 0x80, 0x8a, 0x80,
-    0x42, 0x3e, 0x01, 0x07, 0x3d, 0x80, 0x88, 0x89,
-    0x0a, 0xb7, 0x80, 0xbc, 0x08, 0x08, 0x80, 0x90,
-    0x10, 0x8c,
+    0x42, 0x41, 0x07, 0x3d, 0x80, 0x88, 0x89, 0x0a,
+    0xf5, 0x08, 0x08, 0x80, 0x90, 0x10, 0x8c,
 };
 
-static const uint8_t unicode_prop_Emoji_Presentation_table[144] = {
+static const uint8_t unicode_prop_Emoji_Presentation_table[143] = {
     0x60, 0x23, 0x19, 0x81, 0x40, 0xcc, 0x1a, 0x01,
     0x80, 0x42, 0x08, 0x81, 0x94, 0x81, 0xb1, 0x8b,
     0xaa, 0x80, 0x92, 0x80, 0x8c, 0x07, 0x81, 0x90,
@@ -4090,13 +4036,13 @@ static const uint8_t unicode_prop_Emoji_Presentation_table[144] = {
     0x1c, 0x8b, 0x90, 0x10, 0x82, 0xc6, 0x00, 0x80,
     0x40, 0xba, 0x81, 0xbe, 0x8c, 0x18, 0x97, 0x91,
     0x80, 0x99, 0x81, 0x8c, 0x80, 0xd5, 0xd4, 0xaf,
-    0xc5, 0x28, 0x12, 0x0a, 0x92, 0x0e, 0x88, 0x40,
-    0xe2, 0x8b, 0x41, 0x1f, 0xae, 0x80, 0x89, 0x80,
-    0xb1, 0x80, 0xd1, 0x80, 0xb2, 0xef, 0x22, 0x14,
-    0x86, 0x88, 0x98, 0x36, 0x88, 0x82, 0x8c, 0x86,
+    0xc5, 0x28, 0x12, 0x08, 0x94, 0x0e, 0x86, 0x40,
+    0xe4, 0x8b, 0x41, 0x20, 0xad, 0x80, 0x89, 0x80,
+    0xaa, 0x03, 0x82, 0xa8, 0x0d, 0x82, 0x9c, 0x81,
+    0xb2, 0xef, 0x1b, 0x14, 0x82, 0x8c, 0x85,
 };
 
-static const uint8_t unicode_prop_Extended_Pictographic_table[156] = {
+static const uint8_t unicode_prop_Extended_Pictographic_table[152] = {
     0x40, 0xa8, 0x03, 0x80, 0x5f, 0x8c, 0x80, 0x8b,
     0x80, 0x40, 0xd7, 0x80, 0x95, 0x80, 0xd9, 0x85,
     0x8e, 0x81, 0x41, 0x6e, 0x81, 0x8b, 0x80, 0xde,
@@ -4115,8 +4061,7 @@ static const uint8_t unicode_prop_Extended_Pictographic_table[156] = {
     0x88, 0x41, 0xb1, 0x84, 0x41, 0x3d, 0x87, 0x41,
     0x09, 0xaf, 0xff, 0xf3, 0x8b, 0xd4, 0xaa, 0x8b,
     0x83, 0xb7, 0x87, 0x89, 0x85, 0xa7, 0x87, 0x9d,
-    0xd1, 0x8b, 0xae, 0x80, 0x89, 0x80, 0x41, 0xb8,
-    0x40, 0xff, 0x43, 0xfd,
+    0xd1, 0x8b, 0xae, 0x80, 0x89, 0x80, 0x46, 0xb6,
 };
 
 static const uint8_t unicode_prop_Default_Ignorable_Code_Point_table[51] = {
@@ -4230,11 +4175,11 @@ static const char unicode_prop_name_table[] =
     "White_Space,space"                  "\0"
     "Bidi_Mirrored,Bidi_M"               "\0"
     "Emoji"                              "\0"
-    "Emoji_Component,EComp"              "\0"
-    "Emoji_Modifier,EMod"                "\0"
-    "Emoji_Modifier_Base,EBase"          "\0"
-    "Emoji_Presentation,EPres"           "\0"
-    "Extended_Pictographic,ExtPict"      "\0"
+    "Emoji_Component"                    "\0"
+    "Emoji_Modifier"                     "\0"
+    "Emoji_Modifier_Base"                "\0"
+    "Emoji_Presentation"                 "\0"
+    "Extended_Pictographic"              "\0"
     "Default_Ignorable_Code_Point,DI"    "\0"
     "ID_Start,IDS"                       "\0"
     "Case_Ignorable,CI"                  "\0"
diff --git a/quickjs-atom.h b/quickjs-atom.h
index 4c22794..233294c 100644
--- a/quickjs-atom.h
+++ b/quickjs-atom.h
@@ -82,7 +82,6 @@ DEF(length, "length")
 DEF(fileName, "fileName")
 DEF(lineNumber, "lineNumber")
 DEF(message, "message")
-DEF(errors, "errors")
 DEF(stack, "stack")
 DEF(name, "name")
 DEF(toString, "toString")
@@ -113,7 +112,6 @@ DEF(caller, "caller")
 DEF(_eval_, "<eval>")
 DEF(_ret_, "<ret>")
 DEF(_var_, "<var>")
-DEF(_arg_var_, "<arg_var>")
 DEF(_with_, "<with>")
 DEF(lastIndex, "lastIndex")
 DEF(target, "target")
@@ -172,10 +170,6 @@ DEF(globalThis, "globalThis")
 #ifdef CONFIG_BIGNUM
 DEF(bigint, "bigint")
 DEF(bigfloat, "bigfloat")
-DEF(bigdecimal, "bigdecimal")
-DEF(roundingMode, "roundingMode")
-DEF(maximumSignificantDigits, "maximumSignificantDigits")
-DEF(maximumFractionDigits, "maximumFractionDigits")
 #endif
 #ifdef CONFIG_ATOMICS
 DEF(not_equal, "not-equal")
@@ -220,9 +214,6 @@ DEF(DataView, "DataView")
 DEF(BigInt, "BigInt")
 DEF(BigFloat, "BigFloat")
 DEF(BigFloatEnv, "BigFloatEnv")
-DEF(BigDecimal, "BigDecimal")
-DEF(OperatorSet, "OperatorSet")
-DEF(Operators, "Operators")
 #endif
 DEF(Map, "Map")
 DEF(Set, "Set") /* Map + 1 */
@@ -267,7 +258,27 @@ DEF(Symbol_species, "Symbol.species")
 DEF(Symbol_unscopables, "Symbol.unscopables")
 DEF(Symbol_asyncIterator, "Symbol.asyncIterator")
 #ifdef CONFIG_BIGNUM
-DEF(Symbol_operatorSet, "Symbol.operatorSet")
+DEF(Symbol_operatorOrder, "Symbol.operatorOrder")
+DEF(Symbol_operatorAdd, "Symbol.operatorAdd")
+DEF(Symbol_operatorSub, "Symbol.operatorSub")
+DEF(Symbol_operatorMul, "Symbol.operatorMul")
+DEF(Symbol_operatorDiv, "Symbol.operatorDiv")
+DEF(Symbol_operatorMod, "Symbol.operatorMod")
+DEF(Symbol_operatorPow, "Symbol.operatorPow")
+DEF(Symbol_operatorShl, "Symbol.operatorShl")
+DEF(Symbol_operatorShr, "Symbol.operatorShr")
+DEF(Symbol_operatorAnd, "Symbol.operatorAnd")
+DEF(Symbol_operatorOr, "Symbol.operatorOr")
+DEF(Symbol_operatorXor, "Symbol.operatorXor")
+DEF(Symbol_operatorCmpLT, "Symbol.operatorCmpLT")
+DEF(Symbol_operatorCmpLE, "Symbol.operatorCmpLE")
+DEF(Symbol_operatorCmpEQ, "Symbol.operatorCmpEQ")
+DEF(Symbol_operatorPlus, "Symbol.operatorPlus")
+DEF(Symbol_operatorNeg, "Symbol.operatorNeg")
+DEF(Symbol_operatorNot, "Symbol.operatorNot")
+DEF(Symbol_operatorInc, "Symbol.operatorInc")
+DEF(Symbol_operatorDec, "Symbol.operatorDec")
+DEF(Symbol_operatorMathMod, "Symbol.operatorMathMod")
 #endif
-    
+
 #endif /* DEF */
diff --git a/quickjs-libc.c b/quickjs-libc.c
index e180dd0..0b86a29 100644
--- a/quickjs-libc.c
+++ b/quickjs-libc.c
@@ -28,50 +28,43 @@
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/time.h>
 #include <time.h>
 #include <signal.h>
 #include <limits.h>
 #include <sys/stat.h>
-#include <dirent.h>
 #if defined(_WIN32)
 #include <windows.h>
 #include <conio.h>
-#include <utime.h>
+#ifndef PATH_MAX
+#define PATH_MAX MAX_PATH
+#endif
 #else
+#include <unistd.h>
+#include <dirent.h>
 #include <dlfcn.h>
 #include <termios.h>
 #include <sys/ioctl.h>
+#include <sys/time.h>
 #include <sys/wait.h>
-
 #if defined(__APPLE__)
 typedef sig_t sighandler_t;
-#if !defined(environ)
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
 #endif
-#endif /* __APPLE__ */
-
-#endif
-
-#if !defined(_WIN32)
-/* enable the os.Worker API. IT relies on POSIX threads */
-#define USE_WORKER
-#endif
-
-#ifdef USE_WORKER
-#include <pthread.h>
-#include <stdatomic.h>
 #endif
 
 #include "cutils.h"
 #include "list.h"
 #include "quickjs-libc.h"
 
+static void js_std_dbuf_init(JSContext *ctx, DynBuf *s)
+{
+    dbuf_init2(s, JS_GetRuntime(ctx), (DynBufReallocFunc *)js_realloc_rt);
+}
+
 /* TODO:
+   - add worker
+   - add minimal VT100 emulation for win32
    - add socket calls
 */
 
@@ -94,54 +87,14 @@ typedef struct {
     JSValue func;
 } JSOSTimer;
 
-typedef struct {
-    struct list_head link;
-    uint8_t *data;
-    size_t data_len;
-    /* list of SharedArrayBuffers, necessary to free the message */
-    uint8_t **sab_tab;
-    size_t sab_tab_len;
-} JSWorkerMessage;
-
-typedef struct {
-    int ref_count;
-#ifdef USE_WORKER
-    pthread_mutex_t mutex;
-#endif
-    struct list_head msg_queue; /* list of JSWorkerMessage.link */
-    int read_fd;
-    int write_fd;
-} JSWorkerMessagePipe;
-
-typedef struct {
-    struct list_head link;
-    JSWorkerMessagePipe *recv_pipe;
-    JSValue on_message_func;
-} JSWorkerMessageHandler;
-
-typedef struct JSThreadState {
-    struct list_head os_rw_handlers; /* list of JSOSRWHandler.link */
-    struct list_head os_signal_handlers; /* list JSOSSignalHandler.link */
-    struct list_head os_timers; /* list of JSOSTimer.link */
-    struct list_head port_list; /* list of JSWorkerMessageHandler.link */
-    int eval_script_recurse; /* only used in the main thread */
-    /* not used in the main thread */
-    JSWorkerMessagePipe *recv_pipe, *send_pipe;
-} JSThreadState;
-
+/* initialize the lists so js_std_free_handlers() can always be called */
+static struct list_head os_rw_handlers = LIST_HEAD_INIT(os_rw_handlers);
+static struct list_head os_signal_handlers = LIST_HEAD_INIT(os_signal_handlers);
+static struct list_head os_timers = LIST_HEAD_INIT(os_timers);
 static uint64_t os_pending_signals;
+static int eval_script_recurse;
 static int (*os_poll_func)(JSContext *ctx);
 
-static void js_std_dbuf_init(JSContext *ctx, DynBuf *s)
-{
-    dbuf_init2(s, JS_GetRuntime(ctx), (DynBufReallocFunc *)js_realloc_rt);
-}
-
-static BOOL my_isdigit(int c)
-{
-    return (c >= '0' && c <= '9');
-}
-
 static JSValue js_printf_internal(JSContext *ctx,
                                   int argc, JSValueConst *argv, FILE *fp)
 {
@@ -153,12 +106,14 @@ static JSValue js_printf_internal(JSContext *ctx,
     const uint8_t *fmt, *fmt_end;
     const uint8_t *p;
     char *q;
-    int i, c, len, mod;
+    int i, c, len;
     size_t fmt_len;
     int32_t int32_arg;
     int64_t int64_arg;
     double double_arg;
     const char *string_arg;
+    enum { PART_FLAGS, PART_WIDTH, PART_DOT, PART_PREC, PART_MODIFIER } part;
+    int modsize;
     /* Use indirect call to dbuf_printf to prevent gcc warning */
     int (*dbuf_printf_fun)(DynBuf *s, const char *fmt, ...) = (void*)dbuf_printf;
 
@@ -180,162 +135,151 @@ static JSValue js_printf_internal(JSContext *ctx,
                 break;
             q = fmtbuf;
             *q++ = *fmt++;  /* copy '%' */
-            
-            /* flags */
-            for(;;) {
-                c = *fmt;
-                if (c == '0' || c == '#' || c == '+' || c == '-' || c == ' ' ||
-                    c == '\'') {
-                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)
-                        goto invalid;
-                    *q++ = c;
-                    fmt++;
-                } else {
-                    break;
-                }
-            }
-            /* width */
-            if (*fmt == '*') {
-                if (i >= argc)
-                    goto missing;
-                if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
-                    goto fail;
-                q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, "%d", int32_arg);
-                fmt++;
-            } else {
-                while (my_isdigit(*fmt)) {
-                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)
-                        goto invalid;
-                    *q++ = *fmt++;
-                }
-            }
-            if (*fmt == '.') {
+            part = PART_FLAGS;
+            modsize = 0;
+            for (;;) {
                 if (q >= fmtbuf + sizeof(fmtbuf) - 1)
                     goto invalid;
-                *q++ = *fmt++;
-                if (*fmt == '*') {
+
+                c = *fmt++;
+                *q++ = c;
+                *q = '\0';
+
+                switch (c) {
+                case '1': case '2': case '3':
+                case '4': case '5': case '6':
+                case '7': case '8': case '9':
+                    if (part != PART_PREC) {
+                        if (part <= PART_WIDTH)
+                            part = PART_WIDTH;
+                        else 
+                            goto invalid;
+                    }
+                    continue;
+
+                case '0': case '#': case '+': case '-': case ' ': case '\'':
+                    if (part > PART_FLAGS)
+                        goto invalid;
+                    continue;
+
+                case '.':
+                    if (part > PART_DOT)
+                        goto invalid;
+                    part = PART_DOT;
+                    continue;
+
+                case '*':
+                    if (part < PART_WIDTH)
+                        part = PART_DOT;
+                    else if (part == PART_DOT)
+                        part = PART_MODIFIER;
+                    else
+                        goto invalid;
+
                     if (i >= argc)
                         goto missing;
+
                     if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
                         goto fail;
                     q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, "%d", int32_arg);
-                    fmt++;
-                } else {
-                    while (my_isdigit(*fmt)) {
-                        if (q >= fmtbuf + sizeof(fmtbuf) - 1)
-                            goto invalid;
-                        *q++ = *fmt++;
+                    continue;
+
+                case 'h':
+                    if (modsize != 0 && modsize != -1)
+                        goto invalid;
+                    modsize--;
+                    part = PART_MODIFIER;
+                    continue;
+                case 'l':
+                    q--;
+                    if (modsize != 0 && modsize != 1)
+                        goto invalid;
+                    modsize++;
+                    part = PART_MODIFIER;
+                    continue;
+
+                case 'c':
+                    if (i >= argc)
+                        goto missing;
+                    if (JS_IsString(argv[i])) {
+                        string_arg = JS_ToCString(ctx, argv[i++]);
+                        if (!string_arg)
+                            goto fail;
+                        int32_arg = unicode_from_utf8((uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);
+                        JS_FreeCString(ctx, string_arg);
+                    } else {
+                        if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
+                            goto fail;
                     }
-                }
-            }
+                    /* handle utf-8 encoding explicitly */
+                    if ((unsigned)int32_arg > 0x10FFFF)
+                        int32_arg = 0xFFFD;
+                    /* ignore conversion flags, width and precision */
+                    len = unicode_to_utf8(cbuf, int32_arg);
+                    dbuf_put(&dbuf, cbuf, len);
+                    break;
 
-            /* we only support the "l" modifier for 64 bit numbers */
-            mod = ' ';
-            if (*fmt == 'l') {
-                mod = *fmt++;
-            }
-            
-            /* type */
-            c = *fmt++;
-            if (q >= fmtbuf + sizeof(fmtbuf) - 1)
-                goto invalid;
-            *q++ = c;
-            *q = '\0';
-            
-            switch (c) {
-            case 'c':
-                if (i >= argc)
-                    goto missing;
-                if (JS_IsString(argv[i])) {
+                case 'd':
+                case 'i':
+                case 'o':
+                case 'u':
+                case 'x':
+                case 'X':
+                    if (i >= argc)
+                        goto missing;
+                    if (modsize > 0) {
+                        if (JS_ToInt64(ctx, &int64_arg, argv[i++]))
+                            goto fail;
+                        q[1] = q[-1];
+                        q[-1] = q[0] = 'l';
+                        q[2] = '\0';
+                        dbuf_printf_fun(&dbuf, fmtbuf, (long long)int64_arg);
+                    } else {
+                        if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
+                            goto fail;
+                        dbuf_printf_fun(&dbuf, fmtbuf, int32_arg);
+                    }
+                    break;
+
+                case 's':
+                    if (i >= argc)
+                        goto missing;
                     string_arg = JS_ToCString(ctx, argv[i++]);
                     if (!string_arg)
                         goto fail;
-                    int32_arg = unicode_from_utf8((uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);
+                    dbuf_printf_fun(&dbuf, fmtbuf, string_arg);
                     JS_FreeCString(ctx, string_arg);
-                } else {
-                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
+                    break;
+
+                case 'e':
+                case 'f':
+                case 'g':
+                case 'a':
+                case 'E':
+                case 'F':
+                case 'G':
+                case 'A':
+                    if (i >= argc)
+                        goto missing;
+                    if (JS_ToFloat64(ctx, &double_arg, argv[i++]))
                         goto fail;
-                }
-                /* handle utf-8 encoding explicitly */
-                if ((unsigned)int32_arg > 0x10FFFF)
-                    int32_arg = 0xFFFD;
-                /* ignore conversion flags, width and precision */
-                len = unicode_to_utf8(cbuf, int32_arg);
-                dbuf_put(&dbuf, cbuf, len);
-                break;
-                
-            case 'd':
-            case 'i':
-            case 'o':
-            case 'u':
-            case 'x':
-            case 'X':
-                if (i >= argc)
-                    goto missing;
-                if (JS_ToInt64Ext(ctx, &int64_arg, argv[i++]))
-                    goto fail;
-                if (mod == 'l') {
-                    /* 64 bit number */
-#if defined(_WIN32)
-                    if (q >= fmtbuf + sizeof(fmtbuf) - 3)
-                        goto invalid;
-                    q[2] = q[-1];
-                    q[-1] = 'I';
-                    q[0] = '6';
-                    q[1] = '4';
-                    q[3] = '\0';
-                    dbuf_printf_fun(&dbuf, fmtbuf, (int64_t)int64_arg);
-#else
-                    if (q >= fmtbuf + sizeof(fmtbuf) - 2)
-                        goto invalid;
-                    q[1] = q[-1];
-                    q[-1] = q[0] = 'l';
-                    q[2] = '\0';
-                    dbuf_printf_fun(&dbuf, fmtbuf, (long long)int64_arg);
-#endif
-                } else {
-                    dbuf_printf_fun(&dbuf, fmtbuf, (int)int64_arg);
-                }
-                break;
+                    dbuf_printf_fun(&dbuf, fmtbuf, double_arg);
+                    break;
+
+                case '%':
+                    dbuf_putc(&dbuf, '%');
+                    break;
 
-            case 's':
-                if (i >= argc)
-                    goto missing;
-                /* XXX: handle strings containing null characters */
-                string_arg = JS_ToCString(ctx, argv[i++]);
-                if (!string_arg)
+                default:
+                    /* XXX: should support an extension mechanism */
+                invalid:
+                    JS_ThrowTypeError(ctx, "invalid conversion specifier in format string");
                     goto fail;
-                dbuf_printf_fun(&dbuf, fmtbuf, string_arg);
-                JS_FreeCString(ctx, string_arg);
-                break;
-                
-            case 'e':
-            case 'f':
-            case 'g':
-            case 'a':
-            case 'E':
-            case 'F':
-            case 'G':
-            case 'A':
-                if (i >= argc)
-                    goto missing;
-                if (JS_ToFloat64(ctx, &double_arg, argv[i++]))
+                missing:
+                    JS_ThrowReferenceError(ctx, "missing argument for conversion specifier");
                     goto fail;
-                dbuf_printf_fun(&dbuf, fmtbuf, double_arg);
-                break;
-                
-            case '%':
-                dbuf_putc(&dbuf, '%');
+                }
                 break;
-                
-            default:
-                /* XXX: should support an extension mechanism */
-            invalid:
-                JS_ThrowTypeError(ctx, "invalid conversion specifier in format string");
-                goto fail;
-            missing:
-                JS_ThrowReferenceError(ctx, "missing argument for conversion specifier");
-                goto fail;
             }
         }
         JS_FreeCString(ctx, fmt_str);
@@ -428,27 +372,6 @@ static JSValue js_loadScript(JSContext *ctx, JSValueConst this_val,
     return ret;
 }
 
-/* load a file as a UTF-8 encoded string */
-static JSValue js_std_loadFile(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    uint8_t *buf;
-    const char *filename;
-    JSValue ret;
-    size_t buf_len;
-    
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        return JS_EXCEPTION;
-    buf = js_load_file(ctx, &buf_len, filename);
-    JS_FreeCString(ctx, filename);
-    if (!buf)
-        return JS_NULL;
-    ret = JS_NewStringLen(ctx, (char *)buf, buf_len);
-    js_free(ctx, buf);
-    return ret;
-}
-
 typedef JSModuleDef *(JSInitModuleFunc)(JSContext *ctx,
                                         const char *module_name);
 
@@ -623,97 +546,6 @@ static JSValue js_std_getenv(JSContext *ctx, JSValueConst this_val,
         return JS_NewString(ctx, str);
 }
 
-#if defined(_WIN32)
-static void setenv(const char *name, const char *value, int overwrite)
-{
-    char *str;
-    size_t name_len, value_len;
-    name_len = strlen(name);
-    value_len = strlen(value);
-    str = malloc(name_len + 1 + value_len + 1);
-    memcpy(str, name, name_len);
-    str[name_len] = '=';
-    memcpy(str + name_len + 1, value, value_len);
-    str[name_len + 1 + value_len] = '\0';
-    _putenv(str);
-    free(str);
-}
-
-static void unsetenv(const char *name)
-{
-    setenv(name, "", TRUE);
-}
-#endif /* _WIN32 */
-
-static JSValue js_std_setenv(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    const char *name, *value;
-    name = JS_ToCString(ctx, argv[0]);
-    if (!name)
-        return JS_EXCEPTION;
-    value = JS_ToCString(ctx, argv[1]);
-    if (!value) {
-        JS_FreeCString(ctx, name);
-        return JS_EXCEPTION;
-    }
-    setenv(name, value, TRUE);
-    JS_FreeCString(ctx, name);
-    JS_FreeCString(ctx, value);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_unsetenv(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    const char *name;
-    name = JS_ToCString(ctx, argv[0]);
-    if (!name)
-        return JS_EXCEPTION;
-    unsetenv(name);
-    JS_FreeCString(ctx, name);
-    return JS_UNDEFINED;
-}
-
-/* return an object containing the list of the available environment
-   variables. */
-static JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    char **envp;
-    const char *name, *p, *value;
-    JSValue obj;
-    uint32_t idx;
-    size_t name_len;
-    JSAtom atom;
-    int ret;
-
-    obj = JS_NewObject(ctx);
-    if (JS_IsException(obj))
-        return JS_EXCEPTION;
-    envp = environ;
-    for(idx = 0; envp[idx] != NULL; idx++) {
-        name = envp[idx];
-        p = strchr(name, '=');
-        name_len = p - name;
-        if (!p)
-            continue;
-        value = p + 1;
-        atom = JS_NewAtomLen(ctx, name, name_len);
-        if (atom == JS_ATOM_NULL)
-            goto fail;
-        ret = JS_DefinePropertyValue(ctx, obj, atom, JS_NewString(ctx, value),
-                                     JS_PROP_C_W_E);
-        JS_FreeAtom(ctx, atom);
-        if (ret < 0)
-            goto fail;
-    }
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
 static JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
 {
@@ -726,53 +558,22 @@ static int interrupt_handler(JSRuntime *rt, void *opaque)
     return (os_pending_signals >> SIGINT) & 1;
 }
 
-static int get_bool_option(JSContext *ctx, BOOL *pbool,
-                           JSValueConst obj,
-                           const char *option)
-{
-    JSValue val;
-    val = JS_GetPropertyStr(ctx, obj, option);
-    if (JS_IsException(val))
-        return -1;
-    if (!JS_IsUndefined(val)) {
-        *pbool = JS_ToBool(ctx, val);
-    }
-    JS_FreeValue(ctx, val);
-    return 0;
-}
-
 static JSValue js_evalScript(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     const char *str;
     size_t len;
     JSValue ret;
-    JSValueConst options_obj;
-    BOOL backtrace_barrier = FALSE;
-    int flags;
-    
-    if (argc >= 2) {
-        options_obj = argv[1];
-        if (get_bool_option(ctx, &backtrace_barrier, options_obj,
-                            "backtrace_barrier"))
-            return JS_EXCEPTION;
-    }
-
     str = JS_ToCStringLen(ctx, &len, argv[0]);
     if (!str)
         return JS_EXCEPTION;
-    if (!ts->recv_pipe && ++ts->eval_script_recurse == 1) {
+    if (++eval_script_recurse == 1) {
         /* install the interrupt handler */
         JS_SetInterruptHandler(JS_GetRuntime(ctx), interrupt_handler, NULL);
     }
-    flags = JS_EVAL_TYPE_GLOBAL; 
-    if (backtrace_barrier)
-        flags |= JS_EVAL_FLAG_BACKTRACE_BARRIER;
-    ret = JS_Eval(ctx, str, len, "<evalScript>", flags);
+    ret = JS_Eval(ctx, str, len, "<evalScript>", JS_EVAL_TYPE_GLOBAL);
     JS_FreeCString(ctx, str);
-    if (!ts->recv_pipe && --ts->eval_script_recurse == 0) {
+    if (--eval_script_recurse == 0) {
         /* remove the interrupt handler */
         JS_SetInterruptHandler(JS_GetRuntime(ctx), NULL, NULL);
         os_pending_signals &= ~((uint64_t)1 << SIGINT);
@@ -789,7 +590,9 @@ static JSClassID js_std_file_class_id;
 typedef struct {
     FILE *f;
     BOOL close_in_finalizer;
+#ifndef _MSC_VER
     BOOL is_popen;
+#endif
 } JSSTDFile;
 
 static void js_std_file_finalizer(JSRuntime *rt, JSValue val)
@@ -797,23 +600,41 @@ static void js_std_file_finalizer(JSRuntime *rt, JSValue val)
     JSSTDFile *s = JS_GetOpaque(val, js_std_file_class_id);
     if (s) {
         if (s->f && s->close_in_finalizer) {
+#ifndef _MSC_VER
             if (s->is_popen)
                 pclose(s->f);
             else
+#endif
                 fclose(s->f);
         }
         js_free_rt(rt, s);
     }
 }
 
-static ssize_t js_get_errno(ssize_t ret)
+static JSValue js_new_std_error(JSContext *ctx, int err)
 {
-    if (ret == -1)
-        ret = -errno;
-    return ret;
+    JSValue obj;
+    /* XXX: could add a specific Error prototype */
+    obj = JS_NewError(ctx);
+    JS_DefinePropertyValueStr(ctx, obj, "message",
+                              JS_NewString(ctx, strerror(err)),
+                              JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
+    JS_DefinePropertyValueStr(ctx, obj, "errno",
+                              JS_NewInt32(ctx, err),
+                              JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
+    return obj;
+}
+
+static JSValue js_std_error_constructor(JSContext *ctx, JSValueConst new_target,
+                                        int argc, JSValueConst *argv)
+{
+    int err;
+    if (JS_ToInt32(ctx, &err, argv[0]))
+        return JS_EXCEPTION;
+    return js_new_std_error(ctx, err);
 }
 
-static JSValue js_std_strerror(JSContext *ctx, JSValueConst this_val,
+static JSValue js_std_error_strerror(JSContext *ctx, JSValueConst this_val,
                                      int argc, JSValueConst *argv)
 {
     int err;
@@ -822,19 +643,13 @@ static JSValue js_std_strerror(JSContext *ctx, JSValueConst this_val,
     return JS_NewString(ctx, strerror(err));
 }
 
-static JSValue js_std_parseExtJSON(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
+static JSValue js_std_throw_errno(JSContext *ctx, int err)
 {
     JSValue obj;
-    const char *str;
-    size_t len;
-
-    str = JS_ToCStringLen(ctx, &len, argv[0]);
-    if (!str)
-        return JS_EXCEPTION;
-    obj = JS_ParseJSON2(ctx, str, len, "<input>", JS_PARSE_JSON_EXT);
-    JS_FreeCString(ctx, str);
-    return obj;
+    obj = js_new_std_error(ctx, err);
+    if (JS_IsException(obj))
+        obj = JS_NULL;
+    return JS_Throw(ctx, obj);
 }
 
 static JSValue js_new_std_file(JSContext *ctx, FILE *f,
@@ -852,26 +667,20 @@ static JSValue js_new_std_file(JSContext *ctx, FILE *f,
         return JS_EXCEPTION;
     }
     s->close_in_finalizer = close_in_finalizer;
+#ifndef _MSC_VER
     s->is_popen = is_popen;
+#endif
     s->f = f;
     JS_SetOpaque(obj, s);
     return obj;
 }
 
-static void js_set_error_object(JSContext *ctx, JSValue obj, int err)
-{
-    if (!JS_IsUndefined(obj)) {
-        JS_SetPropertyStr(ctx, obj, "errno", JS_NewInt32(ctx, err));
-    }
-}
-
 static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
 {
     const char *filename, *mode = NULL;
     FILE *f;
-    int err;
-    
+
     filename = JS_ToCString(ctx, argv[0]);
     if (!filename)
         goto fail;
@@ -879,21 +688,15 @@ static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
     if (!mode)
         goto fail;
     if (mode[strspn(mode, "rwa+b")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
+        js_std_throw_errno(ctx, EINVAL);
         goto fail;
     }
 
     f = fopen(filename, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
     JS_FreeCString(ctx, filename);
     JS_FreeCString(ctx, mode);
     if (!f)
-        return JS_NULL;
+        return js_std_throw_errno(ctx, errno);
     return js_new_std_file(ctx, f, TRUE, FALSE);
  fail:
     JS_FreeCString(ctx, filename);
@@ -901,13 +704,13 @@ static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
     return JS_EXCEPTION;
 }
 
+#ifndef _MSC_VER
 static JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
 {
     const char *filename, *mode = NULL;
     FILE *f;
-    int err;
-    
+
     filename = JS_ToCString(ctx, argv[0]);
     if (!filename)
         goto fail;
@@ -915,34 +718,29 @@ static JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,
     if (!mode)
         goto fail;
     if (mode[strspn(mode, "rw")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
+        js_std_throw_errno(ctx, EINVAL);
         goto fail;
     }
 
     f = popen(filename, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
     JS_FreeCString(ctx, filename);
     JS_FreeCString(ctx, mode);
     if (!f)
-        return JS_NULL;
+        return js_std_throw_errno(ctx, errno);
     return js_new_std_file(ctx, f, TRUE, TRUE);
  fail:
     JS_FreeCString(ctx, filename);
     JS_FreeCString(ctx, mode);
     return JS_EXCEPTION;
 }
+#endif
 
 static JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
 {
     const char *mode;
     FILE *f;
-    int fd, err;
+    int fd;
 
     if (JS_ToInt32(ctx, &fd, argv[0]))
         return JS_EXCEPTION;
@@ -950,20 +748,14 @@ static JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,
     if (!mode)
         goto fail;
     if (mode[strspn(mode, "rwa+")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
+        js_std_throw_errno(ctx, EINVAL);
         goto fail;
     }
 
     f = fdopen(fd, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
     JS_FreeCString(ctx, mode);
     if (!f)
-        return JS_NULL;
+        return js_std_throw_errno(ctx, errno);
     return js_new_std_file(ctx, f, TRUE, FALSE);
  fail:
     JS_FreeCString(ctx, mode);
@@ -975,10 +767,8 @@ static JSValue js_std_tmpfile(JSContext *ctx, JSValueConst this_val,
 {
     FILE *f;
     f = tmpfile();
-    if (argc >= 1)
-        js_set_error_object(ctx, argv[0], f ? 0 : errno);
     if (!f)
-        return JS_NULL;
+        return js_std_throw_errno(ctx, errno);
     return js_new_std_file(ctx, f, TRUE, FALSE);
 }
 
@@ -1000,7 +790,7 @@ static FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)
     if (!s)
         return NULL;
     if (!s->f) {
-        JS_ThrowTypeError(ctx, "invalid file handle");
+        js_std_throw_errno(ctx, EBADF);
         return NULL;
     }
     return s->f;
@@ -1012,7 +802,6 @@ static JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,
     FILE *f;
     int i;
     const char *str;
-    size_t len;
 
     if (magic == 0) {
         f = stdout;
@@ -1023,10 +812,10 @@ static JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,
     }
     
     for(i = 0; i < argc; i++) {
-        str = JS_ToCStringLen(ctx, &len, argv[i]);
+        str = JS_ToCString(ctx, argv[i]);
         if (!str)
             return JS_EXCEPTION;
-        fwrite(str, 1, len, f);
+        fputs(str, f);
         JS_FreeCString(ctx, str);
     }
     return JS_UNDEFINED;
@@ -1036,17 +825,19 @@ static JSValue js_std_file_close(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv)
 {
     JSSTDFile *s = JS_GetOpaque2(ctx, this_val, js_std_file_class_id);
-    int err;
     if (!s)
         return JS_EXCEPTION;
     if (!s->f)
-        return JS_ThrowTypeError(ctx, "invalid file handle");
+        return js_std_throw_errno(ctx, EBADF);
+    /* XXX: could return exit code */
+#ifndef _MSC_VER
     if (s->is_popen)
-        err = js_get_errno(pclose(s->f));
+        pclose(s->f);
     else
-        err = js_get_errno(fclose(s->f));
+#endif
+        fclose(s->f);
     s->f = NULL;
-    return JS_NewInt32(ctx, err);
+    return JS_UNDEFINED;
 }
 
 static JSValue js_std_file_printf(JSContext *ctx, JSValueConst this_val,
@@ -1069,7 +860,7 @@ static JSValue js_std_file_flush(JSContext *ctx, JSValueConst this_val,
 }
 
 static JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int is_bigint)
+                                int argc, JSValueConst *argv)
 {
     FILE *f = js_std_file_get(ctx, this_val);
     int64_t pos;
@@ -1080,10 +871,7 @@ static JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,
 #else
     pos = ftell(f);
 #endif
-    if (is_bigint)
-        return JS_NewBigInt64(ctx, pos);
-    else
-        return JS_NewInt64(ctx, pos);
+    return JS_NewInt64(ctx, pos);
 }
 
 static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
@@ -1094,7 +882,7 @@ static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
     int whence, ret;
     if (!f)
         return JS_EXCEPTION;
-    if (JS_ToInt64Ext(ctx, &pos, argv[0]))
+    if (JS_ToInt64(ctx, &pos, argv[0]))
         return JS_EXCEPTION;
     if (JS_ToInt32(ctx, &whence, argv[1]))
         return JS_EXCEPTION;
@@ -1104,8 +892,8 @@ static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
     ret = fseek(f, pos, whence);
 #endif
     if (ret < 0)
-        ret = -errno;
-    return JS_NewInt32(ctx, ret);
+        return js_std_throw_errno(ctx, EBADF);
+    return JS_UNDEFINED;
 }
 
 static JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,
@@ -1117,25 +905,6 @@ static JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,
     return JS_NewBool(ctx, feof(f));
 }
 
-static JSValue js_std_file_error(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, ferror(f));
-}
-
-static JSValue js_std_file_clearerr(JSContext *ctx, JSValueConst this_val,
-                                    int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    clearerr(f);
-    return JS_UNDEFINED;
-}
-
 static JSValue js_std_file_fileno(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
 {
@@ -1311,10 +1080,26 @@ static int http_get_status(const char *buf)
     return atoi(p);
 }
 
-static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
+static int get_bool_option(JSContext *ctx, BOOL *pbool,
+                           JSValueConst obj,
+                           const char *option)
 {
-    const char *url;
+    JSValue val;
+    val = JS_GetPropertyStr(ctx, obj, option);
+    if (JS_IsException(val))
+        return -1;
+    if (!JS_IsUndefined(val)) {
+        *pbool = JS_ToBool(ctx, val);
+    }
+    JS_FreeValue(ctx, val);
+    return 0;
+}
+
+#ifndef _MSC_VER
+static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
+                             int argc, JSValueConst *argv)
+{
+    const char *url;
     DynBuf cmd_buf;
     DynBuf data_buf_s, *data_buf = &data_buf_s;
     DynBuf header_buf_s, *header_buf = &header_buf_s;
@@ -1366,7 +1151,7 @@ static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
     f = popen((char *)cmd_buf.buf, "r");
     dbuf_free(&cmd_buf);
     if (!f) {
-        return JS_ThrowTypeError(ctx, "could not start curl");
+        return js_std_throw_errno(ctx, errno);
     }
 
     js_std_dbuf_init(ctx, data_buf);
@@ -1377,21 +1162,20 @@ static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
         goto fail;
 
     /* get the HTTP status */
-    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0) {
-        status = 0;
+    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0)
         goto bad_header;
-    }
     status = http_get_status(buf);
     if (!full_flag && !(status >= 200 && status <= 299)) {
-        goto bad_header;
+        js_std_throw_errno(ctx, ENOENT);
+        goto fail;
     }
     
     /* wait until there is an empty line */
     for(;;) {
         if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, header_buf) < 0) {
         bad_header:
-            response = JS_NULL;
-            goto done;
+            js_std_throw_errno(ctx, EINVAL);
+            goto fail;
         }
         if (!strcmp(buf, "\r\n"))
             break;
@@ -1407,6 +1191,11 @@ static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
             break;
         dbuf_put(data_buf, (uint8_t *)buf, len);
     }
+    js_free(ctx, buf);
+    buf = NULL;
+    pclose(f);
+    f = NULL;
+
     if (dbuf_error(data_buf))
         goto fail;
     if (binary_flag) {
@@ -1415,15 +1204,10 @@ static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
     } else {
         response = JS_NewStringLen(ctx, (char *)data_buf->buf, data_buf->size);
     }
-    if (JS_IsException(response))
-        goto fail;
- done:
-    js_free(ctx, buf);
-    buf = NULL;
-    pclose(f);
-    f = NULL;
     dbuf_free(data_buf);
     data_buf = NULL;
+    if (JS_IsException(response))
+        goto fail;
 
     if (full_flag) {
         ret_obj = JS_NewObject(ctx);
@@ -1432,15 +1216,13 @@ static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
         JS_DefinePropertyValueStr(ctx, ret_obj, "response",
                                   response,
                                   JS_PROP_C_W_E);
-        if (!JS_IsNull(response)) {
-            JS_DefinePropertyValueStr(ctx, ret_obj, "responseHeaders",
-                                      JS_NewStringLen(ctx, (char *)header_buf->buf,
-                                                      header_buf->size),
-                                      JS_PROP_C_W_E);
-            JS_DefinePropertyValueStr(ctx, ret_obj, "status",
-                                      JS_NewInt32(ctx, status),
-                                      JS_PROP_C_W_E);
-        }
+        JS_DefinePropertyValueStr(ctx, ret_obj, "responseHeaders",
+                                  JS_NewStringLen(ctx, (char *)header_buf->buf,
+                                                  header_buf->size),
+                                  JS_PROP_C_W_E);
+        JS_DefinePropertyValueStr(ctx, ret_obj, "status",
+                                  JS_NewInt32(ctx, status),
+                                  JS_PROP_C_W_E);
     } else {
         ret_obj = response;
     }
@@ -1457,46 +1239,28 @@ static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
     JS_FreeValue(ctx, response);
     return JS_EXCEPTION;
 }
+#endif
 
 static JSClassDef js_std_file_class = {
     "FILE",
     .finalizer = js_std_file_finalizer,
 }; 
 
-static const JSCFunctionListEntry js_std_error_props[] = {
-    /* various errno values */
-#define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
-    DEF(EINVAL),
-    DEF(EIO),
-    DEF(EACCES),
-    DEF(EEXIST),
-    DEF(ENOSPC),
-    DEF(ENOSYS),
-    DEF(EBUSY),
-    DEF(ENOENT),
-    DEF(EPERM),
-    DEF(EPIPE),
-    DEF(EBADF),
-#undef DEF
-};
-
 static const JSCFunctionListEntry js_std_funcs[] = {
     JS_CFUNC_DEF("exit", 1, js_std_exit ),
     JS_CFUNC_DEF("gc", 0, js_std_gc ),
     JS_CFUNC_DEF("evalScript", 1, js_evalScript ),
     JS_CFUNC_DEF("loadScript", 1, js_loadScript ),
     JS_CFUNC_DEF("getenv", 1, js_std_getenv ),
-    JS_CFUNC_DEF("setenv", 1, js_std_setenv ),
-    JS_CFUNC_DEF("unsetenv", 1, js_std_unsetenv ),
-    JS_CFUNC_DEF("getenviron", 1, js_std_getenviron ),
+#ifndef _MSC_VER
     JS_CFUNC_DEF("urlGet", 1, js_std_urlGet ),
-    JS_CFUNC_DEF("loadFile", 1, js_std_loadFile ),
-    JS_CFUNC_DEF("strerror", 1, js_std_strerror ),
-    JS_CFUNC_DEF("parseExtJSON", 1, js_std_parseExtJSON ),
-    
+#endif
+
     /* FILE I/O */
     JS_CFUNC_DEF("open", 2, js_std_open ),
+#ifndef _MSC_VER
     JS_CFUNC_DEF("popen", 2, js_std_popen ),
+#endif
     JS_CFUNC_DEF("fdopen", 2, js_std_fdopen ),
     JS_CFUNC_DEF("tmpfile", 0, js_std_tmpfile ),
     JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 0 ),
@@ -1505,33 +1269,49 @@ static const JSCFunctionListEntry js_std_funcs[] = {
     JS_PROP_INT32_DEF("SEEK_SET", SEEK_SET, JS_PROP_CONFIGURABLE ),
     JS_PROP_INT32_DEF("SEEK_CUR", SEEK_CUR, JS_PROP_CONFIGURABLE ),
     JS_PROP_INT32_DEF("SEEK_END", SEEK_END, JS_PROP_CONFIGURABLE ),
-    JS_OBJECT_DEF("Error", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),
+
+    /* setenv, ... */
 };
-    
+
+static const JSCFunctionListEntry js_std_error_funcs[] = {
+    JS_CFUNC_DEF("strerror", 1, js_std_error_strerror ),
+    /* various errno values */
+#define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
+    DEF(EINVAL),
+    DEF(EIO),
+    DEF(EACCES),
+    DEF(EEXIST),
+    DEF(ENOSPC),
+    DEF(ENOSYS),
+    DEF(EBUSY),
+    DEF(ENOENT),
+    DEF(EPERM),
+    DEF(EPIPE),
+    DEF(EBADF),
+#undef DEF
+};
+
 static const JSCFunctionListEntry js_std_file_proto_funcs[] = {
     JS_CFUNC_DEF("close", 0, js_std_file_close ),
     JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 1 ),
     JS_CFUNC_DEF("printf", 1, js_std_file_printf ),
     JS_CFUNC_DEF("flush", 0, js_std_file_flush ),
-    JS_CFUNC_MAGIC_DEF("tell", 0, js_std_file_tell, 0 ),
-    JS_CFUNC_MAGIC_DEF("tello", 0, js_std_file_tell, 1 ),
+    JS_CFUNC_DEF("tell", 0, js_std_file_tell ),
     JS_CFUNC_DEF("seek", 2, js_std_file_seek ),
     JS_CFUNC_DEF("eof", 0, js_std_file_eof ),
     JS_CFUNC_DEF("fileno", 0, js_std_file_fileno ),
-    JS_CFUNC_DEF("error", 0, js_std_file_error ),
-    JS_CFUNC_DEF("clearerr", 0, js_std_file_clearerr ),
     JS_CFUNC_MAGIC_DEF("read", 3, js_std_file_read_write, 0 ),
     JS_CFUNC_MAGIC_DEF("write", 3, js_std_file_read_write, 1 ),
     JS_CFUNC_DEF("getline", 0, js_std_file_getline ),
     JS_CFUNC_DEF("readAsString", 0, js_std_file_readAsString ),
     JS_CFUNC_DEF("getByte", 0, js_std_file_getByte ),
     JS_CFUNC_DEF("putByte", 1, js_std_file_putByte ),
-    /* setvbuf, ...  */
+    /* setvbuf, ferror, clearerr, ...  */
 };
 
 static int js_std_init(JSContext *ctx, JSModuleDef *m)
 {
-    JSValue proto;
+    JSValue proto, obj;
     
     /* FILE class */
     /* the class ID is created once */
@@ -1548,6 +1328,13 @@ static int js_std_init(JSContext *ctx, JSModuleDef *m)
     JS_SetModuleExport(ctx, m, "in", js_new_std_file(ctx, stdin, FALSE, FALSE));
     JS_SetModuleExport(ctx, m, "out", js_new_std_file(ctx, stdout, FALSE, FALSE));
     JS_SetModuleExport(ctx, m, "err", js_new_std_file(ctx, stderr, FALSE, FALSE));
+    
+    obj = JS_NewCFunction2(ctx, js_std_error_constructor,
+                           "Error", 1, JS_CFUNC_constructor, 0);
+    JS_SetPropertyFunctionList(ctx, obj, js_std_error_funcs,
+                               countof(js_std_error_funcs));
+    JS_SetModuleExport(ctx, m, "Error", obj);
+
     return 0;
 }
 
@@ -1561,12 +1348,20 @@ JSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name)
     JS_AddModuleExport(ctx, m, "in");
     JS_AddModuleExport(ctx, m, "out");
     JS_AddModuleExport(ctx, m, "err");
+    JS_AddModuleExport(ctx, m, "Error");
     return m;
 }
 
 /**********************************************************/
 /* 'os' object */
 
+static JSValue js_os_return(JSContext *ctx, ssize_t ret)
+{
+    if (ret < 0)
+        ret = -errno;
+    return JS_NewInt64(ctx, ret);
+}
+
 static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
 {
@@ -1592,9 +1387,9 @@ static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
     if (!(flags & O_TEXT))
         flags |= O_BINARY;
 #endif
-    ret = js_get_errno(open(filename, flags, mode));
+    ret = open(filename, flags, mode);
     JS_FreeCString(ctx, filename);
-    return JS_NewInt32(ctx, ret);
+    return js_os_return(ctx, ret);
 }
 
 static JSValue js_os_close(JSContext *ctx, JSValueConst this_val,
@@ -1603,31 +1398,24 @@ static JSValue js_os_close(JSContext *ctx, JSValueConst this_val,
     int fd, ret;
     if (JS_ToInt32(ctx, &fd, argv[0]))
         return JS_EXCEPTION;
-    ret = js_get_errno(close(fd));
-    return JS_NewInt32(ctx, ret);
+    ret = close(fd);
+    return js_os_return(ctx, ret);
 }
 
 static JSValue js_os_seek(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
 {
-    int fd, whence;
-    int64_t pos, ret;
-    BOOL is_bigint;
+    int fd, whence, ret;
+    int64_t pos;
     
     if (JS_ToInt32(ctx, &fd, argv[0]))
         return JS_EXCEPTION;
-    is_bigint = JS_IsBigInt(ctx, argv[1]);
-    if (JS_ToInt64Ext(ctx, &pos, argv[1]))
+    if (JS_ToInt64(ctx, &pos, argv[1]))
         return JS_EXCEPTION;
     if (JS_ToInt32(ctx, &whence, argv[2]))
         return JS_EXCEPTION;
     ret = lseek(fd, pos, whence);
-    if (ret == -1)
-        ret = -errno;
-    if (is_bigint)
-        return JS_NewBigInt64(ctx, ret);
-    else
-        return JS_NewInt64(ctx, ret);
+    return js_os_return(ctx, ret);
 }
 
 static JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,
@@ -1651,10 +1439,10 @@ static JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,
     if (pos + len > size)
         return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
     if (magic)
-        ret = js_get_errno(write(fd, buf + pos, len));
+        ret = write(fd, buf + pos, len);
     else
-        ret = js_get_errno(read(fd, buf + pos, len));
-    return JS_NewInt64(ctx, ret);
+        ret = read(fd, buf + pos, len);
+    return js_os_return(ctx, ret);
 }
 
 static JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,
@@ -1663,7 +1451,7 @@ static JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,
     int fd;
     if (JS_ToInt32(ctx, &fd, argv[0]))
         return JS_EXCEPTION;
-    return JS_NewBool(ctx, (isatty(fd) != 0));
+    return JS_NewBool(ctx, isatty(fd) == 1);
 }
 
 #if defined(_WIN32)
@@ -1689,10 +1477,6 @@ static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
     return obj;
 }
 
-/* Windows 10 built-in VT100 emulation */
-#define __ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
-#define __ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200
-
 static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
 {
@@ -1702,12 +1486,8 @@ static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
     if (JS_ToInt32(ctx, &fd, argv[0]))
         return JS_EXCEPTION;
     handle = (HANDLE)_get_osfhandle(fd);
-    SetConsoleMode(handle, ENABLE_WINDOW_INPUT | __ENABLE_VIRTUAL_TERMINAL_INPUT);
-    _setmode(fd, _O_BINARY);
-    if (fd == 0) {
-        handle = (HANDLE)_get_osfhandle(1); /* corresponding output */
-        SetConsoleMode(handle, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | __ENABLE_VIRTUAL_TERMINAL_PROCESSING);
-    }
+    
+    SetConsoleMode(handle, ENABLE_WINDOW_INPUT);
     return JS_UNDEFINED;
 }
 #else
@@ -1780,21 +1560,9 @@ static JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,
     filename = JS_ToCString(ctx, argv[0]);
     if (!filename)
         return JS_EXCEPTION;
-#if defined(_WIN32)
-    {
-        struct stat st;
-        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
-            ret = rmdir(filename);
-        } else {
-            ret = unlink(filename);
-        }
-    }
-#else
     ret = remove(filename);
-#endif
-    ret = js_get_errno(ret);
     JS_FreeCString(ctx, filename);
-    return JS_NewInt32(ctx, ret);
+    return js_os_return(ctx, ret);
 }
 
 static JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,
@@ -1811,24 +1579,17 @@ static JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,
         JS_FreeCString(ctx, oldpath);
         return JS_EXCEPTION;
     }
-    ret = js_get_errno(rename(oldpath, newpath));
+    ret = rename(oldpath, newpath);
     JS_FreeCString(ctx, oldpath);
     JS_FreeCString(ctx, newpath);
-    return JS_NewInt32(ctx, ret);
-}
-
-static BOOL is_main_thread(JSRuntime *rt)
-{
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-    return !ts->recv_pipe;
+    return js_os_return(ctx, ret);
 }
 
-static JSOSRWHandler *find_rh(JSThreadState *ts, int fd)
+static JSOSRWHandler *find_rh(int fd)
 {
     JSOSRWHandler *rh;
     struct list_head *el;
-
-    list_for_each(el, &ts->os_rw_handlers) {
+    list_for_each(el, &os_rw_handlers) {
         rh = list_entry(el, JSOSRWHandler, link);
         if (rh->fd == fd)
             return rh;
@@ -1849,8 +1610,6 @@ static void free_rw_handler(JSRuntime *rt, JSOSRWHandler *rh)
 static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
                                     int argc, JSValueConst *argv, int magic)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     JSOSRWHandler *rh;
     int fd;
     JSValueConst func;
@@ -1859,7 +1618,7 @@ static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
         return JS_EXCEPTION;
     func = argv[1];
     if (JS_IsNull(func)) {
-        rh = find_rh(ts, fd);
+        rh = find_rh(fd);
         if (rh) {
             JS_FreeValue(ctx, rh->rw_func[magic]);
             rh->rw_func[magic] = JS_NULL;
@@ -1872,7 +1631,7 @@ static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
     } else {
         if (!JS_IsFunction(ctx, func))
             return JS_ThrowTypeError(ctx, "not a function");
-        rh = find_rh(ts, fd);
+        rh = find_rh(fd);
         if (!rh) {
             rh = js_mallocz(ctx, sizeof(*rh));
             if (!rh)
@@ -1880,7 +1639,7 @@ static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
             rh->fd = fd;
             rh->rw_func[0] = JS_NULL;
             rh->rw_func[1] = JS_NULL;
-            list_add_tail(&rh->link, &ts->os_rw_handlers);
+            list_add_tail(&rh->link, &os_rw_handlers);
         }
         JS_FreeValue(ctx, rh->rw_func[magic]);
         rh->rw_func[magic] = JS_DupValue(ctx, func);
@@ -1888,11 +1647,11 @@ static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
     return JS_UNDEFINED;
 }
 
-static JSOSSignalHandler *find_sh(JSThreadState *ts, int sig_num)
+static JSOSSignalHandler *find_sh(int sig_num)
 {
     JSOSSignalHandler *sh;
     struct list_head *el;
-    list_for_each(el, &ts->os_signal_handlers) {
+    list_for_each(el, &os_signal_handlers) {
         sh = list_entry(el, JSOSSignalHandler, link);
         if (sh->sig_num == sig_num)
             return sh;
@@ -1919,15 +1678,10 @@ typedef void (*sighandler_t)(int sig_num);
 static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     JSOSSignalHandler *sh;
     uint32_t sig_num;
     JSValueConst func;
     sighandler_t handler;
-
-    if (!is_main_thread(rt))
-        return JS_ThrowTypeError(ctx, "signal handler can only be set in the main thread");
     
     if (JS_ToUint32(ctx, &sig_num, argv[0]))
         return JS_EXCEPTION;
@@ -1936,7 +1690,7 @@ static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
     func = argv[1];
     /* func = null: SIG_DFL, func = undefined, SIG_IGN */
     if (JS_IsNull(func) || JS_IsUndefined(func)) {
-        sh = find_sh(ts, sig_num);
+        sh = find_sh(sig_num);
         if (sh) {
             free_sh(JS_GetRuntime(ctx), sh);
         }
@@ -1948,13 +1702,13 @@ static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
     } else {
         if (!JS_IsFunction(ctx, func))
             return JS_ThrowTypeError(ctx, "not a function");
-        sh = find_sh(ts, sig_num);
+        sh = find_sh(sig_num);
         if (!sh) {
             sh = js_mallocz(ctx, sizeof(*sh));
             if (!sh)
                 return JS_EXCEPTION;
             sh->sig_num = sig_num;
-            list_add_tail(&sh->link, &ts->os_signal_handlers);
+            list_add_tail(&sh->link, &os_signal_handlers);
         }
         JS_FreeValue(ctx, sh->func);
         sh->func = JS_DupValue(ctx, func);
@@ -1970,6 +1724,11 @@ static int64_t get_time_ms(void)
     clock_gettime(CLOCK_MONOTONIC, &ts);
     return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
 }
+#elif defined(_MSC_VER)
+static int64_t get_time_ms(void)
+{
+	return GetTickCount();
+}
 #else
 /* more portable, but does not work if the date is updated */
 static int64_t get_time_ms(void)
@@ -2018,8 +1777,6 @@ static void js_os_timer_mark(JSRuntime *rt, JSValueConst val,
 static JSValue js_os_setTimeout(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     int64_t delay;
     JSValueConst func;
     JSOSTimer *th;
@@ -2041,7 +1798,7 @@ static JSValue js_os_setTimeout(JSContext *ctx, JSValueConst this_val,
     th->has_object = TRUE;
     th->timeout = get_time_ms() + delay;
     th->func = JS_DupValue(ctx, func);
-    list_add_tail(&th->link, &ts->os_timers);
+    list_add_tail(&th->link, &os_timers);
     JS_SetOpaque(obj, th);
     return obj;
 }
@@ -2079,8 +1836,6 @@ static void call_handler(JSContext *ctx, JSValueConst func)
 
 static int js_os_poll(JSContext *ctx)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     int min_delay, console_fd;
     int64_t cur_time, delay;
     JSOSRWHandler *rh;
@@ -2088,14 +1843,14 @@ static int js_os_poll(JSContext *ctx)
     
     /* XXX: handle signals if useful */
 
-    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers))
+    if (list_empty(&os_rw_handlers) && list_empty(&os_timers))
         return -1; /* no more events */
     
     /* XXX: only timers and basic console input are supported */
-    if (!list_empty(&ts->os_timers)) {
+    if (!list_empty(&os_timers)) {
         cur_time = get_time_ms();
         min_delay = 10000;
-        list_for_each(el, &ts->os_timers) {
+        list_for_each(el, &os_timers) {
             JSOSTimer *th = list_entry(el, JSOSTimer, link);
             delay = th->timeout - cur_time;
             if (delay <= 0) {
@@ -2103,9 +1858,9 @@ static int js_os_poll(JSContext *ctx)
                 /* the timer expired */
                 func = th->func;
                 th->func = JS_UNDEFINED;
-                unlink_timer(rt, th);
+                unlink_timer(JS_GetRuntime(ctx), th);
                 if (!th->has_object)
-                    free_timer(rt, th);
+                    free_timer(JS_GetRuntime(ctx), th);
                 call_handler(ctx, func);
                 JS_FreeValue(ctx, func);
                 return 0;
@@ -2118,7 +1873,7 @@ static int js_os_poll(JSContext *ctx)
     }
 
     console_fd = -1;
-    list_for_each(el, &ts->os_rw_handlers) {
+    list_for_each(el, &os_rw_handlers) {
         rh = list_entry(el, JSOSRWHandler, link);
         if (rh->fd == 0 && !JS_IsNull(rh->rw_func[0])) {
             console_fd = rh->fd;
@@ -2136,7 +1891,7 @@ static int js_os_poll(JSContext *ctx)
         handle = (HANDLE)_get_osfhandle(console_fd);
         ret = WaitForSingleObject(handle, ti);
         if (ret == WAIT_OBJECT_0) {
-            list_for_each(el, &ts->os_rw_handlers) {
+            list_for_each(el, &os_rw_handlers) {
                 rh = list_entry(el, JSOSRWHandler, link);
                 if (rh->fd == console_fd && !JS_IsNull(rh->rw_func[0])) {
                     call_handler(ctx, rh->rw_func[0]);
@@ -2151,88 +1906,8 @@ static int js_os_poll(JSContext *ctx)
     return 0;
 }
 #else
-
-#ifdef USE_WORKER
-
-static void js_free_message(JSWorkerMessage *msg);
-
-/* return 1 if a message was handled, 0 if no message */
-static int handle_posted_message(JSRuntime *rt, JSContext *ctx,
-                                 JSWorkerMessageHandler *port)
-{
-    JSWorkerMessagePipe *ps = port->recv_pipe;
-    int ret;
-    struct list_head *el;
-    JSWorkerMessage *msg;
-    JSValue obj, data_obj, func, retval;
-    
-    pthread_mutex_lock(&ps->mutex);
-    if (!list_empty(&ps->msg_queue)) {
-        el = ps->msg_queue.next;
-        msg = list_entry(el, JSWorkerMessage, link);
-
-        /* remove the message from the queue */
-        list_del(&msg->link);
-
-        if (list_empty(&ps->msg_queue)) {
-            uint8_t buf[16];
-            int ret;
-            for(;;) {
-                ret = read(ps->read_fd, buf, sizeof(buf));
-                if (ret >= 0)
-                    break;
-                if (errno != EAGAIN && errno != EINTR)
-                    break;
-            }
-        }
-
-        pthread_mutex_unlock(&ps->mutex);
-
-        data_obj = JS_ReadObject(ctx, msg->data, msg->data_len,
-                                 JS_READ_OBJ_SAB | JS_READ_OBJ_REFERENCE);
-
-        js_free_message(msg);
-        
-        if (JS_IsException(data_obj))
-            goto fail;
-        obj = JS_NewObject(ctx);
-        if (JS_IsException(obj)) {
-            JS_FreeValue(ctx, data_obj);
-            goto fail;
-        }
-        JS_DefinePropertyValueStr(ctx, obj, "data", data_obj, JS_PROP_C_W_E);
-
-        /* 'func' might be destroyed when calling itself (if it frees the
-           handler), so must take extra care */
-        func = JS_DupValue(ctx, port->on_message_func);
-        retval = JS_Call(ctx, func, JS_UNDEFINED, 1, (JSValueConst *)&obj);
-        JS_FreeValue(ctx, obj);
-        JS_FreeValue(ctx, func);
-        if (JS_IsException(retval)) {
-        fail:
-            js_std_dump_error(ctx);
-        } else {
-            JS_FreeValue(ctx, retval);
-        }
-        ret = 1;
-    } else {
-        pthread_mutex_unlock(&ps->mutex);
-        ret = 0;
-    }
-    return ret;
-}
-#else
-static int handle_posted_message(JSRuntime *rt, JSContext *ctx,
-                                 JSWorkerMessageHandler *port)
-{
-    return 0;
-}
-#endif
-
 static int js_os_poll(JSContext *ctx)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     int ret, fd_max, min_delay;
     int64_t cur_time, delay;
     fd_set rfds, wfds;
@@ -2240,13 +1915,11 @@ static int js_os_poll(JSContext *ctx)
     struct list_head *el;
     struct timeval tv, *tvp;
 
-    /* only check signals in the main thread */
-    if (!ts->recv_pipe &&
-        unlikely(os_pending_signals != 0)) {
+    if (unlikely(os_pending_signals != 0)) {
         JSOSSignalHandler *sh;
         uint64_t mask;
         
-        list_for_each(el, &ts->os_signal_handlers) {
+        list_for_each(el, &os_signal_handlers) {
             sh = list_entry(el, JSOSSignalHandler, link);
             mask = (uint64_t)1 << sh->sig_num;
             if (os_pending_signals & mask) {
@@ -2256,15 +1929,14 @@ static int js_os_poll(JSContext *ctx)
             }
         }
     }
-
-    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers) &&
-        list_empty(&ts->port_list))
+    
+    if (list_empty(&os_rw_handlers) && list_empty(&os_timers))
         return -1; /* no more events */
     
-    if (!list_empty(&ts->os_timers)) {
+    if (!list_empty(&os_timers)) {
         cur_time = get_time_ms();
         min_delay = 10000;
-        list_for_each(el, &ts->os_timers) {
+        list_for_each(el, &os_timers) {
             JSOSTimer *th = list_entry(el, JSOSTimer, link);
             delay = th->timeout - cur_time;
             if (delay <= 0) {
@@ -2272,9 +1944,9 @@ static int js_os_poll(JSContext *ctx)
                 /* the timer expired */
                 func = th->func;
                 th->func = JS_UNDEFINED;
-                unlink_timer(rt, th);
+                unlink_timer(JS_GetRuntime(ctx), th);
                 if (!th->has_object)
-                    free_timer(rt, th);
+                    free_timer(JS_GetRuntime(ctx), th);
                 call_handler(ctx, func);
                 JS_FreeValue(ctx, func);
                 return 0;
@@ -2292,7 +1964,7 @@ static int js_os_poll(JSContext *ctx)
     FD_ZERO(&rfds);
     FD_ZERO(&wfds);
     fd_max = -1;
-    list_for_each(el, &ts->os_rw_handlers) {
+    list_for_each(el, &os_rw_handlers) {
         rh = list_entry(el, JSOSRWHandler, link);
         fd_max = max_int(fd_max, rh->fd);
         if (!JS_IsNull(rh->rw_func[0]))
@@ -2300,46 +1972,25 @@ static int js_os_poll(JSContext *ctx)
         if (!JS_IsNull(rh->rw_func[1]))
             FD_SET(rh->fd, &wfds);
     }
-
-    list_for_each(el, &ts->port_list) {
-        JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
-        if (!JS_IsNull(port->on_message_func)) {
-            JSWorkerMessagePipe *ps = port->recv_pipe;
-            fd_max = max_int(fd_max, ps->read_fd);
-            FD_SET(ps->read_fd, &rfds);
-        }
-    }
-
+    
     ret = select(fd_max + 1, &rfds, &wfds, NULL, tvp);
     if (ret > 0) {
-        list_for_each(el, &ts->os_rw_handlers) {
+        list_for_each(el, &os_rw_handlers) {
             rh = list_entry(el, JSOSRWHandler, link);
             if (!JS_IsNull(rh->rw_func[0]) &&
                 FD_ISSET(rh->fd, &rfds)) {
                 call_handler(ctx, rh->rw_func[0]);
                 /* must stop because the list may have been modified */
-                goto done;
+                break;
             }
-            if (!JS_IsNull(rh->rw_func[1]) &&
-                FD_ISSET(rh->fd, &wfds)) {
+            if (!JS_IsNull(rh->rw_func[1])) {
+                FD_SET(rh->fd, &wfds);
                 call_handler(ctx, rh->rw_func[1]);
                 /* must stop because the list may have been modified */
-                goto done;
-            }
-        }
-
-        list_for_each(el, &ts->port_list) {
-            JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
-            if (!JS_IsNull(port->on_message_func)) {
-                JSWorkerMessagePipe *ps = port->recv_pipe;
-                if (FD_ISSET(ps->read_fd, &rfds)) {
-                    if (handle_posted_message(rt, ctx, port))
-                        goto done;
-                }
+                break;
             }
         }
     }
-    done:
     return 0;
 }
 #endif /* !_WIN32 */
@@ -2377,25 +2028,35 @@ static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,
     
     if (!getcwd(buf, sizeof(buf))) {
         buf[0] = '\0';
-        err = errno;
+        err = -errno;
     } else {
         err = 0;
     }
     return make_string_error(ctx, buf, err);
 }
 
-static JSValue js_os_chdir(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
+#if !defined(_WIN32)
+
+/* return [path, errorcode] */
+static JSValue js_os_realpath(JSContext *ctx, JSValueConst this_val,
+                              int argc, JSValueConst *argv)
 {
-    const char *target;
+    const char *path;
+    char buf[PATH_MAX], *res;
     int err;
 
-    target = JS_ToCString(ctx, argv[0]);
-    if (!target)
+    path = JS_ToCString(ctx, argv[0]);
+    if (!path)
         return JS_EXCEPTION;
-    err = js_get_errno(chdir(target));
-    JS_FreeCString(ctx, target);
-    return JS_NewInt32(ctx, err);
+    res = realpath(path, buf);
+    JS_FreeCString(ctx, path);
+    if (!res) {
+        buf[0] = '\0';
+        err = -errno;
+    } else {
+        err = 0;
+    }
+    return make_string_error(ctx, buf, err);
 }
 
 static JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,
@@ -2413,66 +2074,15 @@ static JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,
     path = JS_ToCString(ctx, argv[0]);
     if (!path)
         return JS_EXCEPTION;
-#if defined(_WIN32)
-    (void)mode;
-    ret = js_get_errno(mkdir(path));
-#else
-    ret = js_get_errno(mkdir(path, mode));
-#endif
-    JS_FreeCString(ctx, path);
-    return JS_NewInt32(ctx, ret);
-}
-
-/* return [array, errorcode] */
-static JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *path;
-    DIR *f;
-    struct dirent *d;
-    JSValue obj;
-    int err;
-    uint32_t len;
-    
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-    obj = JS_NewArray(ctx);
-    if (JS_IsException(obj)) {
-        JS_FreeCString(ctx, path);
-        return JS_EXCEPTION;
-    }
-    f = opendir(path);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
+    ret = mkdir(path, mode);
     JS_FreeCString(ctx, path);
-    if (!f)
-        goto done;
-    len = 0;
-    for(;;) {
-        errno = 0;
-        d = readdir(f);
-        if (!d) {
-            err = errno;
-            break;
-        }
-        JS_DefinePropertyValueUint32(ctx, obj, len++,
-                                     JS_NewString(ctx, d->d_name),
-                                     JS_PROP_C_W_E);
-    }
-    closedir(f);
- done:
-    return make_obj_error(ctx, obj, err);
+    return js_os_return(ctx, ret);
 }
 
-#if !defined(_WIN32)
 static int64_t timespec_to_ms(const struct timespec *tv)
 {
     return (int64_t)tv->tv_sec * 1000 + (tv->tv_nsec / 1000000);
 }
-#endif
 
 /* return [obj, errcode] */
 static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
@@ -2486,17 +2096,13 @@ static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
     path = JS_ToCString(ctx, argv[0]);
     if (!path)
         return JS_EXCEPTION;
-#if defined(_WIN32)
-    res = stat(path, &st);
-#else
     if (is_lstat)
         res = lstat(path, &st);
     else
         res = stat(path, &st);
-#endif
     JS_FreeCString(ctx, path);
     if (res < 0) {
-        err = errno;
+        err = -errno;
         obj = JS_NULL;
     } else {
         err = 0;
@@ -2527,22 +2133,10 @@ static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
         JS_DefinePropertyValueStr(ctx, obj, "size",
                                   JS_NewInt64(ctx, st.st_size),
                                   JS_PROP_C_W_E);
-#if !defined(_WIN32)
         JS_DefinePropertyValueStr(ctx, obj, "blocks",
                                   JS_NewInt64(ctx, st.st_blocks),
                                   JS_PROP_C_W_E);
-#endif
-#if defined(_WIN32)
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),
-                                  JS_PROP_C_W_E);
-#elif defined(__APPLE__)
+#if defined(__APPLE__)
         JS_DefinePropertyValueStr(ctx, obj, "atime",
                                   JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),
                                   JS_PROP_C_W_E);
@@ -2567,130 +2161,24 @@ static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
     return make_obj_error(ctx, obj, err);
 }
 
-#if !defined(_WIN32)
-static void ms_to_timeval(struct timeval *tv, uint64_t v)
-{
-    tv->tv_sec = v / 1000;
-    tv->tv_usec = (v % 1000) * 1000;
-}
-#endif
-
-static JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
+static JSValue js_os_symlink(JSContext *ctx, JSValueConst this_val,
+                              int argc, JSValueConst *argv)
 {
-    const char *path;
-    int64_t atime, mtime;
-    int ret;
+    const char *target, *linkpath;
+    int err;
     
-    if (JS_ToInt64(ctx, &atime, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToInt64(ctx, &mtime, argv[2]))
-        return JS_EXCEPTION;
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    {
-        struct _utimbuf times;
-        times.actime = atime / 1000;
-        times.modtime = mtime / 1000;
-        ret = js_get_errno(_utime(path, &times));
-    }
-#else
-    {
-        struct timeval times[2];
-        ms_to_timeval(&times[0], atime);
-        ms_to_timeval(&times[1], mtime);
-        ret = js_get_errno(utimes(path, times));
-    }
-#endif
-    JS_FreeCString(ctx, path);
-    return JS_NewInt32(ctx, ret);
-}
-
-/* sleep(delay_ms) */
-static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    int64_t delay;
-    int ret;
-    
-    if (JS_ToInt64(ctx, &delay, argv[0]))
-        return JS_EXCEPTION;
-    if (delay < 0)
-        delay = 0;
-#if defined(_WIN32)
-    {
-        if (delay > INT32_MAX)
-            delay = INT32_MAX;
-        Sleep(delay);
-        ret = 0;
-    }
-#else
-    {
-        struct timespec ts;
-
-        ts.tv_sec = delay / 1000;
-        ts.tv_nsec = (delay % 1000) * 1000000;
-        ret = js_get_errno(nanosleep(&ts, NULL));
-    }
-#endif
-    return JS_NewInt32(ctx, ret);
-}
-
-#if defined(_WIN32)
-static char *realpath(const char *path, char *buf)
-{
-    if (!_fullpath(buf, path, PATH_MAX)) {
-        errno = ENOENT;
-        return NULL;
-    } else {
-        return buf;
-    }
-}
-#endif
-
-/* return [path, errorcode] */
-static JSValue js_os_realpath(JSContext *ctx, JSValueConst this_val,
-                              int argc, JSValueConst *argv)
-{
-    const char *path;
-    char buf[PATH_MAX], *res;
-    int err;
-
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-    res = realpath(path, buf);
-    JS_FreeCString(ctx, path);
-    if (!res) {
-        buf[0] = '\0';
-        err = errno;
-    } else {
-        err = 0;
-    }
-    return make_string_error(ctx, buf, err);
-}
-
-#if !defined(_WIN32)
-static JSValue js_os_symlink(JSContext *ctx, JSValueConst this_val,
-                              int argc, JSValueConst *argv)
-{
-    const char *target, *linkpath;
-    int err;
-    
-    target = JS_ToCString(ctx, argv[0]);
-    if (!target)
+    target = JS_ToCString(ctx, argv[0]);
+    if (!target)
         return JS_EXCEPTION;
     linkpath = JS_ToCString(ctx, argv[1]);
     if (!linkpath) {
         JS_FreeCString(ctx, target);
         return JS_EXCEPTION;
     }
-    err = js_get_errno(symlink(target, linkpath));
+    err = symlink(target, linkpath);
     JS_FreeCString(ctx, target);
     JS_FreeCString(ctx, linkpath);
-    return JS_NewInt32(ctx, err);
+    return js_os_return(ctx, err);
 }
 
 /* return [path, errorcode] */
@@ -2706,130 +2194,86 @@ static JSValue js_os_readlink(JSContext *ctx, JSValueConst this_val,
     if (!path)
         return JS_EXCEPTION;
     res = readlink(path, buf, sizeof(buf) - 1);
+    JS_FreeCString(ctx, path);
     if (res < 0) {
         buf[0] = '\0';
-        err = errno;
+        err = -errno;
     } else {
         buf[res] = '\0';
         err = 0;
     }
-    JS_FreeCString(ctx, path);
     return make_string_error(ctx, buf, err);
 }
 
-static char **build_envp(JSContext *ctx, JSValueConst obj)
+/* return [array, errorcode] */
+static JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,
+                             int argc, JSValueConst *argv)
 {
-    uint32_t len, i;
-    JSPropertyEnum *tab;
-    char **envp, *pair;
-    const char *key, *str;
-    JSValue val;
-    size_t key_len, str_len;
+    const char *path;
+    DIR *f;
+    struct dirent *d;
+    JSValue obj;
+    int err;
+    uint32_t len;
     
-    if (JS_GetOwnPropertyNames(ctx, &tab, &len, obj,
-                               JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY) < 0)
-        return NULL;
-    envp = js_mallocz(ctx, sizeof(envp[0]) * ((size_t)len + 1));
-    if (!envp)
-        goto fail;
-    for(i = 0; i < len; i++) {
-        val = JS_GetProperty(ctx, obj, tab[i].atom);
-        if (JS_IsException(val))
-            goto fail;
-        str = JS_ToCString(ctx, val);
-        JS_FreeValue(ctx, val);
-        if (!str)
-            goto fail;
-        key = JS_AtomToCString(ctx, tab[i].atom);
-        if (!key) {
-            JS_FreeCString(ctx, str);
-            goto fail;
-        }
-        key_len = strlen(key);
-        str_len = strlen(str);
-        pair = js_malloc(ctx, key_len + str_len + 2);
-        if (!pair) {
-            JS_FreeCString(ctx, key);
-            JS_FreeCString(ctx, str);
-            goto fail;
+    path = JS_ToCString(ctx, argv[0]);
+    if (!path)
+        return JS_EXCEPTION;
+    obj = JS_NewArray(ctx);
+    if (JS_IsException(obj)) {
+        JS_FreeCString(ctx, path);
+        return JS_EXCEPTION;
+    }
+    f = opendir(path);
+    JS_FreeCString(ctx, path);
+    err = 0;
+    if (!f) {
+        err = -errno;
+        goto done;
+    }
+    len = 0;
+    for(;;) {
+        errno = 0;
+        d = readdir(f);
+        if (!d) {
+            err = -errno;
+            break;
         }
-        memcpy(pair, key, key_len);
-        pair[key_len] = '=';
-        memcpy(pair + key_len + 1, str, str_len);
-        pair[key_len + 1 + str_len] = '\0';
-        envp[i] = pair;
-        JS_FreeCString(ctx, key);
-        JS_FreeCString(ctx, str);
+        JS_DefinePropertyValueUint32(ctx, obj, len++,
+                                     JS_NewString(ctx, d->d_name),
+                                     JS_PROP_C_W_E);
     }
+    closedir(f);
  done:
-    for(i = 0; i < len; i++)
-        JS_FreeAtom(ctx, tab[i].atom);
-    js_free(ctx, tab);
-    return envp;
- fail:
-    if (envp) {
-        for(i = 0; i < len; i++)
-            js_free(ctx, envp[i]);
-        js_free(ctx, envp);
-        envp = NULL;
-    }
-    goto done;
+    return make_obj_error(ctx, obj, err);
 }
 
-/* execvpe is not available on non GNU systems */
-static int my_execvpe(const char *filename, char **argv, char **envp)
+static void ms_to_timeval(struct timeval *tv, uint64_t v)
 {
-    char *path, *p, *p_next, *p1;
-    char buf[PATH_MAX];
-    size_t filename_len, path_len;
-    BOOL eacces_error;
-    
-    filename_len = strlen(filename);
-    if (filename_len == 0) {
-        errno = ENOENT;
-        return -1;
-    }
-    if (strchr(filename, '/'))
-        return execve(filename, argv, envp);
+    tv->tv_sec = v / 1000;
+    tv->tv_usec = (v % 1000) * 1000;
+}
+
+static JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,
+                            int argc, JSValueConst *argv)
+{
+    const char *path;
+    int64_t atime, mtime;
+    int ret;
+    struct timeval times[2];
     
-    path = getenv("PATH");
+    if (JS_ToInt64(ctx, &atime, argv[1]))
+        return JS_EXCEPTION;
+    if (JS_ToInt64(ctx, &mtime, argv[2]))
+        return JS_EXCEPTION;
+    path = JS_ToCString(ctx, argv[0]);
     if (!path)
-        path = (char *)"/bin:/usr/bin";
-    eacces_error = FALSE;
-    p = path;
-    for(p = path; p != NULL; p = p_next) {
-        p1 = strchr(p, ':');
-        if (!p1) {
-            p_next = NULL;
-            path_len = strlen(p);
-        } else {
-            p_next = p1 + 1;
-            path_len = p1 - p;
-        }
-        /* path too long */
-        if ((path_len + 1 + filename_len + 1) > PATH_MAX)
-            continue;
-        memcpy(buf, p, path_len);
-        buf[path_len] = '/';
-        memcpy(buf + path_len + 1, filename, filename_len);
-        buf[path_len + 1 + filename_len] = '\0';
-        
-        execve(buf, argv, envp);
-
-        switch(errno) {
-        case EACCES:
-            eacces_error = TRUE;
-            break;
-        case ENOENT:
-        case ENOTDIR:
-            break;
-        default:
-            return -1;
-        }
-    }
-    if (eacces_error)
-        errno = EACCES;
-    return -1;
+        return JS_EXCEPTION;
+    ms_to_timeval(&times[0], atime);
+    ms_to_timeval(&times[1], mtime);
+    ret = utimes(path, times);
+    JS_FreeCString(ctx, path);
+    return js_os_return(ctx, ret);
 }
 
 /* exec(args[, options]) -> exitcode */
@@ -2839,13 +2283,11 @@ static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
     JSValueConst options, args = argv[0];
     JSValue val, ret_val;
     const char **exec_argv, *file = NULL, *str, *cwd = NULL;
-    char **envp = environ;
     uint32_t exec_argc, i;
     int ret, pid, status;
     BOOL block_flag = TRUE, use_path = TRUE;
     static const char *std_name[3] = { "stdin", "stdout", "stderr" };
     int std_fds[3];
-    uint32_t uid = -1, gid = -1;
     
     val = JS_GetPropertyStr(ctx, args, "length");
     if (JS_IsException(val))
@@ -2919,36 +2361,6 @@ static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
                 std_fds[i] = fd;
             }
         }
-
-        val = JS_GetPropertyStr(ctx, options, "env");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            envp = build_envp(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!envp)
-                goto exception;
-        }
-        
-        val = JS_GetPropertyStr(ctx, options, "uid");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_ToUint32(ctx, &uid, val);
-            JS_FreeValue(ctx, val);
-            if (ret)
-                goto exception;
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "gid");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_ToUint32(ctx, &gid, val);
-            JS_FreeValue(ctx, val);
-            if (ret)
-                goto exception;
-        }
     }
 
     pid = fork();
@@ -2974,21 +2386,12 @@ static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
             if (chdir(cwd) < 0)
                 _exit(127);
         }
-        if (uid != -1) {
-            if (setuid(uid) < 0)
-                _exit(127);
-        }
-        if (gid != -1) {
-            if (setgid(gid) < 0)
-                _exit(127);
-        }
-
         if (!file)
             file = exec_argv[0];
         if (use_path)
-            ret = my_execvpe(file, (char **)exec_argv, envp);
+            ret = execvp(file, (char **)exec_argv);
         else
-            ret = execve(file, (char **)exec_argv, envp);
+            ret = execv(file, (char **)exec_argv);
         _exit(127);
     }
     /* parent */
@@ -3015,15 +2418,6 @@ static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
     for(i = 0; i < exec_argc; i++)
         JS_FreeCString(ctx, exec_argv[i]);
     js_free(ctx, exec_argv);
-    if (envp != environ) {
-        char **p;
-        p = envp;
-        while (*p != NULL) {
-            js_free(ctx, *p);
-            p++;
-        }
-        js_free(ctx, envp);
-    }
     return ret_val;
  exception:
     ret_val = JS_EXCEPTION;
@@ -3088,8 +2482,24 @@ static JSValue js_os_kill(JSContext *ctx, JSValueConst this_val,
         return JS_EXCEPTION;
     if (JS_ToInt32(ctx, &sig, argv[1]))
         return JS_EXCEPTION;
-    ret = js_get_errno(kill(pid, sig));
-    return JS_NewInt32(ctx, ret);
+    ret = kill(pid, sig);
+    return js_os_return(ctx, ret);
+}
+
+/* sleep(delay_ms) */
+static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
+                          int argc, JSValueConst *argv)
+{
+    int64_t delay;
+    struct timespec ts;
+    int ret;
+    
+    if (JS_ToInt64(ctx, &delay, argv[0]))
+        return JS_EXCEPTION;
+    ts.tv_sec = delay / 1000;
+    ts.tv_nsec = (delay % 1000) * 1000000;
+    ret = nanosleep(&ts, NULL);
+    return js_os_return(ctx, ret);
 }
 
 /* dup(fd) */
@@ -3100,8 +2510,8 @@ static JSValue js_os_dup(JSContext *ctx, JSValueConst this_val,
     
     if (JS_ToInt32(ctx, &fd, argv[0]))
         return JS_EXCEPTION;
-    ret = js_get_errno(dup(fd));
-    return JS_NewInt32(ctx, ret);
+    ret = dup(fd);
+    return js_os_return(ctx, ret);
 }
 
 /* dup2(fd) */
@@ -3114,457 +2524,12 @@ static JSValue js_os_dup2(JSContext *ctx, JSValueConst this_val,
         return JS_EXCEPTION;
     if (JS_ToInt32(ctx, &fd2, argv[1]))
         return JS_EXCEPTION;
-    ret = js_get_errno(dup2(fd, fd2));
-    return JS_NewInt32(ctx, ret);
+    ret = dup2(fd, fd2);
+    return js_os_return(ctx, ret);
 }
 
 #endif /* !_WIN32 */
 
-#ifdef USE_WORKER
-
-/* Worker */
-
-typedef struct {
-    JSWorkerMessagePipe *recv_pipe;
-    JSWorkerMessagePipe *send_pipe;
-    JSWorkerMessageHandler *msg_handler;
-} JSWorkerData;
-
-typedef struct {
-    char *filename; /* module filename */
-    char *basename; /* module base name */
-    JSWorkerMessagePipe *recv_pipe, *send_pipe;
-} WorkerFuncArgs;
-
-typedef struct {
-    int ref_count;
-    uint64_t buf[0];
-} JSSABHeader;
-
-static JSClassID js_worker_class_id;
-static JSContext *(*js_worker_new_context_func)(JSRuntime *rt);
-
-static int atomic_add_int(int *ptr, int v)
-{
-    return atomic_fetch_add((_Atomic(uint32_t) *)ptr, v) + v;
-}
-
-/* shared array buffer allocator */
-static void *js_sab_alloc(void *opaque, size_t size)
-{
-    JSSABHeader *sab;
-    sab = malloc(sizeof(JSSABHeader) + size);
-    if (!sab)
-        return NULL;
-    sab->ref_count = 1;
-    return sab->buf;
-}
-
-static void js_sab_free(void *opaque, void *ptr)
-{
-    JSSABHeader *sab;
-    int ref_count;
-    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));
-    ref_count = atomic_add_int(&sab->ref_count, -1);
-    assert(ref_count >= 0);
-    if (ref_count == 0) {
-        free(sab);
-    }
-}
-
-static void js_sab_dup(void *opaque, void *ptr)
-{
-    JSSABHeader *sab;
-    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));
-    atomic_add_int(&sab->ref_count, 1);
-}
-
-static JSWorkerMessagePipe *js_new_message_pipe(void)
-{
-    JSWorkerMessagePipe *ps;
-    int pipe_fds[2];
-    
-    if (pipe(pipe_fds) < 0)
-        return NULL;
-
-    ps = malloc(sizeof(*ps));
-    if (!ps) {
-        close(pipe_fds[0]);
-        close(pipe_fds[1]);
-        return NULL;
-    }
-    ps->ref_count = 1;
-    init_list_head(&ps->msg_queue);
-    pthread_mutex_init(&ps->mutex, NULL);
-    ps->read_fd = pipe_fds[0];
-    ps->write_fd = pipe_fds[1];
-    return ps;
-}
-
-static JSWorkerMessagePipe *js_dup_message_pipe(JSWorkerMessagePipe *ps)
-{
-    atomic_add_int(&ps->ref_count, 1);
-    return ps;
-}
-
-static void js_free_message(JSWorkerMessage *msg)
-{
-    size_t i;
-    /* free the SAB */
-    for(i = 0; i < msg->sab_tab_len; i++) {
-        js_sab_free(NULL, msg->sab_tab[i]);
-    }
-    free(msg->sab_tab);
-    free(msg->data);
-    free(msg);
-}
-
-static void js_free_message_pipe(JSWorkerMessagePipe *ps)
-{
-    struct list_head *el, *el1;
-    JSWorkerMessage *msg;
-    int ref_count;
-    
-    if (!ps)
-        return;
-    
-    ref_count = atomic_add_int(&ps->ref_count, -1);
-    assert(ref_count >= 0);
-    if (ref_count == 0) {
-        list_for_each_safe(el, el1, &ps->msg_queue) {
-            msg = list_entry(el, JSWorkerMessage, link);
-            js_free_message(msg);
-        }
-        pthread_mutex_destroy(&ps->mutex);
-        close(ps->read_fd);
-        close(ps->write_fd);
-        free(ps);
-    }
-}
-
-static void js_free_port(JSRuntime *rt, JSWorkerMessageHandler *port)
-{
-    if (port) {
-        js_free_message_pipe(port->recv_pipe);
-        JS_FreeValueRT(rt, port->on_message_func);
-        list_del(&port->link);
-        js_free_rt(rt, port);
-    }
-}
-
-static void js_worker_finalizer(JSRuntime *rt, JSValue val)
-{
-    JSWorkerData *worker = JS_GetOpaque(val, js_worker_class_id);
-    if (worker) {
-        js_free_message_pipe(worker->recv_pipe);
-        js_free_message_pipe(worker->send_pipe);
-        js_free_port(rt, worker->msg_handler);
-        js_free_rt(rt, worker);
-    }
-}
-
-static JSClassDef js_worker_class = {
-    "Worker",
-    .finalizer = js_worker_finalizer,
-}; 
-
-static void *worker_func(void *opaque)
-{
-    WorkerFuncArgs *args = opaque;
-    JSRuntime *rt;
-    JSThreadState *ts;
-    JSContext *ctx;
-    
-    rt = JS_NewRuntime();
-    if (rt == NULL) {
-        fprintf(stderr, "JS_NewRuntime failure");
-        exit(1);
-    }        
-    js_std_init_handlers(rt);
-
-    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);
-
-    /* set the pipe to communicate with the parent */
-    ts = JS_GetRuntimeOpaque(rt);
-    ts->recv_pipe = args->recv_pipe;
-    ts->send_pipe = args->send_pipe;
-    
-    /* function pointer to avoid linking the whole JS_NewContext() if
-       not needed */
-    ctx = js_worker_new_context_func(rt);
-    if (ctx == NULL) {
-        fprintf(stderr, "JS_NewContext failure");
-    }
-
-    JS_SetCanBlock(rt, TRUE);
-
-    js_std_add_helpers(ctx, -1, NULL);
-
-    if (!JS_RunModule(ctx, args->basename, args->filename))
-        js_std_dump_error(ctx);
-    free(args->filename);
-    free(args->basename);
-    free(args);
-
-    js_std_loop(ctx);
-
-    JS_FreeContext(ctx);
-    js_std_free_handlers(rt);
-    JS_FreeRuntime(rt);
-    return NULL;
-}
-
-static JSValue js_worker_ctor_internal(JSContext *ctx, JSValueConst new_target,
-                                       JSWorkerMessagePipe *recv_pipe,
-                                       JSWorkerMessagePipe *send_pipe)
-{
-    JSValue obj = JS_UNDEFINED, proto;
-    JSWorkerData *s;
-    
-    /* create the object */
-    if (JS_IsUndefined(new_target)) {
-        proto = JS_GetClassProto(ctx, js_worker_class_id);
-    } else {
-        proto = JS_GetPropertyStr(ctx, new_target, "prototype");
-        if (JS_IsException(proto))
-            goto fail;
-    }
-    obj = JS_NewObjectProtoClass(ctx, proto, js_worker_class_id);
-    JS_FreeValue(ctx, proto);
-    if (JS_IsException(obj))
-        goto fail;
-    s = js_mallocz(ctx, sizeof(*s));
-    if (!s)
-        goto fail;
-    s->recv_pipe = js_dup_message_pipe(recv_pipe);
-    s->send_pipe = js_dup_message_pipe(send_pipe);
-
-    JS_SetOpaque(obj, s);
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_worker_ctor(JSContext *ctx, JSValueConst new_target,
-                              int argc, JSValueConst *argv)
-{
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    WorkerFuncArgs *args = NULL;
-    pthread_t tid;
-    pthread_attr_t attr;
-    JSValue obj = JS_UNDEFINED;
-    int ret;
-    const char *filename = NULL, *basename;
-    JSAtom basename_atom;
-    
-    /* XXX: in order to avoid problems with resource liberation, we
-       don't support creating workers inside workers */
-    if (!is_main_thread(rt))
-        return JS_ThrowTypeError(ctx, "cannot create a worker inside a worker");
-
-    /* base name, assuming the calling function is a normal JS
-       function */
-    basename_atom = JS_GetScriptOrModuleName(ctx, 1);
-    if (basename_atom == JS_ATOM_NULL) {
-        return JS_ThrowTypeError(ctx, "could not determine calling script or module name");
-    }
-    basename = JS_AtomToCString(ctx, basename_atom);
-    JS_FreeAtom(ctx, basename_atom);
-    if (!basename)
-        goto fail;
-    
-    /* module name */
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        goto fail;
-
-    args = malloc(sizeof(*args));
-    if (!args)
-        goto oom_fail;
-    memset(args, 0, sizeof(*args));
-    args->filename = strdup(filename);
-    args->basename = strdup(basename);
-
-    /* ports */
-    args->recv_pipe = js_new_message_pipe();
-    if (!args->recv_pipe)
-        goto oom_fail;
-    args->send_pipe = js_new_message_pipe();
-    if (!args->send_pipe)
-        goto oom_fail;
-
-    obj = js_worker_ctor_internal(ctx, new_target,
-                                  args->send_pipe, args->recv_pipe);
-    if (JS_IsException(obj))
-        goto fail;
-    
-    pthread_attr_init(&attr);
-    /* no join at the end */
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    ret = pthread_create(&tid, &attr, worker_func, args);
-    pthread_attr_destroy(&attr);
-    if (ret != 0) {
-        JS_ThrowTypeError(ctx, "could not create worker");
-        goto fail;
-    }
-    JS_FreeCString(ctx, basename);
-    JS_FreeCString(ctx, filename);
-    return obj;
- oom_fail:
-    JS_ThrowOutOfMemory(ctx);
- fail:
-    JS_FreeCString(ctx, basename);
-    JS_FreeCString(ctx, filename);
-    if (args) {
-        free(args->filename);
-        free(args->basename);
-        js_free_message_pipe(args->recv_pipe);
-        js_free_message_pipe(args->send_pipe);
-        free(args);
-    }
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_worker_postMessage(JSContext *ctx, JSValueConst this_val,
-                                     int argc, JSValueConst *argv)
-{
-    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
-    JSWorkerMessagePipe *ps;
-    size_t data_len, sab_tab_len, i;
-    uint8_t *data;
-    JSWorkerMessage *msg;
-    uint8_t **sab_tab;
-    
-    if (!worker)
-        return JS_EXCEPTION;
-    
-    data = JS_WriteObject2(ctx, &data_len, argv[0],
-                           JS_WRITE_OBJ_SAB | JS_WRITE_OBJ_REFERENCE,
-                           &sab_tab, &sab_tab_len);
-    if (!data)
-        return JS_EXCEPTION;
-
-    msg = malloc(sizeof(*msg));
-    if (!msg)
-        goto fail;
-    msg->data = NULL;
-    msg->sab_tab = NULL;
-
-    /* must reallocate because the allocator may be different */
-    msg->data = malloc(data_len);
-    if (!msg->data)
-        goto fail;
-    memcpy(msg->data, data, data_len);
-    msg->data_len = data_len;
-
-    msg->sab_tab = malloc(sizeof(msg->sab_tab[0]) * sab_tab_len);
-    if (!msg->sab_tab)
-        goto fail;
-    memcpy(msg->sab_tab, sab_tab, sizeof(msg->sab_tab[0]) * sab_tab_len);
-    msg->sab_tab_len = sab_tab_len;
-
-    js_free(ctx, data);
-    js_free(ctx, sab_tab);
-    
-    /* increment the SAB reference counts */
-    for(i = 0; i < msg->sab_tab_len; i++) {
-        js_sab_dup(NULL, msg->sab_tab[i]);
-    }
-
-    ps = worker->send_pipe;
-    pthread_mutex_lock(&ps->mutex);
-    /* indicate that data is present */
-    if (list_empty(&ps->msg_queue)) {
-        uint8_t ch = '\0';
-        int ret;
-        for(;;) {
-            ret = write(ps->write_fd, &ch, 1);
-            if (ret == 1)
-                break;
-            if (ret < 0 && (errno != EAGAIN || errno != EINTR))
-                break;
-        }
-    }
-    list_add_tail(&msg->link, &ps->msg_queue);
-    pthread_mutex_unlock(&ps->mutex);
-    return JS_UNDEFINED;
- fail:
-    if (msg) {
-        free(msg->data);
-        free(msg->sab_tab);
-        free(msg);
-    }
-    js_free(ctx, data);
-    js_free(ctx, sab_tab);
-    return JS_EXCEPTION;
-    
-}
-
-static JSValue js_worker_set_onmessage(JSContext *ctx, JSValueConst this_val,
-                                   JSValueConst func)
-{
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
-    JSWorkerMessageHandler *port;
-    
-    if (!worker)
-        return JS_EXCEPTION;
-
-    port = worker->msg_handler;
-    if (JS_IsNull(func)) {
-        if (port) {
-            js_free_port(rt, port);
-            worker->msg_handler = NULL;
-        }
-    } else {
-        if (!JS_IsFunction(ctx, func))
-            return JS_ThrowTypeError(ctx, "not a function");
-        if (!port) {
-            port = js_mallocz(ctx, sizeof(*port));
-            if (!port)
-                return JS_EXCEPTION;
-            port->recv_pipe = js_dup_message_pipe(worker->recv_pipe);
-            port->on_message_func = JS_NULL;
-            list_add_tail(&port->link, &ts->port_list);
-            worker->msg_handler = port;
-        }
-        JS_FreeValue(ctx, port->on_message_func);
-        port->on_message_func = JS_DupValue(ctx, func);
-    }
-    return JS_UNDEFINED;
-}
-
-static JSValue js_worker_get_onmessage(JSContext *ctx, JSValueConst this_val)
-{
-    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
-    JSWorkerMessageHandler *port;
-    if (!worker)
-        return JS_EXCEPTION;
-    port = worker->msg_handler;
-    if (port) {
-        return JS_DupValue(ctx, port->on_message_func);
-    } else {
-        return JS_NULL;
-    }
-}
-
-static const JSCFunctionListEntry js_worker_proto_funcs[] = {
-    JS_CFUNC_DEF("postMessage", 1, js_worker_postMessage ),
-    JS_CGETSET_DEF("onmessage", js_worker_get_onmessage, js_worker_set_onmessage ),
-};
-
-#endif /* USE_WORKER */
-
-void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt))
-{
-#ifdef USE_WORKER
-    js_worker_new_context_func = func;
-#endif
-}
-
 #if defined(_WIN32)
 #define OS_PLATFORM "win32"
 #elif defined(__APPLE__)
@@ -3625,9 +2590,11 @@ static const JSCFunctionListEntry js_os_funcs[] = {
     JS_CFUNC_DEF("clearTimeout", 1, js_os_clearTimeout ),
     JS_PROP_STRING_DEF("platform", OS_PLATFORM, 0 ),
     JS_CFUNC_DEF("getcwd", 0, js_os_getcwd ),
-    JS_CFUNC_DEF("chdir", 0, js_os_chdir ),
+#if !defined(_WIN32)
+    JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
     JS_CFUNC_DEF("mkdir", 1, js_os_mkdir ),
-    JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
+    JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
+    JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
     /* st_mode constants */
     OS_FLAG(S_IFMT),
     OS_FLAG(S_IFIFO),
@@ -3635,25 +2602,20 @@ static const JSCFunctionListEntry js_os_funcs[] = {
     OS_FLAG(S_IFDIR),
     OS_FLAG(S_IFBLK),
     OS_FLAG(S_IFREG),
-#if !defined(_WIN32)
     OS_FLAG(S_IFSOCK),
     OS_FLAG(S_IFLNK),
     OS_FLAG(S_ISGID),
     OS_FLAG(S_ISUID),
-#endif
-    JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
-    JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
-    JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
-    JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
-#if !defined(_WIN32)
-    JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
     JS_CFUNC_DEF("symlink", 2, js_os_symlink ),
     JS_CFUNC_DEF("readlink", 1, js_os_readlink ),
+    JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
+    JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
     JS_CFUNC_DEF("exec", 1, js_os_exec ),
     JS_CFUNC_DEF("waitpid", 2, js_os_waitpid ),
     OS_FLAG(WNOHANG),
     JS_CFUNC_DEF("pipe", 0, js_os_pipe ),
     JS_CFUNC_DEF("kill", 2, js_os_kill ),
+    JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
     JS_CFUNC_DEF("dup", 1, js_os_dup ),
     JS_CFUNC_DEF("dup2", 2, js_os_dup2 ),
 #endif
@@ -3666,35 +2628,7 @@ static int js_os_init(JSContext *ctx, JSModuleDef *m)
     /* OSTimer class */
     JS_NewClassID(&js_os_timer_class_id);
     JS_NewClass(JS_GetRuntime(ctx), js_os_timer_class_id, &js_os_timer_class);
-
-#ifdef USE_WORKER
-    {
-        JSRuntime *rt = JS_GetRuntime(ctx);
-        JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-        JSValue proto, obj;
-        /* Worker class */
-        JS_NewClassID(&js_worker_class_id);
-        JS_NewClass(JS_GetRuntime(ctx), js_worker_class_id, &js_worker_class);
-        proto = JS_NewObject(ctx);
-        JS_SetPropertyFunctionList(ctx, proto, js_worker_proto_funcs, countof(js_worker_proto_funcs));
-        
-        obj = JS_NewCFunction2(ctx, js_worker_ctor, "Worker", 1,
-                               JS_CFUNC_constructor, 0);
-        JS_SetConstructor(ctx, obj, proto);
-        
-        JS_SetClassProto(ctx, js_worker_class_id, proto);
-        
-        /* set 'Worker.parent' if necessary */
-        if (ts->recv_pipe && ts->send_pipe) {
-            JS_DefinePropertyValueStr(ctx, obj, "parent",
-                                      js_worker_ctor_internal(ctx, JS_UNDEFINED, ts->recv_pipe, ts->send_pipe),
-                                      JS_PROP_C_W_E);
-        }
-        
-        JS_SetModuleExport(ctx, m, "Worker", obj);
-    }
-#endif /* USE_WORKER */
-
+    
     return JS_SetModuleExportList(ctx, m, js_os_funcs,
                                   countof(js_os_funcs));
 }
@@ -3706,9 +2640,6 @@ JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name)
     if (!m)
         return NULL;
     JS_AddModuleExportList(ctx, m, js_os_funcs, countof(js_os_funcs));
-#ifdef USE_WORKER
-    JS_AddModuleExport(ctx, m, "Worker");
-#endif
     return m;
 }
 
@@ -3719,15 +2650,14 @@ static JSValue js_print(JSContext *ctx, JSValueConst this_val,
 {
     int i;
     const char *str;
-    size_t len;
 
     for(i = 0; i < argc; i++) {
         if (i != 0)
             putchar(' ');
-        str = JS_ToCStringLen(ctx, &len, argv[i]);
+        str = JS_ToCString(ctx, argv[i]);
         if (!str)
             return JS_EXCEPTION;
-        fwrite(str, 1, len, stdout);
+        fputs(str, stdout);
         JS_FreeCString(ctx, str);
     }
     putchar('\n');
@@ -3748,132 +2678,71 @@ void js_std_add_helpers(JSContext *ctx, int argc, char **argv)
     JS_SetPropertyStr(ctx, global_obj, "console", console);
 
     /* same methods as the mozilla JS shell */
-    if (argc >= 0) {
-        args = JS_NewArray(ctx);
-        for(i = 0; i < argc; i++) {
-            JS_SetPropertyUint32(ctx, args, i, JS_NewString(ctx, argv[i]));
-        }
-        JS_SetPropertyStr(ctx, global_obj, "scriptArgs", args);
+    args = JS_NewArray(ctx);
+    for(i = 0; i < argc; i++) {
+        JS_SetPropertyUint32(ctx, args, i, JS_NewString(ctx, argv[i]));
     }
-    
+    JS_SetPropertyStr(ctx, global_obj, "scriptArgs", args);
+
     JS_SetPropertyStr(ctx, global_obj, "print",
                       JS_NewCFunction(ctx, js_print, "print", 1));
     JS_SetPropertyStr(ctx, global_obj, "__loadScript",
                       JS_NewCFunction(ctx, js_loadScript, "__loadScript", 1));
     
     JS_FreeValue(ctx, global_obj);
-}
 
-void js_std_init_handlers(JSRuntime *rt)
-{
-    JSThreadState *ts;
-
-    ts = malloc(sizeof(*ts));
-    if (!ts) {
-        fprintf(stderr, "Could not allocate memory for the worker");
-        exit(1);
-    }
-    memset(ts, 0, sizeof(*ts));
-    init_list_head(&ts->os_rw_handlers);
-    init_list_head(&ts->os_signal_handlers);
-    init_list_head(&ts->os_timers);
-    init_list_head(&ts->port_list);
-
-    JS_SetRuntimeOpaque(rt, ts);
-
-#ifdef USE_WORKER
-    /* set the SharedArrayBuffer memory handlers */
-    {
-        JSSharedArrayBufferFunctions sf;
-        memset(&sf, 0, sizeof(sf));
-        sf.sab_alloc = js_sab_alloc;
-        sf.sab_free = js_sab_free;
-        sf.sab_dup = js_sab_dup;
-        JS_SetSharedArrayBufferFunctions(rt, &sf);
-    }
-#endif
+    /* XXX: not multi-context */
+    init_list_head(&os_rw_handlers);
+    init_list_head(&os_signal_handlers);
+    init_list_head(&os_timers);
+    os_pending_signals = 0;
 }
 
 void js_std_free_handlers(JSRuntime *rt)
 {
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
     struct list_head *el, *el1;
 
-    list_for_each_safe(el, el1, &ts->os_rw_handlers) {
+    list_for_each_safe(el, el1, &os_rw_handlers) {
         JSOSRWHandler *rh = list_entry(el, JSOSRWHandler, link);
         free_rw_handler(rt, rh);
     }
 
-    list_for_each_safe(el, el1, &ts->os_signal_handlers) {
+    list_for_each_safe(el, el1, &os_signal_handlers) {
         JSOSSignalHandler *sh = list_entry(el, JSOSSignalHandler, link);
         free_sh(rt, sh);
     }
     
-    list_for_each_safe(el, el1, &ts->os_timers) {
+    list_for_each_safe(el, el1, &os_timers) {
         JSOSTimer *th = list_entry(el, JSOSTimer, link);
         unlink_timer(rt, th);
         if (!th->has_object)
             free_timer(rt, th);
     }
-
-#ifdef USE_WORKER
-    /* XXX: free port_list ? */
-    js_free_message_pipe(ts->recv_pipe);
-    js_free_message_pipe(ts->send_pipe);
-#endif
-
-    free(ts);
-    JS_SetRuntimeOpaque(rt, NULL); /* fail safe */
 }
 
-static void js_dump_obj(JSContext *ctx, FILE *f, JSValueConst val)
-{
-    const char *str;
-    
-    str = JS_ToCString(ctx, val);
-    if (str) {
-        fprintf(f, "%s\n", str);
-        JS_FreeCString(ctx, str);
-    } else {
-        fprintf(f, "[exception]\n");
-    }
-}
-
-static void js_std_dump_error1(JSContext *ctx, JSValueConst exception_val)
+void js_std_dump_error(JSContext *ctx)
 {
-    JSValue val;
+    JSValue exception_val, val;
+    const char *stack;
     BOOL is_error;
     
+    exception_val = JS_GetException(ctx);
     is_error = JS_IsError(ctx, exception_val);
-    js_dump_obj(ctx, stderr, exception_val);
+    if (!is_error)
+        printf("Throw: ");
+    js_print(ctx, JS_NULL, 1, (JSValueConst *)&exception_val);
     if (is_error) {
         val = JS_GetPropertyStr(ctx, exception_val, "stack");
         if (!JS_IsUndefined(val)) {
-            js_dump_obj(ctx, stderr, val);
+            stack = JS_ToCString(ctx, val);
+            printf("%s\n", stack);
+            JS_FreeCString(ctx, stack);
         }
         JS_FreeValue(ctx, val);
     }
-}
-
-void js_std_dump_error(JSContext *ctx)
-{
-    JSValue exception_val;
-    
-    exception_val = JS_GetException(ctx);
-    js_std_dump_error1(ctx, exception_val);
     JS_FreeValue(ctx, exception_val);
 }
 
-void js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,
-                                      JSValueConst reason,
-                                      BOOL is_handled, void *opaque)
-{
-    if (!is_handled) {
-        fprintf(stderr, "Possibly unhandled promise rejection: ");
-        js_std_dump_error1(ctx, reason);
-    }
-}
-
 /* main loop which calls the user JS callbacks */
 void js_std_loop(JSContext *ctx)
 {
@@ -3925,3 +2794,4 @@ void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
         JS_FreeValue(ctx, val);
     }
 }
+
diff --git a/quickjs-libc.h b/quickjs-libc.h
index fbbe5b0..ac7947e 100644
--- a/quickjs-libc.h
+++ b/quickjs-libc.h
@@ -29,15 +29,10 @@
 
 #include "quickjs.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 JSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name);
 JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name);
 void js_std_add_helpers(JSContext *ctx, int argc, char **argv);
 void js_std_loop(JSContext *ctx);
-void js_std_init_handlers(JSRuntime *rt);
 void js_std_free_handlers(JSRuntime *rt);
 void js_std_dump_error(JSContext *ctx);
 uint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename);
@@ -47,13 +42,5 @@ JSModuleDef *js_module_loader(JSContext *ctx,
                               const char *module_name, void *opaque);
 void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                         int flags);
-void js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,
-                                      JSValueConst reason,
-                                      JS_BOOL is_handled, void *opaque);
-void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt));
-                                        
-#ifdef __cplusplus
-} /* extern "C" { */
-#endif
 
 #endif /* QUICKJS_LIBC_H */
diff --git a/quickjs-opcode.h b/quickjs-opcode.h
index c731a14..910bb75 100644
--- a/quickjs-opcode.h
+++ b/quickjs-opcode.h
@@ -114,11 +114,12 @@ DEF(    check_brand, 1, 2, 2, none) /* this_obj func -> this_obj func */
 DEF(      add_brand, 1, 2, 0, none) /* this_obj home_obj -> */
 DEF(   return_async, 1, 1, 0, none)
 DEF(          throw, 1, 1, 0, none)
-DEF(    throw_error, 6, 0, 0, atom_u8)
+DEF(      throw_var, 6, 0, 0, atom_u8)
 DEF(           eval, 5, 1, 1, npop_u16) /* func args... -> ret_val */
 DEF(     apply_eval, 3, 2, 1, u16) /* func array -> ret_eval */
 DEF(         regexp, 1, 2, 1, none) /* create a RegExp object from the pattern and a
                                        bytecode string */
+DEF( get_super_ctor, 1, 1, 1, none)
 DEF(      get_super, 1, 1, 1, none)
 DEF(         import, 1, 1, 1, none) /* dynamic module import */
 
@@ -205,15 +206,16 @@ DEF(   for_of_start, 1, 1, 3, none)
 DEF(for_await_of_start, 1, 1, 3, none)
 DEF(    for_in_next, 1, 1, 3, none)
 DEF(    for_of_next, 2, 3, 5, u8)
-DEF(iterator_check_object, 1, 1, 1, none)
+DEF(for_await_of_next, 1, 3, 4, none)
 DEF(iterator_get_value_done, 1, 1, 2, none)
 DEF( iterator_close, 1, 3, 0, none)
 DEF(iterator_close_return, 1, 4, 4, none)
-DEF(  iterator_next, 1, 4, 4, none)
-DEF(  iterator_call, 2, 4, 5, u8)
+DEF(async_iterator_close, 1, 3, 2, none)
+DEF(async_iterator_next, 1, 4, 4, none)
+DEF(async_iterator_get, 2, 4, 5, u8)
 DEF(  initial_yield, 1, 0, 0, none)
 DEF(          yield, 1, 1, 2, none)
-DEF(     yield_star, 1, 1, 2, none)
+DEF(     yield_star, 1, 2, 2, none)
 DEF(async_yield_star, 1, 1, 2, none)
 DEF(          await, 1, 1, 1, none)
 
@@ -255,16 +257,20 @@ DEF(     strict_neq, 1, 2, 1, none)
 DEF(            and, 1, 2, 1, none)
 DEF(            xor, 1, 2, 1, none)
 DEF(             or, 1, 2, 1, none)
-DEF(is_undefined_or_null, 1, 1, 1, none)
 #ifdef CONFIG_BIGNUM
 DEF(      mul_pow10, 1, 2, 1, none)
+DEF(       math_div, 1, 2, 1, none)
 DEF(       math_mod, 1, 2, 1, none)
+DEF(       math_pow, 1, 2, 1, none)
 #endif
 /* must be the last non short and non temporary opcode */
 DEF(            nop, 1, 0, 0, none) 
 
 /* temporary opcodes: never emitted in the final bytecode */
 
+def(set_arg_valid_upto, 3, 0, 0, arg) /* emitted in phase 1, removed in phase 2 */
+
+def(close_var_object, 1, 0, 0, none) /* emitted in phase 1, removed in phase 2 */
 def(    enter_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
 def(    leave_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
 
@@ -356,8 +362,7 @@ DEF(          call3, 1, 1, 1, npopx)
 
 DEF(   is_undefined, 1, 1, 1, none)
 DEF(        is_null, 1, 1, 1, none)
-DEF(typeof_is_undefined, 1, 1, 1, none)
-DEF( typeof_is_function, 1, 1, 1, none)
+DEF(    is_function, 1, 1, 1, none)
 #endif
 
 #undef DEF
diff --git a/quickjs.c b/quickjs.c
index 48aeffc..de11db1 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -28,7 +28,6 @@
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <sys/time.h>
 #include <time.h>
 #include <fenv.h>
 #include <math.h>
@@ -36,8 +35,35 @@
 #include <malloc/malloc.h>
 #elif defined(__linux__)
 #include <malloc.h>
-#elif defined(__FreeBSD__)
-#include <malloc_np.h>
+#elif defined(_MSC_VER)
+#include <malloc.h>
+#endif
+
+#ifdef _MSC_VER
+#include <WinSock2.h>
+
+// From: https://stackoverflow.com/a/26085827
+int gettimeofday(struct timeval * tp, struct timezone * tzp)
+{
+	static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
+
+	SYSTEMTIME  system_time;
+	FILETIME    file_time;
+	uint64_t    time;
+
+	GetSystemTime(&system_time);
+	SystemTimeToFileTime(&system_time, &file_time);
+	time = ((uint64_t)file_time.dwLowDateTime);
+	time += ((uint64_t)file_time.dwHighDateTime) << 32;
+
+	tp->tv_sec = (long)((time - EPOCH) / 10000000L);
+	tp->tv_usec = (long)(system_time.wMilliseconds * 1000);
+
+	return 0;
+}
+
+#else
+#include <sys/time.h>
 #endif
 
 #include "cutils.h"
@@ -50,7 +76,7 @@
 
 #define OPTIMIZE         1
 #define SHORT_OPCODES    1
-#if defined(EMSCRIPTEN)
+#if defined(EMSCRIPTEN) || defined(_MSC_VER)
 #define DIRECT_DISPATCH  0
 #else
 #define DIRECT_DISPATCH  1
@@ -70,15 +96,9 @@
 /* define to include Atomics.* operations which depend on the OS
    threads */
 #if !defined(EMSCRIPTEN)
-#define CONFIG_ATOMICS
+//#define CONFIG_ATOMICS
 #endif
 
-#if !defined(EMSCRIPTEN)
-/* enable stack limitation */
-#define CONFIG_STACK_CHECK
-#endif
-
-
 /* dump object free */
 //#define DUMP_FREE
 //#define DUMP_CLOSURE
@@ -155,8 +175,6 @@ enum {
     JS_CLASS_BIG_INT,           /* u.object_data */
     JS_CLASS_BIG_FLOAT,         /* u.object_data */
     JS_CLASS_FLOAT_ENV,         /* u.float_env */
-    JS_CLASS_BIG_DECIMAL,       /* u.object_data */
-    JS_CLASS_OPERATOR_SET,      /* u.operator_set */
 #endif
     JS_CLASS_MAP,               /* u.map_state */
     JS_CLASS_SET,               /* u.map_state */
@@ -195,49 +213,24 @@ typedef enum JSErrorEnum {
     JS_TYPE_ERROR,
     JS_URI_ERROR,
     JS_INTERNAL_ERROR,
-    JS_AGGREGATE_ERROR,
-    
+
     JS_NATIVE_ERROR_COUNT, /* number of different NativeError objects */
 } JSErrorEnum;
 
 #define JS_MAX_LOCAL_VARS 65536
-#define JS_STACK_SIZE_MAX 65534
+#define JS_STACK_SIZE_MAX 65536
 #define JS_STRING_LEN_MAX ((1 << 30) - 1)
 
+#ifdef _MSC_VER
+#define __exception
+#else
 #define __exception __attribute__((warn_unused_result))
+#endif
 
 typedef struct JSShape JSShape;
 typedef struct JSString JSString;
 typedef struct JSString JSAtomStruct;
 
-typedef enum {
-    JS_GC_PHASE_NONE,
-    JS_GC_PHASE_DECREF,
-    JS_GC_PHASE_REMOVE_CYCLES,
-} JSGCPhaseEnum;
-
-typedef enum OPCodeEnum OPCodeEnum;
-
-#ifdef CONFIG_BIGNUM
-/* function pointers are used for numeric operations so that it is
-   possible to remove some numeric types */
-typedef struct {
-    JSValue (*to_string)(JSContext *ctx, JSValueConst val);
-    JSValue (*from_string)(JSContext *ctx, const char *buf,
-                           int radix, int flags, slimb_t *pexponent);
-    int (*unary_arith)(JSContext *ctx,
-                       JSValue *pres, OPCodeEnum op, JSValue op1);
-    int (*binary_arith)(JSContext *ctx, OPCodeEnum op,
-                        JSValue *pres, JSValue op1, JSValue op2);
-    int (*compare)(JSContext *ctx, OPCodeEnum op,
-                   JSValue op1, JSValue op2);
-    /* only for bigfloat: */
-    JSValue (*mul_pow10_to_float64)(JSContext *ctx, const bf_t *a,
-                                    int64_t exponent);
-    int (*mul_pow10)(JSContext *ctx, JSValue *sp);
-} JSNumericOperations;
-#endif
-
 struct JSRuntime {
     JSMallocFunctions mf;
     JSMallocState malloc_state;
@@ -255,44 +248,28 @@ struct JSRuntime {
     JSClass *class_array;
 
     struct list_head context_list; /* list of JSContext.link */
-    /* list of JSGCObjectHeader.link. List of allocated GC objects (used
-       by the garbage collector) */
-    struct list_head gc_obj_list;
-    /* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */
-    struct list_head gc_zero_ref_count_list; 
-    struct list_head tmp_obj_list; /* used during GC */
-    JSGCPhaseEnum gc_phase : 8;
+    /* list of allocated objects (used by the garbage collector) */
+    struct list_head obj_list; /* list of JSObject.link */
     size_t malloc_gc_threshold;
 #ifdef DUMP_LEAKS
     struct list_head string_list; /* list of JSString.link */
 #endif
-    /* stack limitation */
-    uintptr_t stack_size; /* in bytes, 0 if no limit */
-    uintptr_t stack_top;
-    uintptr_t stack_limit; /* lower stack limit */
-    
-    JSValue current_exception;
-    /* true if inside an out of memory error, to avoid recursing */
-    BOOL in_out_of_memory : 8;
-
-    struct JSStackFrame *current_stack_frame;
+    struct list_head tmp_obj_list; /* used during gc */
+    struct list_head free_obj_list; /* used during gc */
+    struct list_head *el_next; /* used during gc */
 
     JSInterruptHandler *interrupt_handler;
     void *interrupt_opaque;
 
-    JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
-    void *host_promise_rejection_tracker_opaque;
-    
     struct list_head job_list; /* list of JSJobEntry.link */
 
     JSModuleNormalizeFunc *module_normalize_func;
     JSModuleLoaderFunc *module_loader_func;
     void *module_loader_opaque;
 
+    BOOL in_gc_sweep : 8;
     BOOL can_block : 8; /* TRUE if Atomics.wait can block */
-    /* used to allocate, free and clone SharedArrayBuffers */
-    JSSharedArrayBufferFunctions sab_funcs;
-    
+
     /* Shape hash table */
     int shape_hash_bits;
     int shape_hash_size;
@@ -300,12 +277,7 @@ struct JSRuntime {
     JSShape **shape_hash;
 #ifdef CONFIG_BIGNUM
     bf_context_t bf_ctx;
-    JSNumericOperations bigint_ops;
-    JSNumericOperations bigfloat_ops;
-    JSNumericOperations bigdecimal_ops;
-    uint32_t operator_count;
 #endif
-    void *user_opaque;
 };
 
 struct JSClass {
@@ -320,7 +292,8 @@ struct JSClass {
 
 #define JS_MODE_STRICT (1 << 0)
 #define JS_MODE_STRIP  (1 << 1)
-#define JS_MODE_MATH   (1 << 2)
+#define JS_MODE_BIGINT (1 << 2)
+#define JS_MODE_MATH   (1 << 3)
 
 typedef struct JSStackFrame {
     struct JSStackFrame *prev_frame; /* NULL if first stack frame */
@@ -331,50 +304,23 @@ typedef struct JSStackFrame {
     const uint8_t *cur_pc; /* only used in bytecode functions : PC of the
                         instruction after the call */
     int arg_count;
-    int js_mode; /* 0 or JS_MODE_MATH for C functions */
+    int js_mode; /* for C functions: 0 */
     /* only used in generators. Current stack pointer value. NULL if
        the function is running. */ 
     JSValue *cur_sp;
 } JSStackFrame;
 
-typedef enum {
-    JS_GC_OBJ_TYPE_JS_OBJECT,
-    JS_GC_OBJ_TYPE_FUNCTION_BYTECODE,
-    JS_GC_OBJ_TYPE_SHAPE,
-    JS_GC_OBJ_TYPE_VAR_REF,
-    JS_GC_OBJ_TYPE_ASYNC_FUNCTION,
-    JS_GC_OBJ_TYPE_JS_CONTEXT,
-} JSGCObjectTypeEnum;
-
-/* header for GC objects. GC objects are C data structures with a
-   reference count that can reference other GC objects. JS Objects are
-   a particular type of GC object. */
-struct JSGCObjectHeader {
-    int ref_count; /* must come first, 32-bit */
-    JSGCObjectTypeEnum gc_obj_type : 4;
-    uint8_t mark : 4; /* used by the GC */
-    uint8_t dummy1; /* not used by the GC */
-    uint16_t dummy2; /* not used by the GC */
-    struct list_head link;
-};
+typedef struct JSGCHeader {
+    uint8_t mark;
+} JSGCHeader;
 
 typedef struct JSVarRef {
-    union {
-        JSGCObjectHeader header; /* must come first */
-        struct {
-            int __gc_ref_count; /* corresponds to header.ref_count */
-            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */
-
-            /* 0 : the JSVarRef is on the stack. header.link is an element
-               of JSStackFrame.var_ref_list.
-               1 : the JSVarRef is detached. header.link has the normal meanning 
-            */
-            uint8_t is_detached : 1; 
-            uint8_t is_arg : 1;
-            uint16_t var_idx; /* index of the corresponding function variable on
-                                 the stack */
-        };
-    };
+    JSRefCountHeader header; /* must come first, 32-bit */
+    JSGCHeader gc_header; /* must come after JSRefCountHeader, 8-bit */
+    uint8_t is_arg : 1;
+    int var_idx; /* index of the corresponding function variable on
+                    the stack */
+    struct list_head link; /* prev = NULL if no longer on the stack */
     JSValue *pvalue; /* pointer to the value, either on the stack or
                         to 'value' */
     JSValue value; /* used when the variable is no longer on the stack */
@@ -393,37 +339,35 @@ typedef struct JSBigFloat {
     JSRefCountHeader header; /* must come first, 32-bit */
     bf_t num;
 } JSBigFloat;
-
-typedef struct JSBigDecimal {
-    JSRefCountHeader header; /* must come first, 32-bit */
-    bfdec_t num;
-} JSBigDecimal;
 #endif
 
-typedef enum {
-    JS_AUTOINIT_ID_PROTOTYPE,
-    JS_AUTOINIT_ID_MODULE_NS,
-    JS_AUTOINIT_ID_PROP,
-} JSAutoInitIDEnum;
-
 /* must be large enough to have a negligible runtime cost and small
    enough to call the interrupt callback often. */
 #define JS_INTERRUPT_COUNTER_INIT 10000
 
 struct JSContext {
-    JSGCObjectHeader header; /* must come first */
     JSRuntime *rt;
     struct list_head link;
+    const uint8_t *stack_top;
+    size_t stack_size; /* in bytes */
 
+    JSValue current_exception;
+    /* true if a backtrace needs to be added to the current exception
+       (the backtrace generation cannot be done immediately in a bytecode
+       function) */
+    BOOL exception_needs_backtrace : 8;
+    /* true if inside an out of memory error, to avoid recursing */
+    BOOL in_out_of_memory : 8;
     uint16_t binary_object_count;
     int binary_object_size;
 
     JSShape *array_shape;   /* initial shape for Array objects */
 
+    JSStackFrame *current_stack_frame;
+
     JSValue *class_proto;
     JSValue function_proto;
     JSValue function_ctor;
-    JSValue array_ctor;
     JSValue regexp_ctor;
     JSValue promise_ctor;
     JSValue native_error_proto[JS_NATIVE_ERROR_COUNT];
@@ -440,8 +384,6 @@ struct JSContext {
 #ifdef CONFIG_BIGNUM
     bf_context_t *bf_ctx;   /* points to rt->bf_ctx, shared by all contexts */
     JSFloatEnv fp_env; /* global FP environment */
-    BOOL bignum_ext : 8; /* enable math mode */
-    BOOL allow_operator_overloading : 8;
 #endif
     /* when the counter reaches zero, JSRutime.interrupt_handler is called */
     int interrupt_counter;
@@ -509,17 +451,14 @@ typedef struct JSClosureVar {
     uint8_t is_arg : 1;
     uint8_t is_const : 1;
     uint8_t is_lexical : 1;
-    uint8_t var_kind : 4; /* see JSVarKindEnum */
-    /* 8 bits available */
+    uint8_t var_kind : 3; /* see JSVarKindEnum */
+    /* 9 bits available */
     uint16_t var_idx; /* is_local = TRUE: index to a normal variable of the
                     parent function. otherwise: index to a closure
                     variable of the parent function */
     JSAtom var_name;
 } JSClosureVar;
 
-#define ARG_SCOPE_INDEX 1
-#define ARG_SCOPE_END (-2)
-
 typedef struct JSVarScope {
     int parent;  /* index into fd->scopes of the enclosing scope */
     int first;   /* index into fd->vars of the last variable in this scope */
@@ -532,7 +471,6 @@ typedef enum {
     JS_VAR_NEW_FUNCTION_DECL, /* lexical var with async/generator
                                  function declaration */
     JS_VAR_CATCH,
-    JS_VAR_FUNCTION_NAME, /* function expression name */
     JS_VAR_PRIVATE_FIELD,
     JS_VAR_PRIVATE_METHOD,
     JS_VAR_PRIVATE_GETTER,
@@ -540,21 +478,12 @@ typedef enum {
     JS_VAR_PRIVATE_GETTER_SETTER, /* must come after JS_VAR_PRIVATE_SETTER */
 } JSVarKindEnum;
 
-/* XXX: could use a different structure in bytecode functions to save
-   memory */
 typedef struct JSVarDef {
     JSAtom var_name;
-    /* index into fd->scopes of this variable lexical scope */
-    int scope_level;
-    /* during compilation: 
-        - if scope_level = 0: scope in which the variable is defined
-        - if scope_level != 0: index into fd->vars of the next
-          variable in the same or enclosing lexical scope
-       in a bytecode function:
-       index into fd->vars of the next
-       variable in the same or enclosing lexical scope
-    */
-    int scope_next;    
+    int scope_level;   /* index into fd->scopes of this variable lexical scope */
+    int scope_next;    /* index into fd->vars of the next variable in the
+                        * same or enclosing lexical scope */
+    uint8_t is_func_var : 1; /* used for the function self reference */
     uint8_t is_const : 1;
     uint8_t is_lexical : 1;
     uint8_t is_captured : 1;
@@ -564,9 +493,7 @@ typedef struct JSVarDef {
        JS_VAR_FUNCTION_DECL/JS_VAR_NEW_FUNCTION_DECL or scope level of
        the definition of the 'var' variables (they have scope_level =
        0) */
-    int func_pool_idx : 24; /* only used during compilation : index in
-                               the constant pool for hoisted function
-                               definition */
+    int func_pool_or_scope_idx : 24; /* only used during compilation */
 } JSVarDef;
 
 /* for the encoding of the pc2line table */
@@ -583,7 +510,8 @@ typedef enum JSFunctionKindEnum {
 } JSFunctionKindEnum;
 
 typedef struct JSFunctionBytecode {
-    JSGCObjectHeader header; /* must come first */
+    JSRefCountHeader header; /* must come first, 32-bit */
+    JSGCHeader gc_header; /* must come after header, 8-bit */
     uint8_t js_mode;
     uint8_t has_prototype : 1; /* true if a prototype field is necessary */
     uint8_t has_simple_parameter_list : 1;
@@ -596,7 +524,6 @@ typedef struct JSFunctionBytecode {
     uint8_t super_allowed : 1;
     uint8_t arguments_allowed : 1;
     uint8_t has_debug : 1;
-    uint8_t backtrace_barrier : 1; /* stop backtrace on this function */
     uint8_t read_only_bytecode : 1;
     /* XXX: 4 bits available */
     uint8_t *byte_code_buf; /* (self pointer) */
@@ -608,7 +535,6 @@ typedef struct JSFunctionBytecode {
     uint16_t var_count;
     uint16_t defined_arg_count; /* for length function property */
     uint16_t stack_size; /* maximum stack size */
-    JSContext *realm; /* function realm */
     JSValue *cpool; /* constant pool (self pointer) */
     int cpool_count;
     int closure_var_count;
@@ -651,6 +577,7 @@ typedef struct JSRegExp {
 typedef struct JSProxyData {
     JSValue target;
     JSValue handler;
+    JSValue proto;
     uint8_t is_func;
     uint8_t is_revoked;
 } JSProxyData;
@@ -683,59 +610,13 @@ typedef struct JSAsyncFunctionState {
 /* XXX: could use an object instead to avoid the
    JS_TAG_ASYNC_FUNCTION tag for the GC */
 typedef struct JSAsyncFunctionData {
-    JSGCObjectHeader header; /* must come first */
+    JSRefCountHeader header; /* must come first, 32-bit */
+    JSGCHeader gc_header; /* must come after JSRefCountHeader, 8-bit */
     JSValue resolving_funcs[2];
     BOOL is_active; /* true if the async function state is valid */
     JSAsyncFunctionState func_state;
 } JSAsyncFunctionData;
 
-typedef enum {
-   /* binary operators */
-   JS_OVOP_ADD,
-   JS_OVOP_SUB,
-   JS_OVOP_MUL,
-   JS_OVOP_DIV,
-   JS_OVOP_MOD,
-   JS_OVOP_POW,
-   JS_OVOP_OR,
-   JS_OVOP_AND,
-   JS_OVOP_XOR,
-   JS_OVOP_SHL,
-   JS_OVOP_SAR,
-   JS_OVOP_SHR,
-   JS_OVOP_EQ,
-   JS_OVOP_LESS,
-
-   JS_OVOP_BINARY_COUNT,
-   /* unary operators */
-   JS_OVOP_POS = JS_OVOP_BINARY_COUNT,
-   JS_OVOP_NEG,
-   JS_OVOP_INC,
-   JS_OVOP_DEC,
-   JS_OVOP_NOT,
-
-   JS_OVOP_COUNT,
-} JSOverloadableOperatorEnum;
-
-typedef struct {
-    uint32_t operator_index;
-    JSObject *ops[JS_OVOP_BINARY_COUNT]; /* self operators */
-} JSBinaryOperatorDefEntry;
-
-typedef struct {
-    int count;
-    JSBinaryOperatorDefEntry *tab;
-} JSBinaryOperatorDef;
-
-typedef struct {
-    uint32_t operator_counter;
-    BOOL is_primitive; /* OperatorSet for a primitive type */
-    /* NULL if no operator is defined */
-    JSObject *self_ops[JS_OVOP_COUNT]; /* self operators */
-    JSBinaryOperatorDef left;
-    JSBinaryOperatorDef right;
-} JSOperatorSetData;
-
 typedef struct JSReqModuleEntry {
     JSAtom module_name;
     JSModuleDef *module; /* used using resolution */
@@ -795,7 +676,6 @@ struct JSModuleDef {
     JSValue func_obj; /* only used for JS modules */
     JSModuleInitFunc *init_func; /* only used for C modules */
     BOOL resolved : 8;
-    BOOL func_created : 8;
     BOOL instantiated : 8;
     BOOL evaluated : 8;
     BOOL eval_mark : 8; /* temporary use during js_evaluate_module() */
@@ -823,10 +703,8 @@ typedef struct JSProperty {
         } getset;
         JSVarRef *var_ref;  /* JS_PROP_VARREF */
         struct {            /* JS_PROP_AUTOINIT */
-            /* in order to use only 2 pointers, we compress the realm
-               and the init function pointer */
-            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)
-                                       in the 2 low bits */
+            int (*init_func)(JSContext *ctx, JSObject *obj,
+                             JSAtom prop, void *opaque);
             void *opaque;
         } init;
     } u;
@@ -842,10 +720,19 @@ typedef struct JSShapeProperty {
     JSAtom atom; /* JS_ATOM_NULL = free property entry */
 } JSShapeProperty;
 
+#ifdef _MSC_VER
+#define JSSHAPE_HASH_OFFSET(ptr, offset) (((uint32_t *)(ptr))+(offset))
+#else
+#define JSSHAPE_HASH_OFFSET(ptr, offset) ((ptr)->prop_hash_end[offset])
+#endif
+
 struct JSShape {
-    /* hash table of size hash_mask + 1 before the start of the
-       structure (see prop_hash_end()). */
-    JSGCObjectHeader header;
+#ifndef _MSC_VER
+	uint32_t prop_hash_end[0]; /* hash table of size hash_mask + 1
+                                  before the start of the structure. */
+#endif
+    JSRefCountHeader header; /* must come first, 32-bit */
+    JSGCHeader gc_header; /* must come after JSRefCountHeader, 8-bit */
     /* true if the shape is inserted in the shape hash table. If not,
        JSShape.hash is not valid */
     uint8_t is_hashed;
@@ -856,31 +743,25 @@ struct JSShape {
     uint32_t hash; /* current hash value */
     uint32_t prop_hash_mask;
     int prop_size; /* allocated properties */
-    int prop_count; /* include deleted properties */
-    int deleted_prop_count;
+    int prop_count;
     JSShape *shape_hash_next; /* in JSRuntime.shape_hash[h] list */
     JSObject *proto;
     JSShapeProperty prop[0]; /* prop_size elements */
 };
-
 struct JSObject {
-    union {
-        JSGCObjectHeader header;
-        struct {
-            int __gc_ref_count; /* corresponds to header.ref_count */
-            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */
-            
-            uint8_t extensible : 1;
-            uint8_t free_mark : 1; /* only used when freeing objects with cycles */
-            uint8_t is_exotic : 1; /* TRUE if object has exotic property handlers */
-            uint8_t fast_array : 1; /* TRUE if u.array is used for get/put (for JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS and typed arrays) */
-            uint8_t is_constructor : 1; /* TRUE if object is a constructor function */
-            uint8_t is_uncatchable_error : 1; /* if TRUE, error is not catchable */
-            uint8_t tmp_mark : 1; /* used in JS_WriteObjectRec() */
-            uint8_t is_HTMLDDA : 1; /* specific annex B IsHtmlDDA behavior */
-            uint16_t class_id; /* see JS_CLASS_x */
-        };
-    };
+    JSRefCountHeader header; /* must come first, 32-bit */
+    JSGCHeader gc_header; /* must come after JSRefCountHeader, 8-bit */
+    uint8_t extensible : 1;
+    uint8_t free_mark : 1; /* only used when freeing objects with cycles */
+    uint8_t is_exotic : 1; /* TRUE if object has exotic property handlers */
+    uint8_t fast_array : 1; /* TRUE if u.array is used for get/put */
+    uint8_t is_constructor : 1; /* TRUE if object is a constructor function */
+    uint8_t is_uncatchable_error : 1; /* if TRUE, error is not catchable */
+    uint8_t is_class : 1; /* TRUE if object is a class constructor */
+    uint8_t tmp_mark : 1; /* used in JS_WriteObjectRec() */
+    uint16_t class_id; /* see JS_CLASS_x */
+    /* byte offsets: 8/8 */
+    struct list_head link; /* object list */
     /* byte offsets: 16/24 */
     JSShape *shape; /* prototype and property names + flag */
     JSProperty *prop; /* array of properties */
@@ -896,7 +777,6 @@ struct JSObject {
         struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_DATAVIEW */
 #ifdef CONFIG_BIGNUM
         struct JSFloatEnv *float_env; /* JS_CLASS_FLOAT_ENV */
-        struct JSOperatorSetData *operator_set; /* JS_CLASS_OPERATOR_SET */
 #endif
         struct JSMapState *map_state;   /* JS_CLASS_MAP..JS_CLASS_WEAKSET */
         struct JSMapIteratorData *map_iterator_data; /* JS_CLASS_MAP_ITERATOR, JS_CLASS_SET_ITERATOR */
@@ -915,8 +795,7 @@ struct JSObject {
             JSVarRef **var_refs;
             JSObject *home_object; /* for 'super' access */
         } func;
-        struct { /* JS_CLASS_C_FUNCTION: 12/20 bytes */
-            JSContext *realm;
+        struct { /* JS_CLASS_C_FUNCTION: 8/12 bytes */
             JSCFunctionType c_function;
             uint8_t length;
             uint8_t cproto;
@@ -950,7 +829,7 @@ struct JSObject {
     /* byte sizes: 40/48/72 */
 };
 enum {
-    __JS_ATOM_NULL = JS_ATOM_NULL,
+    JS_ATOM_NULL,
 #define DEF(name, str) JS_ATOM_ ## name,
 #include "quickjs-atom.h"
 #undef DEF
@@ -973,7 +852,7 @@ typedef enum OPCodeFormat {
 #undef FMT
 } OPCodeFormat;
 
-enum OPCodeEnum {
+typedef enum OPCodeEnum {
 #define FMT(f)
 #define DEF(id, size, n_pop, n_push, f) OP_ ## id,
 #define def(id, size, n_pop, n_push, f)
@@ -993,19 +872,13 @@ enum OPCodeEnum {
 #undef DEF
 #undef FMT
     OP_TEMP_END,
-};
+} OPCodeEnum;
 
 static int JS_InitAtoms(JSRuntime *rt);
 static JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,
                                int atom_type);
 static void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p);
 static void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b);
-static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
-                                  JSValueConst this_obj,
-                                  int argc, JSValueConst *argv, int flags);
-static JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,
-                                      JSValueConst this_obj,
-                                      int argc, JSValueConst *argv, int flags);
 static JSValue JS_CallInternal(JSContext *ctx, JSValueConst func_obj,
                                JSValueConst this_obj, JSValueConst new_target,
                                int argc, JSValue *argv, int flags);
@@ -1018,16 +891,21 @@ static JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_o
 static JSValue JS_InvokeFree(JSContext *ctx, JSValue this_val, JSAtom atom,
                              int argc, JSValueConst *argv);
 static __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,
-                                            JSValue val, BOOL is_array_ctor);
+                                            JSValue val);
 static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
                              JSValueConst val, int flags, int scope_idx);
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
+
+JSValue
+#ifndef _MSC_VER
+__attribute__((format(printf, 2, 3)))
+#endif
+JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
+
 static __maybe_unused void JS_DumpAtoms(JSRuntime *rt);
 static __maybe_unused void JS_DumpString(JSRuntime *rt,
                                                   const JSString *p);
 static __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt);
 static __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p);
-static __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p);
 static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
                                                       JSValueConst val);
 static __maybe_unused void JS_DumpValue(JSContext *ctx, JSValueConst val);
@@ -1043,9 +921,6 @@ static void js_array_mark(JSRuntime *rt, JSValueConst val,
 static void js_object_data_finalizer(JSRuntime *rt, JSValue val);
 static void js_object_data_mark(JSRuntime *rt, JSValueConst val,
                                 JS_MarkFunc *mark_func);
-static void js_c_function_finalizer(JSRuntime *rt, JSValue val);
-static void js_c_function_mark(JSRuntime *rt, JSValueConst val,
-                               JS_MarkFunc *mark_func);
 static void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val);
 static void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,
                                 JS_MarkFunc *mark_func);
@@ -1084,11 +959,10 @@ static void js_promise_mark(JSRuntime *rt, JSValueConst val,
 static void js_promise_resolve_function_finalizer(JSRuntime *rt, JSValue val);
 static void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,
                                 JS_MarkFunc *mark_func);
-#ifdef CONFIG_BIGNUM
-static void js_operator_set_finalizer(JSRuntime *rt, JSValue val);
-static void js_operator_set_mark(JSRuntime *rt, JSValueConst val,
-                                 JS_MarkFunc *mark_func);
-#endif
+static JSValue js_promise_resolve_function_call(JSContext *ctx,
+                                                JSValueConst func_obj,
+                                                JSValueConst this_val,
+                                                int argc, JSValueConst *argv);
 static JSValue JS_ToStringFree(JSContext *ctx, JSValue val);
 static int JS_ToBoolFree(JSContext *ctx, JSValue val);
 static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val);
@@ -1119,38 +993,22 @@ static JSProperty *add_property(JSContext *ctx,
                                 JSObject *p, JSAtom prop, int prop_flags);
 #ifdef CONFIG_BIGNUM
 static void js_float_env_finalizer(JSRuntime *rt, JSValue val);
-static JSValue JS_NewBigFloat(JSContext *ctx);
-static inline bf_t *JS_GetBigFloat(JSValueConst val)
-{
-    JSBigFloat *p = JS_VALUE_GET_PTR(val);
-    return &p->num;
-}
-static JSValue JS_NewBigDecimal(JSContext *ctx);
-static inline bfdec_t *JS_GetBigDecimal(JSValueConst val)
-{
-    JSBigDecimal *p = JS_VALUE_GET_PTR(val);
-    return &p->num;
-}
-static JSValue JS_NewBigInt(JSContext *ctx);
-static inline bf_t *JS_GetBigInt(JSValueConst val)
-{
-    JSBigFloat *p = JS_VALUE_GET_PTR(val);
-    return &p->num;
-}
-static JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,
-                                 BOOL convert_to_safe_integer);
-static JSValue JS_CompactBigInt(JSContext *ctx, JSValue val);
+static JSValue JS_NewBigFloat(JSContext *ctx, bf_t *a);
+static JSValue JS_NewBigInt2(JSContext *ctx, bf_t *a, BOOL force_bigint);
+static JSValue JS_NewBigInt(JSContext *ctx, bf_t *a);
 static int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val);
-static bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val);
-static void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf);
-static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val);
-static JSValue JS_ToBigDecimalFree(JSContext *ctx, JSValue val,
-                                   BOOL allow_null_or_undefined);
-static bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val);
+static bf_t *JS_ToBigFloat(JSContext *ctx, BOOL *pis_float, bf_t *buf,
+                           JSValueConst val);
 #endif
 JSValue JS_ThrowOutOfMemory(JSContext *ctx);
 static JSValue JS_ThrowTypeErrorRevokedProxy(JSContext *ctx);
-static JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj);
+static JSValue js_proxy_call(JSContext *ctx, JSValueConst func_obj,
+                             JSValueConst this_obj,
+                             int argc, JSValueConst *argv);
+static JSValue js_proxy_call_constructor(JSContext *ctx, JSValueConst func_obj,
+                                         JSValueConst new_target,
+                                         int argc, JSValueConst *argv);
+static JSValueConst js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj);
 static int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,
                                    JSValueConst proto_val, BOOL throw_flag);
 static int js_proxy_isExtensible(JSContext *ctx, JSValueConst obj);
@@ -1162,17 +1020,6 @@ static int JS_CreateProperty(JSContext *ctx, JSObject *p,
                              int flags);
 static int js_string_memcmp(const JSString *p1, const JSString *p2, int len);
 static void reset_weak_ref(JSRuntime *rt, JSObject *p);
-static JSValue js_array_buffer_constructor3(JSContext *ctx,
-                                            JSValueConst new_target,
-                                            uint64_t len, JSClassID class_id,
-                                            uint8_t *buf,
-                                            JSFreeArrayBufferDataFunc *free_func,
-                                            void *opaque, BOOL alloc_flag);
-static JSArrayBuffer *js_get_array_buffer(JSContext *ctx, JSValueConst obj);
-static JSValue js_typed_array_constructor(JSContext *ctx,
-                                          JSValueConst this_val,
-                                          int argc, JSValueConst *argv,
-                                          int classid);
 static BOOL typed_array_is_detached(JSContext *ctx, JSObject *p);
 static uint32_t typed_array_get_length(JSContext *ctx, JSObject *p);
 static JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx);
@@ -1180,8 +1027,7 @@ static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf, int var_idx,
                              BOOL is_arg);
 static JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,
                                           JSValueConst this_obj,
-                                          int argc, JSValueConst *argv,
-                                          int flags);
+                                          int argc, JSValueConst *argv);
 static void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val);
 static void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,
                                            JS_MarkFunc *mark_func);
@@ -1189,8 +1035,6 @@ static JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                                const char *input, size_t input_len,
                                const char *filename, int flags, int scope_idx);
 static void js_free_module_def(JSContext *ctx, JSModuleDef *m);
-static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
-                               JS_MarkFunc *mark_func);
 static JSValue js_import_meta(JSContext *ctx);
 static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
 static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);
@@ -1238,18 +1082,8 @@ static void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,
                                     JS_MarkFunc *mark_func);
 static JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,
                                        JSValueConst this_val,
-                                       int argc, JSValueConst *argv, int flags);
+                                       int argc, JSValueConst *argv);
 static JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val);
-static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
-                          JSGCObjectTypeEnum type);
-static void remove_gc_object(JSGCObjectHeader *h);
-static void js_async_function_free0(JSRuntime *rt, JSAsyncFunctionData *s);
-static JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);
-static JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
-                                 void *opaque);
-static JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,
-                                               JSAtom atom, void *opaque);
-void JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag);
 
 static const JSClassExoticMethods js_arguments_exotic_methods;
 static const JSClassExoticMethods js_string_exotic_methods;
@@ -1257,6 +1091,18 @@ static const JSClassExoticMethods js_proxy_exotic_methods;
 static const JSClassExoticMethods js_module_ns_exotic_methods;
 static JSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;
 
+JS_BOOL JS_IsNumber(JSValueConst v)
+{
+#ifdef CONFIG_BIGNUM
+    int tag = JS_VALUE_GET_TAG(v);
+    return tag == JS_TAG_INT || tag == JS_TAG_BIG_INT ||
+        tag == JS_TAG_BIG_FLOAT || JS_TAG_IS_FLOAT64(tag);
+#else
+    int tag = JS_VALUE_GET_TAG(v);
+    return tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag);
+#endif
+}
+
 static void js_trigger_gc(JSRuntime *rt, size_t size)
 {
     BOOL force_gc;
@@ -1399,42 +1245,11 @@ char *js_strdup(JSContext *ctx, const char *str)
     return js_strndup(ctx, str, strlen(str));
 }
 
-static no_inline int js_realloc_array(JSContext *ctx, void **parray,
-                                      int elem_size, int *psize, int req_size)
-{
-    int new_size;
-    size_t slack;
-    void *new_array;
-    /* XXX: potential arithmetic overflow */
-    new_size = max_int(req_size, *psize * 3 / 2);
-    new_array = js_realloc2(ctx, *parray, new_size * elem_size, &slack);
-    if (!new_array)
-        return -1;
-    new_size += slack / elem_size;
-    *psize = new_size;
-    *parray = new_array;
-    return 0;
-}
-
-/* resize the array and update its size if req_size > *psize */
-static inline int js_resize_array(JSContext *ctx, void **parray, int elem_size,
-                                  int *psize, int req_size)
-{
-    if (unlikely(req_size > *psize))
-        return js_realloc_array(ctx, parray, elem_size, psize, req_size);
-    else
-        return 0;
-}
-
 static inline void js_dbuf_init(JSContext *ctx, DynBuf *s)
 {
     dbuf_init2(s, ctx->rt, (DynBufReallocFunc *)js_realloc_rt);
 }
 
-static inline int is_digit(int c) {
-    return c >= '0' && c <= '9';
-}
-
 typedef struct JSClassShortDef {
     JSAtom class_name;
     JSClassFinalizer *finalizer;
@@ -1444,7 +1259,7 @@ typedef struct JSClassShortDef {
 static JSClassShortDef const js_std_class_def[] = {
     { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_OBJECT */
     { JS_ATOM_Array, js_array_finalizer, js_array_mark },       /* JS_CLASS_ARRAY */
-    { JS_ATOM_Error, NULL, NULL }, /* JS_CLASS_ERROR */
+    { JS_ATOM_Error, NULL, NULL },                              /* JS_CLASS_ERROR */
     { JS_ATOM_Number, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_NUMBER */
     { JS_ATOM_String, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_STRING */
     { JS_ATOM_Boolean, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_BOOLEAN */
@@ -1453,7 +1268,7 @@ static JSClassShortDef const js_std_class_def[] = {
     { JS_ATOM_Arguments, NULL, NULL },                          /* JS_CLASS_MAPPED_ARGUMENTS */
     { JS_ATOM_Date, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_DATE */
     { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_MODULE_NS */
-    { JS_ATOM_Function, js_c_function_finalizer, js_c_function_mark }, /* JS_CLASS_C_FUNCTION */
+    { JS_ATOM_Function, NULL, NULL },                           /* JS_CLASS_C_FUNCTION */
     { JS_ATOM_Function, js_bytecode_function_finalizer, js_bytecode_function_mark }, /* JS_CLASS_BYTECODE_FUNCTION */
     { JS_ATOM_Function, js_bound_function_finalizer, js_bound_function_mark }, /* JS_CLASS_BOUND_FUNCTION */
     { JS_ATOM_Function, js_c_function_data_finalizer, js_c_function_data_mark }, /* JS_CLASS_C_FUNCTION_DATA */
@@ -1480,8 +1295,6 @@ static JSClassShortDef const js_std_class_def[] = {
     { JS_ATOM_BigInt, js_object_data_finalizer, js_object_data_mark },      /* JS_CLASS_BIG_INT */
     { JS_ATOM_BigFloat, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_FLOAT */
     { JS_ATOM_BigFloatEnv, js_float_env_finalizer, NULL },      /* JS_CLASS_FLOAT_ENV */
-    { JS_ATOM_BigDecimal, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_DECIMAL */
-    { JS_ATOM_OperatorSet, js_operator_set_finalizer, js_operator_set_mark },    /* JS_CLASS_OPERATOR_SET */
 #endif
     { JS_ATOM_Map, js_map_finalizer, js_map_mark },             /* JS_CLASS_MAP */
     { JS_ATOM_Set, js_map_finalizer, js_map_mark },             /* JS_CLASS_SET */
@@ -1491,7 +1304,7 @@ static JSClassShortDef const js_std_class_def[] = {
     { JS_ATOM_Set_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_SET_ITERATOR */
     { JS_ATOM_Array_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_ARRAY_ITERATOR */
     { JS_ATOM_String_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_STRING_ITERATOR */
-    { JS_ATOM_RegExp_String_Iterator, js_regexp_string_iterator_finalizer, js_regexp_string_iterator_mark }, /* JS_CLASS_REGEXP_STRING_ITERATOR */
+    { JS_ATOM_RegExp_String_Iterator, js_regexp_string_iterator_finalizer, js_regexp_string_iterator_mark }, /* JS_CLASS_STRING_ITERATOR */
     { JS_ATOM_Generator, js_generator_finalizer, js_generator_mark }, /* JS_CLASS_GENERATOR */
 };
 
@@ -1512,90 +1325,6 @@ static int init_class_range(JSRuntime *rt, JSClassShortDef const *tab,
     return 0;
 }
 
-#ifdef CONFIG_BIGNUM
-static JSValue JS_ThrowUnsupportedOperation(JSContext *ctx)
-{
-    return JS_ThrowTypeError(ctx, "unsupported operation");
-}
-
-static JSValue invalid_to_string(JSContext *ctx, JSValueConst val)
-{
-    return JS_ThrowUnsupportedOperation(ctx);
-}
-
-static JSValue invalid_from_string(JSContext *ctx, const char *buf,
-                                   int radix, int flags, slimb_t *pexponent)
-{
-    return JS_NAN;
-}
-
-static int invalid_unary_arith(JSContext *ctx,
-                               JSValue *pres, OPCodeEnum op, JSValue op1)
-{
-    JS_FreeValue(ctx, op1);
-    JS_ThrowUnsupportedOperation(ctx);
-    return -1;
-}
-
-static int invalid_binary_arith(JSContext *ctx, OPCodeEnum op,
-                                JSValue *pres, JSValue op1, JSValue op2)
-{
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    JS_ThrowUnsupportedOperation(ctx);
-    return -1;
-}
-
-static JSValue invalid_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,
-                                            int64_t exponent)
-{
-    return JS_ThrowUnsupportedOperation(ctx);
-}
-
-static int invalid_mul_pow10(JSContext *ctx, JSValue *sp)
-{
-    JS_ThrowUnsupportedOperation(ctx);
-    return -1;
-}
-
-static void set_dummy_numeric_ops(JSNumericOperations *ops)
-{
-    ops->to_string = invalid_to_string;
-    ops->from_string = invalid_from_string;
-    ops->unary_arith = invalid_unary_arith;
-    ops->binary_arith = invalid_binary_arith;
-    ops->mul_pow10_to_float64 = invalid_mul_pow10_to_float64;
-    ops->mul_pow10 = invalid_mul_pow10;
-}
-
-#endif /* CONFIG_BIGNUM */
-
-#if !defined(CONFIG_STACK_CHECK)
-/* no stack limitation */
-static inline uintptr_t js_get_stack_pointer(void)
-{
-    return 0;
-}
-
-static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
-{
-    return FALSE;
-}
-#else
-/* Note: OS and CPU dependent */
-static inline uintptr_t js_get_stack_pointer(void)
-{
-    return (uintptr_t)__builtin_frame_address(0);
-}
-
-static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
-{
-    uintptr_t sp;
-    sp = js_get_stack_pointer() - alloca_size;
-    return unlikely(sp < rt->stack_limit);
-}
-#endif
-
 JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque)
 {
     JSRuntime *rt;
@@ -1619,16 +1348,10 @@ JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque)
 
 #ifdef CONFIG_BIGNUM
     bf_context_init(&rt->bf_ctx, js_bf_realloc, rt);
-    set_dummy_numeric_ops(&rt->bigint_ops);
-    set_dummy_numeric_ops(&rt->bigfloat_ops);
-    set_dummy_numeric_ops(&rt->bigdecimal_ops);
 #endif
 
     init_list_head(&rt->context_list);
-    init_list_head(&rt->gc_obj_list);
-    init_list_head(&rt->gc_zero_ref_count_list);
-    rt->gc_phase = JS_GC_PHASE_NONE;
-    
+    init_list_head(&rt->obj_list);
 #ifdef DUMP_LEAKS
     init_list_head(&rt->string_list);
 #endif
@@ -1645,34 +1368,16 @@ JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque)
     rt->class_array[JS_CLASS_STRING].exotic = &js_string_exotic_methods;
     rt->class_array[JS_CLASS_MODULE_NS].exotic = &js_module_ns_exotic_methods;
 
-    rt->class_array[JS_CLASS_C_FUNCTION].call = js_call_c_function;
     rt->class_array[JS_CLASS_C_FUNCTION_DATA].call = js_c_function_data_call;
-    rt->class_array[JS_CLASS_BOUND_FUNCTION].call = js_call_bound_function;
     rt->class_array[JS_CLASS_GENERATOR_FUNCTION].call = js_generator_function_call;
     if (init_shape_hash(rt))
         goto fail;
-
-    rt->stack_size = JS_DEFAULT_STACK_SIZE;
-    JS_UpdateStackTop(rt);
-
-    rt->current_exception = JS_NULL;
-
     return rt;
  fail:
     JS_FreeRuntime(rt);
     return NULL;
 }
 
-void *JS_GetRuntimeOpaque(JSRuntime *rt)
-{
-    return rt->user_opaque;
-}
-
-void JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque)
-{
-    rt->user_opaque = opaque;
-}
-
 /* default memory allocation functions with memory limitation */
 static inline size_t js_def_malloc_usable_size(void *ptr)
 {
@@ -1795,12 +1500,6 @@ void JS_SetCanBlock(JSRuntime *rt, BOOL can_block)
     rt->can_block = can_block;
 }
 
-void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
-                                      const JSSharedArrayBufferFunctions *sf)
-{
-    rt->sab_funcs = *sf;
-}
-
 /* return 0 if OK, < 0 if exception */
 int JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func,
                   int argc, JSValueConst *argv)
@@ -1929,7 +1628,10 @@ void JS_FreeRuntime(JSRuntime *rt)
     struct list_head *el, *el1;
     int i;
 
-    JS_FreeValueRT(rt, rt->current_exception);
+    list_for_each_safe(el, el1, &rt->context_list) {
+        JSContext *ctx = list_entry(el, JSContext, link);
+        JS_FreeContext(ctx);
+    }
 
     list_for_each_safe(el, el1, &rt->job_list) {
         JSJobEntry *e = list_entry(el, JSJobEntry, link);
@@ -1945,34 +1647,34 @@ void JS_FreeRuntime(JSRuntime *rt)
     /* leaking objects */
     {
         BOOL header_done;
-        JSGCObjectHeader *p;
+        JSObject *p;
         int count;
 
         /* remove the internal refcounts to display only the object
            referenced externally */
-        list_for_each(el, &rt->gc_obj_list) {
-            p = list_entry(el, JSGCObjectHeader, link);
-            p->mark = 0;
+        list_for_each(el, &rt->obj_list) {
+            p = list_entry(el, JSObject, link);
+            p->gc_header.mark = 0;
         }
         gc_decref(rt);
 
         header_done = FALSE;
-        list_for_each(el, &rt->gc_obj_list) {
-            p = list_entry(el, JSGCObjectHeader, link);
-            if (p->ref_count != 0) {
+        list_for_each(el, &rt->obj_list) {
+            p = list_entry(el, JSObject, link);
+            if (p->header.ref_count != 0) {
                 if (!header_done) {
                     printf("Object leaks:\n");
                     JS_DumpObjectHeader(rt);
                     header_done = TRUE;
                 }
-                JS_DumpGCObject(rt, p);
+                JS_DumpObject(rt, p);
             }
         }
 
         count = 0;
-        list_for_each(el, &rt->gc_obj_list) {
-            p = list_entry(el, JSGCObjectHeader, link);
-            if (p->ref_count == 0) {
+        list_for_each(el, &rt->obj_list) {
+            p = list_entry(el, JSObject, link);
+            if (p->header.ref_count == 0) {
                 count++;
             }
         }
@@ -1980,7 +1682,7 @@ void JS_FreeRuntime(JSRuntime *rt)
             printf("Secondary object leaks: %d\n", count);
     }
 #endif
-    assert(list_empty(&rt->gc_obj_list));
+    assert(list_empty(&rt->obj_list));
 
     /* free the classes */
     for(i = 0; i < rt->class_count; i++) {
@@ -2112,6 +1814,32 @@ void JS_FreeRuntime(JSRuntime *rt)
     }
 }
 
+#if defined(EMSCRIPTEN) || defined(_MSC_VER)
+/* currently no stack limitation */
+static inline uint8_t *js_get_stack_pointer(void)
+{
+    return NULL;
+}
+
+static inline BOOL js_check_stack_overflow(JSContext *ctx, size_t alloca_size)
+{
+    return FALSE;
+}
+#else
+/* Note: OS and CPU dependent */
+static inline uint8_t *js_get_stack_pointer(void)
+{
+    return __builtin_frame_address(0);
+}
+
+static inline BOOL js_check_stack_overflow(JSContext *ctx, size_t alloca_size)
+{
+    size_t size;
+    size = ctx->stack_top - js_get_stack_pointer();
+    return unlikely((size + alloca_size) > ctx->stack_size);
+}
+#endif
+
 JSContext *JS_NewContextRaw(JSRuntime *rt)
 {
     JSContext *ctx;
@@ -2120,9 +1848,6 @@ JSContext *JS_NewContextRaw(JSRuntime *rt)
     ctx = js_mallocz_rt(rt, sizeof(JSContext));
     if (!ctx)
         return NULL;
-    ctx->header.ref_count = 1;
-    add_gc_object(rt, &ctx->header, JS_GC_OBJ_TYPE_JS_CONTEXT);
-
     ctx->class_proto = js_malloc_rt(rt, sizeof(ctx->class_proto[0]) *
                                     rt->class_count);
     if (!ctx->class_proto) {
@@ -2131,14 +1856,16 @@ JSContext *JS_NewContextRaw(JSRuntime *rt)
     }
     ctx->rt = rt;
     list_add_tail(&ctx->link, &rt->context_list);
+    ctx->stack_top = js_get_stack_pointer();
+    ctx->stack_size = JS_DEFAULT_STACK_SIZE;
+    ctx->current_exception = JS_NULL;
 #ifdef CONFIG_BIGNUM
     ctx->bf_ctx = &rt->bf_ctx;
-    ctx->fp_env.prec = 113;
-    ctx->fp_env.flags = bf_set_exp_bits(15) | BF_RNDN | BF_FLAG_SUBNORMAL;
+    ctx->fp_env.prec = 53;
+    ctx->fp_env.flags = bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL;
 #endif
     for(i = 0; i < rt->class_count; i++)
         ctx->class_proto[i] = JS_NULL;
-    ctx->array_ctor = JS_NULL;
     ctx->regexp_ctor = JS_NULL;
     ctx->promise_ctor = JS_NULL;
     init_list_head(&ctx->loaded_modules);
@@ -2165,9 +1892,7 @@ JSContext *JS_NewContext(JSRuntime *rt)
     JS_AddIntrinsicMapSet(ctx);
     JS_AddIntrinsicTypedArrays(ctx);
     JS_AddIntrinsicPromise(ctx);
-#ifdef CONFIG_BIGNUM
-    JS_AddIntrinsicBigInt(ctx);
-#endif
+
     return ctx;
 }
 
@@ -2225,60 +1950,11 @@ static void js_free_modules(JSContext *ctx, JSFreeModuleEnum flag)
     }
 }
 
-JSContext *JS_DupContext(JSContext *ctx)
-{
-    ctx->header.ref_count++;
-    return ctx;
-}
-
-/* used by the GC */
-static void JS_MarkContext(JSRuntime *rt, JSContext *ctx,
-                           JS_MarkFunc *mark_func)
-{
-    int i;
-    struct list_head *el;
-
-    /* modules are not seen by the GC, so we directly mark the objects
-       referenced by each module */
-    list_for_each(el, &ctx->loaded_modules) {
-        JSModuleDef *m = list_entry(el, JSModuleDef, link);
-        js_mark_module_def(rt, m, mark_func);
-    }
-
-    JS_MarkValue(rt, ctx->global_obj, mark_func);
-    JS_MarkValue(rt, ctx->global_var_obj, mark_func);
-
-    JS_MarkValue(rt, ctx->throw_type_error, mark_func);
-    JS_MarkValue(rt, ctx->eval_obj, mark_func);
-
-    JS_MarkValue(rt, ctx->array_proto_values, mark_func);
-    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
-        JS_MarkValue(rt, ctx->native_error_proto[i], mark_func);
-    }
-    for(i = 0; i < rt->class_count; i++) {
-        JS_MarkValue(rt, ctx->class_proto[i], mark_func);
-    }
-    JS_MarkValue(rt, ctx->iterator_proto, mark_func);
-    JS_MarkValue(rt, ctx->async_iterator_proto, mark_func);
-    JS_MarkValue(rt, ctx->promise_ctor, mark_func);
-    JS_MarkValue(rt, ctx->array_ctor, mark_func);
-    JS_MarkValue(rt, ctx->regexp_ctor, mark_func);
-    JS_MarkValue(rt, ctx->function_ctor, mark_func);
-    JS_MarkValue(rt, ctx->function_proto, mark_func);
-
-    if (ctx->array_shape)
-        mark_func(rt, &ctx->array_shape->header);
-}
-
 void JS_FreeContext(JSContext *ctx)
 {
     JSRuntime *rt = ctx->rt;
     int i;
 
-    if (--ctx->header.ref_count > 0)
-        return;
-    assert(ctx->header.ref_count == 0);
-    
 #ifdef DUMP_ATOMS
     JS_DumpAtoms(ctx->rt);
 #endif
@@ -2288,12 +1964,12 @@ void JS_FreeContext(JSContext *ctx)
 #ifdef DUMP_OBJECTS
     {
         struct list_head *el;
-        JSGCObjectHeader *p;
+        JSObject *p;
         printf("JSObjects: {\n");
         JS_DumpObjectHeader(ctx->rt);
-        list_for_each(el, &rt->gc_obj_list) {
-            p = list_entry(el, JSGCObjectHeader, link);
-            JS_DumpGCObject(rt, p);
+        list_for_each(el, &rt->obj_list) {
+            p = list_entry(el, JSObject, link);
+            JS_DumpObject(rt, p);
         }
         printf("}\n");
     }
@@ -2308,6 +1984,8 @@ void JS_FreeContext(JSContext *ctx)
 
     js_free_modules(ctx, JS_FREE_MODULE_ALL);
 
+    JS_FreeValue(ctx, ctx->current_exception);
+
     JS_FreeValue(ctx, ctx->global_obj);
     JS_FreeValue(ctx, ctx->global_var_obj);
 
@@ -2325,7 +2003,6 @@ void JS_FreeContext(JSContext *ctx)
     JS_FreeValue(ctx, ctx->iterator_proto);
     JS_FreeValue(ctx, ctx->async_iterator_proto);
     JS_FreeValue(ctx, ctx->promise_ctor);
-    JS_FreeValue(ctx, ctx->array_ctor);
     JS_FreeValue(ctx, ctx->regexp_ctor);
     JS_FreeValue(ctx, ctx->function_ctor);
     JS_FreeValue(ctx, ctx->function_proto);
@@ -2333,7 +2010,6 @@ void JS_FreeContext(JSContext *ctx)
     js_free_shape_null(ctx->rt, ctx->array_shape);
 
     list_del(&ctx->link);
-    remove_gc_object(&ctx->header);
     js_free_rt(ctx->rt, ctx);
 }
 
@@ -2342,40 +2018,58 @@ JSRuntime *JS_GetRuntime(JSContext *ctx)
     return ctx->rt;
 }
 
-static void update_stack_limit(JSRuntime *rt)
+void JS_SetMaxStackSize(JSContext *ctx, size_t stack_size)
 {
-    if (rt->stack_size == 0) {
-        rt->stack_limit = 0; /* no limit */
-    } else {
-        rt->stack_limit = rt->stack_top - rt->stack_size;
-    }
+    ctx->stack_size = stack_size;
 }
 
-void JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size)
+static inline BOOL is_strict_mode(JSContext *ctx)
 {
-    rt->stack_size = stack_size;
-    update_stack_limit(rt);
+    JSStackFrame *sf = ctx->current_stack_frame;
+    return (sf && (sf->js_mode & JS_MODE_STRICT));
 }
 
-void JS_UpdateStackTop(JSRuntime *rt)
+#ifdef CONFIG_BIGNUM
+static inline BOOL is_bignum_mode(JSContext *ctx)
 {
-    rt->stack_top = js_get_stack_pointer();
-    update_stack_limit(rt);
+    JSStackFrame *sf = ctx->current_stack_frame;
+    return (sf && (sf->js_mode & JS_MODE_BIGINT));
 }
+#endif
 
-static inline BOOL is_strict_mode(JSContext *ctx)
+JSValue JS_NewInt64(JSContext *ctx, int64_t v)
 {
-    JSStackFrame *sf = ctx->rt->current_stack_frame;
-    return (sf && (sf->js_mode & JS_MODE_STRICT));
+    if (v == (int32_t)v) {
+        return JS_NewInt32(ctx, v);
+    } else {
+#ifdef CONFIG_BIGNUM
+        if (is_bignum_mode(ctx)) {
+            bf_t a_s, *a = &a_s;
+            bf_init(ctx->bf_ctx, a);
+            bf_set_si(a, v);
+            return JS_NewBigInt(ctx, a);
+        } else
+#endif
+        {
+            return __JS_NewFloat64(ctx, (double)v);
+        }
+    }
 }
 
-#ifdef CONFIG_BIGNUM
-static inline BOOL is_math_mode(JSContext *ctx)
+static force_inline JSValue JS_NewUint32(JSContext *ctx, uint32_t val)
 {
-    JSStackFrame *sf = ctx->rt->current_stack_frame;
-    return (sf && (sf->js_mode & JS_MODE_MATH));
-}
+#ifdef CONFIG_BIGNUM
+    return JS_NewInt64(ctx, val);
+#else
+    JSValue v;
+    if (val <= 0x7fffffff) {
+        v = JS_MKVAL(JS_TAG_INT, val);
+    } else {
+        v = __JS_NewFloat64(ctx, val);
+    }
+    return v;
 #endif
+}
 
 /* JSAtom support */
 
@@ -2953,7 +2647,7 @@ JSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len)
 {
     JSValue val;
 
-    if (len == 0 || !is_digit(*str)) {
+    if (len == 0 || !isdigit(*str)) {
         JSAtom atom = __JS_FindAtom(ctx->rt, str, len, JS_ATOM_TYPE_STRING);
         if (atom)
             return atom;
@@ -3397,8 +3091,6 @@ static int JS_NewClass1(JSRuntime *rt, JSClassID class_id,
     JSClass *cl, *new_class_array;
     struct list_head *el;
 
-    if (class_id >= (1 << 16))
-        return -1;
     if (class_id < rt->class_count &&
         rt->class_array[class_id].class_id != 0)
         return -1;
@@ -4236,14 +3928,9 @@ static inline JSShape *get_shape_from_alloc(void *sh_alloc, size_t hash_size)
     return (JSShape *)(void *)((uint32_t *)sh_alloc + hash_size);
 }
 
-static inline uint32_t *prop_hash_end(JSShape *sh)
-{
-    return (uint32_t *)sh;
-}
-
 static inline void *get_alloc_from_shape(JSShape *sh)
 {
-    return prop_hash_end(sh) - ((intptr_t)sh->prop_hash_mask + 1);
+    return JSSHAPE_HASH_OFFSET(sh, -((intptr_t)sh->prop_hash_mask + 1));
 }
 
 static inline JSShapeProperty *get_shape_prop(JSShape *sh)
@@ -4350,17 +4037,16 @@ static no_inline JSShape *js_new_shape2(JSContext *ctx, JSObject *proto,
         return NULL;
     sh = get_shape_from_alloc(sh_alloc, hash_size);
     sh->header.ref_count = 1;
-    add_gc_object(rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);
+    sh->gc_header.mark = 0;
     if (proto)
         JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, proto));
     sh->proto = proto;
-    memset(prop_hash_end(sh) - hash_size, 0, sizeof(prop_hash_end(sh)[0]) *
+    memset(JSSHAPE_HASH_OFFSET(sh, -(intptr_t)hash_size), 0, sizeof(uint32_t) *
            hash_size);
     sh->prop_hash_mask = hash_size - 1;
-    sh->prop_size = prop_size;
     sh->prop_count = 0;
-    sh->deleted_prop_count = 0;
-    
+    sh->prop_size = prop_size;
+
     /* insert in the hash table */
     sh->hash = shape_initial_hash(proto);
     sh->is_hashed = TRUE;
@@ -4394,7 +4080,7 @@ static JSShape *js_clone_shape(JSContext *ctx, JSShape *sh1)
     memcpy(sh_alloc, sh_alloc1, size);
     sh = get_shape_from_alloc(sh_alloc, hash_size);
     sh->header.ref_count = 1;
-    add_gc_object(ctx->rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);
+    sh->gc_header.mark = 0;
     sh->is_hashed = FALSE;
     if (sh->proto) {
         JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
@@ -4411,30 +4097,24 @@ static JSShape *js_dup_shape(JSShape *sh)
     return sh;
 }
 
-static void js_free_shape0(JSRuntime *rt, JSShape *sh)
+static void js_free_shape(JSRuntime *rt, JSShape *sh)
 {
     uint32_t i;
     JSShapeProperty *pr;
 
-    assert(sh->header.ref_count == 0);
-    if (sh->is_hashed)
-        js_shape_hash_unlink(rt, sh);
-    if (sh->proto != NULL) {
-        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
-    }
-    pr = get_shape_prop(sh);
-    for(i = 0; i < sh->prop_count; i++) {
-        JS_FreeAtomRT(rt, pr->atom);
-        pr++;
-    }
-    remove_gc_object(&sh->header);
-    js_free_rt(rt, get_alloc_from_shape(sh));
-}
-
-static void js_free_shape(JSRuntime *rt, JSShape *sh)
-{
     if (unlikely(--sh->header.ref_count <= 0)) {
-        js_free_shape0(rt, sh);
+        assert(sh->header.ref_count == 0);
+        if (sh->is_hashed)
+            js_shape_hash_unlink(rt, sh);
+        if (sh->proto != NULL) {
+            JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
+        }
+        pr = get_shape_prop(sh);
+        for(i = 0; i < sh->prop_count; i++) {
+            JS_FreeAtomRT(rt, pr->atom);
+            pr++;
+        }
+        js_free_rt(rt, get_alloc_from_shape(sh));
     }
 }
 
@@ -4476,109 +4156,36 @@ static no_inline int resize_properties(JSContext *ctx, JSShape **psh,
         if (!sh_alloc)
             return -1;
         sh = get_shape_from_alloc(sh_alloc, new_hash_size);
-        list_del(&old_sh->header.link);
         /* copy all the fields and the properties */
         memcpy(sh, old_sh,
                sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);
-        list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
         new_hash_mask = new_hash_size - 1;
         sh->prop_hash_mask = new_hash_mask;
-        memset(prop_hash_end(sh) - new_hash_size, 0,
-               sizeof(prop_hash_end(sh)[0]) * new_hash_size);
-        for(i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {
+
+				memset(JSSHAPE_HASH_OFFSET(sh, -(intptr_t)new_hash_size), 0,
+				   sizeof(uint32_t) * new_hash_size);
+
+				for(i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {
             if (pr->atom != JS_ATOM_NULL) {
                 h = ((uintptr_t)pr->atom & new_hash_mask);
-                pr->hash_next = prop_hash_end(sh)[-h - 1];
-                prop_hash_end(sh)[-h - 1] = i + 1;
+                pr->hash_next = *JSSHAPE_HASH_OFFSET(sh, -h - 1);
+                *JSSHAPE_HASH_OFFSET(sh, -h - 1) = i + 1;
             }
         }
         js_free(ctx, get_alloc_from_shape(old_sh));
     } else {
         /* only resize the properties */
-        list_del(&sh->header.link);
         sh_alloc = js_realloc(ctx, get_alloc_from_shape(sh),
                               get_shape_size(new_hash_size, new_size));
-        if (unlikely(!sh_alloc)) {
-            /* insert again in the GC list */
-            list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
+        if (unlikely(!sh_alloc))
             return -1;
-        }
         sh = get_shape_from_alloc(sh_alloc, new_hash_size);
-        list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
     }
     *psh = sh;
     sh->prop_size = new_size;
     return 0;
 }
 
-/* remove the deleted properties. */
-static int compact_properties(JSContext *ctx, JSObject *p)
-{
-    JSShape *sh, *old_sh;
-    void *sh_alloc;
-    intptr_t h;
-    uint32_t new_hash_size, i, j, new_hash_mask, new_size;
-    JSShapeProperty *old_pr, *pr;
-    JSProperty *prop, *new_prop;
-    
-    sh = p->shape;
-    assert(!sh->is_hashed);
-
-    new_size = max_int(JS_PROP_INITIAL_SIZE,
-                       sh->prop_count - sh->deleted_prop_count);
-    assert(new_size <= sh->prop_size);
-
-    new_hash_size = sh->prop_hash_mask + 1;
-    while ((new_hash_size / 2) >= new_size)
-        new_hash_size = new_hash_size / 2;
-    new_hash_mask = new_hash_size - 1;
-
-    /* resize the hash table and the properties */
-    old_sh = sh;
-    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));
-    if (!sh_alloc)
-        return -1;
-    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
-    list_del(&old_sh->header.link);
-    memcpy(sh, old_sh, sizeof(JSShape));
-    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
-    
-    memset(prop_hash_end(sh) - new_hash_size, 0,
-           sizeof(prop_hash_end(sh)[0]) * new_hash_size);
-
-    j = 0;
-    old_pr = old_sh->prop;
-    pr = sh->prop;
-    prop = p->prop;
-    for(i = 0; i < sh->prop_count; i++) {
-        if (old_pr->atom != JS_ATOM_NULL) {
-            pr->atom = old_pr->atom;
-            pr->flags = old_pr->flags;
-            h = ((uintptr_t)old_pr->atom & new_hash_mask);
-            pr->hash_next = prop_hash_end(sh)[-h - 1];
-            prop_hash_end(sh)[-h - 1] = j + 1;
-            prop[j] = prop[i];
-            j++;
-            pr++;
-        }
-        old_pr++;
-    }
-    assert(j == (sh->prop_count - sh->deleted_prop_count));
-    sh->prop_hash_mask = new_hash_mask;
-    sh->prop_size = new_size;
-    sh->deleted_prop_count = 0;
-    sh->prop_count = j;
-
-    p->shape = sh;
-    js_free(ctx, get_alloc_from_shape(old_sh));
-    
-    /* reduce the size of the object properties */
-    new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);
-    if (new_prop)
-        p->prop = new_prop;
-    return 0;
-}
-
 static int add_shape_property(JSContext *ctx, JSShape **psh,
                               JSObject *p, JSAtom atom, int prop_flags)
 {
@@ -4618,8 +4225,8 @@ static int add_shape_property(JSContext *ctx, JSShape **psh,
     /* add in hash table */
     hash_mask = sh->prop_hash_mask;
     h = atom & hash_mask;
-    pr->hash_next = prop_hash_end(sh)[-h - 1];
-    prop_hash_end(sh)[-h - 1] = sh->prop_count;
+    pr->hash_next = *JSSHAPE_HASH_OFFSET(sh, -h - 1);
+    *JSSHAPE_HASH_OFFSET(sh, -h - 1) = sh->prop_count;
     return 0;
 }
 
@@ -4697,8 +4304,7 @@ static __maybe_unused void JS_DumpShapes(JSRuntime *rt)
     JSShape *sh;
     struct list_head *el;
     JSObject *p;
-    JSGCObjectHeader *gp;
-    
+
     printf("JSShapes: {\n");
     printf("%5s %4s %14s %5s %5s %s\n", "SLOT", "REFS", "PROTO", "SIZE", "COUNT", "PROPS");
     for(i = 0; i < rt->shape_hash_size; i++) {
@@ -4708,13 +4314,10 @@ static __maybe_unused void JS_DumpShapes(JSRuntime *rt)
         }
     }
     /* dump non-hashed shapes */
-    list_for_each(el, &rt->gc_obj_list) {
-        gp = list_entry(el, JSGCObjectHeader, link);
-        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {
-            p = (JSObject *)gp;
-            if (!p->shape->is_hashed) {
-                JS_DumpShape(rt, -1, p->shape);
-            }
+    list_for_each(el, &rt->obj_list) {
+        p = list_entry(el, JSObject, link);
+        if (!p->shape->is_hashed) {
+            JS_DumpShape(rt, -1, p->shape);
         }
     }
     printf("}\n");
@@ -4728,6 +4331,8 @@ static JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID clas
     p = js_malloc(ctx, sizeof(JSObject));
     if (unlikely(!p))
         goto fail;
+    p->header.ref_count = 1;
+    p->gc_header.mark = 0;
     p->class_id = class_id;
     p->extensible = TRUE;
     p->free_mark = 0;
@@ -4735,8 +4340,8 @@ static JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID clas
     p->fast_array = 0;
     p->is_constructor = 0;
     p->is_uncatchable_error = 0;
+    p->is_class = 0;
     p->tmp_mark = 0;
-    p->is_HTMLDDA = 0;
     p->first_weak_ref = NULL;
     p->u.opaque = NULL;
     p->shape = sh;
@@ -4805,7 +4410,6 @@ static JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID clas
 #ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT:
     case JS_CLASS_BIG_FLOAT:
-    case JS_CLASS_BIG_DECIMAL:
 #endif
         p->u.object_data = JS_UNDEFINED;
         goto set_exotic;
@@ -4820,8 +4424,7 @@ static JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID clas
         }
         break;
     }
-    p->header.ref_count = 1;
-    add_gc_object(ctx->rt, &p->header, JS_GC_OBJ_TYPE_JS_OBJECT);
+    list_add_tail(&p->link, &ctx->rt->obj_list);
     return JS_MKPTR(JS_TAG_OBJECT, p);
 }
 
@@ -4868,7 +4471,6 @@ static JSValue JS_GetObjectData(JSContext *ctx, JSValueConst obj)
 #ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT:
         case JS_CLASS_BIG_FLOAT:
-        case JS_CLASS_BIG_DECIMAL:
 #endif
             return JS_DupValue(ctx, p->u.object_data);
         }
@@ -4892,7 +4494,6 @@ static int JS_SetObjectData(JSContext *ctx, JSValueConst obj, JSValue val)
 #ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT:
         case JS_CLASS_BIG_FLOAT:
-        case JS_CLASS_BIG_DECIMAL:
 #endif
             JS_FreeValue(ctx, p->u.object_data);
             p->u.object_data = val;
@@ -5031,7 +4632,6 @@ static JSValue JS_NewCFunction3(JSContext *ctx, JSCFunction *func,
     if (JS_IsException(func_obj))
         return func_obj;
     p = JS_VALUE_GET_OBJ(func_obj);
-    p->u.cfunc.realm = JS_DupContext(ctx);
     p->u.cfunc.c_function.generic = func;
     p->u.cfunc.length = length;
     p->u.cfunc.cproto = cproto;
@@ -5093,7 +4693,7 @@ static void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,
 
 static JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,
                                        JSValueConst this_val,
-                                       int argc, JSValueConst *argv, int flags)
+                                       int argc, JSValueConst *argv)
 {
     JSCFunctionDataRecord *s = JS_GetOpaque(func_obj, JS_CLASS_C_FUNCTION_DATA);
     JSValueConst *arg_buf;
@@ -5142,27 +4742,6 @@ JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
     return func_obj;
 }
 
-static JSContext *js_autoinit_get_realm(JSProperty *pr)
-{
-    return (JSContext *)(pr->u.init.realm_and_id & ~3);
-}
-
-static JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)
-{
-    return pr->u.init.realm_and_id & 3;
-}
-
-static void js_autoinit_free(JSRuntime *rt, JSProperty *pr)
-{
-    JS_FreeContext(js_autoinit_get_realm(pr));
-}
-
-static void js_autoinit_mark(JSRuntime *rt, JSProperty *pr,
-                             JS_MarkFunc *mark_func)
-{
-    mark_func(rt, &js_autoinit_get_realm(pr)->header);
-}
-
 static void free_property(JSRuntime *rt, JSProperty *pr, int prop_flags)
 {
     if (unlikely(prop_flags & JS_PROP_TMASK)) {
@@ -5174,7 +4753,7 @@ static void free_property(JSRuntime *rt, JSProperty *pr, int prop_flags)
         } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
             free_var_ref(rt, pr->u.var_ref);
         } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
-            js_autoinit_free(rt, pr);
+            /* nothing to do */
         }
     } else {
         JS_FreeValueRT(rt, pr->u.value);
@@ -5189,7 +4768,7 @@ static force_inline JSShapeProperty *find_own_property1(JSObject *p,
     intptr_t h;
     sh = p->shape;
     h = (uintptr_t)atom & sh->prop_hash_mask;
-    h = prop_hash_end(sh)[-h - 1];
+    h = *JSSHAPE_HASH_OFFSET(sh, -h - 1);
     prop = get_shape_prop(sh);
     while (h) {
         pr = &prop[h - 1];
@@ -5210,7 +4789,7 @@ static force_inline JSShapeProperty *find_own_property(JSProperty **ppr,
     intptr_t h;
     sh = p->shape;
     h = (uintptr_t)atom & sh->prop_hash_mask;
-    h = prop_hash_end(sh)[-h - 1];
+    h = *JSSHAPE_HASH_OFFSET(sh, -h - 1);
     prop = get_shape_prop(sh);
     while (h) {
         pr = &prop[h - 1];
@@ -5235,11 +4814,10 @@ static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref)
     if (var_ref) {
         assert(var_ref->header.ref_count > 0);
         if (--var_ref->header.ref_count == 0) {
-            if (var_ref->is_detached) {
-                JS_FreeValueRT(rt, var_ref->value);
-                remove_gc_object(&var_ref->header);
+            if (var_ref->link.prev != NULL) {
+                list_del(&var_ref->link); /* still on the stack */
             } else {
-                list_del(&var_ref->header.link); /* still on the stack */
+                JS_FreeValueRT(rt, var_ref->value);
             }
             js_free_rt(rt, var_ref);
         }
@@ -5282,23 +4860,6 @@ static void js_object_data_mark(JSRuntime *rt, JSValueConst val,
     JS_MarkValue(rt, p->u.object_data, mark_func);
 }
 
-static void js_c_function_finalizer(JSRuntime *rt, JSValue val)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(val);
-
-    if (p->u.cfunc.realm)
-        JS_FreeContext(p->u.cfunc.realm);
-}
-
-static void js_c_function_mark(JSRuntime *rt, JSValueConst val,
-                               JS_MarkFunc *mark_func)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(val);
-
-    if (p->u.cfunc.realm)
-        mark_func(rt, &p->u.cfunc.realm->header);
-}
-
 static void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val)
 {
     JSObject *p1, *p = JS_VALUE_GET_OBJ(val);
@@ -5338,8 +4899,9 @@ static void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,
         if (var_refs) {
             for(i = 0; i < b->closure_var_count; i++) {
                 JSVarRef *var_ref = var_refs[i];
-                if (var_ref && var_ref->is_detached) {
-                    mark_func(rt, &var_ref->header);
+                if (var_ref) {
+                    JS_MarkValue(rt, JS_MKPTR(JS_TAG_VAR_REF, var_ref),
+                                 mark_func);
                 }
             }
         }
@@ -5392,15 +4954,13 @@ static void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,
     JS_MarkValue(rt, it->obj, mark_func);
 }
 
-static void free_object(JSRuntime *rt, JSObject *p)
+static void free_object_struct(JSRuntime *rt, JSObject *p)
 {
     int i;
     JSClassFinalizer *finalizer;
     JSShape *sh;
     JSShapeProperty *pr;
 
-    p->free_mark = 1; /* used to tell the object is invalid when
-                         freeing cycles */
     /* free all the fields */
     sh = p->shape;
     pr = get_shape_prop(sh);
@@ -5409,8 +4969,6 @@ static void free_object(JSRuntime *rt, JSObject *p)
         pr++;
     }
     js_free_rt(rt, p->prop);
-    /* as an optimization we destroy the shape immediately without
-       putting it in gc_zero_ref_count_list */
     js_free_shape(rt, sh);
 
     /* fail safe */
@@ -5430,44 +4988,33 @@ static void free_object(JSRuntime *rt, JSObject *p)
     p->u.opaque = NULL;
     p->u.func.var_refs = NULL;
     p->u.func.home_object = NULL;
-
-    remove_gc_object(&p->header);
-    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && p->header.ref_count != 0) {
-        list_add_tail(&p->header.link, &rt->gc_zero_ref_count_list);
-    } else {
-        js_free_rt(rt, p);
-    }
 }
 
-static void free_gc_object(JSRuntime *rt, JSGCObjectHeader *gp)
+static void free_object2(JSRuntime *rt, JSObject *p)
 {
-    switch(gp->gc_obj_type) {
-    case JS_GC_OBJ_TYPE_JS_OBJECT:
-        free_object(rt, (JSObject *)gp);
-        break;
-    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
-        free_function_bytecode(rt, (JSFunctionBytecode *)gp);
-        break;
-    default:
-        abort();
+    if (p->free_mark) {
+        /* already freed (happen when freeing cycles) */
+        return;
+    }
+    /* indicate that the object is being freed */
+    p->free_mark = 1;
+
+    free_object_struct(rt, p);
+
+    /* remove from the global object list */
+    list_del(&p->link);
+    if (rt->in_gc_sweep) {
+        list_add_tail(&p->link, &rt->free_obj_list);
+    } else {
+        js_free_rt(rt, p);
     }
 }
 
-static void free_zero_refcount(JSRuntime *rt)
+static void free_object(JSRuntime *rt, JSObject *p)
 {
-    struct list_head *el;
-    JSGCObjectHeader *p;
-    
-    rt->gc_phase = JS_GC_PHASE_DECREF;
-    for(;;) {
-        el = rt->gc_zero_ref_count_list.next;
-        if (el == &rt->gc_zero_ref_count_list)
-            break;
-        p = list_entry(el, JSGCObjectHeader, link);
-        assert(p->ref_count == 0);
-        free_gc_object(rt, p);
-    }
-    rt->gc_phase = JS_GC_PHASE_NONE;
+    assert(p->header.ref_count == 0);
+    if (!rt->in_gc_sweep)
+        free_object2(rt, p);
 }
 
 /* called with the ref_count of 'v' reaches zero. */
@@ -5502,18 +5049,14 @@ void __JS_FreeValueRT(JSRuntime *rt, JSValue v)
         }
         break;
     case JS_TAG_OBJECT:
+        free_object(rt, JS_VALUE_GET_OBJ(v));
+        break;
     case JS_TAG_FUNCTION_BYTECODE:
-        {
-            JSGCObjectHeader *p = JS_VALUE_GET_PTR(v);
-            if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {
-                list_del(&p->link);
-                list_add(&p->link, &rt->gc_zero_ref_count_list);
-                if (rt->gc_phase == JS_GC_PHASE_NONE) {
-                    free_zero_refcount(rt);
-                }
-            }
-        }
+        free_function_bytecode(rt, JS_VALUE_GET_PTR(v));
         break;
+    case JS_TAG_SHAPE:
+    case JS_TAG_ASYNC_FUNCTION:
+    case JS_TAG_VAR_REF:
     case JS_TAG_MODULE:
         abort(); /* never freed here */
         break;
@@ -5526,13 +5069,6 @@ void __JS_FreeValueRT(JSRuntime *rt, JSValue v)
             js_free_rt(rt, bf);
         }
         break;
-    case JS_TAG_BIG_DECIMAL:
-        {
-            JSBigDecimal *bf = JS_VALUE_GET_PTR(v);
-            bfdec_delete(&bf->num);
-            js_free_rt(rt, bf);
-        }
-        break;
 #endif
     case JS_TAG_SYMBOL:
         {
@@ -5553,45 +5089,38 @@ void __JS_FreeValue(JSContext *ctx, JSValue v)
 
 /* garbage collection */
 
-static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
-                          JSGCObjectTypeEnum type)
+static BOOL has_children(JSValueConst val)
 {
-    h->mark = 0;
-    h->gc_obj_type = type;
-    list_add_tail(&h->link, &rt->gc_obj_list);
-}
-
-static void remove_gc_object(JSGCObjectHeader *h)
-{
-    list_del(&h->link);
+    switch(JS_VALUE_GET_TAG(val)) {
+    case JS_TAG_VAR_REF:
+    case JS_TAG_OBJECT:
+    case JS_TAG_FUNCTION_BYTECODE:
+    case JS_TAG_ASYNC_FUNCTION:
+    case JS_TAG_SHAPE:
+        return TRUE;
+    default:
+        return FALSE;
+    }
 }
 
 void JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)
 {
-    if (JS_VALUE_HAS_REF_COUNT(val)) {
-        switch(JS_VALUE_GET_TAG(val)) {
-        case JS_TAG_OBJECT:
-        case JS_TAG_FUNCTION_BYTECODE:
-            mark_func(rt, JS_VALUE_GET_PTR(val));
-            break;
-        default:
-            break;
-        }
+    if (JS_VALUE_HAS_REF_COUNT(val) && has_children(val)) {
+        mark_func(rt, val);
     }
 }
 
-static void mark_children(JSRuntime *rt, JSGCObjectHeader *gp,
-                          JS_MarkFunc *mark_func)
+static void mark_children(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)
 {
-    switch(gp->gc_obj_type) {
-    case JS_GC_OBJ_TYPE_JS_OBJECT:
+    switch(JS_VALUE_GET_TAG(val)) {
+    case JS_TAG_OBJECT:
         {
-            JSObject *p = (JSObject *)gp;
+            JSObject *p = JS_VALUE_GET_OBJ(val);
             JSShapeProperty *prs;
             JSShape *sh;
             int i;
             sh = p->shape;
-            mark_func(rt, &sh->header);
+            mark_func(rt, JS_MKPTR(JS_TAG_SHAPE, sh));
             /* mark all the fields */
             prs = get_shape_prop(sh);
             for(i = 0; i < sh->prop_count; i++) {
@@ -5600,17 +5129,13 @@ static void mark_children(JSRuntime *rt, JSGCObjectHeader *gp,
                     if (prs->flags & JS_PROP_TMASK) {
                         if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
                             if (pr->u.getset.getter)
-                                mark_func(rt, &pr->u.getset.getter->header);
+                                mark_func(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));
                             if (pr->u.getset.setter)
-                                mark_func(rt, &pr->u.getset.setter->header);
+                                mark_func(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));
                         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
-                            if (pr->u.var_ref->is_detached) {
-                                /* Note: the tag does not matter
-                                   provided it is a GC object */
-                                mark_func(rt, &pr->u.var_ref->header);
-                            }
+                            JS_MarkValue(rt, JS_MKPTR(JS_TAG_VAR_REF, pr->u.var_ref), mark_func);
                         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
-                            js_autoinit_mark(rt, pr, mark_func);
+                            /* nothing to do */
                         }
                     } else {
                         JS_MarkValue(rt, pr->u.value, mark_func);
@@ -5627,170 +5152,267 @@ static void mark_children(JSRuntime *rt, JSGCObjectHeader *gp,
             }
         }
         break;
-    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
+    case JS_TAG_FUNCTION_BYTECODE:
         /* the template objects can be part of a cycle */
         {
-            JSFunctionBytecode *b = (JSFunctionBytecode *)gp;
+            JSFunctionBytecode *b = JS_VALUE_GET_PTR(val);
             int i;
             for(i = 0; i < b->cpool_count; i++) {
                 JS_MarkValue(rt, b->cpool[i], mark_func);
             }
-            if (b->realm)
-                mark_func(rt, &b->realm->header);
         }
         break;
-    case JS_GC_OBJ_TYPE_VAR_REF:
+    case JS_TAG_VAR_REF:
         {
-            JSVarRef *var_ref = (JSVarRef *)gp;
-            /* only detached variable referenced are taken into account */
-            assert(var_ref->is_detached);
-            JS_MarkValue(rt, *var_ref->pvalue, mark_func);
+            JSVarRef *var_ref = JS_VALUE_GET_PTR(val);
+            /* the refcount of stack values is not incremented, hence
+               the test */
+            if (var_ref->link.prev == NULL) {
+                JS_MarkValue(rt, *var_ref->pvalue, mark_func);
+            }
         }
         break;
-    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
+    case JS_TAG_ASYNC_FUNCTION:
         {
-            JSAsyncFunctionData *s = (JSAsyncFunctionData *)gp;
+            JSAsyncFunctionData *s = JS_VALUE_GET_PTR(val);
             if (s->is_active)
                 async_func_mark(rt, &s->func_state, mark_func);
             JS_MarkValue(rt, s->resolving_funcs[0], mark_func);
             JS_MarkValue(rt, s->resolving_funcs[1], mark_func);
         }
         break;
-    case JS_GC_OBJ_TYPE_SHAPE:
+    case JS_TAG_SHAPE:
         {
-            JSShape *sh = (JSShape *)gp;
+            JSShape *sh = JS_VALUE_GET_PTR(val);
             if (sh->proto != NULL) {
-                mark_func(rt, &sh->proto->header);
+                mark_func(rt, JS_MKPTR(JS_TAG_OBJECT, sh->proto));
             }
         }
         break;
-    case JS_GC_OBJ_TYPE_JS_CONTEXT:
-        {
-            JSContext *ctx = (JSContext *)gp;
-            JS_MarkContext(rt, ctx, mark_func);
-        }
-        break;
     default:
-        abort();
+        /* no children */
+        break;
     }
 }
 
-static void gc_decref_child(JSRuntime *rt, JSGCObjectHeader *p)
+#if 0
+/* not useful until realms are supported */
+static void mark_context(JSRuntime *rt, JSContext *ctx)
 {
-    assert(p->ref_count > 0);
-    p->ref_count--;
-    if (p->ref_count == 0 && p->mark == 1) {
-        list_del(&p->link);
-        list_add_tail(&p->link, &rt->tmp_obj_list);
+    int i;
+    struct list_head *el;
+
+    list_for_each(el, &ctx->loaded_modules) {
+        JSModuleDef *m = list_entry(el, JSModuleDef, link);
+        JS_MarkValue(rt, m->module_ns);
+        JS_MarkValue(rt, m->func_obj);
     }
+
+    JS_MarkValue(rt, ctx->current_exception);
+
+    for(i = 0; i < rt->class_count; i++)
+        JS_MarkValue(rt, ctx->class_proto[i]);
+    JS_MarkValue(rt, ctx->regexp_ctor);
+    JS_MarkValue(rt, ctx->function_ctor);
+    JS_MarkValue(rt, ctx->function_proto);
+    JS_MarkValue(rt, ctx->iterator_proto);
+    JS_MarkValue(rt, ctx->async_iterator_proto);
+    JS_MarkValue(rt, ctx->array_proto_values);
+
+    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++)
+        JS_MarkValue(rt, ctx->native_error_proto[i]);
+
+    JS_MarkValue(rt, ctx->throw_type_error);
+    JS_MarkValue(rt, ctx->eval_obj);
+    JS_MarkValue(rt, ctx->global_obj);
+    JS_MarkValue(rt, ctx->global_var_obj);
 }
+#endif
 
-static void gc_decref(JSRuntime *rt)
+/* 1 = possible member of a cycle
+   2 = member of a cycle
+*/
+
+static void gc_decref_mark(JSRuntime *rt, JSValueConst obj);
+
+//#define DUMP_GC_DECREF
+
+#ifdef DUMP_GC_DECREF
+static int decref_indent;
+#endif
+
+static void gc_decref_child(JSRuntime *rt, JSValueConst obj)
 {
-    struct list_head *el, *el1;
-    JSGCObjectHeader *p;
-    
-    init_list_head(&rt->tmp_obj_list);
-
-    /* decrement the refcount of all the children of all the GC
-       objects and move the GC objects with zero refcount to
-       tmp_obj_list */
-    list_for_each_safe(el, el1, &rt->gc_obj_list) {
-        p = list_entry(el, JSGCObjectHeader, link);
-        assert(p->mark == 0);
-        mark_children(rt, p, gc_decref_child);
-        p->mark = 1;
-        if (p->ref_count == 0) {
-            list_del(&p->link);
-            list_add_tail(&p->link, &rt->tmp_obj_list);
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+
+#ifdef DUMP_LEAKS
+#ifdef DUMP_GC_DECREF
+    {
+        int i;
+        for(i = 0; i < decref_indent; i++)
+                printf("  ");
+        if (JS_IsObject(obj)) {
+            JS_DumpObject(rt, p);
+        } else {
+            JS_DumpValueShort(rt, obj); printf("\n");
+        }
+    }
+#endif
+    if (p->header.ref_count <= 0) {
+        printf("%p: invalid refcount (%d)\n", p, p->header.ref_count);
+        if (JS_IsObject(obj)) {
+            JS_DumpObject(rt, p);
+        } else {
+            JS_DumpValueShort(rt, obj);
         }
     }
+#endif
+    assert(p->header.ref_count > 0);
+    p->header.ref_count--;
+    gc_decref_mark(rt, obj);
 }
 
-static void gc_scan_incref_child(JSRuntime *rt, JSGCObjectHeader *p)
+static void gc_decref_mark(JSRuntime *rt, JSValueConst obj)
 {
-    p->ref_count++;
-    if (p->ref_count == 1) {
-        /* ref_count was 0: remove from tmp_obj_list and add at the
-           end of gc_obj_list */
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+    if (p->gc_header.mark == 0) {
+        p->gc_header.mark = 1;
+#ifdef DUMP_GC_DECREF
+        decref_indent++;
+#endif
+        mark_children(rt, obj, gc_decref_child);
+#ifdef DUMP_GC_DECREF
+        decref_indent--;
+#endif
+    }
+}
+
+static void gc_decref(JSRuntime *rt)
+{
+    struct list_head *el;
+    JSObject *p;
+
+    list_for_each(el, &rt->obj_list) {
+        p = list_entry(el, JSObject, link);
+        gc_decref_mark(rt, JS_MKPTR(JS_TAG_OBJECT, p));
+    }
+}
+
+static void gc_scan_incref(JSRuntime *rt, JSValueConst obj);
+
+static void gc_scan_incref_child(JSRuntime *rt, JSValueConst obj)
+{
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+    p->header.ref_count++;
+    if (p->gc_header.mark != 0) {
+        gc_scan_incref(rt, obj);
+    }
+}
+
+static void gc_scan_incref(JSRuntime *rt, JSValueConst obj)
+{
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+    p->gc_header.mark = 0; /* not freed */
+    if (JS_IsObject(obj)) {
+        /* remove the tmp_obj_list and update the next object to
+           explore */
+        if (rt->el_next == &p->link)
+            rt->el_next = rt->el_next->next;
+        /* add to rt->obj_list */
         list_del(&p->link);
-        list_add_tail(&p->link, &rt->gc_obj_list);
-        p->mark = 0; /* reset the mark for the next GC call */
+        list_add_tail(&p->link, &rt->obj_list);
     }
+    mark_children(rt, obj, gc_scan_incref_child);
+}
+
+static void gc_scan_obj(JSRuntime *rt, JSValueConst obj)
+{
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+    if (p->gc_header.mark == 1) {
+        if (p->header.ref_count > 0) {
+            gc_scan_incref(rt, obj);
+        } else {
+            p->gc_header.mark = 2;
+            mark_children(rt, obj, gc_scan_obj);
+        }
+    }
+}
+
+static void gc_scan_obj2(JSRuntime *rt, JSValueConst obj);
+
+static void gc_scan_incref_child2(JSRuntime *rt, JSValueConst obj)
+{
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+    p->header.ref_count++;
+    gc_scan_obj2(rt, obj);
 }
 
-static void gc_scan_incref_child2(JSRuntime *rt, JSGCObjectHeader *p)
+static void gc_scan_obj2(JSRuntime *rt, JSValueConst obj)
 {
-    p->ref_count++;
+    JSObject *p = JS_VALUE_GET_OBJ(obj);
+    if (p->gc_header.mark == 2) {
+        p->gc_header.mark = 3;
+        mark_children(rt, obj, gc_scan_incref_child2);
+    }
 }
 
 static void gc_scan(JSRuntime *rt)
 {
     struct list_head *el;
-    JSGCObjectHeader *p;
+    JSObject *p;
 
-    /* keep the objects with a refcount > 0 and their children. */
-    list_for_each(el, &rt->gc_obj_list) {
-        p = list_entry(el, JSGCObjectHeader, link);
-        assert(p->ref_count > 0);
-        p->mark = 0; /* reset the mark for the next GC call */
-        mark_children(rt, p, gc_scan_incref_child);
+    /* move obj_list to tmp_obj_list */
+    list_add(&rt->tmp_obj_list, &rt->obj_list);
+    list_del(&rt->obj_list);
+    init_list_head(&rt->obj_list);
+
+    /* keep the objects with a refcount > 0 and their children. After
+       this pass, obj_list contains the objects to be deleted. Their
+       mark is 2. */
+    for(el = rt->tmp_obj_list.next; el != &rt->tmp_obj_list;
+        el = rt->el_next) {
+        rt->el_next = el->next; /* may be modified by gc_scan_obj() */
+        p = list_entry(el, JSObject, link);
+        gc_scan_obj(rt, JS_MKPTR(JS_TAG_OBJECT, p));
     }
-    
-    /* restore the refcount of the objects to be deleted. */
+
+    /* restore the refcount of the objects to be deleted. After this
+       pass, their mark is 3 */
     list_for_each(el, &rt->tmp_obj_list) {
-        p = list_entry(el, JSGCObjectHeader, link);
-        mark_children(rt, p, gc_scan_incref_child2);
+        p = list_entry(el, JSObject, link);
+        gc_scan_obj2(rt, JS_MKPTR(JS_TAG_OBJECT, p));
     }
 }
 
 static void gc_free_cycles(JSRuntime *rt)
 {
     struct list_head *el, *el1;
-    JSGCObjectHeader *p;
+    JSObject *p;
 #ifdef DUMP_GC_FREE
     BOOL header_done = FALSE;
 #endif
-
-    rt->gc_phase = JS_GC_PHASE_REMOVE_CYCLES;
-
-    for(;;) {
-        el = rt->tmp_obj_list.next;
-        if (el == &rt->tmp_obj_list)
-            break;
-        p = list_entry(el, JSGCObjectHeader, link);
-        /* Only need to free the GC object associated with JS
-           values. The rest will be automatically removed because they
-           must be referenced by them. */
-        switch(p->gc_obj_type) {
-        case JS_GC_OBJ_TYPE_JS_OBJECT:
-        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
+    init_list_head(&rt->free_obj_list);
+    rt->in_gc_sweep = TRUE;
+    list_for_each_safe(el, el1, &rt->tmp_obj_list) {
+        p = list_entry(el, JSObject, link);
+        assert(p->gc_header.mark == 3);
 #ifdef DUMP_GC_FREE
-            if (!header_done) {
-                printf("Freeing cycles:\n");
-                JS_DumpObjectHeader(rt);
-                header_done = TRUE;
-            }
-            JS_DumpGCObject(rt, p);
-#endif
-            free_gc_object(rt, p);
-            break;
-        default:
-            list_del(&p->link);
-            list_add_tail(&p->link, &rt->gc_zero_ref_count_list);
-            break;
+        if (!header_done) {
+            printf("Freeing cycles:\n");
+            JS_DumpObjectHeader(rt);
+            header_done = TRUE;
         }
+        JS_DumpObject(rt, p);
+#endif
+        free_object2(rt, p);
     }
-    rt->gc_phase = JS_GC_PHASE_NONE;
-           
-    list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {
-        p = list_entry(el, JSGCObjectHeader, link);
-        assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||
-               p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
+    rt->in_gc_sweep = FALSE;
+
+    /* free all the object structures */
+    list_for_each_safe(el, el1, &rt->free_obj_list) {
+        p = list_entry(el, JSObject, link);
         js_free_rt(rt, p);
     }
-
-    init_list_head(&rt->gc_zero_ref_count_list);
 }
 
 void JS_RunGC(JSRuntime *rt)
@@ -5799,10 +5421,10 @@ void JS_RunGC(JSRuntime *rt)
        1 after this pass. */
     gc_decref(rt);
 
-    /* keep the GC objects with a non zero refcount and their childs */
+    /* keep objects with a non zero refcount and their childs */
     gc_scan(rt);
 
-    /* free the GC objects in a cycle */
+    /* free the objects with a zero refcount */
     gc_free_cycles(rt);
 }
 
@@ -5818,17 +5440,23 @@ BOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj)
     return !p->free_mark;
 }
 
+/* Return true during the GC sweep phase (can be useful inside in finalizer) */
+BOOL JS_IsInGCSweep(JSRuntime *rt)
+{
+    return rt->in_gc_sweep;
+}
+
 /* Compute memory used by various object types */
 /* XXX: poor man's approach to handling multiply referenced objects */
 typedef struct JSMemoryUsage_helper {
     double memory_used_count;
     double str_count;
     double str_size;
-    int64_t js_func_count;
+    double js_func_count;
     double js_func_size;
-    int64_t js_func_code_size;
-    int64_t js_func_pc2line_count;
-    int64_t js_func_pc2line_size;
+    double js_func_code_size;
+    double js_func_pc2line_count;
+    double js_func_pc2line_size;
 } JSMemoryUsage_helper;
 
 static void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp);
@@ -5846,6 +5474,7 @@ static void compute_jsstring_size(JSString *str, JSMemoryUsage_helper *hp)
 static void compute_bytecode_size(JSFunctionBytecode *b, JSMemoryUsage_helper *hp)
 {
     int memory_used_count, js_func_size, i;
+    double ref_count = b->header.ref_count;
 
     memory_used_count = 0;
     js_func_size = offsetof(JSFunctionBytecode, debug);
@@ -5863,7 +5492,7 @@ static void compute_bytecode_size(JSFunctionBytecode *b, JSMemoryUsage_helper *h
         js_func_size += b->closure_var_count * sizeof(*b->closure_var);
     }
     if (!b->read_only_bytecode && b->byte_code_buf) {
-        hp->js_func_code_size += b->byte_code_len;
+        hp->js_func_code_size += b->byte_code_len / ref_count;
     }
     if (b->has_debug) {
         js_func_size += sizeof(*b) - offsetof(JSFunctionBytecode, debug);
@@ -5873,13 +5502,13 @@ static void compute_bytecode_size(JSFunctionBytecode *b, JSMemoryUsage_helper *h
         }
         if (b->debug.pc2line_len) {
             memory_used_count++;
-            hp->js_func_pc2line_count += 1;
-            hp->js_func_pc2line_size += b->debug.pc2line_len;
+            hp->js_func_pc2line_count += 1 / ref_count;
+            hp->js_func_pc2line_size += b->debug.pc2line_len / ref_count;
         }
     }
-    hp->js_func_size += js_func_size;
-    hp->js_func_count += 1;
-    hp->memory_used_count += memory_used_count;
+    hp->js_func_size += js_func_size / ref_count;
+    hp->js_func_count += 1 / ref_count;
+    hp->memory_used_count += memory_used_count / ref_count;
 }
 
 static void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp)
@@ -5888,10 +5517,12 @@ static void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp)
     case JS_TAG_STRING:
         compute_jsstring_size(JS_VALUE_GET_STRING(val), hp);
         break;
+    case JS_TAG_FUNCTION_BYTECODE:
+        compute_bytecode_size(JS_VALUE_GET_PTR(val), hp);
+        break;
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
-    case JS_TAG_BIG_DECIMAL:
         /* should track JSBigFloat usage */
         break;
 #endif
@@ -5960,21 +5591,10 @@ void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)
         }
     }
 
-    list_for_each(el, &rt->gc_obj_list) {
-        JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);
-        JSObject *p;
-        JSShape *sh;
+    list_for_each(el, &rt->obj_list) {
+        JSObject *p = list_entry(el, JSObject, link);
+        JSShape *sh = p->shape;
         JSShapeProperty *prs;
-
-        /* XXX: could count the other GC object types too */
-        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE) {
-            compute_bytecode_size((JSFunctionBytecode *)gp, hp);
-            continue;
-        } else if (gp->gc_obj_type != JS_GC_OBJ_TYPE_JS_OBJECT) {
-            continue;
-        }
-        p = (JSObject *)gp;
-        sh = p->shape;
         s->obj_count++;
         if (p->prop) {
             s->memory_used_count++;
@@ -6021,7 +5641,6 @@ void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)
 #ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT:           /* u.object_data */
         case JS_CLASS_BIG_FLOAT:         /* u.object_data */
-        case JS_CLASS_BIG_DECIMAL:         /* u.object_data */
 #endif
             compute_value_size(p->u.object_data, hp);
             break;
@@ -6049,6 +5668,7 @@ void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)
                         }
                     }
                 }
+                compute_bytecode_size(b, hp);
             }
             break;
         case JS_CLASS_BOUND_FUNCTION:    /* u.bound_function */
@@ -6174,11 +5794,11 @@ void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)
     }
     s->str_count = round(mem.str_count);
     s->str_size = round(mem.str_size);
-    s->js_func_count = mem.js_func_count;
+    s->js_func_count = round(mem.js_func_count);
     s->js_func_size = round(mem.js_func_size);
-    s->js_func_code_size = mem.js_func_code_size;
-    s->js_func_pc2line_count = mem.js_func_pc2line_count;
-    s->js_func_pc2line_size = mem.js_func_pc2line_size;
+    s->js_func_code_size = round(mem.js_func_code_size);
+    s->js_func_pc2line_count = round(mem.js_func_pc2line_count);
+    s->js_func_pc2line_size = round(mem.js_func_pc2line_size);
     s->memory_used_count += round(mem.memory_used_count) +
         s->atom_count + s->str_count +
         s->obj_count + s->shape_count +
@@ -6229,13 +5849,9 @@ void JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt)
             int obj_classes[JS_CLASS_INIT_COUNT + 1] = { 0 };
             int class_id;
             struct list_head *el;
-            list_for_each(el, &rt->gc_obj_list) {
-                JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);
-                JSObject *p;
-                if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {
-                    p = (JSObject *)gp;
-                    obj_classes[min_uint32(p->class_id, JS_CLASS_INIT_COUNT)]++;
-                }
+            list_for_each(el, &rt->obj_list) {
+                JSObject *p = list_entry(el, JSObject, link);
+                obj_classes[min_uint32(p->class_id, JS_CLASS_INIT_COUNT)]++;
             }
             fprintf(fp, "\n" "JSObject classes\n");
             if (obj_classes[0])
@@ -6325,9 +5941,9 @@ JSValue JS_GetGlobalObject(JSContext *ctx)
 /* WARNING: obj is freed */
 JSValue JS_Throw(JSContext *ctx, JSValue obj)
 {
-    JSRuntime *rt = ctx->rt;
-    JS_FreeValue(ctx, rt->current_exception);
-    rt->current_exception = obj;
+    JS_FreeValue(ctx, ctx->current_exception);
+    ctx->current_exception = obj;
+    ctx->exception_needs_backtrace = JS_IsError(ctx, obj);
     return JS_EXCEPTION;
 }
 
@@ -6335,9 +5951,9 @@ JSValue JS_Throw(JSContext *ctx, JSValue obj)
 JSValue JS_GetException(JSContext *ctx)
 {
     JSValue val;
-    JSRuntime *rt = ctx->rt;
-    val = rt->current_exception;
-    rt->current_exception = JS_NULL;
+    val = ctx->current_exception;
+    ctx->current_exception = JS_NULL;
+    ctx->exception_needs_backtrace = FALSE;
     return val;
 }
 
@@ -6463,15 +6079,12 @@ static const char *get_func_name(JSContext *ctx, JSValueConst func)
     return JS_ToCString(ctx, val);
 }
 
-#define JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL (1 << 0)
-/* only taken into account if filename is provided */
-#define JS_BACKTRACE_FLAG_SINGLE_LEVEL     (1 << 1)
-
 /* if filename != NULL, an additional level is added with the filename
-   and line number information (used for parse error). */
+   and line number information (used for parse error). If 'pc' !=
+   NULL, it is used as the cur_pc value for the current stack frame */
 static void build_backtrace(JSContext *ctx, JSValueConst error_obj,
                             const char *filename, int line_num,
-                            int backtrace_flags)
+                            const uint8_t *cur_pc)
 {
     JSStackFrame *sf;
     JSValue str;
@@ -6479,8 +6092,8 @@ static void build_backtrace(JSContext *ctx, JSValueConst error_obj,
     const char *func_name_str;
     const char *str1;
     JSObject *p;
-    BOOL backtrace_barrier;
-    
+
+    ctx->exception_needs_backtrace = FALSE;
     js_dbuf_init(ctx, &dbuf);
     if (filename) {
         dbuf_printf(&dbuf, "    at %s", filename);
@@ -6492,14 +6105,8 @@ static void build_backtrace(JSContext *ctx, JSValueConst error_obj,
                                JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
         JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_lineNumber, JS_NewInt32(ctx, line_num),
                                JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-        if (backtrace_flags & JS_BACKTRACE_FLAG_SINGLE_LEVEL)
-            goto done;
     }
-    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
-        if (backtrace_flags & JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL) {
-            backtrace_flags &= ~JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL;
-            continue;
-        }
+    for(sf = ctx->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
         func_name_str = get_func_name(ctx, sf->cur_func);
         if (!func_name_str || func_name_str[0] == '\0')
             str1 = "<anonymous>";
@@ -6509,21 +6116,27 @@ static void build_backtrace(JSContext *ctx, JSValueConst error_obj,
         JS_FreeCString(ctx, func_name_str);
 
         p = JS_VALUE_GET_OBJ(sf->cur_func);
-        backtrace_barrier = FALSE;
         if (js_class_has_bytecode(p->class_id)) {
             JSFunctionBytecode *b;
-            const char *atom_str;
+            char atom_buf[ATOM_GET_STR_BUF_SIZE];
             int line_num1;
 
             b = p->u.func.function_bytecode;
-            backtrace_barrier = b->backtrace_barrier;
             if (b->has_debug) {
-                line_num1 = find_line_num(ctx, b,
-                                          sf->cur_pc - b->byte_code_buf - 1);
-                atom_str = JS_AtomToCString(ctx, b->debug.filename);
+                if (sf == ctx->current_stack_frame) {
+                    if (!cur_pc) {
+                        line_num1 = b->debug.line_num;
+                    } else {
+                        line_num1 = find_line_num(ctx, b,
+                                                  cur_pc - b->byte_code_buf - 1);
+                    }
+                } else {
+                    line_num1 = find_line_num(ctx, b,
+                                              sf->cur_pc - b->byte_code_buf - 1);
+                }
                 dbuf_printf(&dbuf, " (%s",
-                            atom_str ? atom_str : "<null>");
-                JS_FreeCString(ctx, atom_str);
+                            JS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf),
+                                          b->debug.filename));
                 if (line_num1 != -1)
                     dbuf_printf(&dbuf, ":%d", line_num1);
                 dbuf_putc(&dbuf, ')');
@@ -6532,42 +6145,21 @@ static void build_backtrace(JSContext *ctx, JSValueConst error_obj,
             dbuf_printf(&dbuf, " (native)");
         }
         dbuf_putc(&dbuf, '\n');
-        /* stop backtrace if JS_EVAL_FLAG_BACKTRACE_BARRIER was used */
-        if (backtrace_barrier)
-            break;
     }
- done:
     dbuf_putc(&dbuf, '\0');
-    if (dbuf_error(&dbuf))
-        str = JS_NULL;
-    else
-        str = JS_NewString(ctx, (char *)dbuf.buf);
+    str = JS_NewString(ctx, (char *)dbuf.buf);
     dbuf_free(&dbuf);
     JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_stack, str,
                            JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 }
 
-/* Note: it is important that no exception is returned by this function */
-static BOOL is_backtrace_needed(JSContext *ctx, JSValueConst obj)
-{
-    JSObject *p;
-    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
-        return FALSE;
-    p = JS_VALUE_GET_OBJ(obj);
-    if (p->class_id != JS_CLASS_ERROR)
-        return FALSE;
-    if (find_own_property1(p, JS_ATOM_stack))
-        return FALSE;
-    return TRUE;
-}
-
 JSValue JS_NewError(JSContext *ctx)
 {
     return JS_NewObjectClass(ctx, JS_CLASS_ERROR);
 }
 
-static JSValue JS_ThrowError2(JSContext *ctx, JSErrorEnum error_num,
-                              const char *fmt, va_list ap, BOOL add_backtrace)
+static JSValue JS_ThrowError(JSContext *ctx, JSErrorEnum error_num,
+                             const char *fmt, va_list ap)
 {
     char buf[256];
     JSValue obj, ret;
@@ -6583,28 +6175,11 @@ static JSValue JS_ThrowError2(JSContext *ctx, JSErrorEnum error_num,
                                JS_NewString(ctx, buf),
                                JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
     }
-    if (add_backtrace) {
-        build_backtrace(ctx, obj, NULL, 0, 0);
-    }
     ret = JS_Throw(ctx, obj);
     return ret;
 }
 
-static JSValue JS_ThrowError(JSContext *ctx, JSErrorEnum error_num,
-                             const char *fmt, va_list ap)
-{
-    JSRuntime *rt = ctx->rt;
-    JSStackFrame *sf;
-    BOOL add_backtrace;
-
-    /* the backtrace is added later if called from a bytecode function */
-    sf = rt->current_stack_frame;
-    add_backtrace = !rt->in_out_of_memory &&
-        (!sf || (JS_GetFunctionBytecode(sf->cur_func) == NULL));
-    return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
-}
-
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6615,7 +6190,7 @@ JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6626,7 +6201,7 @@ JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx,
     return val;
 }
 
-static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
+static int __js_printf_like(3, 4) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
 {
     va_list ap;
 
@@ -6641,39 +6216,20 @@ static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSCont
     }
 }
 
-/* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
-{
-    char buf[ATOM_GET_STR_BUF_SIZE];
-    return JS_ThrowTypeError(ctx, fmt,
-                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
-}
-
-/* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
-{
-    char buf[ATOM_GET_STR_BUF_SIZE];
-    return JS_ThrowSyntaxError(ctx, fmt,
-                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
-}
-
-/* %s is replaced by 'atom'. The macro is used so that gcc can check
-    the format string. */
-#define JS_ThrowTypeErrorAtom(ctx, fmt, atom) __JS_ThrowTypeErrorAtom(ctx, atom, fmt, "")
-#define JS_ThrowSyntaxErrorAtom(ctx, fmt, atom) __JS_ThrowSyntaxErrorAtom(ctx, atom, fmt, "")
-
 static int JS_ThrowTypeErrorReadOnly(JSContext *ctx, int flags, JSAtom atom)
 {
     if ((flags & JS_PROP_THROW) ||
         ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
-        JS_ThrowTypeErrorAtom(ctx, "'%s' is read-only", atom);
+        char buf[ATOM_GET_STR_BUF_SIZE];
+        JS_ThrowTypeError(ctx, "%s is read-only",
+                          JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
         return -1;
     } else {
         return FALSE;
     }
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6684,7 +6240,7 @@ JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6695,7 +6251,7 @@ JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx,
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
+JSValue __js_printf_like(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6708,11 +6264,10 @@ JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *c
 
 JSValue JS_ThrowOutOfMemory(JSContext *ctx)
 {
-    JSRuntime *rt = ctx->rt;
-    if (!rt->in_out_of_memory) {
-        rt->in_out_of_memory = TRUE;
+    if (!ctx->in_out_of_memory) {
+        ctx->in_out_of_memory = TRUE;
         JS_ThrowInternalError(ctx, "out of memory");
-        rt->in_out_of_memory = FALSE;
+        ctx->in_out_of_memory = FALSE;
     }
     return JS_EXCEPTION;
 }
@@ -6735,7 +6290,7 @@ static JSValue JS_ThrowTypeErrorNotASymbol(JSContext *ctx)
 static JSValue JS_ThrowReferenceErrorNotDefined(JSContext *ctx, JSAtom name)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
-    return JS_ThrowReferenceError(ctx, "'%s' is not defined",
+    return JS_ThrowReferenceError(ctx, "%s is not defined",
                                   JS_AtomGetStr(ctx, buf, sizeof(buf), name));
 }
 
@@ -6747,51 +6302,14 @@ static JSValue JS_ThrowReferenceErrorUninitialized(JSContext *ctx, JSAtom name)
                                   JS_AtomGetStr(ctx, buf, sizeof(buf), name));
 }
 
-static JSValue JS_ThrowReferenceErrorUninitialized2(JSContext *ctx,
-                                                    JSFunctionBytecode *b,
-                                                    int idx, BOOL is_ref)
-{
-    JSAtom atom = JS_ATOM_NULL;
-    if (is_ref) {
-        atom = b->closure_var[idx].var_name;
-    } else {
-        /* not present if the function is stripped and contains no eval() */
-        if (b->vardefs)
-            atom = b->vardefs[b->arg_count + idx].var_name;
-    }
-    return JS_ThrowReferenceErrorUninitialized(ctx, atom);
-}
-
 static JSValue JS_ThrowTypeErrorInvalidClass(JSContext *ctx, int class_id)
 {
     JSRuntime *rt = ctx->rt;
+    char buf[ATOM_GET_STR_BUF_SIZE];
     JSAtom name;
     name = rt->class_array[class_id].class_name;
-    return JS_ThrowTypeErrorAtom(ctx, "%s object expected", name);
-}
-
-static no_inline __exception int __js_poll_interrupts(JSContext *ctx)
-{
-    JSRuntime *rt = ctx->rt;
-    ctx->interrupt_counter = JS_INTERRUPT_COUNTER_INIT;
-    if (rt->interrupt_handler) {
-        if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {
-            /* XXX: should set a specific flag to avoid catching */
-            JS_ThrowInternalError(ctx, "interrupted");
-            JS_SetUncatchableError(ctx, ctx->rt->current_exception, TRUE);
-            return -1;
-        }
-    }
-    return 0;
-}
-
-static inline __exception int js_poll_interrupts(JSContext *ctx)
-{
-    if (unlikely(--ctx->interrupt_counter <= 0)) {
-        return __js_poll_interrupts(ctx);
-    } else {
-        return 0;
-    }
+    return JS_ThrowTypeError(ctx, "%s object expected",
+                             JS_AtomGetStr(ctx, buf, sizeof(buf), name));
 }
 
 /* return -1 (exception) or TRUE/FALSE */
@@ -6871,25 +6389,35 @@ int JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val)
     return JS_SetPrototypeInternal(ctx, obj, proto_val, TRUE);
 }
 
-/* Only works for primitive types, otherwise return JS_NULL. */
-static JSValueConst JS_GetPrototypePrimitive(JSContext *ctx, JSValueConst val)
+/* Return an Object, JS_NULL or JS_EXCEPTION in case of Proxy object. */
+JSValueConst JS_GetPrototype(JSContext *ctx, JSValueConst val)
 {
+    JSObject *p;
+
     switch(JS_VALUE_GET_NORM_TAG(val)) {
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         val = ctx->class_proto[JS_CLASS_BIG_INT];
         break;
+    case JS_TAG_INT:
+        if (is_bignum_mode(ctx)) {
+            val = ctx->class_proto[JS_CLASS_BIG_INT];
+        } else {
+            val = ctx->class_proto[JS_CLASS_NUMBER];
+        }
+        break;
+    case JS_TAG_FLOAT64:
+        val = ctx->class_proto[JS_CLASS_NUMBER];
+        break;
     case JS_TAG_BIG_FLOAT:
         val = ctx->class_proto[JS_CLASS_BIG_FLOAT];
         break;
-    case JS_TAG_BIG_DECIMAL:
-        val = ctx->class_proto[JS_CLASS_BIG_DECIMAL];
-        break;
-#endif
+#else
     case JS_TAG_INT:
     case JS_TAG_FLOAT64:
         val = ctx->class_proto[JS_CLASS_NUMBER];
         break;
+#endif
     case JS_TAG_BOOL:
         val = ctx->class_proto[JS_CLASS_BOOLEAN];
         break;
@@ -6900,45 +6428,26 @@ static JSValueConst JS_GetPrototypePrimitive(JSContext *ctx, JSValueConst val)
         val = ctx->class_proto[JS_CLASS_SYMBOL];
         break;
     case JS_TAG_OBJECT:
-    case JS_TAG_NULL:
-    case JS_TAG_UNDEFINED:
-    default:
-        val = JS_NULL;
-        break;
-    }
-    return val;
-}
-
-/* Return an Object, JS_NULL or JS_EXCEPTION in case of Proxy object. */
-JSValue JS_GetPrototype(JSContext *ctx, JSValueConst obj)
-{
-    JSValue val;
-    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
-        JSObject *p;
-        p = JS_VALUE_GET_OBJ(obj);
+        p = JS_VALUE_GET_OBJ(val);
         if (unlikely(p->class_id == JS_CLASS_PROXY)) {
-            val = js_proxy_getPrototypeOf(ctx, obj);
+            val = js_proxy_getPrototypeOf(ctx, val);
         } else {
             p = p->shape->proto;
             if (!p)
                 val = JS_NULL;
             else
-                val = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
+                val = JS_MKPTR(JS_TAG_OBJECT, p);
         }
-    } else {
-        val = JS_DupValue(ctx, JS_GetPrototypePrimitive(ctx, obj));
+        break;
+    case JS_TAG_NULL:
+    case JS_TAG_UNDEFINED:
+    default:
+        val = JS_NULL;
+        break;
     }
     return val;
 }
 
-static JSValue JS_GetPrototypeFree(JSContext *ctx, JSValue obj)
-{
-    JSValue obj1;
-    obj1 = JS_GetPrototype(ctx, obj);
-    JS_FreeValue(ctx, obj);
-    return obj1;
-}
-
 /* return TRUE, FALSE or (-1) in case of exception */
 static int JS_OrdinaryIsInstanceOf(JSContext *ctx, JSValueConst val,
                                    JSValueConst obj)
@@ -6959,6 +6468,7 @@ static int JS_OrdinaryIsInstanceOf(JSContext *ctx, JSValueConst val,
     /* Only explicitly boxed values are instances of constructors */
     if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
         return FALSE;
+    ret = FALSE;
     obj_proto = JS_GetProperty(ctx, obj, JS_ATOM_prototype);
     if (JS_VALUE_GET_TAG(obj_proto) != JS_TAG_OBJECT) {
         if (!JS_IsException(obj_proto))
@@ -6971,36 +6481,19 @@ static int JS_OrdinaryIsInstanceOf(JSContext *ctx, JSValueConst val,
     for(;;) {
         proto1 = p->shape->proto;
         if (!proto1) {
-            /* slow case if proxy in the prototype chain */
-            if (unlikely(p->class_id == JS_CLASS_PROXY)) {
-                JSValue obj1;
-                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, (JSObject *)p));
-                for(;;) {
-                    obj1 = JS_GetPrototypeFree(ctx, obj1);
-                    if (JS_IsException(obj1)) {
-                        ret = -1;
-                        break;
-                    }
-                    if (JS_IsNull(obj1)) {
-                        ret = FALSE;
-                        break;
-                    }
-                    if (proto == JS_VALUE_GET_OBJ(obj1)) {
-                        JS_FreeValue(ctx, obj1);
-                        ret = TRUE;
-                        break;
-                    }
-                    /* must check for timeout to avoid infinite loop */
-                    if (js_poll_interrupts(ctx)) {
-                        JS_FreeValue(ctx, obj1);
-                        ret = -1;
-                        break;
-                    }
+            if (p->class_id == JS_CLASS_PROXY) {
+                JSValueConst proto_val;
+                proto_val = JS_GetPrototype(ctx, JS_MKPTR(JS_TAG_OBJECT, (JSObject *)p));
+                if (JS_IsException(proto_val)) {
+                    ret = -1;
+                    goto done;
                 }
+                proto1 = JS_VALUE_GET_OBJ(proto_val);
+                if (!proto1)
+                    break;
             } else {
-                ret = FALSE;
+                break;
             }
-            break;
         }
         p = proto1;
         if (proto == p) {
@@ -7038,37 +6531,9 @@ int JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj)
     return JS_OrdinaryIsInstanceOf(ctx, val, obj);
 }
 
-/* return the value associated to the autoinit property or an exception */
-typedef JSValue JSAutoInitFunc(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);
-
-static JSAutoInitFunc *js_autoinit_func_table[] = {
-    js_instantiate_prototype, /* JS_AUTOINIT_ID_PROTOTYPE */
-    js_module_ns_autoinit, /* JS_AUTOINIT_ID_MODULE_NS */
-    JS_InstantiateFunctionListItem2, /* JS_AUTOINIT_ID_PROP */
-};
-
-/* warning: 'prs' is reallocated after it */
-static int JS_AutoInitProperty(JSContext *ctx, JSObject *p, JSAtom prop,
-                               JSProperty *pr, JSShapeProperty *prs)
+static int JS_AutoInitProperty(JSContext *ctx, JSObject *p, JSAtom prop, JSProperty *pr)
 {
-    JSValue val;
-    JSContext *realm;
-    JSAutoInitFunc *func;
-
-    if (js_shape_prepare_update(ctx, p, &prs))
-        return -1;
-
-    realm = js_autoinit_get_realm(pr);
-    func = js_autoinit_func_table[js_autoinit_get_id(pr)];
-    /* 'func' shall not modify the object properties 'pr' */
-    val = func(realm, p, prop, pr->u.init.opaque);
-    js_autoinit_free(ctx->rt, pr);
-    prs->flags &= ~JS_PROP_TMASK;
-    pr->u.value = JS_UNDEFINED;
-    if (JS_IsException(val))
-        return -1;
-    pr->u.value = val;
-    return 0;
+    return (*pr->u.init.init_func)(ctx, p, prop, pr->u.init.opaque);
 }
 
 JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
@@ -7084,9 +6549,8 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
     if (unlikely(tag != JS_TAG_OBJECT)) {
         switch(tag) {
         case JS_TAG_NULL:
-            return JS_ThrowTypeErrorAtom(ctx, "cannot read property '%s' of null", prop);
         case JS_TAG_UNDEFINED:
-            return JS_ThrowTypeErrorAtom(ctx, "cannot read property '%s' of undefined", prop);
+            return JS_ThrowTypeError(ctx, "value has no property");
         case JS_TAG_EXCEPTION:
             return JS_EXCEPTION;
         case JS_TAG_STRING:
@@ -7111,7 +6575,7 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
             break;
         }
         /* cannot raise an exception */
-        p = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));
+        p = JS_VALUE_GET_OBJ(JS_GetPrototype(ctx, obj));
         if (!p)
             return JS_UNDEFINED;
     } else {
@@ -7139,7 +6603,7 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
                     return JS_DupValue(ctx, val);
                 } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
                     /* Instantiate property and retry */
-                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
+                    if (JS_AutoInitProperty(ctx, p, prop, pr))
                         return JS_EXCEPTION;
                     continue;
                 }
@@ -7157,7 +6621,7 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
                         return JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);
                     } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
                                p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
-                        return JS_UNDEFINED;
+                        goto typed_array_oob;
                     }
                 } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
                            p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
@@ -7166,6 +6630,9 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
                     if (ret != 0) {
                         if (ret < 0)
                             return JS_EXCEPTION;
+                    typed_array_oob:
+                        if (typed_array_is_detached(ctx, p))
+                            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
                         return JS_UNDEFINED;
                     }
                 }
@@ -7173,25 +6640,15 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
                 const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
                 if (em) {
                     if (em->get_property) {
-                        JSValue obj1, retval;
                         /* XXX: should pass throw_ref_error */
-                        /* Note: if 'p' is a prototype, it can be
-                           freed in the called function */
-                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-                        retval = em->get_property(ctx, obj1, prop, this_obj);
-                        JS_FreeValue(ctx, obj1);
-                        return retval;
+                        return em->get_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p),
+                                                prop, this_obj);
                     }
                     if (em->get_own_property) {
                         JSPropertyDescriptor desc;
                         int ret;
-                        JSValue obj1;
 
-                        /* Note: if 'p' is a prototype, it can be
-                           freed in the called function */
-                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-                        ret = em->get_own_property(ctx, &desc, obj1, prop);
-                        JS_FreeValue(ctx, obj1);
+                        ret = em->get_own_property(ctx, &desc, JS_MKPTR(JS_TAG_OBJECT, p), prop);
                         if (ret < 0)
                             return JS_EXCEPTION;
                         if (ret) {
@@ -7219,8 +6676,9 @@ JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
 
 static JSValue JS_ThrowTypeErrorPrivateNotFound(JSContext *ctx, JSAtom atom)
 {
-    return JS_ThrowTypeErrorAtom(ctx, "private class field '%s' does not exist",
-                                 atom);
+    char buf[ATOM_GET_STR_BUF_SIZE];
+    return JS_ThrowTypeError(ctx, "private class field %s does not exist",
+                      JS_AtomGetStr(ctx, buf, sizeof(buf), atom));
 }
 
 /* Private fields can be added even on non extensible objects or
@@ -7242,12 +6700,13 @@ static int JS_DefinePrivateField(JSContext *ctx, JSValueConst obj,
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (prs) {
-        JS_ThrowTypeErrorAtom(ctx, "private class field '%s' already exists",
-                              prop);
+        char buf[ATOM_GET_STR_BUF_SIZE];
+        JS_ThrowTypeError(ctx, "private class field %s already exists",
+                          JS_AtomGetStr(ctx, buf, sizeof(buf), prop));
         goto fail;
     }
     pr = add_property(ctx, p, prop, JS_PROP_C_W_E);
@@ -7273,7 +6732,7 @@ static JSValue JS_GetPrivateField(JSContext *ctx, JSValueConst obj,
     /* safety check */
     if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))
         return JS_ThrowTypeErrorNotASymbol(ctx);
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7300,7 +6759,7 @@ static int JS_SetPrivateField(JSContext *ctx, JSValueConst obj,
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7390,7 +6849,7 @@ static int JS_CheckBrand(JSContext *ctx, JSValueConst obj, JSValueConst func)
     if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
         goto not_obj;
     p = JS_VALUE_GET_OBJ(obj);
-    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));
+    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, brand));
     if (!prs) {
         JS_ThrowTypeError(ctx, "invalid brand on object");
         return -1;
@@ -7398,22 +6857,6 @@ static int JS_CheckBrand(JSContext *ctx, JSValueConst obj, JSValueConst func)
     return 0;
 }
 
-static uint32_t js_string_obj_get_length(JSContext *ctx,
-                                         JSValueConst obj)
-{
-    JSObject *p;
-    JSString *p1;
-    uint32_t len = 0;
-
-    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */
-    p = JS_VALUE_GET_OBJ(obj);
-    if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {
-        p1 = JS_VALUE_GET_STRING(p->u.object_data);
-        len = p1->len;
-    }
-    return len;
-}
-
 static int num_keys_cmp(const void *p1, const void *p2, void *opaque)
 {
     JSContext *ctx = opaque;
@@ -7456,7 +6899,7 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
     JSPropertyEnum *tab_atom, *tab_exotic;
     JSAtom atom;
     uint32_t num_keys_count, str_keys_count, sym_keys_count, atom_count;
-    uint32_t num_index, str_index, sym_index, exotic_count, exotic_keys_count;
+    uint32_t num_index, str_index, sym_index, exotic_count;
     BOOL is_enumerable, num_sorted;
     uint32_t num_key;
     JSAtomKindEnum kind;
@@ -7469,7 +6912,6 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
     num_keys_count = 0;
     str_keys_count = 0;
     sym_keys_count = 0;
-    exotic_keys_count = 0;
     exotic_count = 0;
     tab_exotic = NULL;
     sh = p->shape;
@@ -7503,13 +6945,17 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
 
     if (p->is_exotic) {
         if (p->fast_array) {
-            if (flags & JS_GPN_STRING_MASK) {
-                num_keys_count += p->u.array.count;
-            }
-        } else if (p->class_id == JS_CLASS_STRING) {
-            if (flags & JS_GPN_STRING_MASK) {
-                num_keys_count += js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
+            /* the implicit GetOwnProperty raises an exception if the
+               typed array is detached */
+            if ((flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY)) &&
+                 (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
+                  p->class_id <= JS_CLASS_FLOAT64_ARRAY) &&
+                 typed_array_is_detached(ctx, p) &&
+                typed_array_get_length(ctx, p) != 0) {
+                JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
+                return -1;
             }
+            num_keys_count += p->u.array.count;
         } else {
             const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
             if (em && em->get_own_property_names) {
@@ -7538,7 +6984,13 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
                             tab_exotic[i].is_enumerable = is_enumerable;
                         }
                         if (!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) {
-                            exotic_keys_count++;
+                            if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
+                                num_keys_count++;
+                            } else if (kind == JS_ATOM_KIND_STRING) {
+                                str_keys_count++;
+                            } else {
+                                sym_keys_count++;
+                            }
                         }
                     }
                 }
@@ -7548,7 +7000,7 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
 
     /* fill them */
 
-    atom_count = num_keys_count + str_keys_count + sym_keys_count + exotic_keys_count;
+    atom_count = num_keys_count + str_keys_count + sym_keys_count;
     /* avoid allocating 0 bytes */
     tab_atom = js_malloc(ctx, sizeof(tab_atom[0]) * max_int(atom_count, 1));
     if (!tab_atom) {
@@ -7584,43 +7036,41 @@ static int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,
     }
 
     if (p->is_exotic) {
-        int len;
         if (p->fast_array) {
-            if (flags & JS_GPN_STRING_MASK) {
-                len = p->u.array.count;
-                goto add_array_keys;
-            }
-        } else if (p->class_id == JS_CLASS_STRING) {
-            if (flags & JS_GPN_STRING_MASK) {
-                len = js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-            add_array_keys:
-                for(i = 0; i < len; i++) {
-                    tab_atom[num_index].atom = __JS_AtomFromUInt32(i);
-                    if (tab_atom[num_index].atom == JS_ATOM_NULL) {
-                        js_free_prop_enum(ctx, tab_atom, num_index);
-                        return -1;
-                    }
-                    tab_atom[num_index].is_enumerable = TRUE;
-                    num_index++;
+            for(i = 0; i < p->u.array.count; i++) {
+                tab_atom[num_index].atom = __JS_AtomFromUInt32(i);
+                if (tab_atom[num_index].atom == JS_ATOM_NULL) {
+                    js_free_prop_enum(ctx, tab_exotic, exotic_count);
+                    js_free_prop_enum(ctx, tab_atom, num_index);
+                    return -1;
                 }
+                tab_atom[num_index].is_enumerable = TRUE;
+                num_index++;
             }
-        } else {
-            /* Note: exotic keys are not reordered and comes after the object own properties. */
+        }
+        if (exotic_count > 0) {
             for(i = 0; i < exotic_count; i++) {
                 atom = tab_exotic[i].atom;
                 is_enumerable = tab_exotic[i].is_enumerable;
                 kind = JS_AtomGetKind(ctx, atom);
                 if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&
                     ((flags >> kind) & 1) != 0) {
-                    tab_atom[sym_index].atom = atom;
-                    tab_atom[sym_index].is_enumerable = is_enumerable;
-                    sym_index++;
+                    if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {
+                        j = num_index++;
+                        num_sorted = FALSE;
+                    } else if (kind == JS_ATOM_KIND_STRING) {
+                        j = str_index++;
+                    } else {
+                        j = sym_index++;
+                    }
+                    tab_atom[j].atom = atom;
+                    tab_atom[j].is_enumerable = is_enumerable;
                 } else {
                     JS_FreeAtom(ctx, atom);
                 }
             }
-            js_free(ctx, tab_exotic);
         }
+        js_free(ctx, tab_exotic);
     }
 
     assert(num_index == num_keys_count);
@@ -7680,7 +7130,7 @@ retry:
                     desc->value = JS_DupValue(ctx, val);
                 } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
                     /* Instantiate property and retry */
-                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
+                    if (JS_AutoInitProperty(ctx, p, prop, pr))
                         return -1;
                     goto retry;
                 }
@@ -7708,8 +7158,10 @@ retry:
                 idx = __JS_AtomToUInt32(prop);
                 if (idx < p->u.array.count) {
                     if (desc) {
-                        desc->flags = JS_PROP_WRITABLE | JS_PROP_ENUMERABLE |
-                            JS_PROP_CONFIGURABLE;
+                        desc->flags = JS_PROP_WRITABLE | JS_PROP_ENUMERABLE;
+                        if (p->class_id == JS_CLASS_ARRAY ||
+                            p->class_id == JS_CLASS_ARGUMENTS)
+                            desc->flags |= JS_PROP_CONFIGURABLE;
                         desc->getter = JS_UNDEFINED;
                         desc->setter = JS_UNDEFINED;
                         desc->value = JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);
@@ -7717,6 +7169,19 @@ retry:
                     return TRUE;
                 }
             }
+            if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
+                p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
+                int ret;
+                ret = JS_AtomIsNumericIndex(ctx, prop);
+                if (ret != 0) {
+                    if (ret < 0)
+                        return -1;
+                    if (typed_array_is_detached(ctx, p)) {
+                        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
+                        return -1;
+                    }
+                }
+            }
         } else {
             const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
             if (em && em->get_own_property) {
@@ -7771,7 +7236,6 @@ int JS_HasProperty(JSContext *ctx, JSValueConst obj, JSAtom prop)
 {
     JSObject *p;
     int ret;
-    JSValue obj1;
 
     if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
         return FALSE;
@@ -7779,18 +7243,10 @@ int JS_HasProperty(JSContext *ctx, JSValueConst obj, JSAtom prop)
     for(;;) {
         if (p->is_exotic) {
             const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
-            if (em && em->has_property) {
-                /* has_property can free the prototype */
-                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-                ret = em->has_property(ctx, obj1, prop);
-                JS_FreeValue(ctx, obj1);
-                return ret;
-            }
+            if (em && em->has_property)
+                return em->has_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p), prop);
         }
-        /* JS_GetOwnPropertyInternal can free the prototype */
-        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
         ret = JS_GetOwnPropertyInternal(ctx, NULL, p, prop);
-        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
         if (ret != 0)
             return ret;
         if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
@@ -7799,6 +7255,8 @@ int JS_HasProperty(JSContext *ctx, JSValueConst obj, JSAtom prop)
             if (ret != 0) {
                 if (ret < 0)
                     return -1;
+                /* the detached array test was done in
+                   JS_GetOwnPropertyInternal() */
                 return FALSE;
             }
         }
@@ -8062,7 +7520,7 @@ static int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)
  redo:
     sh = p->shape;
     h1 = atom & sh->prop_hash_mask;
-    h = prop_hash_end(sh)[-h1 - 1];
+    h = *JSSHAPE_HASH_OFFSET(sh, -h1 - 1);
     prop = get_shape_prop(sh);
     lpr = NULL;
     lpr_idx = 0;   /* prevent warning */
@@ -8083,9 +7541,8 @@ static int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)
                 lpr = get_shape_prop(sh) + lpr_idx;
                 lpr->hash_next = pr->hash_next;
             } else {
-                prop_hash_end(sh)[-h1 - 1] = pr->hash_next;
+                *JSSHAPE_HASH_OFFSET(sh, -h1 - 1) = pr->hash_next;
             }
-            sh->deleted_prop_count++;
             /* free the entry */
             pr1 = &p->prop[h - 1];
             free_property(ctx->rt, pr1, pr->flags);
@@ -8094,12 +7551,6 @@ static int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)
             pr->flags = 0;
             pr->atom = JS_ATOM_NULL;
             pr1->u.value = JS_UNDEFINED;
-
-            /* compact the properties if too many deleted properties */
-            if (sh->deleted_prop_count >= 8 &&
-                sh->deleted_prop_count >= ((unsigned)sh->prop_count / 2)) {
-                compact_properties(ctx, p);
-            }
             return TRUE;
         }
         lpr = pr;
@@ -8123,7 +7574,7 @@ static int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)
                         return -1;
                     goto redo;
                 } else {
-                    return FALSE;
+                    return FALSE; /* not configurable */
                 }
             }
         } else {
@@ -8150,7 +7601,6 @@ static int call_setter(JSContext *ctx, JSObject *setter,
         if (JS_IsException(ret))
             return -1;
         JS_FreeValue(ctx, ret);
-        return TRUE;
     } else {
         JS_FreeValue(ctx, val);
         if ((flags & JS_PROP_THROW) ||
@@ -8158,25 +7608,21 @@ static int call_setter(JSContext *ctx, JSObject *setter,
             JS_ThrowTypeError(ctx, "no setter for property");
             return -1;
         }
-        return FALSE;
+        /* XXX: should return FALSE? */
     }
+    return TRUE;
 }
 
 /* set the array length and remove the array elements if necessary. */
-static int set_array_length(JSContext *ctx, JSObject *p, JSValue val,
-                            int flags)
+static int set_array_length(JSContext *ctx, JSObject *p, JSProperty *prop,
+                            JSValue val, int flags)
 {
     uint32_t len, idx, cur_len;
     int i, ret;
 
-    /* Note: this call can reallocate the properties of 'p' */
-    ret = JS_ToArrayLengthFree(ctx, &len, val, FALSE);
+    ret = JS_ToArrayLengthFree(ctx, &len, val);
     if (ret)
         return -1;
-    /* JS_ToArrayLengthFree() must be done before the read-only test */
-    if (unlikely(!(p->shape->prop[0].flags & JS_PROP_WRITABLE)))
-        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);
-
     if (likely(p->fast_array)) {
         uint32_t old_len = p->u.array.count;
         if (len < old_len) {
@@ -8185,11 +7631,15 @@ static int set_array_length(JSContext *ctx, JSObject *p, JSValue val,
             }
             p->u.array.count = len;
         }
-        p->prop[0].u.value = JS_NewUint32(ctx, len);
+#ifdef CONFIG_BIGNUM
+        set_value(ctx, &prop->u.value, JS_NewUint32(ctx, len));
+#else
+        prop->u.value = JS_NewUint32(ctx, len);
+#endif
     } else {
         /* Note: length is always a uint32 because the object is an
            array */
-        JS_ToUint32(ctx, &cur_len, p->prop[0].u.value);
+        JS_ToUint32(ctx, &cur_len, prop->u.value);
         if (len < cur_len) {
             uint32_t d;
             JSShape *sh;
@@ -8253,23 +7703,6 @@ static int set_array_length(JSContext *ctx, JSObject *p, JSValue val,
     return TRUE;
 }
 
-/* return -1 if exception */
-static int expand_fast_array(JSContext *ctx, JSObject *p, uint32_t new_len)
-{
-    uint32_t new_size;
-    size_t slack;
-    JSValue *new_array_prop;
-    /* XXX: potential arithmetic overflow */
-    new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);
-    new_array_prop = js_realloc2(ctx, p->u.array.u.values, sizeof(JSValue) * new_size, &slack);
-    if (!new_array_prop)
-        return -1;
-    new_size += slack / sizeof(*new_array_prop);
-    p->u.array.u.values = new_array_prop;
-    p->u.array.u1.size = new_size;
-    return 0;
-}
-
 /* Preconditions: 'p' must be of class JS_CLASS_ARRAY, p->fast_array =
    TRUE and p->extensible = TRUE */
 static int add_fast_array_element(JSContext *ctx, JSObject *p,
@@ -8292,10 +7725,19 @@ static int add_fast_array_element(JSContext *ctx, JSObject *p,
         }
     }
     if (unlikely(new_len > p->u.array.u1.size)) {
-        if (expand_fast_array(ctx, p, new_len)) {
+        uint32_t new_size;
+        size_t slack;
+        JSValue *new_array_prop;
+        /* XXX: potential arithmetic overflow */
+        new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);
+        new_array_prop = js_realloc2(ctx, p->u.array.u.values, sizeof(JSValue) * new_size, &slack);
+        if (!new_array_prop) {
             JS_FreeValue(ctx, val);
             return -1;
         }
+        new_size += slack / sizeof(*new_array_prop);
+        p->u.array.u.values = new_array_prop;
+        p->u.array.u1.size = new_size;
     }
     p->u.array.u.values[new_len - 1] = val;
     p->u.array.count = new_len;
@@ -8309,38 +7751,29 @@ static void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc)
     JS_FreeValue(ctx, desc->value);
 }
 
-/* generic (and slower) version of JS_SetProperty() for
- * Reflect.set(). 'obj' must be an object.  */
+/* generic (and slower) version of JS_SetProperty() for Reflect.set() */
 static int JS_SetPropertyGeneric(JSContext *ctx,
-                                 JSValueConst obj, JSAtom prop,
+                                 JSObject *p, JSAtom prop,
                                  JSValue val, JSValueConst this_obj,
                                  int flags)
 {
     int ret;
     JSPropertyDescriptor desc;
-    JSValue obj1;
-    JSObject *p;
-    
-    obj1 = JS_DupValue(ctx, obj);
-    for(;;) {
-        p = JS_VALUE_GET_OBJ(obj1);
+
+    while (p != NULL) {
         if (p->is_exotic) {
             const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
             if (em && em->set_property) {
-                ret = em->set_property(ctx, obj1, prop,
+                ret = em->set_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p), prop,
                                        val, this_obj, flags);
-                JS_FreeValue(ctx, obj1);
                 JS_FreeValue(ctx, val);
                 return ret;
             }
         }
 
         ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
-        if (ret < 0) {
-            JS_FreeValue(ctx, obj1);
-            JS_FreeValue(ctx, val);
+        if (ret < 0)
             return ret;
-        }
         if (ret) {
             if (desc.flags & JS_PROP_GETSET) {
                 JSObject *setter;
@@ -8351,38 +7784,27 @@ static int JS_SetPropertyGeneric(JSContext *ctx,
                 ret = call_setter(ctx, setter, this_obj, val, flags);
                 JS_FreeValue(ctx, desc.getter);
                 JS_FreeValue(ctx, desc.setter);
-                JS_FreeValue(ctx, obj1);
                 return ret;
             } else {
                 JS_FreeValue(ctx, desc.value);
                 if (!(desc.flags & JS_PROP_WRITABLE)) {
-                    JS_FreeValue(ctx, obj1);
                     goto read_only_error;
                 }
             }
             break;
         }
-        /* Note: at this point 'obj1' cannot be a proxy. XXX: may have
-           to check recursion */
-        obj1 = JS_GetPrototypeFree(ctx, obj1);
-        if (JS_IsNull(obj1))
-            break;
+        p = p->shape->proto;
     }
-    JS_FreeValue(ctx, obj1);
 
-    if (!JS_IsObject(this_obj)) {
-        JS_FreeValue(ctx, val);
+    if (!JS_IsObject(this_obj))
         return JS_ThrowTypeErrorOrFalse(ctx, flags, "receiver is not an object");
-    }
-    
+
     p = JS_VALUE_GET_OBJ(this_obj);
 
     /* modify the property in this_obj if it already exists */
     ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
-    if (ret < 0) {
-        JS_FreeValue(ctx, val);
+    if (ret < 0)
         return ret;
-    }
     if (ret) {
         if (desc.flags & JS_PROP_GETSET) {
             JS_FreeValue(ctx, desc.getter);
@@ -8436,17 +7858,14 @@ int JS_SetPropertyInternal(JSContext *ctx, JSValueConst this_obj,
     if (unlikely(tag != JS_TAG_OBJECT)) {
         switch(tag) {
         case JS_TAG_NULL:
-            JS_FreeValue(ctx, val);
-            JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of null", prop);
-            return -1;
         case JS_TAG_UNDEFINED:
             JS_FreeValue(ctx, val);
-            JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of undefined", prop);
+            JS_ThrowTypeError(ctx, "value has no property");
             return -1;
         default:
             /* even on a primitive type we can have setters on the prototype */
             p = NULL;
-            p1 = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, this_obj));
+            p1 = JS_VALUE_GET_OBJ(JS_GetPrototype(ctx, this_obj));
             goto prototype_lookup;
         }
     }
@@ -8459,10 +7878,11 @@ retry:
             /* fast case */
             set_value(ctx, &pr->u.value, val);
             return TRUE;
-        } else if (prs->flags & JS_PROP_LENGTH) {
+        } else if ((prs->flags & (JS_PROP_LENGTH | JS_PROP_WRITABLE)) ==
+                   (JS_PROP_LENGTH | JS_PROP_WRITABLE)) {
             assert(p->class_id == JS_CLASS_ARRAY);
             assert(prop == JS_ATOM_length);
-            return set_array_length(ctx, p, val, flags);
+            return set_array_length(ctx, p, pr, val, flags);
         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {
             return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
@@ -8475,7 +7895,7 @@ retry:
             return TRUE;
         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
             /* Instantiate property and retry (potentially useless) */
-            if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) {
+            if (JS_AutoInitProperty(ctx, p, prop, pr)) {
                 JS_FreeValue(ctx, val);
                 return -1;
             }
@@ -8513,28 +7933,25 @@ retry:
                         JS_FreeValue(ctx, val);
                         if (JS_IsException(val))
                             return -1;
+                        if (typed_array_is_detached(ctx, p1)) {
+                            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
+                            return -1;
+                        }
                         return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound numeric index");
                     }
                 }
             } else {
                 const JSClassExoticMethods *em = ctx->rt->class_array[p1->class_id].exotic;
                 if (em) {
-                    JSValue obj1;
                     if (em->set_property) {
-                        /* set_property can free the prototype */
-                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));
-                        ret = em->set_property(ctx, obj1, prop,
+                        ret = em->set_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p1), prop,
                                                val, this_obj, flags);
-                        JS_FreeValue(ctx, obj1);
                         JS_FreeValue(ctx, val);
                         return ret;
                     }
                     if (em->get_own_property) {
-                        /* get_own_property can free the prototype */
-                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));
                         ret = em->get_own_property(ctx, &desc,
-                                                   obj1, prop);
-                        JS_FreeValue(ctx, obj1);
+                                                   JS_MKPTR(JS_TAG_OBJECT, p1), prop);
                         if (ret < 0) {
                             JS_FreeValue(ctx, val);
                             return ret;
@@ -8581,7 +7998,7 @@ retry:
                 return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
             } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
                 /* Instantiate property and retry (potentially useless) */
-                if (JS_AutoInitProperty(ctx, p1, prop, pr, prs))
+                if (JS_AutoInitProperty(ctx, p1, prop, pr))
                     return -1;
                 goto retry2;
             } else if (!(prs->flags & JS_PROP_WRITABLE)) {
@@ -8749,7 +8166,12 @@ static int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,
                 return -1;
             if (unlikely(idx >= (uint32_t)p->u.array.count)) {
             ta_out_of_bound:
-                return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound numeric index");
+                if (typed_array_is_detached(ctx, p)) {
+                    JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
+                    return -1;
+                } else {
+                    return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound numeric index");
+                }
             }
             p->u.array.u.double_ptr[idx] = d;
             break;
@@ -9034,32 +8456,13 @@ int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
  redo_prop_update:
     prs = find_own_property(&pr, p, prop);
     if (prs) {
-        /* the range of the Array length property is always tested before */
-        if ((prs->flags & JS_PROP_LENGTH) && (flags & JS_PROP_HAS_VALUE)) {
-            uint32_t array_length;
-            if (JS_ToArrayLengthFree(ctx, &array_length,
-                                     JS_DupValue(ctx, val), FALSE)) {
-                return -1;
-            }
-            /* this code relies on the fact that Uint32 are never allocated */
-            val = (JSValueConst)JS_NewUint32(ctx, array_length);
-            /* prs may have been modified */
-            prs = find_own_property(&pr, p, prop);
-            assert(prs != NULL);
-        }
         /* property already exists */
         if (!check_define_prop_flags(prs->flags, flags)) {
         not_configurable:
             return JS_ThrowTypeErrorOrFalse(ctx, flags, "property is not configurable");
         }
 
-        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
-            /* Instantiate property and retry */
-            if (JS_AutoInitProperty(ctx, p, prop, pr, prs))
-                return -1;
-            goto redo_prop_update;
-        }
-
+    retry:
         if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |
                      JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
             if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {
@@ -9082,6 +8485,13 @@ int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
                     /* convert to getset */
                     if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
                         free_var_ref(ctx->rt, pr->u.var_ref);
+                    } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
+                        /* clear property and update */
+                        if (js_shape_prepare_update(ctx, p, &prs))
+                            return -1;
+                        prs->flags &= ~JS_PROP_TMASK;
+                        pr->u.value = JS_UNDEFINED;
+                        goto retry;
                     } else {
                         JS_FreeValue(ctx, pr->u.value);
                     }
@@ -9129,17 +8539,38 @@ int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
                     pr->u.value = JS_UNDEFINED;
                 } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
                     /* Note: JS_PROP_VARREF is always writable */
+                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
+                    /* clear property and update */
+                    if (js_shape_prepare_update(ctx, p, &prs))
+                        return -1;
+                    prs->flags &= ~JS_PROP_TMASK;
+                    pr->u.value = JS_UNDEFINED;
                 } else {
                     if ((prs->flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0 &&
-                        (flags & JS_PROP_HAS_VALUE)) {
-                        if (!js_same_value(ctx, val, pr->u.value)) {
-                            goto not_configurable;
-                        } else {
-                            return TRUE;
-                        }
+                        (flags & JS_PROP_HAS_VALUE) &&
+                        !js_same_value(ctx, val, pr->u.value)) {
+                        goto not_configurable;
                     }
                 }
-                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
+                if (prs->flags & JS_PROP_LENGTH) {
+                    if (flags & JS_PROP_HAS_VALUE) {
+                        res = set_array_length(ctx, p, pr, JS_DupValue(ctx, val),
+                                               flags);
+                    } else {
+                        res = TRUE;
+                    }
+                    /* still need to reset the writable flag if needed.
+                       The JS_PROP_LENGTH is reset to have the correct
+                       read-only behavior in JS_SetProperty(). */
+                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==
+                        JS_PROP_HAS_WRITABLE) {
+                        prs = get_shape_prop(p->shape);
+                        if (js_update_property_flags(ctx, p, &prs,
+                                                     prs->flags & ~(JS_PROP_WRITABLE | JS_PROP_LENGTH)))
+                            return -1;
+                    }
+                    return res;
+                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
                     if (flags & JS_PROP_HAS_VALUE) {
                         if (p->class_id == JS_CLASS_MODULE_NS) {
                             /* JS_PROP_WRITABLE is always true for variable
@@ -9163,27 +8594,9 @@ int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
                         pr->u.value = val1;
                         prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);
                     }
-                } else if (prs->flags & JS_PROP_LENGTH) {
-                    if (flags & JS_PROP_HAS_VALUE) {
-                        /* Note: no JS code is executable because
-                           'val' is guaranted to be a Uint32 */
-                        res = set_array_length(ctx, p, JS_DupValue(ctx, val),
-                                               flags);
-                    } else {
-                        res = TRUE;
-                    }
-                    /* still need to reset the writable flag if
-                       needed.  The JS_PROP_LENGTH is kept because the
-                       Uint32 test is still done if the length
-                       property is read-only. */
-                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==
-                        JS_PROP_HAS_WRITABLE) {
-                        prs = get_shape_prop(p->shape);
-                        if (js_update_property_flags(ctx, p, &prs,
-                                                     prs->flags & ~JS_PROP_WRITABLE))
-                            return -1;
-                    }
-                    return res;
+                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
+                    /* XXX: should never happen, type was reset above */
+                    abort();
                 } else {
                     if (flags & JS_PROP_HAS_VALUE) {
                         JS_FreeValue(ctx, pr->u.value);
@@ -9268,9 +8681,9 @@ int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
             typed_array_oob:
                 return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound index in typed array");
             }
-            prop_flags = get_prop_flags(flags, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
+            prop_flags = get_prop_flags(flags, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE);
             if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET) ||
-                prop_flags != (JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE)) {
+                prop_flags != (JS_PROP_ENUMERABLE | JS_PROP_WRITABLE)) {
                 return JS_ThrowTypeErrorOrFalse(ctx, flags, "invalid descriptor flags");
             }
             if (flags & JS_PROP_HAS_VALUE) {
@@ -9285,7 +8698,8 @@ int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
 }
 
 static int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,
-                                     JSAtom prop, JSAutoInitIDEnum id,
+                                     JSAtom prop, int (*init_func)(JSContext *ctx, JSObject *obj,
+                                                                   JSAtom prop, void *opaque),
                                      void *opaque, int flags)
 {
     JSObject *p;
@@ -9306,10 +8720,8 @@ static int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,
     pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);
     if (unlikely(!pr))
         return -1;
-    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);
-    assert((pr->u.init.realm_and_id & 3) == 0);
-    assert(id <= 3);
-    pr->u.init.realm_and_id |= id;
+
+    pr->u.init.init_func = init_func;
     pr->u.init.opaque = opaque;
     return TRUE;
 }
@@ -9446,7 +8858,9 @@ static int JS_DefineObjectNameComputed(JSContext *ctx, JSValueConst obj,
 
 static JSValue JS_ThrowSyntaxErrorVarRedeclaration(JSContext *ctx, JSAtom prop)
 {
-    return JS_ThrowSyntaxErrorAtom(ctx, "redeclaration of '%s'", prop);
+    char buf[ATOM_GET_STR_BUF_SIZE];
+    return JS_ThrowSyntaxError(ctx, "redeclaration of %s",
+                               JS_AtomGetStr(ctx, buf, sizeof(buf), prop));
 }
 
 /* flags is 0, DEFINE_GLOBAL_LEX_VAR or DEFINE_GLOBAL_FUNC_VAR */
@@ -9455,6 +8869,7 @@ static int JS_CheckDefineGlobalVar(JSContext *ctx, JSAtom prop, int flags)
 {
     JSObject *p;
     JSShapeProperty *prs;
+    char buf[ATOM_GET_STR_BUF_SIZE];
 
     p = JS_VALUE_GET_OBJ(ctx->global_obj);
     prs = find_own_property1(p, prop);
@@ -9472,8 +8887,8 @@ static int JS_CheckDefineGlobalVar(JSContext *ctx, JSAtom prop, int flags)
                      ((prs->flags & (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)) !=
                       (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)))) {
                 define_error:
-                    JS_ThrowTypeErrorAtom(ctx, "cannot define variable '%s'",
-                                          prop);
+                    JS_ThrowTypeError(ctx, "cannot define variable %s",
+                                      JS_AtomGetStr(ctx, buf, sizeof(buf), prop));
                     return -1;
                 }
             }
@@ -9655,8 +9070,9 @@ static int JS_SetGlobalVar(JSContext *ctx, JSAtom prop, JSValue val,
         set_value(ctx, &pr->u.value, val);
         return 0;
     }
+
     flags = JS_PROP_THROW_STRICT;
-    if (is_strict_mode(ctx)) 
+    if (flag != 2 && is_strict_mode(ctx))
         flags |= JS_PROP_NO_ADD;
     return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, flags);
 }
@@ -9711,6 +9127,8 @@ BOOL JS_IsFunction(JSContext *ctx, JSValueConst val)
     p = JS_VALUE_GET_OBJ(val);
     switch(p->class_id) {
     case JS_CLASS_BYTECODE_FUNCTION:
+    case JS_CLASS_C_FUNCTION:
+    case JS_CLASS_BOUND_FUNCTION:
         return TRUE;
     case JS_CLASS_PROXY:
         return p->u.proxy_data->is_func;
@@ -9740,7 +9158,8 @@ BOOL JS_IsConstructor(JSContext *ctx, JSValueConst val)
     return p->is_constructor;
 }
 
-BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, BOOL val)
+static BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj,
+                                 BOOL val)
 {
     JSObject *p;
     if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
@@ -9756,7 +9175,22 @@ BOOL JS_IsError(JSContext *ctx, JSValueConst val)
     if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)
         return FALSE;
     p = JS_VALUE_GET_OBJ(val);
-    return (p->class_id == JS_CLASS_ERROR);
+    if (p->class_id == JS_CLASS_ERROR)
+        return TRUE;
+    if (ctx->is_error_property_enabled) {
+        /* check for a special property for test262 test suites */
+        JSValue isError;
+        isError = JS_GetPropertyStr(ctx, val, "isError");
+        return JS_ToBoolFree(ctx, isError);
+    } else {
+        return FALSE;
+    }
+}
+
+/* only used for test262 test suites */
+void JS_EnableIsErrorProperty(JSContext *ctx, BOOL enable)
+{
+    ctx->is_error_property_enabled = enable;
 }
 
 /* used to avoid catching interrupt exceptions */
@@ -9781,7 +9215,7 @@ void JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag)
 
 void JS_ResetUncatchableError(JSContext *ctx)
 {
-    JS_SetUncatchableError(ctx, ctx->rt->current_exception, FALSE);
+    JS_SetUncatchableError(ctx, ctx->current_exception, FALSE);
 }
 
 void JS_SetOpaque(JSValue obj, void *opaque)
@@ -9817,6 +9251,9 @@ void *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id)
 #define HINT_STRING  0
 #define HINT_NUMBER  1
 #define HINT_NONE    2
+#ifdef CONFIG_BIGNUM
+#define HINT_INTEGER 3
+#endif
 /* don't try Symbol.toPrimitive */
 #define HINT_FORCE_ORDINARY (1 << 4)
 
@@ -9851,6 +9288,11 @@ static JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint)
             case HINT_NONE:
                 atom = JS_ATOM_default;
                 break;
+#ifdef CONFIG_BIGNUM
+            case HINT_INTEGER:
+                atom = JS_ATOM_integer;
+                break;
+#endif
             }
             arg = JS_AtomToString(ctx, atom);
             ret = JS_CallFree(ctx, method, val, 1, (JSValueConst *)&arg);
@@ -9899,24 +9341,6 @@ static JSValue JS_ToPrimitive(JSContext *ctx, JSValueConst val, int hint)
     return JS_ToPrimitiveFree(ctx, JS_DupValue(ctx, val), hint);
 }
 
-void JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj)
-{
-    JSObject *p;
-    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
-        return;
-    p = JS_VALUE_GET_OBJ(obj);
-    p->is_HTMLDDA = TRUE;
-}
-
-static inline BOOL JS_IsHTMLDDA(JSContext *ctx, JSValueConst obj)
-{
-    JSObject *p;
-    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
-        return FALSE;
-    p = JS_VALUE_GET_OBJ(obj);
-    return p->is_HTMLDDA;
-}
-                         
 static int JS_ToBoolFree(JSContext *ctx, JSValue val)
 {
     uint32_t tag = JS_VALUE_GET_TAG(val);
@@ -9945,24 +9369,7 @@ static int JS_ToBoolFree(JSContext *ctx, JSValue val)
             JS_FreeValue(ctx, val);
             return ret;
         }
-    case JS_TAG_BIG_DECIMAL:
-        {
-            JSBigDecimal *p = JS_VALUE_GET_PTR(val);
-            BOOL ret;
-            ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;
-            JS_FreeValue(ctx, val);
-            return ret;
-        }
 #endif
-    case JS_TAG_OBJECT:
-        {
-            JSObject *p = JS_VALUE_GET_OBJ(val);
-            BOOL ret;
-            ret = !p->is_HTMLDDA;
-            JS_FreeValue(ctx, val);
-            return ret;
-        }
-        break;
     default:
         if (JS_TAG_IS_FLOAT64(tag)) {
             double d = JS_VALUE_GET_FLOAT64(val);
@@ -10001,6 +9408,55 @@ static int skip_spaces(const char *pc)
     return p - p_start;
 }
 
+#ifdef CONFIG_BIGNUM
+
+/* force big int type if integer result */
+#define BF_ATOF_BIG_INT     (1 << 30)
+/* return JS_EXCEPTION if invalid syntax. Otherwise return NaN */
+#define BF_ATOF_THROW       (1 << 29)
+#define BF_ATOF_FLOAT64     (1 << 28)
+
+static JSValue js_atof(JSContext *ctx, const char *p, const char **pp,
+                       int radix, int flags)
+{
+    bf_t a_s, *a = &a_s;
+    int res;
+    slimb_t prec;
+    JSValue val;
+
+    bf_init(ctx->bf_ctx, a);
+    if (flags & BF_ATOF_FLOAT64) {
+        prec = 53;
+        flags |= bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL;
+    } else {
+        /* use the current precision */
+        prec = ctx->fp_env.prec;
+        flags |= ctx->fp_env.flags;
+    }
+    p += skip_spaces(p);
+    res = bf_atof(a, p, &p, radix, prec, flags);
+    if ((flags & BF_ATOF_THROW) && bf_is_nan(a)) {
+        bf_delete(a);
+        return JS_EXCEPTION;
+    }
+    if (res & BF_ATOF_ST_INTEGER) {
+        val = JS_NewBigInt2(ctx, a, (flags & BF_ATOF_BIG_INT) != 0);
+    } else if (flags & BF_ATOF_FLOAT64) {
+        double d;
+        bf_get_float64(a, &d, BF_RNDN);
+        bf_delete(a);
+        /* return int or float64 */
+        val = JS_NewFloat64(ctx, d);
+    } else {
+        val = JS_NewBigFloat(ctx, a);
+    }
+    if (pp)
+        *pp = p;
+    return val;
+}
+
+#else
+
 static inline int to_digit(int c)
 {
     if (c >= '0' && c <= '9')
@@ -10013,180 +9469,44 @@ static inline int to_digit(int c)
         return 36;
 }
 
-/* XXX: remove */
-static double js_strtod(const char *p, int radix, BOOL is_float)
-{
-    double d;
-    int c;
-    
-    if (!is_float || radix != 10) {
-        uint64_t n_max, n;
-        int int_exp, is_neg;
-        
-        is_neg = 0;
-        if (*p == '-') {
-            is_neg = 1;
-            p++;
-        }
-
-        /* skip leading zeros */
-        while (*p == '0')
-            p++;
-        n = 0;
-        if (radix == 10)
-            n_max = ((uint64_t)-1 - 9) / 10; /* most common case */
-        else
-            n_max = ((uint64_t)-1 - (radix - 1)) / radix;
-        /* XXX: could be more precise */
-        int_exp = 0;
-        while (*p != '\0') {
-            c = to_digit((uint8_t)*p);
-            if (c >= radix)
-                break;
-            if (n <= n_max) {
-                n = n * radix + c;
-            } else {
-                int_exp++;
-            }
-            p++;
-        }
-        d = n;
-        if (int_exp != 0) {
-            d *= pow(radix, int_exp);
-        }
-        if (is_neg)
-            d = -d;
-    } else {
-        d = strtod(p, NULL);
-    }
-    return d;
-}
-
 #define ATOD_INT_ONLY        (1 << 0)
+/* return JS_EXCEPTION if invalid syntax. Otherwise return NaN */
+#define ATOD_THROW           (1 << 1)
 /* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */
 #define ATOD_ACCEPT_BIN_OCT  (1 << 2)
+/* if set return NaN if empty number string */
+#define ATOD_NAN_IF_EMPTY    (1 << 3)
 /* accept O prefix as octal if radix == 0 and properly formed (Annex B) */
 #define ATOD_ACCEPT_LEGACY_OCTAL  (1 << 4)
 /* accept _ between digits as a digit separator */
 #define ATOD_ACCEPT_UNDERSCORES  (1 << 5)
-/* allow a suffix to override the type */
-#define ATOD_ACCEPT_SUFFIX    (1 << 6) 
-/* default type */
-#define ATOD_TYPE_MASK        (3 << 7)
-#define ATOD_TYPE_FLOAT64     (0 << 7)
-#define ATOD_TYPE_BIG_INT     (1 << 7)
-#define ATOD_TYPE_BIG_FLOAT   (2 << 7)
-#define ATOD_TYPE_BIG_DECIMAL (3 << 7)
-/* assume bigint mode: floats are parsed as integers if no decimal
-   point nor exponent */
-#define ATOD_MODE_BIGINT      (1 << 9) 
-/* accept -0x1 */
-#define ATOD_ACCEPT_PREFIX_AFTER_SIGN (1 << 10)
-
-#ifdef CONFIG_BIGNUM
-static JSValue js_string_to_bigint(JSContext *ctx, const char *buf,
-                                   int radix, int flags, slimb_t *pexponent)
-{
-    bf_t a_s, *a = &a_s;
-    int ret;
-    JSValue val;
-    val = JS_NewBigInt(ctx);
-    if (JS_IsException(val))
-        return val;
-    a = JS_GetBigInt(val);
-    ret = bf_atof(a, buf, NULL, radix, BF_PREC_INF, BF_RNDZ);
-    if (ret & BF_ST_MEM_ERROR) {
-        JS_FreeValue(ctx, val);
-        return JS_ThrowOutOfMemory(ctx);
-    }
-    val = JS_CompactBigInt1(ctx, val, (flags & ATOD_MODE_BIGINT) != 0);
-    return val;
-}
 
-static JSValue js_string_to_bigfloat(JSContext *ctx, const char *buf,
-                                     int radix, int flags, slimb_t *pexponent)
-{
-    bf_t *a;
-    int ret;
-    JSValue val;
-    
-    val = JS_NewBigFloat(ctx);
-    if (JS_IsException(val))
-        return val;
-    a = JS_GetBigFloat(val);
-    if (flags & ATOD_ACCEPT_SUFFIX) {
-        /* return the exponent to get infinite precision */
-        ret = bf_atof2(a, pexponent, buf, NULL, radix, BF_PREC_INF,
-                       BF_RNDZ | BF_ATOF_EXPONENT);
-    } else {
-        ret = bf_atof(a, buf, NULL, radix, ctx->fp_env.prec,
-                      ctx->fp_env.flags);
-    }
-    if (ret & BF_ST_MEM_ERROR) {
-        JS_FreeValue(ctx, val);
-        return JS_ThrowOutOfMemory(ctx);
-    }
-    return val;
-}
-
-static JSValue js_string_to_bigdecimal(JSContext *ctx, const char *buf,
-                                       int radix, int flags, slimb_t *pexponent)
-{
-    bfdec_t *a;
-    int ret;
-    JSValue val;
-    
-    val = JS_NewBigDecimal(ctx);
-    if (JS_IsException(val))
-        return val;
-    a = JS_GetBigDecimal(val);
-    ret = bfdec_atof(a, buf, NULL, BF_PREC_INF,
-                     BF_RNDZ | BF_ATOF_NO_NAN_INF);
-    if (ret & BF_ST_MEM_ERROR) {
-        JS_FreeValue(ctx, val);
-        return JS_ThrowOutOfMemory(ctx);
-    }
-    return val;
-}
-
-#endif
-
-/* return an exception in case of memory error. Return JS_NAN if
-   invalid syntax */
-#ifdef CONFIG_BIGNUM
-static JSValue js_atof2(JSContext *ctx, const char *str, const char **pp,
-                        int radix, int flags, slimb_t *pexponent)
-#else
-static JSValue js_atof(JSContext *ctx, const char *str, const char **pp,
+/* radix = 0 accepts prefixes. radix = 16 also
+   accepts 0x prefix. radix must be 0 or between 2 and 36 */
+static JSValue js_atod(JSContext *ctx, const char *str, const char **pp,
                        int radix, int flags)
-#endif
 {
-    const char *p, *p_start;
-    int sep, is_neg;
-    BOOL is_float, has_legacy_octal;
-    int atod_type = flags & ATOD_TYPE_MASK;
-    char buf1[64], *buf;
-    int i, j, len;
-    BOOL buf_allocated = FALSE;
-    JSValue val;
-    
+    const char *p;
+    const char *p_start;
+    int is_neg, c, sep;
+    double d;
+
     /* optional separator between digits */
     sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;
-    has_legacy_octal = FALSE;
-    
-    p = str;
+
+    p = str + skip_spaces(str);
     p_start = p;
     is_neg = 0;
     if (p[0] == '+') {
         p++;
         p_start++;
-        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))
+        if (!(flags & ATOD_INT_ONLY))
             goto no_radix_prefix;
     } else if (p[0] == '-') {
+        is_neg = 1;
         p++;
         p_start++;
-        is_neg = 1;
-        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))
+        if (!(flags & ATOD_INT_ONLY))
             goto no_radix_prefix;
     }
     if (p[0] == '0') {
@@ -10205,7 +9525,6 @@ static JSValue js_atof(JSContext *ctx, const char *str, const char **pp,
         } else if ((p[1] >= '0' && p[1] <= '9') &&
                    radix == 0 && (flags & ATOD_ACCEPT_LEGACY_OCTAL)) {
             int i;
-            has_legacy_octal = TRUE;
             sep = 256;
             for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++)
                 continue;
@@ -10222,187 +9541,121 @@ static JSValue js_atof(JSContext *ctx, const char *str, const char **pp,
     no_prefix: ;
     } else {
  no_radix_prefix:
-        if (!(flags & ATOD_INT_ONLY) &&
-            (atod_type == ATOD_TYPE_FLOAT64 ||
-             atod_type == ATOD_TYPE_BIG_FLOAT) &&
-            strstart(p, "Infinity", &p)) {
-#ifdef CONFIG_BIGNUM
-            if (atod_type == ATOD_TYPE_BIG_FLOAT) {
-                bf_t *a;
-                val = JS_NewBigFloat(ctx);
-                if (JS_IsException(val))
-                    goto done;
-                a = JS_GetBigFloat(val);
-                bf_set_inf(a, is_neg);
-            } else
+        if (!(flags & ATOD_INT_ONLY) && strstart(p, "Infinity", &p)) {
+#ifdef _MSC_VER
+            d = INFINITY;
+#else
+            d = 1.0 / 0.0;
 #endif
-            {
-                double d = 1.0 / 0.0;
-                if (is_neg)
-                    d = -d;
-                val = JS_NewFloat64(ctx, d);
-            }
             goto done;
         }
     }
     if (radix == 0)
         radix = 10;
-    is_float = FALSE;
-    p_start = p;
-    while (to_digit((uint8_t)*p) < radix
-           ||  (*p == sep && (radix != 10 ||
-                              p != p_start + 1 || p[-1] != '0') &&
-                to_digit((uint8_t)p[1]) < radix)) {
-        p++;
-    }
-    if (!(flags & ATOD_INT_ONLY)) {
-        if (*p == '.' && (p > p_start || to_digit((uint8_t)p[1]) < radix)) {
-            is_float = TRUE;
+    if ((flags & ATOD_INT_ONLY) || radix != 10) {
+        uint64_t n_max, n;
+        int int_exp;
+
+        /* skip leading zeros */
+        while (*p == '0')
             p++;
-            if (*p == sep)
-                goto fail;
-            while (to_digit((uint8_t)*p) < radix ||
-                   (*p == sep && to_digit((uint8_t)p[1]) < radix))
+        n = 0;
+        if (radix == 10)
+            n_max = ((uint64_t)-1 - 9) / 10; /* most common case */
+        else
+            n_max = ((uint64_t)-1 - (radix - 1)) / radix;
+        /* XXX: could be more precise */
+        int_exp = 0;
+        while (*p != '\0') {
+            if (*p == sep && to_digit(p[1]) < radix)
+                p++;
+            c = to_digit((uint8_t)*p);
+            if (c >= radix)
+                break;
+            if (n <= n_max) {
+                n = n * radix + c;
+            } else {
+                int_exp++;
+            }
+            p++;
+        }
+        d = n;
+        if (int_exp != 0) {
+            d *= pow(radix, int_exp);
+        }
+    } else {
+        p_start = p;
+        while (isdigit((uint8_t)*p)
+           ||  (*p == sep && (p != p_start + 1 || p[-1] != '0') &&
+               isdigit((uint8_t)p[1]))) {
+            p++;
+        }
+        if (*p == '.' && (p > p_start || isdigit((uint8_t)p[1]))) {
+            p++;
+            while (isdigit((uint8_t)*p) || (*p == sep && isdigit((uint8_t)p[1])))
                 p++;
         }
-        if (p > p_start &&
-            (((*p == 'e' || *p == 'E') && radix == 10) ||
-             ((*p == 'p' || *p == 'P') && (radix == 2 || radix == 8 || radix == 16)))) {
+        if (p > p_start && (*p == 'e' || *p == 'E')) {
             const char *p1 = p + 1;
-            is_float = TRUE;
             if (*p1 == '+') {
                 p1++;
             } else if (*p1 == '-') {
                 p1++;
             }
-            if (is_digit((uint8_t)*p1)) {
+            if (isdigit((uint8_t)*p1)) {
                 p = p1 + 1;
-                while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))
+                while (isdigit((uint8_t)*p) || (*p == sep && isdigit((uint8_t)p[1])))
                     p++;
             }
         }
-    }
-    if (p == p_start)
-        goto fail;
-
-    buf = buf1;
-    buf_allocated = FALSE;
-    len = p - p_start;
-    if (unlikely((len + 2) > sizeof(buf1))) {
-        buf = js_malloc_rt(ctx->rt, len + 2); /* no exception raised */
-        if (!buf)
-            goto mem_error;
-        buf_allocated = TRUE;
-    }
-    /* remove the separators and the radix prefixes */
-    j = 0;
-    if (is_neg)
-        buf[j++] = '-';
-    for (i = 0; i < len; i++) {
-        if (p_start[i] != '_')
-            buf[j++] = p_start[i];
-    }
-    buf[j] = '\0';
-
-#ifdef CONFIG_BIGNUM
-    if (flags & ATOD_ACCEPT_SUFFIX) {
-        if (*p == 'n') {
-            p++;
-            atod_type = ATOD_TYPE_BIG_INT;
-        } else if (*p == 'l') {
-            p++;
-            atod_type = ATOD_TYPE_BIG_FLOAT;
-        } else if (*p == 'm') {
-            p++;
-            atod_type = ATOD_TYPE_BIG_DECIMAL;
+        if (*p == '\0' && sep != '_') {
+            d = strtod(p_start, NULL);
         } else {
-            if (flags & ATOD_MODE_BIGINT) {
-                if (!is_float)
-                    atod_type = ATOD_TYPE_BIG_INT;
-                if (has_legacy_octal)
-                    goto fail;
-            } else {
-                if (is_float && radix != 10)
-                    goto fail;
+            char buf1[64], *buf;
+            int i, j, len;
+            BOOL buf_allocated;
+
+            buf = buf1;
+            buf_allocated = FALSE;
+            len = p - p_start;
+            if (len >= sizeof(buf1)) {
+                buf = js_malloc(ctx, len + 1);
+                if (!buf)
+                    return JS_EXCEPTION;
+                buf_allocated = TRUE;
             }
-        }
-    } else {
-        if (atod_type == ATOD_TYPE_FLOAT64) {
-            if (flags & ATOD_MODE_BIGINT) {
-                if (!is_float)
-                    atod_type = ATOD_TYPE_BIG_INT;
-                if (has_legacy_octal)
-                    goto fail;
-            } else {
-                if (is_float && radix != 10)
-                    goto fail;
+            for (i = j = 0; i < len; i++) {
+                if (p_start[i] != '_')
+                    buf[j++] = p_start[i];
             }
+            buf[j] = '\0';
+            d = strtod(buf, NULL);
+            if (buf_allocated)
+                js_free(ctx, buf);
         }
     }
-
-    switch(atod_type) {
-    case ATOD_TYPE_FLOAT64:
-        {
-            double d;
-            d = js_strtod(buf, radix, is_float);
-            /* return int or float64 */
-            val = JS_NewFloat64(ctx, d);
-        }
-        break;
-    case ATOD_TYPE_BIG_INT:
-        if (has_legacy_octal || is_float)
-            goto fail;
-        val = ctx->rt->bigint_ops.from_string(ctx, buf, radix, flags, NULL);
-        break;
-    case ATOD_TYPE_BIG_FLOAT:
-        if (has_legacy_octal)
-            goto fail;
-        val = ctx->rt->bigfloat_ops.from_string(ctx, buf, radix, flags,
-                                                pexponent);
-        break;
-    case ATOD_TYPE_BIG_DECIMAL:
-        if (radix != 10)
-            goto fail;
-        val = ctx->rt->bigdecimal_ops.from_string(ctx, buf, radix, flags, NULL);
-        break;
-    default:
-        abort();
-    }
-#else
-    {
-        double d;
-        (void)has_legacy_octal;
-        if (is_float && radix != 10)
-            goto fail;
-        d = js_strtod(buf, radix, is_float);
-        val = JS_NewFloat64(ctx, d);
-    }
-#endif
-    
 done:
-    if (buf_allocated)
-        js_free_rt(ctx->rt, buf);
+    if (is_neg)
+        d = -d;
+    if (p == p_start && (flags & ATOD_NAN_IF_EMPTY)) {
+        d = JS_FLOAT64_NAN;
+    }
     if (pp)
         *pp = p;
-    return val;
+    return JS_NewFloat64(ctx, d);
  fail:
-    val = JS_NAN;
-    goto done;
- mem_error:
-    val = JS_ThrowOutOfMemory(ctx);
-    goto done;
-}
-
-#ifdef CONFIG_BIGNUM
-static JSValue js_atof(JSContext *ctx, const char *str, const char **pp,
-                       int radix, int flags)
-{
-    return js_atof2(ctx, str, pp, radix, flags, NULL);
+    if (pp)
+        *pp = p;
+    if (flags & ATOD_THROW)
+        return JS_EXCEPTION;
+    else
+        return JS_NAN;
 }
 #endif
 
 typedef enum JSToNumberHintEnum {
     TON_FLAG_NUMBER,
+    TON_FLAG_INTEGER,
     TON_FLAG_NUMERIC,
 } JSToNumberHintEnum;
 
@@ -10411,32 +9664,19 @@ static JSValue JS_ToNumberHintFree(JSContext *ctx, JSValue val,
 {
     uint32_t tag;
     JSValue ret;
+    int hint;
 
  redo:
     tag = JS_VALUE_GET_NORM_TAG(val);
     switch(tag) {
 #ifdef CONFIG_BIGNUM
-    case JS_TAG_BIG_DECIMAL:
-        if (flag != TON_FLAG_NUMERIC) {
-            JS_FreeValue(ctx, val);
-            return JS_ThrowTypeError(ctx, "cannot convert bigdecimal to number");
-        }
-        ret = val;
-        break;
     case JS_TAG_BIG_INT:
-        if (flag != TON_FLAG_NUMERIC) {
+        if (flag == TON_FLAG_NUMBER && !is_bignum_mode(ctx)) {
             JS_FreeValue(ctx, val);
             return JS_ThrowTypeError(ctx, "cannot convert bigint to number");
         }
-        ret = val;
-        break;
+        /* fall thru */
     case JS_TAG_BIG_FLOAT:
-        if (flag != TON_FLAG_NUMERIC) {
-            JS_FreeValue(ctx, val);
-            return JS_ThrowTypeError(ctx, "cannot convert bigfloat to number");
-        }
-        ret = val;
-        break;
 #endif
     case JS_TAG_FLOAT64:
     case JS_TAG_INT:
@@ -10451,7 +9691,12 @@ static JSValue JS_ToNumberHintFree(JSContext *ctx, JSValue val,
         ret = JS_NAN;
         break;
     case JS_TAG_OBJECT:
-        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
+#ifdef CONFIG_BIGNUM
+        hint = flag == TON_FLAG_INTEGER ? HINT_INTEGER : HINT_NUMBER;
+#else
+        hint = HINT_NUMBER;
+#endif
+        val = JS_ToPrimitiveFree(ctx, val, hint);
         if (JS_IsException(val))
             return JS_EXCEPTION;
         goto redo;
@@ -10459,26 +9704,29 @@ static JSValue JS_ToNumberHintFree(JSContext *ctx, JSValue val,
         {
             const char *str;
             const char *p;
-            size_t len;
-            
-            str = JS_ToCStringLen(ctx, &len, val);
+
+            str = JS_ToCString(ctx, val);
             JS_FreeValue(ctx, val);
             if (!str)
                 return JS_EXCEPTION;
-            p = str;
+#ifdef CONFIG_BIGNUM
+            {
+                int flags;
+                flags = BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN |
+                    BF_ATOF_JS_QUIRKS | BF_ATOF_FLOAT64;
+                if (is_bignum_mode(ctx))
+                    flags |= BF_ATOF_INT_PREC_INF;
+                else
+                    flags |= BF_ATOF_ONLY_DEC_FLOAT;
+                ret = js_atof(ctx, str, &p, 0, flags);
+            }
+#else
+            ret = js_atod(ctx, str, &p, 0, ATOD_ACCEPT_BIN_OCT);
+#endif
             p += skip_spaces(p);
-            if ((p - str) == len) {
-                ret = JS_NewInt32(ctx, 0);
-            } else {
-                int flags = ATOD_ACCEPT_BIN_OCT;
-                ret = js_atof(ctx, p, &p, 0, flags);
-                if (!JS_IsException(ret)) {
-                    p += skip_spaces(p);
-                    if ((p - str) != len) {
-                        JS_FreeValue(ctx, ret);
-                        ret = JS_NAN;
-                    }
-                }
+            if (*p != '\0') {
+                JS_FreeValue(ctx, ret);
+                ret = JS_NAN;
             }
             JS_FreeCString(ctx, str);
         }
@@ -10499,6 +9747,7 @@ static JSValue JS_ToNumberFree(JSContext *ctx, JSValue val)
     return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);
 }
 
+#ifdef CONFIG_BIGNUM
 static JSValue JS_ToNumericFree(JSContext *ctx, JSValue val)
 {
     return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);
@@ -10508,6 +9757,7 @@ static JSValue JS_ToNumeric(JSContext *ctx, JSValueConst val)
 {
     return JS_ToNumericFree(ctx, JS_DupValue(ctx, val));
 }
+#endif
 
 static __exception int __JS_ToFloat64Free(JSContext *ctx, double *pres,
                                           JSValue val)
@@ -10574,7 +9824,6 @@ static JSValue JS_ToNumber(JSContext *ctx, JSValueConst val)
     return JS_ToNumberFree(ctx, JS_DupValue(ctx, val));
 }
 
-/* same as JS_ToNumber() but return 0 in case of NaN/Undefined */
 static __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)
 {
     uint32_t tag;
@@ -10596,18 +9845,24 @@ static __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)
                 ret = JS_NewInt32(ctx, 0);
             } else {
                 /* convert -0 to +0 */
+                /* XXX: should not be done here ? */
                 d = trunc(d) + 0.0;
                 ret = JS_NewFloat64(ctx, d);
             }
         }
         break;
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
+        if (!is_bignum_mode(ctx))
+            goto to_number;
+        ret = val;
+        break;
     case JS_TAG_BIG_FLOAT:
         {
             bf_t a_s, *a, r_s, *r = &r_s;
-            BOOL is_nan;
+            BOOL is_float, is_nan;
 
-            a = JS_ToBigFloat(ctx, &a_s, val);
+            a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
             if (!bf_is_finite(a)) {
                 is_nan = bf_is_nan(a);
                 if (is_nan)
@@ -10615,13 +9870,10 @@ static __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)
                 else
                     ret = JS_DupValue(ctx, val);
             } else {
-                ret = JS_NewBigInt(ctx);
-                if (!JS_IsException(ret)) {
-                    r = JS_GetBigInt(ret);
-                    bf_set(r, a);
-                    bf_rint(r, BF_RNDZ);
-                    ret = JS_CompactBigInt(ctx, ret);
-                }
+                bf_init(ctx->bf_ctx, r);
+                bf_set(r, a);
+                bf_rint(r, BF_PREC_INF, BF_RNDZ);
+                ret = JS_NewBigInt(ctx, r);
             }
             if (a == &a_s)
                 bf_delete(a);
@@ -10630,6 +9882,9 @@ static __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)
         break;
 #endif
     default:
+#ifdef CONFIG_BIGNUM
+    to_number:
+#endif
         val = JS_ToNumberFree(ctx, val);
         if (JS_IsException(val))
             return val;
@@ -10673,12 +9928,17 @@ static int JS_ToInt32SatFree(JSContext *ctx, int *pres, JSValue val)
         break;
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
+    to_bf:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             bf_get_int32(&ret, &p->num, 0);
             JS_FreeValue(ctx, val);
         }
         break;
+    case JS_TAG_BIG_INT:
+        if (is_bignum_mode(ctx))
+            goto to_bf;
+        /* fall thru */
 #endif
     default:
         val = JS_ToNumberFree(ctx, val);
@@ -10747,12 +10007,17 @@ static int JS_ToInt64SatFree(JSContext *ctx, int64_t *pres, JSValue val)
         return 0;
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
+    to_bf:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             bf_get_int64(pres, &p->num, 0);
             JS_FreeValue(ctx, val);
         }
         return 0;
+    case JS_TAG_BIG_INT:
+        if (is_bignum_mode(ctx))
+            goto to_bf;
+        /* fall thru */
 #endif
     default:
         val = JS_ToNumberFree(ctx, val);
@@ -10827,12 +10092,17 @@ static int JS_ToInt64Free(JSContext *ctx, int64_t *pres, JSValue val)
         break;
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
+    to_bf:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             bf_get_int64(&ret, &p->num, BF_GET_INT_MOD);
             JS_FreeValue(ctx, val);
         }
         break;
+    case JS_TAG_BIG_INT:
+        if (is_bignum_mode(ctx))
+            goto to_bf;
+        /* fall thru */
 #endif
     default:
         val = JS_ToNumberFree(ctx, val);
@@ -10851,14 +10121,6 @@ int JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
     return JS_ToInt64Free(ctx, pres, JS_DupValue(ctx, val));
 }
 
-int JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val)
-{
-    if (JS_IsBigInt(ctx, val))
-        return JS_ToBigInt64(ctx, pres, val);
-    else
-        return JS_ToInt64(ctx, pres, val);
-}
-
 /* return (<0, 0) in case of exception */
 static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val)
 {
@@ -10902,12 +10164,17 @@ static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val)
         break;
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
+    to_bf:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             bf_get_int32(&ret, &p->num, BF_GET_INT_MOD);
             JS_FreeValue(ctx, val);
         }
         break;
+    case JS_TAG_BIG_INT:
+        if (is_bignum_mode(ctx))
+            goto to_bf;
+        /* fall thru */
 #endif
     default:
         val = JS_ToNumberFree(ctx, val);
@@ -10965,13 +10232,22 @@ static int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val)
         }
         break;
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
+        {
+            JSBigFloat *p = JS_VALUE_GET_PTR(val);
+            if (!is_bignum_mode(ctx))
+                goto to_number;
+            bf_get_int32(&res, &p->num, 0);
+            JS_FreeValue(ctx, val);
+        }
+        goto int_clamp;
     case JS_TAG_BIG_FLOAT:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             bf_t r_s, *r = &r_s;
             bf_init(ctx->bf_ctx, r);
             bf_set(r, &p->num);
-            bf_rint(r, BF_RNDN);
+            bf_rint(r, BF_PREC_INF, BF_RNDN);
             bf_get_int32(&res, r, 0);
             bf_delete(r);
             JS_FreeValue(ctx, val);
@@ -10979,6 +10255,9 @@ static int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val)
         goto int_clamp;
 #endif
     default:
+#ifdef CONFIG_BIGNUM
+    to_number:
+#endif
         val = JS_ToNumberFree(ctx, val);
         if (JS_IsException(val)) {
             *pres = 0;
@@ -10991,10 +10270,11 @@ static int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val)
 }
 
 static __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,
-                                            JSValue val, BOOL is_array_ctor)
+                                            JSValue val)
 {
     uint32_t tag, len;
 
+ redo:
     tag = JS_VALUE_GET_TAG(val);
     switch(tag) {
     case JS_TAG_INT:
@@ -11031,36 +10311,16 @@ static __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,
             double d;
             d = JS_VALUE_GET_FLOAT64(val);
             len = (uint32_t)d;
-            if (len != d)
-                goto fail;
-        } else {
-            uint32_t len1;
-
-            if (is_array_ctor) {
-                val = JS_ToNumberFree(ctx, val);
-                if (JS_IsException(val))
-                    return -1;
-                /* cannot recurse because val is a number */
-                if (JS_ToArrayLengthFree(ctx, &len, val, TRUE))
-                    return -1;
-            } else {
-                /* legacy behavior: must do the conversion twice and compare */
-                if (JS_ToUint32(ctx, &len, val)) {
-                    JS_FreeValue(ctx, val);
-                    return -1;
-                }
-                val = JS_ToNumberFree(ctx, val);
-                if (JS_IsException(val))
-                    return -1;
-                /* cannot recurse because val is a number */
-                if (JS_ToArrayLengthFree(ctx, &len1, val, FALSE))
-                    return -1;
-                if (len1 != len) {
-                fail:
-                    JS_ThrowRangeError(ctx, "invalid array length");
-                    return -1;
-                }
+            if (len != d) {
+            fail:
+                JS_ThrowRangeError(ctx, "invalid array length");
+                return -1;
             }
+        } else {
+            val = JS_ToNumberFree(ctx, val);
+            if (JS_IsException(val))
+                return -1;
+            goto redo;
         }
         break;
     }
@@ -11070,12 +10330,6 @@ static __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,
 
 #define MAX_SAFE_INTEGER (((int64_t)1 << 53) - 1)
 
-static BOOL is_safe_integer(double d)
-{
-    return isfinite(d) && floor(d) == d &&
-        fabs(d) <= (double)MAX_SAFE_INTEGER;
-}
-
 int JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val)
 {
     int64_t v;
@@ -11101,6 +10355,7 @@ static __exception int JS_ToLengthFree(JSContext *ctx, int64_t *plen,
 }
 
 /* Note: can return an exception */
+/* XXX: bignum case */
 static int JS_NumberIsInteger(JSContext *ctx, JSValueConst val)
 {
     double d;
@@ -11142,12 +10397,6 @@ static BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val)
             return p->num.sign;
         }
         break;
-    case JS_TAG_BIG_DECIMAL:
-        {
-            JSBigDecimal *p = JS_VALUE_GET_PTR(val);
-            return p->num.sign;
-        }
-        break;
 #endif
     default:
         return FALSE;
@@ -11156,47 +10405,19 @@ static BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val)
 
 #ifdef CONFIG_BIGNUM
 
-static JSValue js_bigint_to_string1(JSContext *ctx, JSValueConst val, int radix)
-{
-    JSValue ret;
-    bf_t a_s, *a;
-    char *str;
-    int saved_sign;
-
-    a = JS_ToBigInt(ctx, &a_s, val);
-    if (!a)
-        return JS_EXCEPTION;
-    saved_sign = a->sign;
-    if (a->expn == BF_EXP_ZERO)
-        a->sign = 0;
-    str = bf_ftoa(NULL, a, radix, 0, BF_RNDZ | BF_FTOA_FORMAT_FRAC |
-                  BF_FTOA_JS_QUIRKS);
-    a->sign = saved_sign;
-    JS_FreeBigInt(ctx, a, &a_s);
-    if (!str)
-        return JS_ThrowOutOfMemory(ctx);
-    ret = JS_NewString(ctx, str);
-    bf_free(ctx->bf_ctx, str);
-    return ret;
-}
-
-static JSValue js_bigint_to_string(JSContext *ctx, JSValueConst val)
-{
-    return js_bigint_to_string1(ctx, val, 10);
-}
-
 static JSValue js_ftoa(JSContext *ctx, JSValueConst val1, int radix,
                        limb_t prec, bf_flags_t flags)
 {
     JSValue val, ret;
     bf_t a_s, *a;
+    BOOL is_float;
     char *str;
     int saved_sign;
 
     val = JS_ToNumeric(ctx, val1);
     if (JS_IsException(val))
         return val;
-    a = JS_ToBigFloat(ctx, &a_s, val);
+    a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
     saved_sign = a->sign;
     if (a->expn == BF_EXP_ZERO)
         a->sign = 0;
@@ -11204,74 +10425,45 @@ static JSValue js_ftoa(JSContext *ctx, JSValueConst val1, int radix,
     if ((flags & BF_FTOA_FORMAT_MASK) == BF_FTOA_FORMAT_FREE_MIN) {
         /* Note: for floating point numbers with a radix which is not
            a power of two, the current precision is used to compute
-           the number of digits. */
-        if ((radix & (radix - 1)) != 0) {
-            bf_t r_s, *r = &r_s;
-            int prec, flags1;
-            /* must round first */
-            if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {
-                prec = ctx->fp_env.prec;
-                flags1 = ctx->fp_env.flags &
-                    (BF_FLAG_SUBNORMAL | (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT));
+           the number of digits. For integers, the full precision is
+           always returned. */
+        if (is_float || (flags & BF_FTOA_FORCE_EXP)) {
+            if ((radix & (radix - 1)) != 0) {
+                bf_t r_s, *r = &r_s;
+                int prec, flags1;
+                /* must round first */
+                if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {
+                    prec = ctx->fp_env.prec;
+                    flags1 = ctx->fp_env.flags &
+                        (BF_FLAG_SUBNORMAL | (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT));
+                } else {
+                    prec = 53;
+                    flags1 = bf_set_exp_bits(11) | BF_FLAG_SUBNORMAL;
+                }
+                bf_init(ctx->bf_ctx, r);
+                bf_set(r, a);
+                bf_round(r, prec, flags1 | BF_RNDN);
+                bf_ftoa(&str, r, radix, prec, flags1 | flags);
+                bf_delete(r);
             } else {
-                prec = 53;
-                flags1 = bf_set_exp_bits(11) | BF_FLAG_SUBNORMAL;
+                bf_ftoa(&str, a, radix, BF_PREC_INF, flags);
             }
-            bf_init(ctx->bf_ctx, r);
-            bf_set(r, a);
-            bf_round(r, prec, flags1 | BF_RNDN);
-            str = bf_ftoa(NULL, r, radix, prec, flags1 | flags);
-            bf_delete(r);
         } else {
-            str = bf_ftoa(NULL, a, radix, BF_PREC_INF, flags);
+            bf_ftoa(&str, a, radix, 0, BF_RNDZ | BF_FTOA_FORMAT_FRAC | BF_FTOA_JS_QUIRKS);
         }
     } else {
-        str = bf_ftoa(NULL, a, radix, prec, flags);
+        bf_ftoa(&str, a, radix, prec, flags);
     }
     a->sign = saved_sign;
     if (a == &a_s)
         bf_delete(a);
     JS_FreeValue(ctx, val);
-    if (!str)
-        return JS_ThrowOutOfMemory(ctx);
-    ret = JS_NewString(ctx, str);
-    bf_free(ctx->bf_ctx, str);
-    return ret;
-}
-
-static JSValue js_bigfloat_to_string(JSContext *ctx, JSValueConst val)
-{
-    return js_ftoa(ctx, val, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
-}
-
-static JSValue js_bigdecimal_to_string1(JSContext *ctx, JSValueConst val,
-                                        limb_t prec, int flags)
-{
-    JSValue ret;
-    bfdec_t *a;
-    char *str;
-    int saved_sign;
-
-    a = JS_ToBigDecimal(ctx, val);
-    saved_sign = a->sign;
-    if (a->expn == BF_EXP_ZERO)
-        a->sign = 0;
-    str = bfdec_ftoa(NULL, a, prec, flags | BF_FTOA_JS_QUIRKS);
-    a->sign = saved_sign;
-    if (!str)
-        return JS_ThrowOutOfMemory(ctx);
     ret = JS_NewString(ctx, str);
-    bf_free(ctx->bf_ctx, str);
+    bf_realloc(ctx->bf_ctx, str, 0);
     return ret;
 }
 
-static JSValue js_bigdecimal_to_string(JSContext *ctx, JSValueConst val)
-{
-    return js_bigdecimal_to_string1(ctx, val, 0,
-                                    BF_RNDZ | BF_FTOA_FORMAT_FREE);
-}
-
-#endif /* CONFIG_BIGNUM */
+#else /* !CONFIG_BIGNUM */
 
 /* 2 <= base <= 36 */
 static char *i64toa(char *buf_end, int64_t n, unsigned int base)
@@ -11439,7 +10631,7 @@ static void js_fcvt(char *buf, int buf_size, double d, int n_digits)
 /* force exponential notation either in fixed or variable format */
 #define JS_DTOA_FORCE_EXP    (1 << 2)
 
-/* XXX: slow and maybe not fully correct. Use libbf when it is fast enough.
+/* XXX: slow and maybe not fully correct
    XXX: radix != 10 is only supported for small integers
 */
 static void js_dtoa1(char *buf, double d, int radix, int n_digits, int flags)
@@ -11539,6 +10731,8 @@ static JSValue js_dtoa(JSContext *ctx,
     return JS_NewString(ctx, buf);
 }
 
+#endif /* !CONFIG_BIGNUM */
+
 JSValue JS_ToStringInternal(JSContext *ctx, JSValueConst val, BOOL is_ToPropertyKey)
 {
     uint32_t tag;
@@ -11582,16 +10776,15 @@ JSValue JS_ToStringInternal(JSContext *ctx, JSValueConst val, BOOL is_ToProperty
         } else {
             return JS_ThrowTypeError(ctx, "cannot convert symbol to string");
         }
+#ifdef CONFIG_BIGNUM
+    case JS_TAG_FLOAT64:
+    case JS_TAG_BIG_FLOAT:
+    case JS_TAG_BIG_INT:
+        return js_ftoa(ctx, val, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
+#else
     case JS_TAG_FLOAT64:
         return js_dtoa(ctx, JS_VALUE_GET_FLOAT64(val), 10, 0,
                        JS_DTOA_VAR_FORMAT);
-#ifdef CONFIG_BIGNUM
-    case JS_TAG_BIG_INT:
-        return ctx->rt->bigint_ops.to_string(ctx, val);
-    case JS_TAG_BIG_FLOAT:
-        return ctx->rt->bigfloat_ops.to_string(ctx, val);
-    case JS_TAG_BIG_DECIMAL:
-        return ctx->rt->bigdecimal_ops.to_string(ctx, val);
 #endif
     default:
         str = "[unsupported type]";
@@ -11781,9 +10974,7 @@ static __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p)
                 } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
                     printf("[varref %p]", (void *)pr->u.var_ref);
                 } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
-                    printf("[autoinit %p %d %p]",
-                           (void *)js_autoinit_get_realm(pr),
-                           js_autoinit_get_id(pr),
+                    printf("[autoinit %p %p]", (void *)pr->u.init.init_func,
                            (void *)pr->u.init.opaque);
                 } else {
                     JS_DumpValueShort(rt, pr->u.value);
@@ -11813,38 +11004,6 @@ static __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p)
     printf("\n");
 }
 
-static __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p)
-{
-    if (p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {
-        JS_DumpObject(rt, (JSObject *)p);
-    } else {
-        printf("%14p %4d ",
-               (void *)p,
-               p->ref_count);
-        switch(p->gc_obj_type) {
-        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
-            printf("[function bytecode]");
-            break;
-        case JS_GC_OBJ_TYPE_SHAPE:
-            printf("[shape]");
-            break;
-        case JS_GC_OBJ_TYPE_VAR_REF:
-            printf("[var_ref]");
-            break;
-        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
-            printf("[async_function]");
-            break;
-        case JS_GC_OBJ_TYPE_JS_CONTEXT:
-            printf("[js_context]");
-            break;
-        default:
-            printf("[unknown %d]", p->gc_obj_type);
-            break;
-        }
-        printf("\n");
-    }
-}
-
 static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
                                                       JSValueConst val)
 {
@@ -11883,8 +11042,8 @@ static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             char *str;
-            str = bf_ftoa(NULL, &p->num, 10, 0,
-                          BF_RNDZ | BF_FTOA_FORMAT_FRAC);
+            bf_ftoa(&str, &p->num, 10, 0,
+                    BF_RNDZ | BF_FTOA_FORMAT_FRAC);
             printf("%sn", str);
             bf_realloc(&rt->bf_ctx, str, 0);
         }
@@ -11893,20 +11052,10 @@ static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             char *str;
-            str = bf_ftoa(NULL, &p->num, 16, BF_PREC_INF,
-                          BF_RNDZ | BF_FTOA_FORMAT_FREE | BF_FTOA_ADD_PREFIX);
+            bf_ftoa(&str, &p->num, 16, BF_PREC_INF,
+                    BF_RNDZ | BF_FTOA_FORMAT_FREE | BF_FTOA_ADD_PREFIX);
             printf("%sl", str);
-            bf_free(&rt->bf_ctx, str);
-        }
-        break;
-    case JS_TAG_BIG_DECIMAL:
-        {
-            JSBigDecimal *p = JS_VALUE_GET_PTR(val);
-            char *str;
-            str = bfdec_ftoa(NULL, &p->num, BF_PREC_INF,
-                             BF_RNDZ | BF_FTOA_FORMAT_FREE);
-            printf("%sm", str);
-            bf_free(&rt->bf_ctx, str);
+            bf_realloc(&rt->bf_ctx, str, 0);
         }
         break;
 #endif
@@ -11944,6 +11093,9 @@ static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
     case JS_TAG_MODULE:
         printf("[module]");
         break;
+    case JS_TAG_VAR_REF:
+        printf("[var_ref]");
+        break;
     default:
         printf("[unknown tag %d]", tag);
         break;
@@ -11992,57 +11144,40 @@ static double js_pow(double a, double b)
 
 #ifdef CONFIG_BIGNUM
 
-JSValue JS_NewBigInt64_1(JSContext *ctx, int64_t v)
-{
-    JSValue val;
-    bf_t *a;
-    val = JS_NewBigInt(ctx);
-    if (JS_IsException(val))
-        return val;
-    a = JS_GetBigInt(val);
-    if (bf_set_si(a, v)) {
-        JS_FreeValue(ctx, val);
-        return JS_ThrowOutOfMemory(ctx);
-    }
-    return val;
-}
-
 JSValue JS_NewBigInt64(JSContext *ctx, int64_t v)
 {
-    if (is_math_mode(ctx) &&
-        v >= -MAX_SAFE_INTEGER && v <= MAX_SAFE_INTEGER) {
-        return JS_NewInt64(ctx, v);
+    BOOL is_bignum = is_bignum_mode(ctx);
+    if (is_bignum && v == (int32_t)v) {
+        return JS_NewInt32(ctx, v);
     } else {
-        return JS_NewBigInt64_1(ctx, v);
+        bf_t a_s, *a = &a_s;
+        bf_init(ctx->bf_ctx, a);
+        bf_set_si(a, v);
+        return JS_NewBigInt2(ctx, a, TRUE);
     }
 }
 
 JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)
 {
-    JSValue val;
-    if (is_math_mode(ctx) && v <= MAX_SAFE_INTEGER) {
-        val = JS_NewInt64(ctx, v);
+    BOOL is_bignum = is_bignum_mode(ctx);
+    if (is_bignum && v == (int32_t)v) {
+        return JS_NewInt32(ctx, v);
     } else {
-        bf_t *a;
-        val = JS_NewBigInt(ctx);
-        if (JS_IsException(val))
-            return val;
-        a = JS_GetBigInt(val);
-        if (bf_set_ui(a, v)) {
-            JS_FreeValue(ctx, val);
-            return JS_ThrowOutOfMemory(ctx);
-        }
+        bf_t a_s, *a = &a_s;
+        bf_init(ctx->bf_ctx, a);
+        bf_set_ui(a, v);
+        return JS_NewBigInt2(ctx, a, TRUE);
     }
-    return val;
 }
 
 /* if the returned bigfloat is allocated it is equal to
-   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. Return
-   NULL in case of error. */
-static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)
+   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */
+static bf_t *JS_ToBigFloat(JSContext *ctx, BOOL *pis_float, bf_t *buf,
+                           JSValueConst val)
 {
     uint32_t tag;
     bf_t *r;
+    BOOL is_float;
     JSBigFloat *p;
 
     tag = JS_VALUE_GET_NORM_TAG(val);
@@ -12052,20 +11187,21 @@ static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)
     case JS_TAG_NULL:
         r = buf;
         bf_init(ctx->bf_ctx, r);
-        if (bf_set_si(r, JS_VALUE_GET_INT(val)))
-            goto fail;
+        bf_set_si(r, JS_VALUE_GET_INT(val));
+        is_float = FALSE;
         break;
     case JS_TAG_FLOAT64:
         r = buf;
         bf_init(ctx->bf_ctx, r);
-        if (bf_set_float64(r, JS_VALUE_GET_FLOAT64(val))) {
-        fail:
-            bf_delete(r);
-            return NULL;
-        }
+        bf_set_float64(r, JS_VALUE_GET_FLOAT64(val));
+        is_float = TRUE;
         break;
     case JS_TAG_BIG_INT:
+        is_float = FALSE;
+        goto get_ptr;
     case JS_TAG_BIG_FLOAT:
+        is_float = TRUE;
+    get_ptr:
         p = JS_VALUE_GET_PTR(val);
         r = &p->num;
         break;
@@ -12074,69 +11210,46 @@ static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)
         r = buf;
         bf_init(ctx->bf_ctx, r);
         bf_set_nan(r);
+        is_float = TRUE;
         break;
     }
-    return r;
-}
-
-/* return NULL if invalid type */
-static bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val)
-{
-    uint32_t tag;
-    JSBigDecimal *p;
-    bfdec_t *r;
-    
-    tag = JS_VALUE_GET_NORM_TAG(val);
-    switch(tag) {
-    case JS_TAG_BIG_DECIMAL:
-        p = JS_VALUE_GET_PTR(val);
-        r = &p->num;
-        break;
-    default:
-        JS_ThrowTypeError(ctx, "bigdecimal expected");
-        r = NULL;
-        break;
-    }
+    *pis_float = is_float;
     return r;
 }
 
 /* return NaN if bad bigint literal */
 static JSValue JS_StringToBigInt(JSContext *ctx, JSValue val)
 {
-    const char *str, *p;
-    size_t len;
-    int flags;
-    
-    str = JS_ToCStringLen(ctx, &len, val);
+    const char *str;
+    const char *p;
+    int flags, err;
+
+    str = JS_ToCString(ctx, val);
     JS_FreeValue(ctx, val);
     if (!str)
         return JS_EXCEPTION;
-    p = str;
+    flags = BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN |
+        BF_ATOF_JS_QUIRKS | BF_ATOF_INT_ONLY | BF_ATOF_INT_PREC_INF;
+    if (!is_bignum_mode(ctx))
+        flags |= BF_ATOF_BIG_INT;
+    val = js_atof(ctx, str, &p, 0, flags);
     p += skip_spaces(p);
-    if ((p - str) == len) {
-        val = JS_NewBigInt64(ctx, 0);
-    } else {
-        flags = ATOD_INT_ONLY | ATOD_ACCEPT_BIN_OCT | ATOD_TYPE_BIG_INT;
-        if (is_math_mode(ctx))
-            flags |= ATOD_MODE_BIGINT;
-        val = js_atof(ctx, p, &p, 0, flags);
-        p += skip_spaces(p);
-        if (!JS_IsException(val)) {
-            if ((p - str) != len) {
-                JS_FreeValue(ctx, val);
-                val = JS_NAN;
-            }
-        }
-    }
+    err = (*p != '\0');
     JS_FreeCString(ctx, str);
+    if (err) {
+        JS_FreeValue(ctx, val);
+        val = JS_NAN;
+    }
     return val;
 }
 
 static JSValue JS_StringToBigIntErr(JSContext *ctx, JSValue val)
 {
     val = JS_StringToBigInt(ctx, val);
-    if (JS_VALUE_IS_NAN(val))
+    if (JS_VALUE_GET_TAG(val) != JS_TAG_BIG_INT) {
+        JS_FreeValue(ctx, val);
         return JS_ThrowSyntaxError(ctx, "invalid bigint literal");
+    }
     return val;
 }
 
@@ -12154,7 +11267,7 @@ static bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)
     case JS_TAG_INT:
     case JS_TAG_NULL:
     case JS_TAG_UNDEFINED:
-        if (!is_math_mode(ctx))
+        if (!is_bignum_mode(ctx))
             goto fail;
         /* fall tru */
     case JS_TAG_BOOL:
@@ -12165,7 +11278,7 @@ static bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)
     case JS_TAG_FLOAT64:
         {
             double d = JS_VALUE_GET_FLOAT64(val);
-            if (!is_math_mode(ctx))
+            if (!is_bignum_mode(ctx))
                 goto fail;
             if (!isfinite(d))
                 goto fail;
@@ -12180,7 +11293,7 @@ static bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)
         r = &p->num;
         break;
     case JS_TAG_BIG_FLOAT:
-        if (!is_math_mode(ctx))
+        if (!is_bignum_mode(ctx))
             goto fail;
         p = JS_VALUE_GET_PTR(val);
         if (!bf_is_finite(&p->num))
@@ -12188,7 +11301,7 @@ static bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)
         r = buf;
         bf_init(ctx->bf_ctx, r);
         bf_set(r, &p->num);
-        bf_rint(r, BF_RNDZ);
+        bf_rint(r, BF_PREC_INF, BF_RNDZ);
         JS_FreeValue(ctx, val);
         break;
     case JS_TAG_STRING:
@@ -12197,7 +11310,8 @@ static bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)
             return NULL;
         goto redo;
     case JS_TAG_OBJECT:
-        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
+        val = JS_ToPrimitiveFree(ctx, val,
+                                 is_bignum_mode(ctx) ? HINT_INTEGER : HINT_NUMBER);
         if (JS_IsException(val))
             return NULL;
         goto redo;
@@ -12220,26 +11334,11 @@ static __maybe_unused JSValue JS_ToBigIntValueFree(JSContext *ctx, JSValue val)
     if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_INT) {
         return val;
     } else {
-        bf_t a_s, *a, *r;
-        int ret;
-        JSValue res; 
-
-        res = JS_NewBigInt(ctx);
-        if (JS_IsException(res))
-            return JS_EXCEPTION;
+        bf_t a_s, *a;
         a = JS_ToBigIntFree(ctx, &a_s, val);
-        if (!a) {
-            JS_FreeValue(ctx, res);
+        if (!a)
             return JS_EXCEPTION;
-        }
-        r = JS_GetBigInt(res);
-        ret = bf_set(r, a);
-        JS_FreeBigInt(ctx, a, &a_s);
-        if (ret) {
-            JS_FreeValue(ctx, res);
-            return JS_ThrowOutOfMemory(ctx);
-        }
-        return JS_CompactBigInt(ctx, res);
+        return JS_NewBigInt2(ctx, a, TRUE);
     }
 }
 
@@ -12278,7 +11377,7 @@ int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
 static JSBigFloat *js_new_bf(JSContext *ctx)
 {
     JSBigFloat *p;
-    p = js_malloc(ctx, sizeof(*p));
+    p = js_mallocz(ctx, sizeof(*p));
     if (!p)
         return NULL;
     p->header.ref_count = 1;
@@ -12286,388 +11385,208 @@ static JSBigFloat *js_new_bf(JSContext *ctx)
     return p;
 }
 
-static JSValue JS_NewBigFloat(JSContext *ctx)
+/* WARNING: 'a' is freed */
+static JSValue JS_NewBigFloat(JSContext *ctx, bf_t *a)
 {
+    JSValue ret;
     JSBigFloat *p;
-    p = js_malloc(ctx, sizeof(*p));
-    if (!p)
-        return JS_EXCEPTION;
-    p->header.ref_count = 1;
-    bf_init(ctx->bf_ctx, &p->num);
-    return JS_MKPTR(JS_TAG_BIG_FLOAT, p);
-}
 
-static JSValue JS_NewBigDecimal(JSContext *ctx)
-{
-    JSBigDecimal *p;
-    p = js_malloc(ctx, sizeof(*p));
-    if (!p)
-        return JS_EXCEPTION;
-    p->header.ref_count = 1;
-    bfdec_init(ctx->bf_ctx, &p->num);
-    return JS_MKPTR(JS_TAG_BIG_DECIMAL, p);
+    p = js_new_bf(ctx);
+    p->num = *a;
+    ret = JS_MKPTR(JS_TAG_BIG_FLOAT, p);
+    return ret;
 }
 
-static JSValue JS_NewBigInt(JSContext *ctx)
+/* WARNING: 'a' is freed */
+static JSValue JS_NewBigInt2(JSContext *ctx, bf_t *a, BOOL force_bigint)
 {
+    JSValue ret;
     JSBigFloat *p;
-    p = js_malloc(ctx, sizeof(*p));
-    if (!p)
-        return JS_EXCEPTION;
-    p->header.ref_count = 1;
-    bf_init(ctx->bf_ctx, &p->num);
-    return JS_MKPTR(JS_TAG_BIG_INT, p);
+    int32_t v;
+
+    if (!force_bigint && bf_get_int32(&v, a, 0) == 0) {
+        /* can fit in an int32 */
+        ret = JS_NewInt32(ctx, v);
+        bf_delete(a);
+    } else {
+        p = js_new_bf(ctx);
+        p->num = *a;
+        /* normalize the zero representation */
+        if (bf_is_zero(&p->num))
+            p->num.sign = 0;
+        ret = JS_MKPTR(JS_TAG_BIG_INT, p);
+    }
+    return ret;
 }
 
-static JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,
-                                 BOOL convert_to_safe_integer)
+static JSValue JS_NewBigInt(JSContext *ctx, bf_t *a)
 {
-    int64_t v;
-    bf_t *a;
-    
-    if (JS_VALUE_GET_TAG(val) != JS_TAG_BIG_INT)
-        return val; /* fail safe */
-    a = JS_GetBigInt(val);
-    if (convert_to_safe_integer && bf_get_int64(&v, a, 0) == 0 &&
-        v >= -MAX_SAFE_INTEGER && v <= MAX_SAFE_INTEGER) {
-        JS_FreeValue(ctx, val);
-        return JS_NewInt64(ctx, v);
-    } else if (a->expn == BF_EXP_ZERO && a->sign) {
-        JSBigFloat *p = JS_VALUE_GET_PTR(val);
-        assert(p->header.ref_count == 1);
-        a->sign = 0;
-    }
-    return val;
+    return JS_NewBigInt2(ctx, a, FALSE);
 }
 
-/* Convert the big int to a safe integer if in math mode. normalize
-   the zero representation. Could also be used to convert the bigint
-   to a short bigint value. The reference count of the value must be
-   1. Cannot fail */
-static JSValue JS_CompactBigInt(JSContext *ctx, JSValue val)
-{
-    return JS_CompactBigInt1(ctx, val, is_math_mode(ctx));
-}
-
-/* must be kept in sync with JSOverloadableOperatorEnum */
-/* XXX: use atoms ? */
-static const char js_overloadable_operator_names[JS_OVOP_COUNT][4] = {
-    "+",
-    "-",
-    "*",
-    "/",
-    "%",
-    "**",
-    "|",
-    "&",
-    "^",
-    "<<",
-    ">>",
-    ">>>",
-    "==",
-    "<",
-    "pos",
-    "neg",
-    "++",
-    "--",
-    "~",
-};
+/* return < 0 if exception, 0 if overloading method, 1 if overloading
+   operator called */
+static __exception int js_call_binary_op_fallback(JSContext *ctx,
+                                                   JSValue *pret,
+                                                   JSValueConst op1,
+                                                   JSValueConst op2,
+                                                   OPCodeEnum op)
+{
+    JSAtom op_name;
+    JSValue method, ret, c1, c2;
+    BOOL bool_result, swap_op;
+    JSValueConst args[2];
 
-static int get_ovop_from_opcode(OPCodeEnum op)
-{
+    bool_result = FALSE;
+    swap_op = FALSE;
+    c1 = JS_UNDEFINED;
+    c2 = JS_UNDEFINED;
     switch(op) {
     case OP_add:
-        return JS_OVOP_ADD;
+        op_name = JS_ATOM_Symbol_operatorAdd;
+        break;
     case OP_sub:
-        return JS_OVOP_SUB;
+        op_name = JS_ATOM_Symbol_operatorSub;
+        break;
     case OP_mul:
-        return JS_OVOP_MUL;
+        op_name = JS_ATOM_Symbol_operatorMul;
+        break;
     case OP_div:
-        return JS_OVOP_DIV;
+    case OP_math_div:
+        op_name = JS_ATOM_Symbol_operatorDiv;
+        break;
     case OP_mod:
-    case OP_math_mod:
-        return JS_OVOP_MOD;
+        op_name = JS_ATOM_Symbol_operatorMod;
+        break;
     case OP_pow:
-        return JS_OVOP_POW;
-    case OP_or:
-        return JS_OVOP_OR;
-    case OP_and:
-        return JS_OVOP_AND;
-    case OP_xor:
-        return JS_OVOP_XOR;
+    case OP_math_pow:
+        op_name = JS_ATOM_Symbol_operatorPow;
+        break;
+    case OP_math_mod:
+        op_name = JS_ATOM_Symbol_operatorMathMod;
+        break;
     case OP_shl:
-        return JS_OVOP_SHL;
+        op_name = JS_ATOM_Symbol_operatorShl;
+        break;
     case OP_sar:
-        return JS_OVOP_SAR;
-    case OP_shr:
-        return JS_OVOP_SHR;
-    case OP_eq:
-    case OP_neq:
-        return JS_OVOP_EQ;
+        op_name = JS_ATOM_Symbol_operatorShr;
+        break;
+    case OP_and:
+        op_name = JS_ATOM_Symbol_operatorAnd;
+        break;
+    case OP_or:
+        op_name = JS_ATOM_Symbol_operatorOr;
+        break;
+    case OP_xor:
+        op_name = JS_ATOM_Symbol_operatorXor;
+        break;
     case OP_lt:
+        op_name = JS_ATOM_Symbol_operatorCmpLT;
+        bool_result = TRUE;
+        break;
     case OP_lte:
+        op_name = JS_ATOM_Symbol_operatorCmpLE;
+        bool_result = TRUE;
+        break;
     case OP_gt:
+        op_name = JS_ATOM_Symbol_operatorCmpLT;
+        bool_result = TRUE;
+        swap_op = TRUE;
+        break;
     case OP_gte:
-        return JS_OVOP_LESS;
-    case OP_plus:
-        return JS_OVOP_POS;
-    case OP_neg:
-        return JS_OVOP_NEG;
-    case OP_inc:
-        return JS_OVOP_INC;
-    case OP_dec:
-        return JS_OVOP_DEC;
+        op_name = JS_ATOM_Symbol_operatorCmpLE;
+        bool_result = TRUE;
+        swap_op = TRUE;
+        break;
+    case OP_eq:
+    case OP_neq:
+        op_name = JS_ATOM_Symbol_operatorCmpEQ;
+        bool_result = TRUE;
+        break;
     default:
-        abort();
-    }
-}
-
-/* return NULL if not present */
-static JSObject *find_binary_op(JSBinaryOperatorDef *def,
-                                uint32_t operator_index,
-                                JSOverloadableOperatorEnum op)
-{
-    JSBinaryOperatorDefEntry *ent;
-    int i;
-    for(i = 0; i < def->count; i++) {
-        ent = &def->tab[i];
-        if (ent->operator_index == operator_index)
-            return ent->ops[op];
+        goto fail;
     }
-    return NULL;
-}
-
-/* return -1 if exception, 0 if no operator overloading, 1 if
-   overloaded operator called */
-static __exception int js_call_binary_op_fallback(JSContext *ctx,
-                                                  JSValue *pret,
-                                                  JSValueConst op1,
-                                                  JSValueConst op2,
-                                                  OPCodeEnum op,
-                                                  BOOL is_numeric,
-                                                  int hint)
-{
-    JSValue opset1_obj, opset2_obj, method, ret, new_op1, new_op2;
-    JSOperatorSetData *opset1, *opset2;
-    JSOverloadableOperatorEnum ovop;
-    JSObject *p;
-    JSValueConst args[2];
-    
-    if (!ctx->allow_operator_overloading)
-        return 0;
-    
-    opset2_obj = JS_UNDEFINED;
-    opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);
-    if (JS_IsException(opset1_obj))
-        goto exception;
-    if (JS_IsUndefined(opset1_obj))
-        return 0;
-    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);
-    if (!opset1)
-        goto exception;
-
-    opset2_obj = JS_GetProperty(ctx, op2, JS_ATOM_Symbol_operatorSet);
-    if (JS_IsException(opset2_obj))
+    c1 = JS_GetProperty(ctx, op1, JS_ATOM_constructor);
+    if (JS_IsException(c1))
         goto exception;
-    if (JS_IsUndefined(opset2_obj)) {
-        JS_FreeValue(ctx, opset1_obj);
-        return 0;
-    }
-    opset2 = JS_GetOpaque2(ctx, opset2_obj, JS_CLASS_OPERATOR_SET);
-    if (!opset2)
+    c2 = JS_GetProperty(ctx, op2, JS_ATOM_constructor);
+    if (JS_IsException(c2))
         goto exception;
-
-    if (opset1->is_primitive && opset2->is_primitive) {
-        JS_FreeValue(ctx, opset1_obj);
-        JS_FreeValue(ctx, opset2_obj);
-        return 0;
-    }
-
-    ovop = get_ovop_from_opcode(op);
-    
-    if (opset1->operator_counter == opset2->operator_counter) {
-        p = opset1->self_ops[ovop];
-    } else if (opset1->operator_counter > opset2->operator_counter) {
-        p = find_binary_op(&opset1->left, opset2->operator_counter, ovop);
+    if (JS_VALUE_GET_TAG(c1) != JS_TAG_OBJECT ||
+        JS_VALUE_GET_TAG(c2) != JS_TAG_OBJECT)
+        goto fail;
+    if (JS_VALUE_GET_OBJ(c1) == JS_VALUE_GET_OBJ(c2)) {
+        /* if same constructor, there is no ambiguity */
+        method = JS_GetProperty(ctx, c1, op_name);
     } else {
-        p = find_binary_op(&opset2->right, opset1->operator_counter, ovop);
-    }
-    if (!p) {
-        JS_ThrowTypeError(ctx, "operator %s: no function defined",
-                          js_overloadable_operator_names[ovop]);
-        goto exception;
-    }
+        JSValue val;
+        int order1, order2;
 
-    if (opset1->is_primitive) {
-        if (is_numeric) {
-            new_op1 = JS_ToNumeric(ctx, op1);
-        } else {
-            new_op1 = JS_ToPrimitive(ctx, op1, hint);
-        }
-        if (JS_IsException(new_op1))
+        /* different constructors: we use a user-defined ordering */
+        val = JS_GetProperty(ctx, c1, JS_ATOM_Symbol_operatorOrder);
+        if (JS_IsException(val))
             goto exception;
-    } else {
-        new_op1 = JS_DupValue(ctx, op1);
-    }
-    
-    if (opset2->is_primitive) {
-        if (is_numeric) {
-            new_op2 = JS_ToNumeric(ctx, op2);
-        } else {
-            new_op2 = JS_ToPrimitive(ctx, op2, hint);
+        if (JS_IsUndefined(val))
+            goto undef_order;
+        if (JS_ToInt32Free(ctx, &order1, val))
+            goto exception;
+        val = JS_GetProperty(ctx, c2, JS_ATOM_Symbol_operatorOrder);
+        if (JS_IsException(val))
+            goto exception;
+        if (JS_IsUndefined(val)) {
+        undef_order:
+            JS_FreeValue(ctx, c1);
+            JS_FreeValue(ctx, c2);
+            *pret = JS_UNDEFINED;
+            return 0;
         }
-        if (JS_IsException(new_op2)) {
-            JS_FreeValue(ctx, new_op1);
+        if (JS_ToInt32Free(ctx, &order2, val))
+            goto exception;
+        /* ambiguous priority: error */
+        if (order1 == order2) {
+            JS_ThrowTypeError(ctx, "operator_order is identical in both constructors");
             goto exception;
         }
-    } else {
-        new_op2 = JS_DupValue(ctx, op2);
-    }
-
-    /* XXX: could apply JS_ToPrimitive() if primitive type so that the
-       operator function does not get a value object */
-    
-    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-    if (ovop == JS_OVOP_LESS && (op == OP_lte || op == OP_gt)) {
-        args[0] = new_op2;
-        args[1] = new_op1;
-    } else {
-        args[0] = new_op1;
-        args[1] = new_op2;
-    }
-    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 2, args);
-    JS_FreeValue(ctx, new_op1);
-    JS_FreeValue(ctx, new_op2);
-    if (JS_IsException(ret))
-        goto exception;
-    if (ovop == JS_OVOP_EQ) {
-        BOOL res = JS_ToBoolFree(ctx, ret);
-        if (op == OP_neq)
-            res ^= 1;
-        ret = JS_NewBool(ctx, res);
-    } else if (ovop == JS_OVOP_LESS) {
-        if (JS_IsUndefined(ret)) {
-            ret = JS_FALSE;
+        if (order1 > order2) {
+            val = c1;
         } else {
-            BOOL res = JS_ToBoolFree(ctx, ret);
-            if (op == OP_lte || op == OP_gte)
-                res ^= 1;
-            ret = JS_NewBool(ctx, res);
+            val = c2;
         }
+        method = JS_GetProperty(ctx, val, op_name);
     }
-    JS_FreeValue(ctx, opset1_obj);
-    JS_FreeValue(ctx, opset2_obj);
-    *pret = ret;
-    return 1;
- exception:
-    JS_FreeValue(ctx, opset1_obj);
-    JS_FreeValue(ctx, opset2_obj);
-    *pret = JS_UNDEFINED;
-    return -1;
-}
-
-/* try to call the operation on the operatorSet field of 'obj'. Only
-   used for "/" and "**" on the BigInt prototype in math mode */
-static __exception int js_call_binary_op_simple(JSContext *ctx,
-                                                JSValue *pret,
-                                                JSValueConst obj,
-                                                JSValueConst op1,
-                                                JSValueConst op2,
-                                                OPCodeEnum op)
-{
-    JSValue opset1_obj, method, ret, new_op1, new_op2;
-    JSOperatorSetData *opset1;
-    JSOverloadableOperatorEnum ovop;
-    JSObject *p;
-    JSValueConst args[2];
-
-    opset1_obj = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_operatorSet);
-    if (JS_IsException(opset1_obj))
-        goto exception;
-    if (JS_IsUndefined(opset1_obj))
-        return 0;
-    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);
-    if (!opset1)
+    JS_FreeValue(ctx, c1);
+    JS_FreeValue(ctx, c2);
+    c1 = JS_UNDEFINED;
+    c2 = JS_UNDEFINED;
+    if (JS_IsException(method))
         goto exception;
-    ovop = get_ovop_from_opcode(op);
-
-    p = opset1->self_ops[ovop];
-    if (!p) {
-        JS_FreeValue(ctx, opset1_obj);
+    if (JS_IsUndefined(method) || JS_IsNull(method)) {
+        *pret = JS_UNDEFINED;
         return 0;
     }
-
-    new_op1 = JS_ToNumeric(ctx, op1);
-    if (JS_IsException(new_op1))
-        goto exception;
-    new_op2 = JS_ToNumeric(ctx, op2);
-    if (JS_IsException(new_op2)) {
-        JS_FreeValue(ctx, new_op1);
-        goto exception;
+    if (swap_op) {
+        args[0] = op2;
+        args[1] = op1;
+    } else {
+        args[0] = op1;
+        args[1] = op2;
     }
-
-    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-    args[0] = new_op1;
-    args[1] = new_op2;
     ret = JS_CallFree(ctx, method, JS_UNDEFINED, 2, args);
-    JS_FreeValue(ctx, new_op1);
-    JS_FreeValue(ctx, new_op2);
     if (JS_IsException(ret))
         goto exception;
-    JS_FreeValue(ctx, opset1_obj);
-    *pret = ret;
-    return 1;
- exception:
-    JS_FreeValue(ctx, opset1_obj);
-    *pret = JS_UNDEFINED;
-    return -1;
-}
-
-/* return -1 if exception, 0 if no operator overloading, 1 if
-   overloaded operator called */
-static __exception int js_call_unary_op_fallback(JSContext *ctx,
-                                                 JSValue *pret,
-                                                 JSValueConst op1,
-                                                 OPCodeEnum op)
-{
-    JSValue opset1_obj, method, ret;
-    JSOperatorSetData *opset1;
-    JSOverloadableOperatorEnum ovop;
-    JSObject *p;
-
-    if (!ctx->allow_operator_overloading)
-        return 0;
-    
-    opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);
-    if (JS_IsException(opset1_obj))
-        goto exception;
-    if (JS_IsUndefined(opset1_obj))
-        return 0;
-    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);
-    if (!opset1)
-        goto exception;
-    if (opset1->is_primitive) {
-        JS_FreeValue(ctx, opset1_obj);
-        return 0;
-    }
-
-    ovop = get_ovop_from_opcode(op);
-
-    p = opset1->self_ops[ovop];
-    if (!p) {
-        JS_ThrowTypeError(ctx, "no overloaded operator %s",
-                          js_overloadable_operator_names[ovop]);
-        goto exception;
+    if (bool_result) {
+        BOOL res = JS_ToBoolFree(ctx, ret);
+        if (op == OP_neq)
+            res ^= 1;
+        ret = JS_NewBool(ctx, res);
     }
-    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));
-    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 1, &op1);
-    if (JS_IsException(ret))
-        goto exception;
-    JS_FreeValue(ctx, opset1_obj);
     *pret = ret;
     return 1;
+ fail:
+    JS_ThrowTypeError(ctx, "invalid types for binary operator");
  exception:
-    JS_FreeValue(ctx, opset1_obj);
+    JS_FreeValue(ctx, c1);
+    JS_FreeValue(ctx, c2);
     *pret = JS_UNDEFINED;
     return -1;
 }
@@ -12675,8 +11594,6 @@ static __exception int js_call_unary_op_fallback(JSContext *ctx,
 static JSValue throw_bf_exception(JSContext *ctx, int status)
 {
     const char *str;
-    if (status & BF_ST_MEM_ERROR)
-        return JS_ThrowOutOfMemory(ctx);
     if (status & BF_ST_DIVIDE_ZERO) {
         str = "division by zero";
     } else if (status & BF_ST_INVALID_OP) {
@@ -12687,160 +11604,15 @@ static JSValue throw_bf_exception(JSContext *ctx, int status)
     return JS_ThrowRangeError(ctx, "%s", str);
 }
 
-static int js_unary_arith_bigint(JSContext *ctx,
-                                 JSValue *pres, OPCodeEnum op, JSValue op1)
-{
-    bf_t a_s, *r, *a;
-    int ret, v;
-    JSValue res;
-    
-    if (op == OP_plus && !is_math_mode(ctx)) {
-        JS_ThrowTypeError(ctx, "bigint argument with unary +");
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-    res = JS_NewBigInt(ctx);
-    if (JS_IsException(res)) {
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-    r = JS_GetBigInt(res);
-    a = JS_ToBigInt(ctx, &a_s, op1);
-    ret = 0;
-    switch(op) {
-    case OP_inc:
-    case OP_dec:
-        v = 2 * (op - OP_dec) - 1;
-        ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_plus:
-        ret = bf_set(r, a);
-        break;
-    case OP_neg:
-        ret = bf_set(r, a);
-        bf_neg(r);
-        break;
-    case OP_not:
-        ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ);
-        bf_neg(r);
-        break;
-    default:
-        abort();
-    }
-    JS_FreeBigInt(ctx, a, &a_s);
-    JS_FreeValue(ctx, op1);
-    if (unlikely(ret)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
-    }
-    res = JS_CompactBigInt(ctx, res);
-    *pres = res;
-    return 0;
-}
-
-static int js_unary_arith_bigfloat(JSContext *ctx,
-                                   JSValue *pres, OPCodeEnum op, JSValue op1)
-{
-    bf_t a_s, *r, *a;
-    int ret, v;
-    JSValue res;
-    
-    if (op == OP_plus && !is_math_mode(ctx)) {
-        JS_ThrowTypeError(ctx, "bigfloat argument with unary +");
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-
-    res = JS_NewBigFloat(ctx);
-    if (JS_IsException(res)) {
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-    r = JS_GetBigFloat(res);
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    ret = 0;
-    switch(op) {
-    case OP_inc:
-    case OP_dec:
-        v = 2 * (op - OP_dec) - 1;
-        ret = bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_plus:
-        ret = bf_set(r, a);
-        break;
-    case OP_neg:
-        ret = bf_set(r, a);
-        bf_neg(r);
-        break;
-    default:
-        abort();
-    }
-    if (a == &a_s)
-        bf_delete(a);
-    JS_FreeValue(ctx, op1);
-    if (unlikely(ret & BF_ST_MEM_ERROR)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
-    }
-    *pres = res;
-    return 0;
-}
-
-static int js_unary_arith_bigdecimal(JSContext *ctx,
-                                     JSValue *pres, OPCodeEnum op, JSValue op1)
-{
-    bfdec_t *r, *a;
-    int ret, v;
-    JSValue res;
-    
-    if (op == OP_plus && !is_math_mode(ctx)) {
-        JS_ThrowTypeError(ctx, "bigdecimal argument with unary +");
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-
-    res = JS_NewBigDecimal(ctx);
-    if (JS_IsException(res)) {
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-    r = JS_GetBigDecimal(res);
-    a = JS_ToBigDecimal(ctx, op1);
-    ret = 0;
-    switch(op) {
-    case OP_inc:
-    case OP_dec:
-        v = 2 * (op - OP_dec) - 1;
-        ret = bfdec_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_plus:
-        ret = bfdec_set(r, a);
-        break;
-    case OP_neg:
-        ret = bfdec_set(r, a);
-        bfdec_neg(r);
-        break;
-    default:
-        abort();
-    }
-    JS_FreeValue(ctx, op1);
-    if (unlikely(ret)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
-    }
-    *pres = res;
-    return 0;
-}
-
 static no_inline __exception int js_unary_arith_slow(JSContext *ctx,
                                                      JSValue *sp,
                                                      OPCodeEnum op)
 {
-    JSValue op1, val;
-    int v, ret;
+    JSValue op1, val, method;
+    bf_t a_s, r_s, *r = &r_s, *a;
+    BOOL is_float, is_legacy;
+    JSAtom op_name;
+    int ret, v;
     uint32_t tag;
 
     op1 = sp[-1];
@@ -12848,84 +11620,154 @@ static no_inline __exception int js_unary_arith_slow(JSContext *ctx,
     if (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(op1)))
         goto handle_float64;
     if (JS_IsObject(op1)) {
-        ret = js_call_unary_op_fallback(ctx, &val, op1, op);
-        if (ret < 0)
-            return -1;
-        if (ret) {
-            JS_FreeValue(ctx, op1);
-            sp[-1] = val;
-            return 0;
-        }
-    }
-
-    op1 = JS_ToNumericFree(ctx, op1);
-    if (JS_IsException(op1))
-        goto exception;
-    tag = JS_VALUE_GET_TAG(op1);
-    switch(tag) {
-    case JS_TAG_INT:
-        {
-            int64_t v64;
-            v64 = JS_VALUE_GET_INT(op1);
-            switch(op) {
-            case OP_inc:
-            case OP_dec:
-                v = 2 * (op - OP_dec) - 1;
-                v64 += v;
-                break;
-            case OP_plus:
-                break;
-            case OP_neg:
-                if (v64 == 0) {
-                    sp[-1] = __JS_NewFloat64(ctx, -0.0);
-                    return 0;
-                } else {
-                    v64 = -v64;
-                }
-                break;
-            default:
-                abort();
-            }
-            sp[-1] = JS_NewInt64(ctx, v64);
+        switch(op) {
+        case OP_plus:
+            op_name = JS_ATOM_Symbol_operatorPlus;
+            break;
+        case OP_neg:
+            op_name = JS_ATOM_Symbol_operatorNeg;
+            break;
+        case OP_inc:
+            op_name = JS_ATOM_Symbol_operatorInc;
+            break;
+        case OP_dec:
+            op_name = JS_ATOM_Symbol_operatorDec;
+            break;
+        default:
+            abort();
         }
-        break;
-    case JS_TAG_BIG_INT:
-    handle_bigint:
-        if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, op, op1))
-            goto exception;
-        break;
-    case JS_TAG_BIG_FLOAT:
-        if (ctx->rt->bigfloat_ops.unary_arith(ctx, sp - 1, op, op1))
-            goto exception;
-        break;
-    case JS_TAG_BIG_DECIMAL:
-        if (ctx->rt->bigdecimal_ops.unary_arith(ctx, sp - 1, op, op1))
+        method = JS_GetProperty(ctx, op1, op_name);
+        if (JS_IsException(method))
+            return -1;
+        if (JS_IsUndefined(method) || JS_IsNull(method))
+            goto to_number;
+        val = JS_CallFree(ctx, method, op1, 0, NULL);
+        if (JS_IsException(val))
+            return -1;
+        JS_FreeValue(ctx, op1);
+        sp[-1] = val;
+    } else {
+    to_number:
+        op1 = JS_ToNumericFree(ctx, op1);
+        if (JS_IsException(op1))
             goto exception;
-        break;
-    default:
-    handle_float64:
-        {
-            double d;
-            if (is_math_mode(ctx))
-                goto handle_bigint;
-            d = JS_VALUE_GET_FLOAT64(op1);
+        is_legacy = is_bignum_mode(ctx) ^ 1;
+        tag = JS_VALUE_GET_TAG(op1);
+        switch(tag) {
+        case JS_TAG_INT:
+            {
+                int64_t v64;
+                v64 = JS_VALUE_GET_INT(op1);
+                switch(op) {
+                case OP_inc:
+                case OP_dec:
+                    v = 2 * (op - OP_dec) - 1;
+                    v64 += v;
+                    break;
+                case OP_plus:
+                    break;
+                case OP_neg:
+                    if (v64 == 0 && is_legacy) {
+                        sp[-1] = __JS_NewFloat64(ctx, -0.0);
+                        return 0;
+                    } else {
+                        v64 = -v64;
+                    }
+                    break;
+                default:
+                    abort();
+                }
+                sp[-1] = JS_NewInt64(ctx, v64);
+            }
+            break;
+        case JS_TAG_BIG_INT:
+            if (is_legacy && op == OP_plus) {
+                JS_ThrowTypeError(ctx, "bigint argument with unary +");
+                JS_FreeValue(ctx, op1);
+                goto exception;
+            }
+            a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+            bf_init(ctx->bf_ctx, r);
+            ret = 0;
+            switch(op) {
+            case OP_inc:
+            case OP_dec:
+                v = 2 * (op - OP_dec) - 1;
+                ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
+                break;
+            case OP_plus:
+                bf_set(r, a);
+                break;
+            case OP_neg:
+                bf_set(r, a);
+                bf_neg(r);
+                break;
+            default:
+                abort();
+            }
+            if (a == &a_s)
+                bf_delete(a);
+            JS_FreeValue(ctx, op1);
+            if (unlikely(ret)) {
+                bf_delete(r);
+                throw_bf_exception(ctx, ret);
+                goto exception;
+            }
+            sp[-1] = JS_NewBigInt2(ctx, r, is_legacy);
+            break;
+        case JS_TAG_BIG_FLOAT:
+            a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+            bf_init(ctx->bf_ctx, r);
+            ret = 0;
             switch(op) {
             case OP_inc:
             case OP_dec:
                 v = 2 * (op - OP_dec) - 1;
-                d += v;
+                bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);
                 break;
             case OP_plus:
+                bf_set(r, a);
                 break;
             case OP_neg:
-                d = -d;
+                bf_set(r, a);
+                bf_neg(r);
                 break;
             default:
                 abort();
             }
-            sp[-1] = __JS_NewFloat64(ctx, d);
+            if (a == &a_s)
+                bf_delete(a);
+            JS_FreeValue(ctx, op1);
+            if (unlikely(ret)) {
+                bf_delete(r);
+                throw_bf_exception(ctx, ret);
+                goto exception;
+            }
+            sp[-1] = JS_NewBigFloat(ctx, r);
+            break;
+        default:
+        handle_float64:
+            {
+                double d;
+                d = JS_VALUE_GET_FLOAT64(op1);
+                switch(op) {
+                case OP_inc:
+                case OP_dec:
+                    v = 2 * (op - OP_dec) - 1;
+                    d += v;
+                    break;
+                case OP_plus:
+                    break;
+                case OP_neg:
+                    d = -d;
+                    break;
+                default:
+                    abort();
+                }
+                sp[-1] = __JS_NewFloat64(ctx, d);
+            }
+            break;
         }
-        break;
     }
     return 0;
  exception:
@@ -12952,339 +11794,53 @@ static __exception int js_post_inc_slow(JSContext *ctx,
 
 static no_inline int js_not_slow(JSContext *ctx, JSValue *sp)
 {
-    JSValue op1, val;
+    JSValue op1, method, val;
+    bf_t a_s, r_s, *r = &r_s, *a;
     int ret;
-    
+    BOOL is_legacy;
+
     op1 = sp[-1];
     if (JS_IsObject(op1)) {
-        ret = js_call_unary_op_fallback(ctx, &val, op1, OP_not);
-        if (ret < 0)
+        method = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorNot);
+        if (JS_IsException(method))
+            return -1;
+        if (JS_IsUndefined(method) || JS_IsNull(method))
+            goto to_number;
+        val = JS_CallFree(ctx, method, op1, 0, NULL);
+        if (JS_IsException(val))
             return -1;
-        if (ret) {
-            JS_FreeValue(ctx, op1);
-            sp[-1] = val;
-            return 0;
-        }
-    }
-
-    op1 = JS_ToNumericFree(ctx, op1);
-    if (JS_IsException(op1))
-        goto exception;
-    if (is_math_mode(ctx) || JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT) {
-        if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, OP_not, op1))
-            goto exception;
-    } else {
-        int32_t v1;
-        if (unlikely(JS_ToInt32Free(ctx, &v1, op1)))
-            goto exception;
-        sp[-1] = JS_NewInt32(ctx, ~v1);
-    }
-    return 0;
- exception:
-    sp[-1] = JS_UNDEFINED;
-    return -1;
-}
-
-static int js_binary_arith_bigfloat(JSContext *ctx, OPCodeEnum op,
-                                    JSValue *pres, JSValue op1, JSValue op2)
-{
-    bf_t a_s, b_s, *r, *a, *b;
-    int ret;
-    JSValue res;
-    
-    res = JS_NewBigFloat(ctx);
-    if (JS_IsException(res)) {
         JS_FreeValue(ctx, op1);
-        JS_FreeValue(ctx, op2);
-        return -1;
-    }
-    r = JS_GetBigFloat(res);
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    b = JS_ToBigFloat(ctx, &b_s, op2);
-    bf_init(ctx->bf_ctx, r);
-    switch(op) {
-    case OP_add:
-        ret = bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_sub:
-        ret = bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_mul:
-        ret = bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_div:
-        ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_math_mod:
-        /* Euclidian remainder */
-        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
-                     BF_DIVREM_EUCLIDIAN);
-        break;
-    case OP_mod:
-        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
-                     BF_RNDZ);
-        break;
-    case OP_pow:
-        ret = bf_pow(r, a, b, ctx->fp_env.prec,
-                     ctx->fp_env.flags | BF_POW_JS_QUIRKS);
-        break;
-    default:
-        abort();
-    }
-    if (a == &a_s)
-        bf_delete(a);
-    if (b == &b_s)
-        bf_delete(b);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    if (unlikely(ret & BF_ST_MEM_ERROR)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
-    }
-    *pres = res;
-    return 0;
-}
-
-static int js_binary_arith_bigint(JSContext *ctx, OPCodeEnum op,
-                                  JSValue *pres, JSValue op1, JSValue op2)
-{
-    bf_t a_s, b_s, *r, *a, *b;
-    int ret;
-    JSValue res;
-    
-    res = JS_NewBigInt(ctx);
-    if (JS_IsException(res))
-        goto fail;
-    a = JS_ToBigInt(ctx, &a_s, op1);
-    if (!a)
-        goto fail;
-    b = JS_ToBigInt(ctx, &b_s, op2);
-    if (!b) {
-        JS_FreeBigInt(ctx, a, &a_s);
-        goto fail;
-    }
-    r = JS_GetBigInt(res);
-    ret = 0;
-    switch(op) {
-    case OP_add:
-        ret = bf_add(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_sub:
-        ret = bf_sub(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_mul:
-        ret = bf_mul(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_div:
-        if (!is_math_mode(ctx)) {
-            bf_t rem_s, *rem = &rem_s;
-            bf_init(ctx->bf_ctx, rem);
-            ret = bf_divrem(r, rem, a, b, BF_PREC_INF, BF_RNDZ,
-                            BF_RNDZ);
-            bf_delete(rem);
-        } else {
-            goto math_mode_div_pow;
+        sp[-1] = val;
+    } else {
+        if (JS_IsString(op1)) {
+        to_number:
+            op1 = JS_ToNumberHintFree(ctx, op1, TON_FLAG_INTEGER);
+            if (JS_IsException(op1))
+                goto exception;
         }
-        break;
-    case OP_math_mod:
-        /* Euclidian remainder */
-        ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,
-                     BF_DIVREM_EUCLIDIAN) & BF_ST_INVALID_OP;
-        break;
-    case OP_mod:
-        ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,
-                     BF_RNDZ) & BF_ST_INVALID_OP;
-        break;
-    case OP_pow:
-        if (b->sign) {
-            if (!is_math_mode(ctx)) {
-                ret = BF_ST_INVALID_OP;
-            } else {
-            math_mode_div_pow:
-                JS_FreeValue(ctx, res);
-                ret = js_call_binary_op_simple(ctx, &res, ctx->class_proto[JS_CLASS_BIG_INT], op1, op2, op);
-                if (ret != 0) {
-                    JS_FreeBigInt(ctx, a, &a_s);
-                    JS_FreeBigInt(ctx, b, &b_s);
-                    JS_FreeValue(ctx, op1);
-                    JS_FreeValue(ctx, op2);
-                    if (ret < 0) {
-                        return -1;
-                    } else {
-                        *pres = res;
-                        return 0;
-                    }
-                }
-                /* if no BigInt power operator defined, return a
-                   bigfloat */
-                res = JS_NewBigFloat(ctx);
-                if (JS_IsException(res)) {
-                    JS_FreeBigInt(ctx, a, &a_s);
-                    JS_FreeBigInt(ctx, b, &b_s);
-                    goto fail;
-                }
-                r = JS_GetBigFloat(res);
-                if (op == OP_div) {
-                    ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags) & BF_ST_MEM_ERROR;
-                } else {
-                    ret = bf_pow(r, a, b, ctx->fp_env.prec,
-                                 ctx->fp_env.flags | BF_POW_JS_QUIRKS) & BF_ST_MEM_ERROR;
-                }
-                JS_FreeBigInt(ctx, a, &a_s);
-                JS_FreeBigInt(ctx, b, &b_s);
-                JS_FreeValue(ctx, op1);
-                JS_FreeValue(ctx, op2);
-                if (unlikely(ret)) {
-                    JS_FreeValue(ctx, res);
-                    throw_bf_exception(ctx, ret);
-                    return -1;
-                }
-                *pres = res;
-                return 0;
+        is_legacy = is_bignum_mode(ctx) ^ 1;
+        if (!is_legacy || JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT) {
+            a = JS_ToBigIntFree(ctx, &a_s, op1);
+            bf_init(ctx->bf_ctx, r);
+            ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
+            bf_neg(r);
+            JS_FreeBigInt(ctx, a, &a_s);
+            if (unlikely(ret)) {
+                bf_delete(r);
+                throw_bf_exception(ctx, ret);
+                goto exception;
             }
+            sp[-1] = JS_NewBigInt2(ctx, r, is_legacy);
         } else {
-            ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUIRKS);
-        }
-        break;
-
-        /* logical operations */
-    case OP_shl:
-    case OP_sar:
-        {
-            slimb_t v2;
-#if LIMB_BITS == 32
-            bf_get_int32(&v2, b, 0);
-            if (v2 == INT32_MIN)
-                v2 = INT32_MIN + 1;
-#else
-            bf_get_int64(&v2, b, 0);
-            if (v2 == INT64_MIN)
-                v2 = INT64_MIN + 1;
-#endif
-            if (op == OP_sar)
-                v2 = -v2;
-            ret = bf_set(r, a);
-            ret |= bf_mul_2exp(r, v2, BF_PREC_INF, BF_RNDZ);
-            if (v2 < 0) {
-                ret |= bf_rint(r, BF_RNDD) & (BF_ST_OVERFLOW | BF_ST_MEM_ERROR);
-            }
+            int32_t v1;
+            if (unlikely(JS_ToInt32Free(ctx, &v1, op1)))
+                goto exception;
+            sp[-1] = JS_NewInt32(ctx, ~v1);
         }
-        break;
-    case OP_and:
-        ret = bf_logic_and(r, a, b);
-        break;
-    case OP_or:
-        ret = bf_logic_or(r, a, b);
-        break;
-    case OP_xor:
-        ret = bf_logic_xor(r, a, b);
-        break;
-    default:
-        abort();
-    }
-    JS_FreeBigInt(ctx, a, &a_s);
-    JS_FreeBigInt(ctx, b, &b_s);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    if (unlikely(ret)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
-    }
-    *pres = JS_CompactBigInt(ctx, res);
-    return 0;
- fail:
-    JS_FreeValue(ctx, res);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    return -1;
-}
-
-/* b must be a positive integer */
-static int js_bfdec_pow(bfdec_t *r, const bfdec_t *a, const bfdec_t *b)
-{
-    bfdec_t b1;
-    int32_t b2;
-    int ret;
-
-    bfdec_init(b->ctx, &b1);
-    ret = bfdec_set(&b1, b);
-    if (ret) {
-        bfdec_delete(&b1);
-        return ret;
-    }
-    ret = bfdec_rint(&b1, BF_RNDZ);
-    if (ret) {
-        bfdec_delete(&b1);
-        return BF_ST_INVALID_OP; /* must be an integer */
-    }
-    ret = bfdec_get_int32(&b2, &b1);
-    bfdec_delete(&b1);
-    if (ret)
-        return ret; /* overflow */
-    if (b2 < 0)
-        return BF_ST_INVALID_OP; /* must be positive */
-    return bfdec_pow_ui(r, a, b2);
-}
-
-static int js_binary_arith_bigdecimal(JSContext *ctx, OPCodeEnum op,
-                                      JSValue *pres, JSValue op1, JSValue op2)
-{
-    bfdec_t *r, *a, *b;
-    int ret;
-    JSValue res;
-
-    res = JS_NewBigDecimal(ctx);
-    if (JS_IsException(res))
-        goto fail;
-    r = JS_GetBigDecimal(res);
-    
-    a = JS_ToBigDecimal(ctx, op1);
-    if (!a)
-        goto fail;
-    b = JS_ToBigDecimal(ctx, op2);
-    if (!b)
-        goto fail;
-    switch(op) {
-    case OP_add:
-        ret = bfdec_add(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_sub:
-        ret = bfdec_sub(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_mul:
-        ret = bfdec_mul(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_div:
-        ret = bfdec_div(r, a, b, BF_PREC_INF, BF_RNDZ);
-        break;
-    case OP_math_mod:
-        /* Euclidian remainder */
-        ret = bfdec_rem(r, a, b, BF_PREC_INF, BF_RNDZ, BF_DIVREM_EUCLIDIAN);
-        break;
-    case OP_mod:
-        ret = bfdec_rem(r, a, b, BF_PREC_INF, BF_RNDZ, BF_RNDZ);
-        break;
-    case OP_pow:
-        ret = js_bfdec_pow(r, a, b);
-        break;
-    default:
-        abort();
-    }
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    if (unlikely(ret)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
     }
-    *pres = res;
     return 0;
- fail:
-    JS_FreeValue(ctx, res);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
+ exception:
+    sp[-1] = JS_UNDEFINED;
     return -1;
 }
 
@@ -13292,8 +11848,9 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
                                                       OPCodeEnum op)
 {
     JSValue op1, op2, res;
+    BOOL is_float, is_legacy;
     uint32_t tag1, tag2;
-    int ret;
+    int ret, rnd_mode;
     double d1, d2;
 
     op1 = sp[-2];
@@ -13312,7 +11869,7 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
          (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
         (tag2 == JS_TAG_OBJECT &&
          (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
-        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);
+        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op);
         if (ret != 0) {
             JS_FreeValue(ctx, op1);
             JS_FreeValue(ctx, op2);
@@ -13338,6 +11895,15 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
     tag1 = JS_VALUE_GET_NORM_TAG(op1);
     tag2 = JS_VALUE_GET_NORM_TAG(op2);
 
+    is_legacy = is_bignum_mode(ctx) ^ 1;
+    if (is_legacy && (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) &&
+        tag1 != tag2) {
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        JS_ThrowTypeError(ctx, "both operands must be bigint");
+        goto exception;
+    }
+
     if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {
         int32_t v1, v2;
         int64_t v;
@@ -13349,17 +11915,14 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
             break;
         case OP_mul:
             v = (int64_t)v1 * (int64_t)v2;
-            if (is_math_mode(ctx) &&
-                (v < -MAX_SAFE_INTEGER || v > MAX_SAFE_INTEGER))
-                goto handle_bigint;
-            if (v == 0 && (v1 | v2) < 0) {
+            if (is_legacy && v == 0 && (v1 | v2) < 0) {
                 sp[-2] = __JS_NewFloat64(ctx, -0.0);
                 return 0;
             }
             break;
+        case OP_math_div:
+            goto op_fallback2;
         case OP_div:
-            if (is_math_mode(ctx))
-                goto handle_bigint;
             sp[-2] = __JS_NewFloat64(ctx, (double)v1 / (double)v2);
             return 0;
         case OP_math_mod:
@@ -13376,15 +11939,20 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
             }
             break;
         case OP_mod:
-            if (v1 < 0 || v2 <= 0) {
+            if (is_legacy && (v1 < 0 || v2 <= 0)) {
                 sp[-2] = JS_NewFloat64(ctx, fmod(v1, v2));
                 return 0;
             } else {
+                if (unlikely(v2 == 0)) {
+                    throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);
+                    goto exception;
+                }
                 v = (int64_t)v1 % (int64_t)v2;
             }
             break;
         case OP_pow:
-            if (!is_math_mode(ctx)) {
+        case OP_math_pow:
+            if (is_legacy) {
                 sp[-2] = JS_NewFloat64(ctx, js_pow(v1, v2));
                 return 0;
             } else {
@@ -13395,28 +11963,124 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
             abort();
         }
         sp[-2] = JS_NewInt64(ctx, v);
-    } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
-        if (ctx->rt->bigdecimal_ops.binary_arith(ctx, op, sp - 2, op1, op2))
-            goto exception;
-    } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {
-        if (ctx->rt->bigfloat_ops.binary_arith(ctx, op, sp - 2, op1, op2))
-            goto exception;
-    } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
+    } else if ((tag1 == JS_TAG_BIG_INT && (tag2 == JS_TAG_INT ||
+                                           tag2 == JS_TAG_BIG_INT)) ||
+               (tag2 == JS_TAG_BIG_INT && tag1 == JS_TAG_INT)) {
+        /* big int result */
+        bf_t a_s, b_s, r_s, *r, *a, *b;
     handle_bigint:
-        if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))
+        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+        b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
+        r = &r_s;
+        bf_init(ctx->bf_ctx, r);
+        ret = 0;
+        switch(op) {
+        case OP_sub:
+            ret = bf_sub(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
+            break;
+        case OP_mul:
+            ret = bf_mul(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
+            break;
+        case OP_math_div:
+            goto op_fallback;
+        case OP_div:
+            if (is_legacy) {
+                bf_t rem_s, *rem = &rem_s;
+                bf_init(ctx->bf_ctx, rem);
+                ret = bf_divrem(r, rem, a, b, BF_PREC_INF, BF_RNDZ,
+                                BF_RNDZ) & BF_ST_INVALID_OP;
+                bf_delete(rem);
+            } else {
+                bf_div(r, a, b, 53, bf_set_exp_bits(11) |
+                       BF_RNDN | BF_FLAG_SUBNORMAL);
+                goto float64_result;
+            }
+            break;
+        case OP_math_mod:
+            /* Euclidian remainder */
+            rnd_mode = BF_DIVREM_EUCLIDIAN;
+            goto do_int_mod;
+        case OP_mod:
+            rnd_mode = BF_RNDZ;
+        do_int_mod:
+            {
+                bf_t q_s, *q = &q_s;
+                bf_init(ctx->bf_ctx, q);
+                ret = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ,
+                                rnd_mode) & BF_ST_INVALID_OP;
+                bf_delete(q);
+            }
+            break;
+        case OP_pow:
+        case OP_math_pow:
+            if (b->sign) {
+                if (is_legacy) {
+                    ret = BF_ST_INVALID_OP;
+                } else if (op == OP_math_pow) {
+                op_fallback:
+                    bf_delete(r);
+                    if (a == &a_s)
+                        bf_delete(a);
+                    if (b == &b_s)
+                        bf_delete(b);
+                op_fallback2:
+                    ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op);
+                    JS_FreeValue(ctx, op1);
+                    JS_FreeValue(ctx, op2);
+                    if (ret < 0) {
+                        goto exception;
+                    } else if (ret == 0) {
+                        JS_ThrowTypeError(ctx, "operator must be defined for exact division or power");
+                        goto exception;
+                    }
+                    sp[-2] = res;
+                    return 0;
+                } else {
+                    double dr;
+                    bf_pow(r, a, b, 53, bf_set_exp_bits(11) |
+                           BF_RNDN | BF_FLAG_SUBNORMAL);
+                float64_result:
+                    bf_get_float64(r, &dr, BF_RNDN);
+                    bf_delete(r);
+                    if (a == &a_s)
+                        bf_delete(a);
+                    if (b == &b_s)
+                        bf_delete(b);
+                    JS_FreeValue(ctx, op1);
+                    JS_FreeValue(ctx, op2);
+                    sp[-2] = __JS_NewFloat64(ctx, dr);
+                    return 0;
+                }
+            } else {
+                ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUICKS) &
+                    BF_ST_OVERFLOW;
+            }
+            break;
+        default:
+            abort();
+        }
+        if (a == &a_s)
+            bf_delete(a);
+        if (b == &b_s)
+            bf_delete(b);
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        if (unlikely(ret)) {
+            bf_delete(r);
+            throw_bf_exception(ctx, ret);
             goto exception;
-    } else {
+        }
+        sp[-2] = JS_NewBigInt2(ctx, r, is_legacy);
+    } else if ((tag1 == JS_TAG_FLOAT64 && (tag2 == JS_TAG_FLOAT64 ||
+                                           tag2 == JS_TAG_INT ||
+                                           tag2 == JS_TAG_BIG_INT)) ||
+               (tag2 == JS_TAG_FLOAT64 && (tag1 == JS_TAG_INT ||
+                                           tag1 == JS_TAG_BIG_INT))) {
         double dr;
         /* float64 result */
-        if (JS_ToFloat64Free(ctx, &d1, op1)) {
-            JS_FreeValue(ctx, op2);
-            goto exception;
-        }
-        if (JS_ToFloat64Free(ctx, &d2, op2))
-            goto exception;
+        JS_ToFloat64Free(ctx, &d1, op1);
+        JS_ToFloat64Free(ctx, &d2, op2);
     handle_float64:
-        if (is_math_mode(ctx) && is_safe_integer(d1) && is_safe_integer(d2))
-            goto handle_bigint;
         switch(op) {
         case OP_sub:
             dr = d1 - d2;
@@ -13425,25 +12089,95 @@ static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *s
             dr = d1 * d2;
             break;
         case OP_div:
+        case OP_math_div:
             dr = d1 / d2;
             break;
         case OP_mod:
             dr = fmod(d1, d2);
             break;
         case OP_math_mod:
-            d2 = fabs(d2);
-            dr = fmod(d1, d2);
-            /* XXX: loss of accuracy if dr < 0 */
-            if (dr < 0)
-                dr += d2;
+            if (d1 >= 0 && d2 >= 0) {
+                dr = fmod(d1, d2);
+            } else {
+                /* XXX: slow */
+                bf_t a, b, r, q;
+                bf_init(ctx->bf_ctx, &a);
+                bf_init(ctx->bf_ctx, &b);
+                bf_init(ctx->bf_ctx, &r);
+                bf_set_float64(&a, d1);
+                bf_set_float64(&b, d2);
+                bf_divrem(&q, &r, &a, &b,
+                          53, bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL,
+                          BF_DIVREM_EUCLIDIAN);
+                bf_get_float64(&q, &dr, BF_RNDN);
+                bf_delete(&a);
+                bf_delete(&b);
+                bf_delete(&q);
+                bf_delete(&r);
+            }
             break;
         case OP_pow:
+        case OP_math_pow:
             dr = js_pow(d1, d2);
             break;
         default:
             abort();
         }
         sp[-2] = __JS_NewFloat64(ctx, dr);
+    } else {
+        bf_t a_s, b_s, r_s, *r, *a, *b;
+        /* big float result */
+        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+        b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
+        r = &r_s;
+        bf_init(ctx->bf_ctx, r);
+        ret = 0;
+        switch(op) {
+        case OP_sub:
+            bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+            break;
+        case OP_mul:
+            bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+            break;
+        case OP_math_div:
+        case OP_div:
+            bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+            break;
+        case OP_math_mod:
+            /* Euclidian remainder */
+            rnd_mode = BF_DIVREM_EUCLIDIAN;
+            goto do_mod;
+        case OP_mod:
+            rnd_mode = BF_RNDZ;
+        do_mod:
+            {
+                bf_t q_s, *q = &q_s;
+                bf_init(ctx->bf_ctx, q);
+                bf_divrem(q, r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
+                          rnd_mode);
+                bf_delete(q);
+            }
+            break;
+        case OP_pow:
+        case OP_math_pow:
+            bf_pow(r, a, b, ctx->fp_env.prec,
+                   ctx->fp_env.flags | BF_POW_JS_QUICKS);
+            break;
+        default:
+            abort();
+        }
+        if (a == &a_s)
+            bf_delete(a);
+        if (b == &b_s)
+            bf_delete(b);
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        if (unlikely(ret)) {
+            bf_delete(r);
+            throw_bf_exception(ctx, ret);
+            goto exception;
+        }
+        sp[-2] = JS_NewBigFloat(ctx, r);
     }
     return 0;
  exception:
@@ -13456,6 +12190,7 @@ static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
 {
     JSValue op1, op2, res;
     uint32_t tag1, tag2;
+    BOOL is_float, is_legacy;
     int ret;
 
     op1 = sp[-2];
@@ -13475,13 +12210,10 @@ static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
     if (tag1 == JS_TAG_OBJECT || tag2 == JS_TAG_OBJECT) {
         /* try to call an overloaded operator */
         if ((tag1 == JS_TAG_OBJECT &&
-             (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED &&
-              tag2 != JS_TAG_STRING)) ||
+             (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
             (tag2 == JS_TAG_OBJECT &&
-             (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED &&
-              tag1 != JS_TAG_STRING))) {
-            ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add,
-                                             FALSE, HINT_NONE);
+             (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
+            ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add);
             if (ret != 0) {
                 JS_FreeValue(ctx, op1);
                 JS_FreeValue(ctx, op2);
@@ -13529,6 +12261,15 @@ static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
     tag1 = JS_VALUE_GET_NORM_TAG(op1);
     tag2 = JS_VALUE_GET_NORM_TAG(op2);
 
+    is_legacy = is_bignum_mode(ctx) ^ 1;
+    if (is_legacy && (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) &&
+        tag1 != tag2) {
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        JS_ThrowTypeError(ctx, "both operands must be bigint");
+        goto exception;
+    }
+
     if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {
         int32_t v1, v2;
         int64_t v;
@@ -13536,28 +12277,54 @@ static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
         v2 = JS_VALUE_GET_INT(op2);
         v = (int64_t)v1 + (int64_t)v2;
         sp[-2] = JS_NewInt64(ctx, v);
-    } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
-        if (ctx->rt->bigdecimal_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))
-            goto exception;
-    } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {
-        if (ctx->rt->bigfloat_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))
-            goto exception;
-    } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
-    handle_bigint:
-        if (ctx->rt->bigint_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))
+    } else if ((tag1 == JS_TAG_BIG_INT && (tag2 == JS_TAG_INT ||
+                                           tag2 == JS_TAG_BIG_INT)) ||
+               (tag2 == JS_TAG_BIG_INT && tag1 == JS_TAG_INT)) {
+        bf_t a_s, b_s, r_s, *r, *a, *b;
+        /* big int result */
+        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+        b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
+        r = &r_s;
+        bf_init(ctx->bf_ctx, r);
+        ret = bf_add(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
+        if (a == &a_s)
+            bf_delete(a);
+        if (b == &b_s)
+            bf_delete(b);
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        if (unlikely(ret)) {
+            bf_delete(r);
+            throw_bf_exception(ctx, ret);
             goto exception;
-    } else {
+        }
+        sp[-2] = JS_NewBigInt2(ctx, r, is_legacy);
+    } else if ((tag1 == JS_TAG_FLOAT64 && (tag2 == JS_TAG_FLOAT64 ||
+                                           tag2 == JS_TAG_INT ||
+                                           tag2 == JS_TAG_BIG_INT)) ||
+               (tag2 == JS_TAG_FLOAT64 && (tag1 == JS_TAG_INT ||
+                                           tag1 == JS_TAG_BIG_INT))) {
         double d1, d2;
         /* float64 result */
-        if (JS_ToFloat64Free(ctx, &d1, op1)) {
-            JS_FreeValue(ctx, op2);
-            goto exception;
-        }
-        if (JS_ToFloat64Free(ctx, &d2, op2))
-            goto exception;
-        if (is_math_mode(ctx) && is_safe_integer(d1) && is_safe_integer(d2))
-            goto handle_bigint;
+        JS_ToFloat64Free(ctx, &d1, op1);
+        JS_ToFloat64Free(ctx, &d2, op2);
         sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
+    } else {
+        bf_t a_s, b_s, r_s, *r, *a, *b;
+        /* big float result */
+        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+        b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
+
+        r = &r_s;
+        bf_init(ctx->bf_ctx, r);
+        bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+        if (a == &a_s)
+            bf_delete(a);
+        if (b == &b_s)
+            bf_delete(b);
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        sp[-2] = JS_NewBigFloat(ctx, r);
     }
     return 0;
  exception:
@@ -13571,9 +12338,10 @@ static no_inline __exception int js_binary_logic_slow(JSContext *ctx,
                                                       OPCodeEnum op)
 {
     JSValue op1, op2, res;
+    bf_t a_s, b_s, r_s, *r, *a, *b;
     int ret;
     uint32_t tag1, tag2;
-    uint32_t v1, v2, r;
+    BOOL is_legacy;
 
     op1 = sp[-2];
     op2 = sp[-1];
@@ -13585,7 +12353,7 @@ static no_inline __exception int js_binary_logic_slow(JSContext *ctx,
          (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
         (tag2 == JS_TAG_OBJECT &&
          (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
-        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);
+        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op);
         if (ret != 0) {
             JS_FreeValue(ctx, op1);
             JS_FreeValue(ctx, op2);
@@ -13598,61 +12366,111 @@ static no_inline __exception int js_binary_logic_slow(JSContext *ctx,
         }
     }
 
-    op1 = JS_ToNumericFree(ctx, op1);
+    op1 = JS_ToNumberHintFree(ctx, op1, TON_FLAG_INTEGER);
     if (JS_IsException(op1)) {
         JS_FreeValue(ctx, op2);
         goto exception;
     }
-    op2 = JS_ToNumericFree(ctx, op2);
+    op2 = JS_ToNumberHintFree(ctx, op2, TON_FLAG_INTEGER);
     if (JS_IsException(op2)) {
         JS_FreeValue(ctx, op1);
         goto exception;
     }
 
-    if (is_math_mode(ctx))
-        goto bigint_op;
+    is_legacy = is_bignum_mode(ctx) ^ 1;
+    if (is_legacy) {
+        uint32_t v1, v2, r;
 
-    tag1 = JS_VALUE_GET_TAG(op1);
-    tag2 = JS_VALUE_GET_TAG(op2);
-    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
-        if (tag1 != tag2) {
-            JS_FreeValue(ctx, op1);
-            JS_FreeValue(ctx, op2);
-            JS_ThrowTypeError(ctx, "both operands must be bigint");
-            goto exception;
+        tag1 = JS_VALUE_GET_TAG(op1);
+        tag2 = JS_VALUE_GET_TAG(op2);
+        if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
+            if (tag1 != tag2) {
+                JS_FreeValue(ctx, op1);
+                JS_FreeValue(ctx, op2);
+                JS_ThrowTypeError(ctx, "both operands must be bigint");
+                goto exception;
+            }
         } else {
-        bigint_op:
-            if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))
+            if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
+                JS_FreeValue(ctx, op2);
                 goto exception;
+            }
+            if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))
+                goto exception;
+            switch(op) {
+            case OP_shl:
+                r = v1 << (v2 & 0x1f);
+                break;
+            case OP_sar:
+                r = (int)v1 >> (v2 & 0x1f);
+                break;
+            case OP_and:
+                r = v1 & v2;
+                break;
+            case OP_or:
+                r = v1 | v2;
+                break;
+            case OP_xor:
+                r = v1 ^ v2;
+                break;
+            default:
+                abort();
+            }
+            sp[-2] = JS_NewInt32(ctx, r);
+            return 0;
         }
-    } else {
-        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
-            JS_FreeValue(ctx, op2);
-            goto exception;
-        }
-        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))
-            goto exception;
-        switch(op) {
-        case OP_shl:
-            r = v1 << (v2 & 0x1f);
-            break;
-        case OP_sar:
-            r = (int)v1 >> (v2 & 0x1f);
-            break;
-        case OP_and:
-            r = v1 & v2;
-            break;
-        case OP_or:
-            r = v1 | v2;
-            break;
-        case OP_xor:
-            r = v1 ^ v2;
-            break;
-        default:
-            abort();
+    }
+
+    a = JS_ToBigIntFree(ctx, &a_s, op1);
+    b = JS_ToBigIntFree(ctx, &b_s, op2);
+
+    r = &r_s;
+    bf_init(ctx->bf_ctx, r);
+    ret = 0;
+    switch(op) {
+    case OP_shl:
+    case OP_sar:
+        {
+            slimb_t v2;
+#if LIMB_BITS == 32
+            bf_get_int32(&v2, b, 0);
+            if (v2 == INT32_MIN)
+                v2 = INT32_MIN + 1;
+#else
+            bf_get_int64(&v2, b, 0);
+            if (v2 == INT64_MIN)
+                v2 = INT64_MIN + 1;
+#endif
+            if (op == OP_sar)
+                v2 = -v2;
+            bf_set(r, a);
+            ret = bf_mul_2exp(r, v2, BF_PREC_INF, BF_RNDZ);
+            if (v2 < 0) {
+                ret |= bf_rint(r, BF_PREC_INF, BF_RNDD);
+            }
+            ret &= BF_ST_OVERFLOW;
         }
-        sp[-2] = JS_NewInt32(ctx, r);
+        break;
+    case OP_and:
+        bf_logic_and(r, a, b);
+        break;
+    case OP_or:
+        bf_logic_or(r, a, b);
+        break;
+    case OP_xor:
+        bf_logic_xor(r, a, b);
+        break;
+    default:
+        abort();
+    }
+    JS_FreeBigInt(ctx, a, &a_s);
+    JS_FreeBigInt(ctx, b, &b_s);
+    if (unlikely(ret)) {
+        bf_delete(r);
+        throw_bf_exception(ctx, ret);
+        goto exception;
     }
+    sp[-2] = JS_NewBigInt2(ctx, r, is_legacy);
     return 0;
  exception:
     sp[-2] = JS_UNDEFINED;
@@ -13660,103 +12478,10 @@ static no_inline __exception int js_binary_logic_slow(JSContext *ctx,
     return -1;
 }
 
-/* Note: also used for bigint */
-static int js_compare_bigfloat(JSContext *ctx, OPCodeEnum op,
-                               JSValue op1, JSValue op2)
+static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
+                                        OPCodeEnum op)
 {
-    bf_t a_s, b_s, *a, *b;
-    int res;
-    
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    if (!a) {
-        JS_FreeValue(ctx, op2);
-        return -1;
-    }
-    b = JS_ToBigFloat(ctx, &b_s, op2);
-    if (!b) {
-        if (a == &a_s)
-            bf_delete(a);
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-    switch(op) {
-    case OP_lt:
-        res = bf_cmp_lt(a, b); /* if NaN return false */
-        break;
-    case OP_lte:
-        res = bf_cmp_le(a, b); /* if NaN return false */
-        break;
-    case OP_gt:
-        res = bf_cmp_lt(b, a); /* if NaN return false */
-        break;
-    case OP_gte:
-        res = bf_cmp_le(b, a); /* if NaN return false */
-        break;
-    case OP_eq:
-        res = bf_cmp_eq(a, b); /* if NaN return false */
-        break;
-    default:
-        abort();
-    }
-    if (a == &a_s)
-        bf_delete(a);
-    if (b == &b_s)
-        bf_delete(b);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    return res;
-}
-
-static int js_compare_bigdecimal(JSContext *ctx, OPCodeEnum op,
-                                 JSValue op1, JSValue op2)
-{
-    bfdec_t *a, *b;
-    int res;
-
-    /* Note: binary floats are converted to bigdecimal with
-       toString(). It is not mathematically correct but is consistent
-       with the BigDecimal() constructor behavior */
-    op1 = JS_ToBigDecimalFree(ctx, op1, TRUE);
-    if (JS_IsException(op1)) {
-        JS_FreeValue(ctx, op2);
-        return -1;
-    }
-    op2 = JS_ToBigDecimalFree(ctx, op2, TRUE);
-    if (JS_IsException(op2)) {
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
-    a = JS_ToBigDecimal(ctx, op1);
-    b = JS_ToBigDecimal(ctx, op2);
-    
-    switch(op) {
-    case OP_lt:
-        res = bfdec_cmp_lt(a, b); /* if NaN return false */
-        break;
-    case OP_lte:
-        res = bfdec_cmp_le(a, b); /* if NaN return false */
-        break;
-    case OP_gt:
-        res = bfdec_cmp_lt(b, a); /* if NaN return false */
-        break;
-    case OP_gte:
-        res = bfdec_cmp_le(b, a); /* if NaN return false */
-        break;
-    case OP_eq:
-        res = bfdec_cmp_eq(a, b); /* if NaN return false */
-        break;
-    default:
-        abort();
-    }
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    return res;
-}
-
-static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
-                                        OPCodeEnum op)
-{
-    JSValue op1, op2, ret;
+    JSValue op1, op2, ret;
     int res;
     uint32_t tag1, tag2;
 
@@ -13769,8 +12494,7 @@ static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
          (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
         (tag2 == JS_TAG_OBJECT &&
          (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
-        res = js_call_binary_op_fallback(ctx, &ret, op1, op2, op,
-                                         FALSE, HINT_NUMBER);
+        res = js_call_binary_op_fallback(ctx, &ret, op1, op2, op);
         if (res != 0) {
             JS_FreeValue(ctx, op1);
             JS_FreeValue(ctx, op2);
@@ -13819,12 +12543,40 @@ static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
         JS_FreeValue(ctx, op2);
     } else if ((tag1 <= JS_TAG_NULL || tag1 == JS_TAG_FLOAT64) &&
                (tag2 <= JS_TAG_NULL || tag2 == JS_TAG_FLOAT64)) {
-        /* fast path for float64/int */
-        goto float64_compare;
+        /* can use floating point comparison */
+        double d1, d2;
+        if (tag1 == JS_TAG_FLOAT64) {
+            d1 = JS_VALUE_GET_FLOAT64(op1);
+        } else {
+            d1 = JS_VALUE_GET_INT(op1);
+        }
+        if (tag2 == JS_TAG_FLOAT64) {
+            d2 = JS_VALUE_GET_FLOAT64(op2);
+        } else {
+            d2 = JS_VALUE_GET_INT(op2);
+        }
+        switch(op) {
+        case OP_lt:
+            res = (d1 < d2); /* if NaN return false */
+            break;
+        case OP_lte:
+            res = (d1 <= d2); /* if NaN return false */
+            break;
+        case OP_gt:
+            res = (d1 > d2); /* if NaN return false */
+            break;
+        default:
+        case OP_gte:
+            res = (d1 >= d2); /* if NaN return false */
+            break;
+        }
     } else {
+        bf_t a_s, b_s, *a, *b;
+        BOOL is_float;
+
         if (((tag1 == JS_TAG_BIG_INT && tag2 == JS_TAG_STRING) ||
              (tag2 == JS_TAG_BIG_INT && tag1 == JS_TAG_STRING)) &&
-            !is_math_mode(ctx)) {
+            !is_bignum_mode(ctx)) {
             if (tag1 == JS_TAG_STRING) {
                 op1 = JS_StringToBigInt(ctx, op1);
                 if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT)
@@ -13853,52 +12605,30 @@ static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
             }
         }
 
-        tag1 = JS_VALUE_GET_NORM_TAG(op1);
-        tag2 = JS_VALUE_GET_NORM_TAG(op2);
-
-        if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
-            res = ctx->rt->bigdecimal_ops.compare(ctx, op, op1, op2);
-            if (res < 0)
-                goto exception;
-        } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {
-            res = ctx->rt->bigfloat_ops.compare(ctx, op, op1, op2);
-            if (res < 0)
-                goto exception;
-        } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
-            res = ctx->rt->bigint_ops.compare(ctx, op, op1, op2);
-            if (res < 0)
-                goto exception;
-        } else {
-            double d1, d2;
+        a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+        b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
 
-        float64_compare:
-            /* can use floating point comparison */
-            if (tag1 == JS_TAG_FLOAT64) {
-                d1 = JS_VALUE_GET_FLOAT64(op1);
-            } else {
-                d1 = JS_VALUE_GET_INT(op1);
-            }
-            if (tag2 == JS_TAG_FLOAT64) {
-                d2 = JS_VALUE_GET_FLOAT64(op2);
-            } else {
-                d2 = JS_VALUE_GET_INT(op2);
-            }
-            switch(op) {
-            case OP_lt:
-                res = (d1 < d2); /* if NaN return false */
-                break;
-            case OP_lte:
-                res = (d1 <= d2); /* if NaN return false */
-                break;
-            case OP_gt:
-                res = (d1 > d2); /* if NaN return false */
-                break;
-            default:
-            case OP_gte:
-                res = (d1 >= d2); /* if NaN return false */
-                break;
-            }
+        switch(op) {
+        case OP_lt:
+            res = bf_cmp_lt(a, b); /* if NaN return false */
+            break;
+        case OP_lte:
+            res = bf_cmp_le(a, b); /* if NaN return false */
+            break;
+        case OP_gt:
+            res = bf_cmp_lt(b, a); /* if NaN return false */
+            break;
+        default:
+        case OP_gte:
+            res = bf_cmp_le(b, a); /* if NaN return false */
+            break;
         }
+        if (a == &a_s)
+            bf_delete(a);
+        if (b == &b_s)
+            bf_delete(b);
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
     }
  done:
     sp[-2] = JS_NewBool(ctx, res);
@@ -13912,8 +12642,7 @@ static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
 static BOOL tag_is_number(uint32_t tag)
 {
     return (tag == JS_TAG_INT || tag == JS_TAG_BIG_INT ||
-            tag == JS_TAG_FLOAT64 || tag == JS_TAG_BIG_FLOAT ||
-            tag == JS_TAG_BIG_DECIMAL);
+            tag == JS_TAG_FLOAT64 || tag == JS_TAG_BIG_FLOAT);
 }
 
 static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
@@ -13947,25 +12676,24 @@ static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
                 d2 = JS_VALUE_GET_INT(op2);
             }
             res = (d1 == d2);
-        } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
-            res = ctx->rt->bigdecimal_ops.compare(ctx, OP_eq, op1, op2);
-            if (res < 0)
-                goto exception;
-        } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {
-            res = ctx->rt->bigfloat_ops.compare(ctx, OP_eq, op1, op2);
-            if (res < 0)
-                goto exception;
         } else {
-            res = ctx->rt->bigint_ops.compare(ctx, OP_eq, op1, op2);
-            if (res < 0)
-                goto exception;
+            bf_t a_s, b_s, *a, *b;
+            BOOL is_float;
+            a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+            b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
+            res = bf_cmp_eq(a, b);
+            if (a == &a_s)
+                bf_delete(a);
+            if (b == &b_s)
+                bf_delete(b);
+            JS_FreeValue(ctx, op1);
+            JS_FreeValue(ctx, op2);
         }
     } else if (tag1 == tag2) {
         if (tag1 == JS_TAG_OBJECT) {
             /* try the fallback operator */
             res = js_call_binary_op_fallback(ctx, &ret, op1, op2,
-                                             is_neq ? OP_neq : OP_eq,
-                                             FALSE, HINT_NONE);
+                                              is_neq ? OP_neq : OP_eq);
             if (res != 0) {
                 JS_FreeValue(ctx, op1);
                 JS_FreeValue(ctx, op2);
@@ -13985,7 +12713,7 @@ static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
                (tag2 == JS_TAG_STRING && tag_is_number(tag1))) {
 
         if ((tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) &&
-            !is_math_mode(ctx)) {
+            !is_bignum_mode(ctx)) {
             if (tag1 == JS_TAG_STRING) {
                 op1 = JS_StringToBigInt(ctx, op1);
                 if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT)
@@ -14027,8 +12755,7 @@ static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
 
         /* try the fallback operator */
         res = js_call_binary_op_fallback(ctx, &ret, op1, op2,
-                                         is_neq ? OP_neq : OP_eq,
-                                         FALSE, HINT_NONE);
+                                          is_neq ? OP_neq : OP_eq);
         if (res != 0) {
             JS_FreeValue(ctx, op1);
             JS_FreeValue(ctx, op2);
@@ -14052,17 +12779,9 @@ static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
         }
         goto redo;
     } else {
-        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */
-        if ((JS_IsHTMLDDA(ctx, op1) &&
-             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||
-            (JS_IsHTMLDDA(ctx, op2) &&
-             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {
-            res = TRUE;
-        } else {
-            res = FALSE;
-        }
         JS_FreeValue(ctx, op1);
         JS_FreeValue(ctx, op2);
+        res = FALSE;
     }
  done:
     sp[-2] = JS_NewBool(ctx, res ^ is_neq);
@@ -14091,7 +12810,7 @@ static no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)
         goto exception;
     }
     /* XXX: could forbid >>> in bignum mode */
-    if (!is_math_mode(ctx) &&
+    if (!is_bignum_mode(ctx) &&
         (JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT ||
          JS_VALUE_GET_TAG(op2) == JS_TAG_BIG_INT)) {
         JS_ThrowTypeError(ctx, "bigint operands are forbidden for >>>");
@@ -14111,87 +12830,56 @@ static no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)
     return -1;
 }
 
-static JSValue js_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,
-                                       int64_t exponent)
+static double bf_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,
+                                      int64_t exponent)
 {
     bf_t r_s, *r = &r_s;
     double d;
-    int ret;
-    
     /* always convert to Float64 */
     bf_init(ctx->bf_ctx, r);
-    ret = bf_mul_pow_radix(r, a, 10, exponent,
-                           53, bf_set_exp_bits(11) | BF_RNDN |
-                           BF_FLAG_SUBNORMAL);
+    bf_mul_pow_radix(r, a, 10, exponent,
+                     53, bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
     bf_get_float64(r, &d, BF_RNDN);
     bf_delete(r);
-    if (ret & BF_ST_MEM_ERROR)
-        return JS_ThrowOutOfMemory(ctx);
-    else
-        return __JS_NewFloat64(ctx, d);
+    return d;
 }
 
 static no_inline int js_mul_pow10(JSContext *ctx, JSValue *sp)
 {
-    bf_t a_s, *a, *r;
-    JSValue op1, op2, res;
-    int64_t e;
+    bf_t a_s, *a, r_s, *r = &r_s;
+    BOOL is_float;
+    JSValue op1, op2;
+    slimb_t e;
     int ret;
 
-    res = JS_NewBigFloat(ctx);
-    if (JS_IsException(res))
-        return -1;
-    r = JS_GetBigFloat(res);
     op1 = sp[-2];
     op2 = sp[-1];
-    a = JS_ToBigFloat(ctx, &a_s, op1);
+    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
     if (!a)
         return -1;
-    if (JS_IsBigInt(ctx, op2)) {
-        ret = JS_ToBigInt64(ctx, &e, op2);
-    } else {
-        ret = JS_ToInt64(ctx, &e, op2);
-    }
+#if LIMB_BITS == 32
+    ret = JS_ToInt32(ctx, &e, op2);
+#else
+    ret = JS_ToInt64(ctx, &e, op2);
+#endif
     if (ret) {
         if (a == &a_s)
             bf_delete(a);
-        JS_FreeValue(ctx, res);
         return -1;
     }
 
+    bf_init(ctx->bf_ctx, r);
     bf_mul_pow_radix(r, a, 10, e, ctx->fp_env.prec, ctx->fp_env.flags);
     if (a == &a_s)
         bf_delete(a);
     JS_FreeValue(ctx, op1);
     JS_FreeValue(ctx, op2);
-    sp[-2] = res;
+    sp[-2] = JS_NewBigFloat(ctx, r);
     return 0;
 }
 
 #else /* !CONFIG_BIGNUM */
 
-static JSValue JS_ThrowUnsupportedBigint(JSContext *ctx)
-{
-    return JS_ThrowTypeError(ctx, "bigint is not supported");
-}
-
-JSValue JS_NewBigInt64(JSContext *ctx, int64_t v)
-{
-    return JS_ThrowUnsupportedBigint(ctx);
-}
-
-JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)
-{
-    return JS_ThrowUnsupportedBigint(ctx);
-}
-
-int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
-{
-    JS_ThrowUnsupportedBigint(ctx);
-    *pres = 0;
-    return -1;
-}
-
 static no_inline __exception int js_unary_arith_slow(JSContext *ctx,
                                                      JSValue *sp,
                                                      OPCodeEnum op)
@@ -14513,17 +13201,9 @@ static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
         }
         goto redo;
     } else {
-        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */
-        if ((JS_IsHTMLDDA(ctx, op1) &&
-             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||
-            (JS_IsHTMLDDA(ctx, op2) &&
-             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {
-            res = TRUE;
-        } else {
-            res = FALSE;
-        }
         JS_FreeValue(ctx, op1);
         JS_FreeValue(ctx, op2);
+        res = FALSE;
     }
     sp[-2] = JS_NewBool(ctx, res ^ is_neq);
     return 0;
@@ -14616,9 +13296,22 @@ static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
             d2 = JS_VALUE_GET_INT(op2);
             goto number_test;
         } else if (tag2 == JS_TAG_FLOAT64) {
-            d2 = JS_VALUE_GET_FLOAT64(op2);
-            goto number_test;
-        } else {
+#ifdef CONFIG_BIGNUM
+            if (is_bignum_mode(ctx)) {
+                res = FALSE;
+            } else
+#endif
+            {
+                d2 = JS_VALUE_GET_FLOAT64(op2);
+                goto number_test;
+            }
+        } else
+#ifdef CONFIG_BIGNUM
+        if (tag2 == JS_TAG_BIG_INT && is_bignum_mode(ctx)) {
+            goto bigint_test;
+        } else
+#endif
+        {
             res = FALSE;
         }
         break;
@@ -14626,7 +13319,11 @@ static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
         d1 = JS_VALUE_GET_FLOAT64(op1);
         if (tag2 == JS_TAG_FLOAT64) {
             d2 = JS_VALUE_GET_FLOAT64(op2);
-        } else if (tag2 == JS_TAG_INT) {
+        } else if (tag2 == JS_TAG_INT
+#ifdef CONFIG_BIGNUM
+                   && !is_bignum_mode(ctx)
+#endif
+                   ) {
             d2 = JS_VALUE_GET_INT(op2);
         } else {
             res = FALSE;
@@ -14653,17 +13350,23 @@ static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
     case JS_TAG_BIG_INT:
         {
             bf_t a_s, *a, b_s, *b;
-            if (tag1 != tag2) {
+            BOOL is_float;
+            if (tag1 == tag2) {
+                /* OK */
+            } else if (tag2 == JS_TAG_INT && is_bignum_mode(ctx)) {
+                /* OK */
+            } else {
                 res = FALSE;
                 break;
             }
-            a = JS_ToBigFloat(ctx, &a_s, op1);
-            b = JS_ToBigFloat(ctx, &b_s, op2);
+        bigint_test:
+            a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+            b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
             res = bf_cmp_eq(a, b);
             if (a == &a_s)
                 bf_delete(a);
             if (b == &b_s)
-                bf_delete(b);
+                bf_delete(a);
         }
         break;
     case JS_TAG_BIG_FLOAT:
@@ -14690,21 +13393,6 @@ static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
             }
         }
         break;
-    case JS_TAG_BIG_DECIMAL:
-        {
-            JSBigDecimal *p1, *p2;
-            const bfdec_t *a, *b;
-            if (tag1 != tag2) {
-                res = FALSE;
-                break;
-            }
-            p1 = JS_VALUE_GET_PTR(op1);
-            p2 = JS_VALUE_GET_PTR(op2);
-            a = &p1->num;
-            b = &p2->num;
-            res = bfdec_cmp_eq(a, b);
-        }
-        break;
 #endif
     default:
         res = FALSE;
@@ -14804,7 +13492,7 @@ static __exception int js_operator_instanceof(JSContext *ctx, JSValue *sp)
     return 0;
 }
 
-static __exception int js_operator_typeof(JSContext *ctx, JSValueConst op1)
+static __exception int js_operator_typeof(JSContext *ctx, JSValue op1)
 {
     JSAtom atom;
     uint32_t tag;
@@ -14812,20 +13500,27 @@ static __exception int js_operator_typeof(JSContext *ctx, JSValueConst op1)
     tag = JS_VALUE_GET_NORM_TAG(op1);
     switch(tag) {
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_INT:
+        if (is_bignum_mode(ctx))
+            atom = JS_ATOM_bigint;
+        else
+            atom = JS_ATOM_number;
+        break;
     case JS_TAG_BIG_INT:
         atom = JS_ATOM_bigint;
         break;
+    case JS_TAG_FLOAT64:
+        atom = JS_ATOM_number;
+        break;
     case JS_TAG_BIG_FLOAT:
         atom = JS_ATOM_bigfloat;
         break;
-    case JS_TAG_BIG_DECIMAL:
-        atom = JS_ATOM_bigdecimal;
-        break;
-#endif
+#else
     case JS_TAG_INT:
     case JS_TAG_FLOAT64:
         atom = JS_ATOM_number;
         break;
+#endif
     case JS_TAG_UNDEFINED:
         atom = JS_ATOM_undefined;
         break;
@@ -14836,16 +13531,10 @@ static __exception int js_operator_typeof(JSContext *ctx, JSValueConst op1)
         atom = JS_ATOM_string;
         break;
     case JS_TAG_OBJECT:
-        {
-            JSObject *p;
-            p = JS_VALUE_GET_OBJ(op1);
-            if (unlikely(p->is_HTMLDDA)) 
-                atom = JS_ATOM_undefined;
-            else if (JS_IsFunction(ctx, op1))
-                atom = JS_ATOM_function;
-            else
-                goto obj_type;
-        }
+        if (JS_IsFunction(ctx, op1))
+            atom = JS_ATOM_function;
+        else
+            goto obj_type;
         break;
     case JS_TAG_NULL:
     obj_type:
@@ -15038,7 +13727,7 @@ static JSValue js_build_mapped_arguments(JSContext *ctx, int argc,
                            JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
     /* callee returns this function in non strict mode */
     JS_DefinePropertyValue(ctx, val, JS_ATOM_callee,
-                           JS_DupValue(ctx, ctx->rt->current_stack_frame->cur_func),
+                           JS_DupValue(ctx, ctx->current_stack_frame->cur_func),
                            JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
     return val;
  fail:
@@ -15068,10 +13757,10 @@ static JSValue js_build_rest(JSContext *ctx, int first, int argc, JSValueConst *
 
 static JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)
 {
-    JSObject *p;
+    JSObject *p, *p1;
     JSPropertyEnum *tab_atom;
     int i;
-    JSValue enum_obj, obj1;
+    JSValue enum_obj;
     JSForInIterator *it;
     uint32_t tag, tab_atom_count;
 
@@ -15100,34 +13789,20 @@ static JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)
     if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)
         return enum_obj;
 
+    p = JS_VALUE_GET_OBJ(obj);
+
     /* fast path: assume no enumerable properties in the prototype chain */
-    obj1 = JS_DupValue(ctx, obj);
-    for(;;) {
-        obj1 = JS_GetPrototypeFree(ctx, obj1);
-        if (JS_IsNull(obj1))
-            break;
-        if (JS_IsException(obj1))
-            goto fail;
-        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
-                                           JS_VALUE_GET_OBJ(obj1),
-                                           JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY)) {
-            JS_FreeValue(ctx, obj1);
+    p1 = p->shape->proto;
+    while (p1 != NULL) {
+        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p1,
+                                   JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY))
             goto fail;
-        }
         js_free_prop_enum(ctx, tab_atom, tab_atom_count);
         if (tab_atom_count != 0) {
-            JS_FreeValue(ctx, obj1);
             goto slow_path;
         }
-        /* must check for timeout to avoid infinite loop */
-        if (js_poll_interrupts(ctx)) {
-            JS_FreeValue(ctx, obj1);
-            goto fail;
-        }
+        p1 = p1->shape->proto;
     }
-
-    p = JS_VALUE_GET_OBJ(obj);
-
     if (p->fast_array) {
         JSShape *sh;
         JSShapeProperty *prs;
@@ -15137,6 +13812,15 @@ static JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)
             if (prs->flags & JS_PROP_ENUMERABLE)
                 goto normal_case;
         }
+        /* the implicit GetOwnProperty raises an exception if the
+           typed array is detached */
+        if ((p->class_id >= JS_CLASS_UINT8C_ARRAY &&
+             p->class_id <= JS_CLASS_FLOAT64_ARRAY) &&
+            typed_array_is_detached(ctx, p) &&
+            typed_array_get_length(ctx, p) != 0) {
+            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
+            goto fail;
+        }
         /* for fast arrays, we only store the number of elements */
         it->is_array = TRUE;
         it->array_length = p->u.array.count;
@@ -15155,30 +13839,17 @@ static JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)
  slow_path:
     /* non enumerable properties hide the enumerables ones in the
        prototype chain */
-    obj1 = JS_DupValue(ctx, obj);
-    for(;;) {
-        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
-                                           JS_VALUE_GET_OBJ(obj1),
-                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
-            JS_FreeValue(ctx, obj1);
+    while (p != NULL) {
+        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
+                                   JS_GPN_STRING_MASK | JS_GPN_SET_ENUM))
             goto fail;
-        }
         for(i = 0; i < tab_atom_count; i++) {
             JS_DefinePropertyValue(ctx, enum_obj, tab_atom[i].atom, JS_NULL,
                                    (tab_atom[i].is_enumerable ?
                                     JS_PROP_ENUMERABLE : 0));
         }
         js_free_prop_enum(ctx, tab_atom, tab_atom_count);
-        obj1 = JS_GetPrototypeFree(ctx, obj1);
-        if (JS_IsNull(obj1))
-            break;
-        if (JS_IsException(obj1))
-            goto fail;
-        /* must check for timeout to avoid infinite loop */
-        if (js_poll_interrupts(ctx)) {
-            JS_FreeValue(ctx, obj1);
-            goto fail;
-        }
+        p = p->shape->proto;
     }
     return enum_obj;
 
@@ -15378,8 +14049,8 @@ static int JS_IteratorClose(JSContext *ctx, JSValueConst enum_obj,
     int res;
 
     if (is_exception_pending) {
-        ex_obj = ctx->rt->current_exception;
-        ctx->rt->current_exception = JS_NULL;
+        ex_obj = ctx->current_exception;
+        ctx->current_exception = JS_NULL;
         res = -1;
     } else {
         ex_obj = JS_UNDEFINED;
@@ -15428,10 +14099,7 @@ static __exception int js_for_of_start(JSContext *ctx, JSValue *sp,
     return 0;
 }
 
-/* enum_rec [objs] -> enum_rec [objs] value done. There are 'offset'
-   objs. If 'done' is true or in case of exception, 'enum_rec' is set
-   to undefined. If 'done' is true, 'value' is always set to
-   undefined. */
+/* enum_rec -> enum_rec value done */
 static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
 {
     JSValue value = JS_UNDEFINED;
@@ -15446,12 +14114,8 @@ static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
             /* replace the iteration object with undefined */
             JS_FreeValue(ctx, sp[offset]);
             sp[offset] = JS_UNDEFINED;
-            if (done < 0) {
+            if (done < 0)
                 return -1;
-            } else {
-                JS_FreeValue(ctx, value);
-                value = JS_UNDEFINED;
-            }
         }
     }
     sp[0] = value;
@@ -15459,6 +14123,16 @@ static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
     return 0;
 }
 
+static __exception int js_for_await_of_next(JSContext *ctx, JSValue *sp)
+{
+    JSValue result;
+    result = JS_Call(ctx, sp[-2], sp[-3], 0, NULL);
+    if (JS_IsException(result))
+        return -1;
+    sp[0] = result;
+    return 0;
+}
+
 static JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValueConst obj,
                                            BOOL *pdone)
 {
@@ -15557,10 +14231,10 @@ static BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,
 static __exception int js_append_enumerate(JSContext *ctx, JSValue *sp)
 {
     JSValue iterator, enumobj, method, value;
-    int is_array_iterator;
+    int pos, is_array_iterator;
     JSValue *arrp;
-    uint32_t i, count32, pos;
-    
+    uint32_t i, count32;
+
     if (JS_VALUE_GET_TAG(sp[-2]) != JS_TAG_INT) {
         JS_ThrowInternalError(ctx, "invalid index for append");
         return -1;
@@ -15593,21 +14267,24 @@ static __exception int js_append_enumerate(JSContext *ctx, JSValue *sp)
     if (is_array_iterator
     &&  JS_IsCFunction(ctx, method, (JSCFunction *)js_array_iterator_next, 0)
     &&  js_get_fast_array(ctx, sp[-1], &arrp, &count32)) {
-        uint32_t len;
-        if (js_get_length32(ctx, &len, sp[-1]))
-            goto exception;
-        /* if len > count32, the elements >= count32 might be read in
-           the prototypes and might have side effects */
-        if (len != count32)
-            goto general_case;
+        int64_t len;
         /* Handle fast arrays explicitly */
+        if (js_get_length64(ctx, &len, sp[-1]))
+            goto exception;
         for (i = 0; i < count32; i++) {
             if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++,
                                              JS_DupValue(ctx, arrp[i]), JS_PROP_C_W_E) < 0)
                 goto exception;
         }
+        if (len > count32) {
+            /* This is not strictly correct because the trailing elements are
+               empty instead of undefined. Append undefined entries instead.
+             */
+            pos += len - count32;
+            if (JS_SetProperty(ctx, sp[-3], JS_ATOM_length, JS_NewUint32(ctx, pos)) < 0)
+                goto exception;
+        }
     } else {
-    general_case:
         for (;;) {
             BOOL done;
             value = JS_IteratorNext(ctx, enumobj, method, 0, NULL, &done);
@@ -15621,7 +14298,6 @@ static __exception int js_append_enumerate(JSContext *ctx, JSValue *sp)
                 goto exception;
         }
     }
-    /* Note: could raise an error if too many elements */
     sp[-2] = JS_NewInt32(ctx, pos);
     JS_FreeValue(ctx, enumobj);
     JS_FreeValue(ctx, method);
@@ -15645,10 +14321,8 @@ static __exception int JS_CopyDataProperties(JSContext *ctx,
     uint32_t i, tab_atom_count;
     JSObject *p;
     JSObject *pexcl = NULL;
-    int ret, gpn_flags;
-    JSPropertyDescriptor desc;
-    BOOL is_enumerable;
-    
+    int ret = 0, flags;
+
     if (JS_VALUE_GET_TAG(source) != JS_TAG_OBJECT)
         return 0;
 
@@ -15656,63 +14330,43 @@ static __exception int JS_CopyDataProperties(JSContext *ctx,
         pexcl = JS_VALUE_GET_OBJ(excluded);
 
     p = JS_VALUE_GET_OBJ(source);
-
-    gpn_flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK | JS_GPN_ENUM_ONLY;
-    if (p->is_exotic) {
-        const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
-        /* cannot use JS_GPN_ENUM_ONLY with e.g. proxies because it
-           introduces a visible change */
-        if (em && em->get_own_property_names) {
-            gpn_flags &= ~JS_GPN_ENUM_ONLY;
-        }
-    }
     if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
-                                       gpn_flags))
+                               JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK |
+                               JS_GPN_ENUM_ONLY))
         return -1;
-    
+
+    flags = JS_PROP_C_W_E;
+
     for (i = 0; i < tab_atom_count; i++) {
         if (pexcl) {
             ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);
             if (ret) {
                 if (ret < 0)
-                    goto exception;
+                    break;
+                ret = 0;
                 continue;
             }
         }
-        if (!(gpn_flags & JS_GPN_ENUM_ONLY)) {
-            /* test if the property is enumerable */
-            ret = JS_GetOwnPropertyInternal(ctx, &desc, p, tab_atom[i].atom);
-            if (ret < 0)
-                goto exception;
-            if (!ret)
-                continue;
-            is_enumerable = (desc.flags & JS_PROP_ENUMERABLE) != 0;
-            js_free_desc(ctx, &desc);
-            if (!is_enumerable)
-                continue;
-        }
+        ret = -1;
         val = JS_GetProperty(ctx, source, tab_atom[i].atom);
         if (JS_IsException(val))
-            goto exception;
+            break;
         if (setprop)
             ret = JS_SetProperty(ctx, target, tab_atom[i].atom, val);
         else
-            ret = JS_DefinePropertyValue(ctx, target, tab_atom[i].atom, val,
-                                         JS_PROP_C_W_E);
+            ret = JS_DefinePropertyValue(ctx, target, tab_atom[i].atom, val, flags);
         if (ret < 0)
-            goto exception;
+            break;
+        ret = 0;
     }
     js_free_prop_enum(ctx, tab_atom, tab_atom_count);
-    return 0;
- exception:
-    js_free_prop_enum(ctx, tab_atom, tab_atom_count);
-    return -1;
+    return ret;
 }
 
 /* only valid inside C functions */
 static JSValueConst JS_GetActiveFunction(JSContext *ctx)
 {
-    return ctx->rt->current_stack_frame->cur_func;
+    return ctx->current_stack_frame->cur_func;
 }
 
 static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf,
@@ -15722,7 +14376,7 @@ static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf,
     struct list_head *el;
 
     list_for_each(el, &sf->var_ref_list) {
-        var_ref = list_entry(el, JSVarRef, header.link);
+        var_ref = list_entry(el, JSVarRef, link);
         if (var_ref->var_idx == var_idx && var_ref->is_arg == is_arg) {
             var_ref->header.ref_count++;
             return var_ref;
@@ -15733,10 +14387,10 @@ static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf,
     if (!var_ref)
         return NULL;
     var_ref->header.ref_count = 1;
-    var_ref->is_detached = FALSE;
+    var_ref->gc_header.mark = 0;
     var_ref->is_arg = is_arg;
     var_ref->var_idx = var_idx;
-    list_add_tail(&var_ref->header.link, &sf->var_ref_list);
+    list_add_tail(&var_ref->link, &sf->var_ref_list);
     if (is_arg)
         var_ref->pvalue = &sf->arg_buf[var_idx];
     else
@@ -15785,7 +14439,7 @@ static JSValue js_closure2(JSContext *ctx, JSValue func_obj,
     return JS_EXCEPTION;
 }
 
-static JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque)
+static int js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque)
 {
     JSValue obj, this_val;
     int ret;
@@ -15793,26 +14447,17 @@ static JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom
     this_val = JS_MKPTR(JS_TAG_OBJECT, p);
     obj = JS_NewObject(ctx);
     if (JS_IsException(obj))
-        return JS_EXCEPTION;
+        return -1;
     set_cycle_flag(ctx, obj);
     set_cycle_flag(ctx, this_val);
     ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_constructor,
                                  JS_DupValue(ctx, this_val),
                                  JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-    if (ret < 0) {
-        JS_FreeValue(ctx, obj);
-        return JS_EXCEPTION;
-    }
-    return obj;
+    if (JS_DefinePropertyValue(ctx, this_val, atom, obj, JS_PROP_WRITABLE) < 0 || ret < 0)
+        return -1;
+    return 0;
 }
 
-static const uint16_t func_kind_to_class_id[] = {
-    [JS_FUNC_NORMAL] = JS_CLASS_BYTECODE_FUNCTION,
-    [JS_FUNC_GENERATOR] = JS_CLASS_GENERATOR_FUNCTION,
-    [JS_FUNC_ASYNC] = JS_CLASS_ASYNC_FUNCTION,
-    [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,
-};
-
 static JSValue js_closure(JSContext *ctx, JSValue bfunc,
                           JSVarRef **cur_var_refs,
                           JSStackFrame *sf)
@@ -15820,6 +14465,12 @@ static JSValue js_closure(JSContext *ctx, JSValue bfunc,
     JSFunctionBytecode *b;
     JSValue func_obj;
     JSAtom name_atom;
+    static const uint16_t func_kind_to_class_id[] = {
+        [JS_FUNC_NORMAL] = JS_CLASS_BYTECODE_FUNCTION,
+        [JS_FUNC_GENERATOR] = JS_CLASS_GENERATOR_FUNCTION,
+        [JS_FUNC_ASYNC] = JS_CLASS_ASYNC_FUNCTION,
+        [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,
+    };
 
     b = JS_VALUE_GET_PTR(bfunc);
     func_obj = JS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);
@@ -15858,7 +14509,7 @@ static JSValue js_closure(JSContext *ctx, JSValue bfunc,
            object is created on the fly when first accessed */
         JS_SetConstructorBit(ctx, func_obj, TRUE);
         JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,
-                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,
+                                  js_instantiate_prototype, NULL,
                                   JS_PROP_WRITABLE);
     }
     return func_obj;
@@ -15972,16 +14623,15 @@ static void close_var_refs(JSRuntime *rt, JSStackFrame *sf)
     int var_idx;
 
     list_for_each_safe(el, el1, &sf->var_ref_list) {
-        var_ref = list_entry(el, JSVarRef, header.link);
+        var_ref = list_entry(el, JSVarRef, link);
         var_idx = var_ref->var_idx;
         if (var_ref->is_arg)
             var_ref->value = JS_DupValueRT(rt, sf->arg_buf[var_idx]);
         else
             var_ref->value = JS_DupValueRT(rt, sf->var_buf[var_idx]);
         var_ref->pvalue = &var_ref->value;
-        /* the reference is no longer to a local variable */
-        var_ref->is_detached = TRUE;
-        add_gc_object(rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+        var_ref->link.prev = NULL; /* the reference is no longer to a
+                                      local variable */
     }
 }
 
@@ -15992,26 +14642,25 @@ static void close_lexical_var(JSContext *ctx, JSStackFrame *sf, int idx, int is_
     int var_idx = idx;
 
     list_for_each_safe(el, el1, &sf->var_ref_list) {
-        var_ref = list_entry(el, JSVarRef, header.link);
+        var_ref = list_entry(el, JSVarRef, link);
         if (var_idx == var_ref->var_idx && var_ref->is_arg == is_arg) {
             var_ref->value = JS_DupValue(ctx, sf->var_buf[var_idx]);
             var_ref->pvalue = &var_ref->value;
-            list_del(&var_ref->header.link);
-            /* the reference is no longer to a local variable */
-            var_ref->is_detached = TRUE;
-            add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+            list_del(&var_ref->link);
+            var_ref->link.prev = NULL; /* the reference is no longer to a
+                                          local variable */
         }
     }
 }
 
-#define JS_CALL_FLAG_COPY_ARGV   (1 << 1)
-#define JS_CALL_FLAG_GENERATOR   (1 << 2)
+#define CALL_FLAG_CONSTRUCTOR (1 << 0)
+#define CALL_FLAG_COPY_ARGV   (1 << 1)
+#define CALL_FLAG_GENERATOR   (1 << 2)
 
 static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
                                   JSValueConst this_obj,
                                   int argc, JSValueConst *argv, int flags)
 {
-    JSRuntime *rt = ctx->rt;
     JSCFunctionType func;
     JSObject *p;
     JSStackFrame sf_s, *sf = &sf_s, *prev_sf;
@@ -16025,25 +14674,23 @@ static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
     arg_count = p->u.cfunc.length;
 
     /* better to always check stack overflow */
-    if (js_check_stack_overflow(rt, sizeof(arg_buf[0]) * arg_count))
+    if (js_check_stack_overflow(ctx, sizeof(arg_buf[0]) * arg_count))
         return JS_ThrowStackOverflow(ctx);
 
-    prev_sf = rt->current_stack_frame;
+    prev_sf = ctx->current_stack_frame;
     sf->prev_frame = prev_sf;
-    rt->current_stack_frame = sf;
-    ctx = p->u.cfunc.realm; /* change the current realm */
-    
+    ctx->current_stack_frame = sf;
 #ifdef CONFIG_BIGNUM
     /* we only propagate the bignum mode as some runtime functions
        test it */
     if (prev_sf)
-        sf->js_mode = prev_sf->js_mode & JS_MODE_MATH;
+        sf->js_mode = prev_sf->js_mode & JS_MODE_BIGINT;
     else
         sf->js_mode = 0;
 #else
     sf->js_mode = 0;
 #endif
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     sf->arg_count = argc;
     arg_buf = argv;
 
@@ -16062,7 +14709,7 @@ static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
     switch(cproto) {
     case JS_CFUNC_constructor:
     case JS_CFUNC_constructor_or_func:
-        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {
+        if (!(flags & CALL_FLAG_CONSTRUCTOR)) {
             if (cproto == JS_CFUNC_constructor) {
             not_a_constructor:
                 ret_val = JS_ThrowTypeError(ctx, "must be called with new");
@@ -16078,7 +14725,7 @@ static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
         break;
     case JS_CFUNC_constructor_magic:
     case JS_CFUNC_constructor_or_func_magic:
-        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {
+        if (!(flags & CALL_FLAG_CONSTRUCTOR)) {
             if (cproto == JS_CFUNC_constructor_magic) {
                 goto not_a_constructor;
             } else {
@@ -16142,7 +14789,7 @@ static JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,
         abort();
     }
 
-    rt->current_stack_frame = sf->prev_frame;
+    ctx->current_stack_frame = sf->prev_frame;
     return ret_val;
 }
 
@@ -16158,7 +14805,7 @@ static JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,
     p = JS_VALUE_GET_OBJ(func_obj);
     bf = p->u.bound_function;
     arg_count = bf->argc + argc;
-    if (js_check_stack_overflow(ctx->rt, sizeof(JSValue) * arg_count))
+    if (js_check_stack_overflow(ctx, sizeof(JSValue) * arg_count))
         return JS_ThrowStackOverflow(ctx);
     arg_buf = alloca(sizeof(JSValue) * arg_count);
     for(i = 0; i < bf->argc; i++) {
@@ -16167,7 +14814,7 @@ static JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,
     for(i = 0; i < argc; i++) {
         arg_buf[bf->argc + i] = argv[i];
     }
-    if (flags & JS_CALL_FLAG_CONSTRUCTOR) {
+    if (flags & CALL_FLAG_CONSTRUCTOR) {
         new_target = this_obj;
         if (js_same_value(ctx, func_obj, new_target))
             new_target = bf->func_obj;
@@ -16179,6 +14826,30 @@ static JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,
     }
 }
 
+static no_inline __exception int __js_poll_interrupts(JSContext *ctx)
+{
+    JSRuntime *rt = ctx->rt;
+    ctx->interrupt_counter = JS_INTERRUPT_COUNTER_INIT;
+    if (rt->interrupt_handler) {
+        if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {
+            /* XXX: should set a specific flag to avoid catching */
+            JS_ThrowInternalError(ctx, "interrupted");
+            JS_SetUncatchableError(ctx, ctx->current_exception, TRUE);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static inline __exception int js_poll_interrupts(JSContext *ctx)
+{
+    if (unlikely(--ctx->interrupt_counter <= 0)) {
+        return __js_poll_interrupts(ctx);
+    } else {
+        return 0;
+    }
+}
+
 /* argument of OP_special_object */
 typedef enum {
     OP_SPECIAL_OBJECT_ARGUMENTS,
@@ -16194,13 +14865,11 @@ typedef enum {
 #define FUNC_RET_YIELD      1
 #define FUNC_RET_YIELD_STAR 2
 
-/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */
-static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
+/* argv[] is modified if (flags & CALL_FLAG_COPY_ARGV) = 0. */
+static JSValue JS_CallInternal(JSContext *ctx, JSValueConst func_obj,
                                JSValueConst this_obj, JSValueConst new_target,
                                int argc, JSValue *argv, int flags)
 {
-    JSRuntime *rt = caller_ctx->rt;
-    JSContext *ctx;
     JSObject *p;
     JSFunctionBytecode *b;
     JSStackFrame sf_s, *sf = &sf_s;
@@ -16232,17 +14901,16 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 #define BREAK           SWITCH(pc)
 #endif
 
-    if (js_poll_interrupts(caller_ctx))
+    if (js_poll_interrupts(ctx))
         return JS_EXCEPTION;
     if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)) {
-        if (flags & JS_CALL_FLAG_GENERATOR) {
+        if (flags & CALL_FLAG_GENERATOR) {
             JSAsyncFunctionState *s = JS_VALUE_GET_PTR(func_obj);
             /* func_obj get contains a pointer to JSFuncAsyncState */
             /* the stack frame is already allocated */
             sf = &s->frame;
             p = JS_VALUE_GET_OBJ(sf->cur_func);
             b = p->u.func.function_bytecode;
-            ctx = b->realm;
             var_refs = p->u.func.var_refs;
             local_buf = arg_buf = sf->arg_buf;
             var_buf = sf->var_buf;
@@ -16250,8 +14918,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             sp = sf->cur_sp;
             sf->cur_sp = NULL; /* cur_sp is NULL if the function is running */
             pc = sf->cur_pc;
-            sf->prev_frame = rt->current_stack_frame;
-            rt->current_stack_frame = sf;
+            sf->prev_frame = ctx->current_stack_frame;
+            ctx->current_stack_frame = sf;
             if (s->throw_flag)
                 goto exception;
             else
@@ -16262,18 +14930,29 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
     }
     p = JS_VALUE_GET_OBJ(func_obj);
     if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
-        JSClassCall *call_func;
-        call_func = rt->class_array[p->class_id].call;
-        if (!call_func) {
-        not_a_function:
-            return JS_ThrowTypeError(caller_ctx, "not a function");
+        switch(p->class_id) {
+        case JS_CLASS_C_FUNCTION:
+            return js_call_c_function(ctx, func_obj, this_obj, argc,
+                                      (JSValueConst *)argv, flags);
+        case JS_CLASS_BOUND_FUNCTION:
+            return js_call_bound_function(ctx, func_obj, this_obj, argc,
+                                          (JSValueConst *)argv, flags);
+        default:
+            {
+                JSClassCall *call_func;
+                call_func = ctx->rt->class_array[p->class_id].call;
+                if (!call_func) {
+                not_a_function:
+                    return JS_ThrowTypeError(ctx, "not a function");
+                }
+                return call_func(ctx, func_obj, this_obj, argc,
+                                 (JSValueConst *)argv);
+            }
         }
-        return call_func(caller_ctx, func_obj, this_obj, argc,
-                         (JSValueConst *)argv, flags);
     }
     b = p->u.func.function_bytecode;
 
-    if (unlikely(argc < b->arg_count || (flags & JS_CALL_FLAG_COPY_ARGV))) {
+    if (unlikely(argc < b->arg_count || (flags & CALL_FLAG_COPY_ARGV))) {
         arg_allocated_size = b->arg_count;
     } else {
         arg_allocated_size = 0;
@@ -16281,13 +14960,13 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 
     alloca_size = sizeof(JSValue) * (arg_allocated_size + b->var_count +
                                      b->stack_size);
-    if (js_check_stack_overflow(rt, alloca_size))
-        return JS_ThrowStackOverflow(caller_ctx);
+    if (js_check_stack_overflow(ctx, alloca_size))
+        return JS_ThrowStackOverflow(ctx);
 
     sf->js_mode = b->js_mode;
     arg_buf = argv;
     sf->arg_count = argc;
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     init_list_head(&sf->var_ref_list);
     var_refs = p->u.func.var_refs;
 
@@ -16296,7 +14975,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
         int n = min_int(argc, b->arg_count);
         arg_buf = local_buf;
         for(i = 0; i < n; i++)
-            arg_buf[i] = JS_DupValue(caller_ctx, argv[i]);
+            arg_buf[i] = JS_DupValue(ctx, argv[i]);
         for(; i < b->arg_count; i++)
             arg_buf[i] = JS_UNDEFINED;
         sf->arg_count = b->arg_count;
@@ -16311,10 +14990,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
     stack_buf = var_buf + b->var_count;
     sp = stack_buf;
     pc = b->byte_code_buf;
-    sf->prev_frame = rt->current_stack_frame;
-    rt->current_stack_frame = sf;
-    ctx = b->realm; /* set the current realm */
-    
+    sf->prev_frame = ctx->current_stack_frame;
+    ctx->current_stack_frame = sf;
  restart:
     for(;;) {
         int call_argc;
@@ -16738,7 +15415,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             /* return TRUE if 'this' should be returned */
             if (!JS_IsObject(sp[-1])) {
                 if (!JS_IsUndefined(sp[-1])) {
-                    JS_ThrowTypeError(caller_ctx, "derived class constructor must return an object or undefined");
+                    JS_ThrowTypeError(ctx, "derived class constructor must return an object or undefined");
                     goto exception;
                 }
                 sp[0] = JS_TRUE;
@@ -16769,12 +15446,11 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             JS_Throw(ctx, *--sp);
             goto exception;
 
-        CASE(OP_throw_error):
+        CASE(OP_throw_var):
 #define JS_THROW_VAR_RO             0
 #define JS_THROW_VAR_REDECL         1
 #define JS_THROW_VAR_UNINITIALIZED  2
-#define JS_THROW_ERROR_DELETE_SUPER   3
-#define JS_THROW_ERROR_ITERATOR_THROW 4
+#define JS_THROW_VAR_DELETE_SUPER   3
             {
                 JSAtom atom;
                 int type;
@@ -16790,11 +15466,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 if (type == JS_THROW_VAR_UNINITIALIZED)
                     JS_ThrowReferenceErrorUninitialized(ctx, atom);
                 else
-                if (type == JS_THROW_ERROR_DELETE_SUPER)
+                if (type == JS_THROW_VAR_DELETE_SUPER)
                     JS_ThrowReferenceError(ctx, "unsupported reference to 'super'");
-                else
-                if (type == JS_THROW_ERROR_ITERATOR_THROW)
-                    JS_ThrowTypeError(ctx, "iterator does not have a throw method");
                 else
                     JS_ThrowInternalError(ctx, "invalid throw var type %d", type);
             }
@@ -16870,10 +15543,26 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             }
             BREAK;
 
+        CASE(OP_get_super_ctor):
+            {
+                JSValue proto;
+                proto = JS_DupValue(ctx, JS_GetPrototype(ctx, sp[-1]));
+                if (JS_IsException(proto))
+                    goto exception;
+                if (!JS_IsConstructor(ctx, proto)) {
+                    JS_FreeValue(ctx, proto);
+                    JS_ThrowTypeError(ctx, "not a constructor");
+                    goto exception;
+                }
+                JS_FreeValue(ctx, sp[-1]);
+                sp[-1] = proto;
+            }
+            BREAK;
+
         CASE(OP_get_super):
             {
                 JSValue proto;
-                proto = JS_GetPrototype(ctx, sp[-1]);
+                proto = JS_DupValue(ctx, JS_GetPrototype(ctx, sp[-1]));
                 if (JS_IsException(proto))
                     goto exception;
                 JS_FreeValue(ctx, sp[-1]);
@@ -17123,7 +15812,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 pc += 2;
                 val = *var_refs[idx]->pvalue;
                 if (unlikely(JS_IsUninitialized(val))) {
-                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);
+                    JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
                     goto exception;
                 }
                 sp[0] = JS_DupValue(ctx, val);
@@ -17136,7 +15825,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 idx = get_u16(pc);
                 pc += 2;
                 if (unlikely(JS_IsUninitialized(*var_refs[idx]->pvalue))) {
-                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);
+                    JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
                     goto exception;
                 }
                 set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
@@ -17149,7 +15838,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 idx = get_u16(pc);
                 pc += 2;
                 if (unlikely(!JS_IsUninitialized(*var_refs[idx]->pvalue))) {
-                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, TRUE);
+                    JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
                     goto exception;
                 }
                 set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
@@ -17170,7 +15859,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 idx = get_u16(pc);
                 pc += 2;
                 if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
-                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);
+                    JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
                     goto exception;
                 }
                 sp[0] = JS_DupValue(ctx, var_buf[idx]);
@@ -17183,7 +15872,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 idx = get_u16(pc);
                 pc += 2;
                 if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
-                    JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);
+                    JS_ThrowReferenceErrorUninitialized(ctx, JS_ATOM_NULL);
                     goto exception;
                 }
                 set_value(ctx, &var_buf[idx], sp[-1]);
@@ -17237,7 +15926,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 pr = add_property(ctx, JS_VALUE_GET_OBJ(sp[-1]), atom,
                                   JS_PROP_WRITABLE | JS_PROP_VARREF);
                 if (!pr) {
-                    free_var_ref(rt, var_ref);
+                    free_var_ref(ctx->rt, var_ref);
                     goto exception;
                 }
                 pr->u.var_ref = var_ref;
@@ -17422,20 +16111,18 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             sp += 1;
             *sp++ = JS_NewCatchOffset(ctx, 0);
             BREAK;
-        CASE(OP_iterator_get_value_done):
-            if (js_iterator_get_value_done(ctx, sp))
+        CASE(OP_for_await_of_next):
+            if (js_for_await_of_next(ctx, sp))
                 goto exception;
             sp += 1;
             BREAK;
-        CASE(OP_iterator_check_object):
-            if (unlikely(!JS_IsObject(sp[-1]))) {
-                JS_ThrowTypeError(ctx, "iterator must return an object");
+        CASE(OP_iterator_get_value_done):
+            if (js_iterator_get_value_done(ctx, sp))
                 goto exception;
-            }
+            sp += 1;
             BREAK;
 
         CASE(OP_iterator_close):
-            /* iter_obj next catch_offset -> */
             sp--; /* drop the catch offset to avoid getting caught by exception */
             JS_FreeValue(ctx, sp[-1]); /* drop the next method */
             sp--;
@@ -17469,7 +16156,33 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             }
             BREAK;
 
-        CASE(OP_iterator_next):
+        CASE(OP_async_iterator_close):
+            /* iter_obj next catch_offset -> value flag */
+            {
+                JSValue ret, method;
+                int ret_flag;
+                method = JS_GetProperty(ctx, sp[-3], JS_ATOM_return);
+                if (JS_IsException(method))
+                    goto exception;
+                if (JS_IsUndefined(method) || JS_IsNull(method)) {
+                    ret = JS_UNDEFINED;
+                    ret_flag = TRUE;
+                } else {
+                    ret = JS_CallFree(ctx, method, sp[-3], 0, NULL);
+                    if (JS_IsException(ret))
+                        goto exception;
+                    ret_flag = FALSE;
+                }
+                JS_FreeValue(ctx, sp[-3]);
+                JS_FreeValue(ctx, sp[-2]);
+                JS_FreeValue(ctx, sp[-1]);
+                sp[-3] = ret;
+                sp[-2] = JS_NewBool(ctx, ret_flag);
+                sp -= 1;
+            }
+            BREAK;
+
+        CASE(OP_async_iterator_next):
             /* stack: iter_obj next catch_offset val */
             {
                 JSValue ret;
@@ -17482,28 +16195,25 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             }
             BREAK;
 
-        CASE(OP_iterator_call):
+        CASE(OP_async_iterator_get):
             /* stack: iter_obj next catch_offset val */
             {
                 JSValue method, ret;
                 BOOL ret_flag;
                 int flags;
                 flags = *pc++;
-                method = JS_GetProperty(ctx, sp[-4], (flags & 1) ?
-                                        JS_ATOM_throw : JS_ATOM_return);
+                if (flags == 2) {
+                    JS_ThrowTypeError(ctx, "iterator does not have a throw method");
+                    goto exception;
+                }
+                method = JS_GetProperty(ctx, sp[-4], flags ? JS_ATOM_throw : JS_ATOM_return);
                 if (JS_IsException(method))
                     goto exception;
                 if (JS_IsUndefined(method) || JS_IsNull(method)) {
                     ret_flag = TRUE;
                 } else {
-                    if (flags & 2) {
-                        /* no argument */
-                        ret = JS_CallFree(ctx, method, sp[-4],
-                                          0, NULL);
-                    } else {
-                        ret = JS_CallFree(ctx, method, sp[-4],
-                                          1, (JSValueConst *)(sp - 1));
-                    }
+                    ret = JS_CallFree(ctx, method, sp[-4],
+                                      1, (JSValueConst *)(sp - 1));
                     if (JS_IsException(ret))
                         goto exception;
                     JS_FreeValue(ctx, sp[-1]);
@@ -17829,8 +16539,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 
         CASE(OP_put_ref_value):
             {
-                int ret, flags;
-                flags = JS_PROP_THROW_STRICT;
+                int ret;
                 if (unlikely(JS_IsUndefined(sp[-3]))) {
                     if (is_strict_mode(ctx)) {
                         JSAtom atom = JS_ValueToAtom(ctx, sp[-2]);
@@ -17842,11 +16551,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                     } else {
                         sp[-3] = JS_DupValue(ctx, ctx->global_obj);
                     }
-                } else {
-                    if (is_strict_mode(ctx))
-                        flags |= JS_PROP_NO_ADD;
                 }
-                ret = JS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1], flags);
+                ret = JS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1], JS_PROP_THROW_STRICT);
                 JS_FreeValue(ctx, sp[-3]);
                 sp -= 3;
                 if (unlikely(ret < 0))
@@ -17865,7 +16571,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 atom = JS_ValueToAtom(ctx, sp[-2]);
                 if (unlikely(atom == JS_ATOM_NULL))
                     goto exception;
-                ret = JS_SetPropertyGeneric(ctx, sp[-3], atom, sp[-1], sp[-4],
+                ret = JS_SetPropertyGeneric(ctx, JS_VALUE_GET_OBJ(sp[-3]),
+                                            atom, sp[-1], sp[-4],
                                             JS_PROP_THROW_STRICT);
                 JS_FreeAtom(ctx, atom);
                 JS_FreeValue(ctx, sp[-4]);
@@ -17938,42 +16645,47 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             BREAK;
         CASE(OP_add_loc):
             {
-                JSValue *pv;
+                JSValue ops[2];
                 int idx;
                 idx = *pc;
                 pc += 1;
 
-                pv = &var_buf[idx];
-                if (likely(JS_VALUE_IS_BOTH_INT(*pv, sp[-1]))) {
+                ops[0] = var_buf[idx];
+                ops[1] = sp[-1];
+                if (likely(JS_VALUE_IS_BOTH_INT(ops[0], ops[1]))) {
                     int64_t r;
-                    r = (int64_t)JS_VALUE_GET_INT(*pv) +
-                        JS_VALUE_GET_INT(sp[-1]);
+                    r = (int64_t)JS_VALUE_GET_INT(ops[0]) + JS_VALUE_GET_INT(ops[1]);
                     if (unlikely((int)r != r))
                         goto add_loc_slow;
-                    *pv = JS_NewInt32(ctx, r);
+                    var_buf[idx] = JS_NewInt32(ctx, r);
                     sp--;
-                } else if (JS_VALUE_GET_TAG(*pv) == JS_TAG_STRING) {
-                    JSValue op1;
-                    op1 = sp[-1];
+                } else if (JS_VALUE_GET_TAG(ops[0]) == JS_TAG_STRING) {
                     sp--;
-                    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
-                    if (JS_IsException(op1))
+                    ops[1] = JS_ToPrimitiveFree(ctx, ops[1], HINT_NONE);
+                    if (JS_IsException(ops[1])) {
                         goto exception;
-                    op1 = JS_ConcatString(ctx, JS_DupValue(ctx, *pv), op1);
-                    if (JS_IsException(op1))
+                    }
+                    /* XXX: should not modify the variable in case of
+                       exception */
+                    ops[0] = JS_ConcatString(ctx, ops[0], ops[1]);
+                    if (JS_IsException(ops[0])) {
+                        var_buf[idx] = JS_UNDEFINED;
                         goto exception;
-                    set_value(ctx, pv, op1);
+                    }
+                    var_buf[idx] = ops[0];
                 } else {
-                    JSValue ops[2];
                 add_loc_slow:
-                    /* In case of exception, js_add_slow frees ops[0]
-                       and ops[1], so we must duplicate *pv */
-                    ops[0] = JS_DupValue(ctx, *pv);
-                    ops[1] = sp[-1];
+                    /* XXX: should not modify the variable in case of
+                       exception */
                     sp--;
-                    if (js_add_slow(ctx, ops + 2))
+                    /* In case of exception, js_add_slow frees ops[0]
+                       and ops[1]. */
+                    /* XXX: change API */
+                    if (js_add_slow(ctx, ops + 2)) {
+                        var_buf[idx] = JS_UNDEFINED;
                         goto exception;
-                    set_value(ctx, pv, ops[0]);
+                    }
+                    var_buf[idx] = ops[0];
                 }
             }
             BREAK;
@@ -18010,12 +16722,11 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                     v1 = JS_VALUE_GET_INT(op1);
                     v2 = JS_VALUE_GET_INT(op2);
                     r = (int64_t)v1 * v2;
-                    if (unlikely((int)r != r)) {
 #ifdef CONFIG_BIGNUM
-                        if (unlikely(sf->js_mode & JS_MODE_MATH) &&
-                            (r < -MAX_SAFE_INTEGER || r > MAX_SAFE_INTEGER))
-                            goto binary_arith_slow;
-#endif
+                    if (unlikely((int)r != r) || (r == 0 && !is_bignum_mode(ctx)))
+                        goto binary_arith_slow;
+#else
+                    if (unlikely((int)r != r)) {
                         d = (double)r;
                         goto mul_fp_res;
                     }
@@ -18024,15 +16735,14 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                         d = -0.0;
                         goto mul_fp_res;
                     }
+#endif
                     sp[-2] = JS_NewInt32(ctx, r);
                     sp--;
                 } else if (JS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
-#ifdef CONFIG_BIGNUM
-                    if (unlikely(sf->js_mode & JS_MODE_MATH))
-                        goto binary_arith_slow;
-#endif
                     d = JS_VALUE_GET_FLOAT64(op1) * JS_VALUE_GET_FLOAT64(op2);
+#ifndef CONFIG_BIGNUM
                 mul_fp_res:
+#endif
                     sp[-2] = __JS_NewFloat64(ctx, d);
                     sp--;
                 } else {
@@ -18040,6 +16750,11 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 }
             }
             BREAK;
+#ifdef CONFIG_BIGNUM
+        CASE(OP_math_div):
+        CASE(OP_div):
+            goto binary_arith_slow;
+#else
         CASE(OP_div):
             {
                 JSValue op1, op2;
@@ -18047,8 +16762,6 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 op2 = sp[-1];
                 if (likely(JS_VALUE_IS_BOTH_INT(op1, op2))) {
                     int v1, v2;
-                    if (unlikely(sf->js_mode & JS_MODE_MATH))
-                        goto binary_arith_slow;
                     v1 = JS_VALUE_GET_INT(op1);
                     v2 = JS_VALUE_GET_INT(op2);
                     sp[-2] = JS_NewFloat64(ctx, (double)v1 / (double)v2);
@@ -18058,6 +16771,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 }
             }
             BREAK;
+#endif
         CASE(OP_mod):
 #ifdef CONFIG_BIGNUM
         CASE(OP_math_mod):
@@ -18083,6 +16797,9 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             }
             BREAK;
         CASE(OP_pow):
+#ifdef CONFIG_BIGNUM
+        CASE(OP_math_pow):
+#endif
         binary_arith_slow:
             if (js_binary_arith_slow(ctx, sp, opcode))
                 goto exception;
@@ -18112,6 +16829,11 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                 tag = JS_VALUE_GET_TAG(op1);
                 if (tag == JS_TAG_INT) {
                     val = JS_VALUE_GET_INT(op1);
+#ifdef CONFIG_BIGNUM
+                    if (unlikely(val == INT32_MIN) ||
+                        (val == 0 && !is_bignum_mode(ctx)))
+                        goto slow_neg;
+#else
                     /* Note: -0 cannot be expressed as integer */
                     if (unlikely(val == 0)) {
                         d = -0.0;
@@ -18121,12 +16843,18 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                         d = -(double)val;
                         goto neg_fp_res;
                     }
+#endif
                     sp[-1] = JS_NewInt32(ctx, -val);
                 } else if (JS_TAG_IS_FLOAT64(tag)) {
                     d = -JS_VALUE_GET_FLOAT64(op1);
+#ifndef CONFIG_BIGNUM
                 neg_fp_res:
+#endif
                     sp[-1] = __JS_NewFloat64(ctx, d);
                 } else {
+#ifdef CONFIG_BIGNUM
+                slow_neg:
+#endif
                     if (js_unary_arith_slow(ctx, sp, opcode))
                         goto exception;
                 }
@@ -18188,12 +16916,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                     var_buf[idx] = JS_NewInt32(ctx, val + 1);
                 } else {
                 inc_loc_slow:
-                    /* must duplicate otherwise the variable value may
-                       be destroyed before JS code accesses it */
-                    op1 = JS_DupValue(ctx, op1);
-                    if (js_unary_arith_slow(ctx, &op1 + 1, OP_inc))
+                    if (js_unary_arith_slow(ctx, var_buf + idx + 1, OP_inc))
                         goto exception;
-                    set_value(ctx, &var_buf[idx], op1);
                 }
             }
             BREAK;
@@ -18213,12 +16937,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                     var_buf[idx] = JS_NewInt32(ctx, val - 1);
                 } else {
                 dec_loc_slow:
-                    /* must duplicate otherwise the variable value may
-                       be destroyed before JS code accesses it */
-                    op1 = JS_DupValue(ctx, op1);
-                    if (js_unary_arith_slow(ctx, &op1 + 1, OP_dec))
+                    if (js_unary_arith_slow(ctx, var_buf + idx + 1, OP_dec))
                         goto exception;
-                    set_value(ctx, &var_buf[idx], op1);
                 }
             }
             BREAK;
@@ -18247,7 +16967,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 #ifdef CONFIG_BIGNUM
                     {
                         int64_t r;
-                        if (unlikely(sf->js_mode & JS_MODE_MATH)) {
+                        if (is_bignum_mode(ctx)) {
                             if (v2 > 0x1f)
                                 goto shl_slow;
                             r = (int64_t)v1 << v2;
@@ -18303,7 +17023,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                     v2 = JS_VALUE_GET_INT(op2);
 #ifdef CONFIG_BIGNUM
                     if (unlikely(v2 > 0x1f)) {
-                        if (unlikely(sf->js_mode & JS_MODE_MATH))
+                        if (is_bignum_mode(ctx))
                             goto sar_slow;
                         else
                             v2 &= 0x1f;
@@ -18405,7 +17125,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 
 #ifdef CONFIG_BIGNUM
         CASE(OP_mul_pow10):
-            if (rt->bigfloat_ops.mul_pow10(ctx, sp))
+            if (js_mul_pow10(ctx, sp))
                 goto exception;
             sp--;
             BREAK;
@@ -18544,7 +17264,6 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                         set_value(ctx, &sp[-1], val);
                         break;
                     case OP_with_put_var:
-                        /* XXX: check if strict mode */
                         ret = JS_SetPropertyInternal(ctx, obj, atom, sp[-2],
                                                      JS_PROP_THROW_STRICT);
                         JS_FreeValue(ctx, sp[-1]);
@@ -18607,13 +17326,6 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 
         CASE(OP_nop):
             BREAK;
-        CASE(OP_is_undefined_or_null):
-            if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED ||
-                JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_NULL) {
-                goto set_true;
-            } else {
-                goto free_and_set_false;
-            }
 #if SHORT_OPCODES
         CASE(OP_is_undefined):
             if (JS_VALUE_GET_TAG(sp[-1]) == JS_TAG_UNDEFINED) {
@@ -18627,15 +17339,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             } else {
                 goto free_and_set_false;
             }
-            /* XXX: could merge to a single opcode */
-        CASE(OP_typeof_is_undefined):
-            /* different from OP_is_undefined because of isHTMLDDA */
-            if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_undefined) {
-                goto free_and_set_true;
-            } else {
-                goto free_and_set_false;
-            }
-        CASE(OP_typeof_is_function):
+        CASE(OP_is_function):
             if (js_operator_typeof(ctx, sp[-1]) == JS_ATOM_function) {
                 goto free_and_set_true;
             } else {
@@ -18643,7 +17347,6 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             }
         free_and_set_true:
             JS_FreeValue(ctx, sp[-1]);
-#endif
         set_true:
             sp[-1] = JS_TRUE;
             BREAK;
@@ -18651,6 +17354,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
             JS_FreeValue(ctx, sp[-1]);
             sp[-1] = JS_FALSE;
             BREAK;
+#endif
         CASE(OP_invalid):
         DEFAULT:
             JS_ThrowInternalError(ctx, "invalid opcode: pc=%u opcode=0x%02x",
@@ -18659,14 +17363,13 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
         }
     }
  exception:
-    if (is_backtrace_needed(ctx, rt->current_exception)) {
+    if (ctx->exception_needs_backtrace) {
         /* add the backtrace information now (it is not done
            before if the exception happens in a bytecode
            operation */
-        sf->cur_pc = pc;
-        build_backtrace(ctx, rt->current_exception, NULL, 0, 0);
+        build_backtrace(ctx, ctx->current_exception, NULL, 0, pc);
     }
-    if (!JS_IsUncatchableError(ctx, rt->current_exception)) {
+    if (!JS_IsUncatchableError(ctx, ctx->current_exception)) {
         while (sp > stack_buf) {
             JSValue val = *--sp;
             JS_FreeValue(ctx, val);
@@ -18678,8 +17381,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
                     sp--;
                     JS_IteratorClose(ctx, sp[-1], TRUE);
                 } else {
-                    *sp++ = rt->current_exception;
-                    rt->current_exception = JS_NULL;
+                    *sp++ = ctx->current_exception;
+                    ctx->current_exception = JS_NULL;
                     pc = b->byte_code_buf + pos;
                     goto restart;
                 }
@@ -18698,14 +17401,14 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
     done:
         if (unlikely(!list_empty(&sf->var_ref_list))) {
             /* variable references reference the stack: must close them */
-            close_var_refs(rt, sf);
+            close_var_refs(ctx->rt, sf);
         }
         /* free the local variables and stack */
         for(pval = local_buf; pval < sp; pval++) {
             JS_FreeValue(ctx, *pval);
         }
     }
-    rt->current_stack_frame = sf->prev_frame;
+    ctx->current_stack_frame = sf->prev_frame;
     return ret_val;
 }
 
@@ -18713,74 +17416,36 @@ JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
                 int argc, JSValueConst *argv)
 {
     return JS_CallInternal(ctx, func_obj, this_obj, JS_UNDEFINED,
-                           argc, (JSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
+                           argc, (JSValue *)argv, CALL_FLAG_COPY_ARGV);
 }
 
 static JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_obj,
                            int argc, JSValueConst *argv)
 {
     JSValue res = JS_CallInternal(ctx, func_obj, this_obj, JS_UNDEFINED,
-                                  argc, (JSValue *)argv, JS_CALL_FLAG_COPY_ARGV);
+                                  argc, (JSValue *)argv, CALL_FLAG_COPY_ARGV);
     JS_FreeValue(ctx, func_obj);
     return res;
 }
 
-/* warning: the refcount of the context is not incremented. Return
-   NULL in case of exception (case of revoked proxy only) */
-static JSContext *JS_GetFunctionRealm(JSContext *ctx, JSValueConst func_obj)
+static JSValue js_get_prototype_from_ctor(JSContext *ctx, JSValueConst ctor,
+                                          JSValueConst def_proto)
 {
-    JSObject *p;
-    JSContext *realm;
-    
-    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
-        return ctx;
-    p = JS_VALUE_GET_OBJ(func_obj);
-    switch(p->class_id) {
-    case JS_CLASS_C_FUNCTION:
-        realm = p->u.cfunc.realm;
-        break;
-    case JS_CLASS_BYTECODE_FUNCTION:
-    case JS_CLASS_GENERATOR_FUNCTION:
-    case JS_CLASS_ASYNC_FUNCTION:
-    case JS_CLASS_ASYNC_GENERATOR_FUNCTION:
-        {
-            JSFunctionBytecode *b;
-            b = p->u.func.function_bytecode;
-            realm = b->realm;
-        }
-        break;
-    case JS_CLASS_PROXY:
-        {
-            JSProxyData *s = p->u.opaque;
-            if (!s)
-                return ctx;
-            if (s->is_revoked) {
-                JS_ThrowTypeErrorRevokedProxy(ctx);
-                return NULL;
-            } else {
-                realm = JS_GetFunctionRealm(ctx, s->target);
-            }
-        }
-        break;
-    case JS_CLASS_BOUND_FUNCTION:
-        {
-            JSBoundFunction *bf = p->u.bound_function;
-            realm = JS_GetFunctionRealm(ctx, bf->func_obj);
-        }
-        break;
-    default:
-        realm = ctx;
-        break;
+    JSValue proto;
+    proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype);
+    if (JS_IsException(proto))
+        return proto;
+    if (!JS_IsObject(proto)) {
+        JS_FreeValue(ctx, proto);
+        proto = JS_DupValue(ctx, def_proto);
     }
-    return realm;
+    return proto;
 }
 
 static JSValue js_create_from_ctor(JSContext *ctx, JSValueConst ctor,
                                    int class_id)
 {
     JSValue proto, obj;
-    JSContext *realm;
-    
     if (JS_IsUndefined(ctor)) {
         proto = JS_DupValue(ctx, ctx->class_proto[class_id]);
     } else {
@@ -18789,10 +17454,14 @@ static JSValue js_create_from_ctor(JSContext *ctx, JSValueConst ctor,
             return proto;
         if (!JS_IsObject(proto)) {
             JS_FreeValue(ctx, proto);
-            realm = JS_GetFunctionRealm(ctx, ctor);
-            if (!realm)
-                return JS_EXCEPTION;
-            proto = JS_DupValue(ctx, realm->class_proto[class_id]);
+            /* check if revoked proxy */
+            {
+                JSProxyData *s = JS_GetOpaque(ctor, JS_CLASS_PROXY);
+                if (s && s->is_revoked)
+                    return JS_ThrowTypeErrorRevokedProxy(ctx);
+            }
+            /* XXX: should use the ctor realm instead of 'ctx' */
+            proto = JS_DupValue(ctx, ctx->class_proto[class_id]);
         }
     }
     obj = JS_NewObjectProtoClass(ctx, proto, class_id);
@@ -18800,7 +17469,7 @@ static JSValue js_create_from_ctor(JSContext *ctx, JSValueConst ctor,
     return obj;
 }
 
-/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */
+/* argv[] is modified if (flags & CALL_FLAG_COPY_ARGV) = 0. */
 static JSValue JS_CallConstructorInternal(JSContext *ctx,
                                           JSValueConst func_obj,
                                           JSValueConst new_target,
@@ -18811,21 +17480,27 @@ static JSValue JS_CallConstructorInternal(JSContext *ctx,
 
     if (js_poll_interrupts(ctx))
         return JS_EXCEPTION;
-    flags |= JS_CALL_FLAG_CONSTRUCTOR;
+    flags |= CALL_FLAG_CONSTRUCTOR;
     if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT))
         goto not_a_function;
     p = JS_VALUE_GET_OBJ(func_obj);
     if (unlikely(!p->is_constructor))
         return JS_ThrowTypeError(ctx, "not a constructor");
     if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
-        JSClassCall *call_func;
-        call_func = ctx->rt->class_array[p->class_id].call;
-        if (!call_func) {
+        switch(p->class_id) {
+        case JS_CLASS_C_FUNCTION:
+            return js_call_c_function(ctx, func_obj, new_target,
+                                      argc, (JSValueConst *)argv, flags);
+        case JS_CLASS_BOUND_FUNCTION:
+            return js_call_bound_function(ctx, func_obj, new_target, argc,
+                                          (JSValueConst *)argv, flags);
+        case JS_CLASS_PROXY:
+            return js_proxy_call_constructor(ctx, func_obj, new_target, argc,
+                                             (JSValueConst *)argv);
+        default:
         not_a_function:
             return JS_ThrowTypeError(ctx, "not a function");
         }
-        return call_func(ctx, func_obj, new_target, argc,
-                         (JSValueConst *)argv, flags);
     }
 
     b = p->u.func.function_bytecode;
@@ -18855,7 +17530,7 @@ JSValue JS_CallConstructor2(JSContext *ctx, JSValueConst func_obj,
 {
     return JS_CallConstructorInternal(ctx, func_obj, new_target,
                                       argc, (JSValue *)argv,
-                                      JS_CALL_FLAG_COPY_ARGV);
+                                      CALL_FLAG_COPY_ARGV);
 }
 
 JSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,
@@ -18863,7 +17538,7 @@ JSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,
 {
     return JS_CallConstructorInternal(ctx, func_obj, func_obj,
                                       argc, (JSValue *)argv,
-                                      JS_CALL_FLAG_COPY_ARGV);
+                                      CALL_FLAG_COPY_ARGV);
 }
 
 JSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,
@@ -18964,13 +17639,10 @@ static JSValue async_func_resume(JSContext *ctx, JSAsyncFunctionState *s)
 {
     JSValue func_obj;
 
-    if (js_check_stack_overflow(ctx->rt, 0))
-        return JS_ThrowStackOverflow(ctx);
-
     /* the tag does not matter provided it is not an object */
     func_obj = JS_MKPTR(JS_TAG_INT, s);
     return JS_CallInternal(ctx, func_obj, s->this_val, JS_UNDEFINED,
-                           s->argc, s->frame.arg_buf, JS_CALL_FLAG_GENERATOR);
+                           s->argc, s->frame.arg_buf, CALL_FLAG_GENERATOR);
 }
 
 
@@ -19035,11 +17707,13 @@ static JSValue js_generator_next(JSContext *ctx, JSValueConst this_val,
     JSGeneratorData *s = JS_GetOpaque(this_val, JS_CLASS_GENERATOR);
     JSStackFrame *sf;
     JSValue ret, func_ret;
+    JSValueConst iter_args[1];
 
     *pdone = TRUE;
     if (!s)
         return JS_ThrowTypeError(ctx, "not a generator");
     sf = &s->func_state.frame;
+ redo:
     switch(s->state) {
     default:
     case JS_GENERATOR_STATE_SUSPENDED_START:
@@ -19051,16 +17725,85 @@ static JSValue js_generator_next(JSContext *ctx, JSValueConst this_val,
         }
         break;
     case JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR:
+        {
+            int done;
+            JSValue method, iter_obj;
+
+            iter_obj = sf->cur_sp[-2];
+            if (magic == GEN_MAGIC_NEXT) {
+                method = JS_DupValue(ctx, sf->cur_sp[-1]);
+            } else {
+                method = JS_GetProperty(ctx, iter_obj,
+                                        magic == GEN_MAGIC_RETURN ?
+                                        JS_ATOM_return : JS_ATOM_throw);
+                if (JS_IsException(method))
+                    goto iter_exception;
+            }
+            if (magic != GEN_MAGIC_NEXT &&
+                (JS_IsUndefined(method) || JS_IsNull(method))) {
+                /* default action */
+                if (magic == GEN_MAGIC_RETURN) {
+                    ret = JS_DupValue(ctx, argv[0]);
+                    goto iter_done;
+                } else {
+                    if (JS_IteratorClose(ctx, iter_obj, FALSE))
+                        goto iter_exception;
+                    JS_ThrowTypeError(ctx, "iterator does not have a throw method");
+                    goto iter_exception;
+                }
+            }
+            ret = JS_IteratorNext2(ctx, iter_obj, method, argc, argv, &done);
+            JS_FreeValue(ctx, method);
+            if (JS_IsException(ret)) {
+            iter_exception:
+                goto exec_throw;
+            }
+            /* if not done, the iterator returns the exact object
+               returned by 'method' */
+            if (done == 2) {
+                JSValue done_val, value;
+                done_val = JS_GetProperty(ctx, ret, JS_ATOM_done);
+                if (JS_IsException(done_val)) {
+                    JS_FreeValue(ctx, ret);
+                    goto iter_exception;
+                }
+                done = JS_ToBoolFree(ctx, done_val);
+                if (done) {
+                    value = JS_GetProperty(ctx, ret, JS_ATOM_value);
+                    JS_FreeValue(ctx, ret);
+                    if (JS_IsException(value))
+                        goto iter_exception;
+                    ret = value;
+                    goto iter_done;
+                } else {
+                    *pdone = 2;
+                }
+            } else {
+                if (done) {
+                    /* 'yield *' returns the value associated to done = true */
+                iter_done:
+                    JS_FreeValue(ctx, sf->cur_sp[-2]);
+                    JS_FreeValue(ctx, sf->cur_sp[-1]);
+                    sf->cur_sp--;
+                    goto exec_arg;
+                } else {
+                    *pdone = FALSE;
+                }
+            }
+            break;
+        }
+        break;
     case JS_GENERATOR_STATE_SUSPENDED_YIELD:
         /* cur_sp[-1] was set to JS_UNDEFINED in the previous call */
         ret = JS_DupValue(ctx, argv[0]);
-        if (magic == GEN_MAGIC_THROW &&
-            s->state == JS_GENERATOR_STATE_SUSPENDED_YIELD) {
+        if (magic == GEN_MAGIC_THROW) {
             JS_Throw(ctx, ret);
+        exec_throw:
             s->func_state.throw_flag = TRUE;
         } else {
+        exec_arg:
             sf->cur_sp[-1] = ret;
-            sf->cur_sp[0] = JS_NewInt32(ctx, magic);
+            sf->cur_sp[0] = JS_NewBool(ctx, (magic == GEN_MAGIC_RETURN));
             sf->cur_sp++;
         exec_no_arg:
             s->func_state.throw_flag = FALSE;
@@ -19074,14 +17817,17 @@ static JSValue js_generator_next(JSContext *ctx, JSValueConst this_val,
             return func_ret;
         }
         if (JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT) {
-            /* get the returned yield value at the top of the stack */
-            ret = sf->cur_sp[-1];
-            sf->cur_sp[-1] = JS_UNDEFINED;
             if (JS_VALUE_GET_INT(func_ret) == FUNC_RET_YIELD_STAR) {
+                /* 'yield *' */
                 s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
-                /* return (value, done) object */
-                *pdone = 2;
+                iter_args[0] = JS_UNDEFINED;
+                argc = 1;
+                argv = iter_args;
+                goto redo;
             } else {
+                /* get the return the yield value at the top of the stack */
+                ret = sf->cur_sp[-1];
+                sf->cur_sp[-1] = JS_UNDEFINED;
                 *pdone = FALSE;
             }
         } else {
@@ -19117,8 +17863,7 @@ static JSValue js_generator_next(JSContext *ctx, JSValueConst this_val,
 
 static JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,
                                           JSValueConst this_obj,
-                                          int argc, JSValueConst *argv,
-                                          int flags)
+                                          int argc, JSValueConst *argv)
 {
     JSValue obj, func_ret;
     JSGeneratorData *s;
@@ -19151,7 +17896,8 @@ static JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,
 
 /* AsyncFunction */
 
-static void js_async_function_terminate(JSRuntime *rt, JSAsyncFunctionData *s)
+static void js_async_function_terminate(JSRuntime *rt, JSContext *ctx,
+                                        JSAsyncFunctionData *s)
 {
     if (s->is_active) {
         async_func_free(rt, &s->func_state);
@@ -19159,19 +17905,15 @@ static void js_async_function_terminate(JSRuntime *rt, JSAsyncFunctionData *s)
     }
 }
 
-static void js_async_function_free0(JSRuntime *rt, JSAsyncFunctionData *s)
-{
-    js_async_function_terminate(rt, s);
-    JS_FreeValueRT(rt, s->resolving_funcs[0]);
-    JS_FreeValueRT(rt, s->resolving_funcs[1]);
-    remove_gc_object(&s->header);
-    js_free_rt(rt, s);
-}
-
-static void js_async_function_free(JSRuntime *rt, JSAsyncFunctionData *s)
+/* ctx can be NULL */
+static void js_async_function_free(JSRuntime *rt, JSContext *ctx,
+                                   JSAsyncFunctionData *s)
 {
     if (--s->header.ref_count == 0) {
-        js_async_function_free0(rt, s);
+        js_async_function_terminate(rt, ctx, s);
+        JS_FreeValueRT(rt, s->resolving_funcs[0]);
+        JS_FreeValueRT(rt, s->resolving_funcs[1]);
+        js_free_rt(rt, s);
     }
 }
 
@@ -19180,7 +17922,7 @@ static void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val)
     JSObject *p = JS_VALUE_GET_OBJ(val);
     JSAsyncFunctionData *s = p->u.async_function_data;
     if (s) {
-        js_async_function_free(rt, s);
+        js_async_function_free(rt, NULL, s);
     }
 }
 
@@ -19190,7 +17932,7 @@ static void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,
     JSObject *p = JS_VALUE_GET_OBJ(val);
     JSAsyncFunctionData *s = p->u.async_function_data;
     if (s) {
-        mark_func(rt, &s->header);
+        JS_MarkValue(rt, JS_MKPTR(JS_TAG_ASYNC_FUNCTION, s), mark_func);
     }
 }
 
@@ -19229,7 +17971,7 @@ static void js_async_function_resume(JSContext *ctx, JSAsyncFunctionData *s)
         ret2 = JS_Call(ctx, s->resolving_funcs[1], JS_UNDEFINED,
                        1, (JSValueConst *)&error);
         JS_FreeValue(ctx, error);
-        js_async_function_terminate(ctx->rt, s);
+        js_async_function_terminate(ctx->rt, ctx, s);
         JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
     } else {
         JSValue value;
@@ -19241,7 +17983,7 @@ static void js_async_function_resume(JSContext *ctx, JSAsyncFunctionData *s)
                            1, (JSValueConst *)&value);
             JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
             JS_FreeValue(ctx, value);
-            js_async_function_terminate(ctx->rt, s);
+            js_async_function_terminate(ctx->rt, ctx, s);
         } else {
             JSValue promise, resolving_funcs[2], resolving_funcs1[2];
             int i, res;
@@ -19277,8 +18019,7 @@ static void js_async_function_resume(JSContext *ctx, JSAsyncFunctionData *s)
 static JSValue js_async_function_resolve_call(JSContext *ctx,
                                               JSValueConst func_obj,
                                               JSValueConst this_obj,
-                                              int argc, JSValueConst *argv,
-                                              int flags)
+                                              int argc, JSValueConst *argv)
 {
     JSObject *p = JS_VALUE_GET_OBJ(func_obj);
     JSAsyncFunctionData *s = p->u.async_function_data;
@@ -19302,7 +18043,7 @@ static JSValue js_async_function_resolve_call(JSContext *ctx,
 
 static JSValue js_async_function_call(JSContext *ctx, JSValueConst func_obj,
                                       JSValueConst this_obj,
-                                      int argc, JSValueConst *argv, int flags)
+                                      int argc, JSValueConst *argv)
 {
     JSValue promise;
     JSAsyncFunctionData *s;
@@ -19311,7 +18052,7 @@ static JSValue js_async_function_call(JSContext *ctx, JSValueConst func_obj,
     if (!s)
         return JS_EXCEPTION;
     s->header.ref_count = 1;
-    add_gc_object(ctx->rt, &s->header, JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
+    s->gc_header.mark = 0;
     s->is_active = FALSE;
     s->resolving_funcs[0] = JS_UNDEFINED;
     s->resolving_funcs[1] = JS_UNDEFINED;
@@ -19323,14 +18064,14 @@ static JSValue js_async_function_call(JSContext *ctx, JSValueConst func_obj,
     if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
     fail:
         JS_FreeValue(ctx, promise);
-        js_async_function_free(ctx->rt, s);
+        js_async_function_free(ctx->rt, ctx, s);
         return JS_EXCEPTION;
     }
     s->is_active = TRUE;
 
     js_async_function_resume(ctx, s);
 
-    js_async_function_free(ctx->rt, s);
+    js_async_function_free(ctx->rt, ctx, s);
 
     return promise;
 }
@@ -19732,8 +18473,7 @@ static JSValue js_async_generator_next(JSContext *ctx, JSValueConst this_val,
 
 static JSValue js_async_generator_function_call(JSContext *ctx, JSValueConst func_obj,
                                                 JSValueConst this_obj,
-                                                int argc, JSValueConst *argv,
-                                                int flags)
+                                                int argc, JSValueConst *argv)
 {
     JSValue obj, func_ret;
     JSAsyncGeneratorData *s;
@@ -19790,9 +18530,6 @@ enum {
     TOK_MATH_POW_ASSIGN,
 #endif
     TOK_POW_ASSIGN,
-    TOK_LAND_ASSIGN,
-    TOK_LOR_ASSIGN,
-    TOK_DOUBLE_QUESTION_MARK_ASSIGN,
     TOK_DEC,
     TOK_INC,
     TOK_SHL,
@@ -19814,8 +18551,6 @@ enum {
     TOK_POW,
     TOK_ARROW,
     TOK_ELLIPSIS,
-    TOK_DOUBLE_QUESTION_MARK,
-    TOK_QUESTION_MARK_DOT,
     TOK_ERROR,
     TOK_PRIVATE_NAME,
     TOK_EOF,
@@ -19892,15 +18627,15 @@ typedef struct BlockEnv {
     int has_iterator;
 } BlockEnv;
 
-typedef struct JSGlobalVar {
-    int cpool_idx; /* if >= 0, index in the constant pool for hoisted
-                      function defintion*/
-    uint8_t force_init : 1; /* force initialization to undefined */
+typedef struct JSHoistedDef {
+    int cpool_idx; /* -1 means variable global definition */
+    uint8_t force_init : 1; /* initialize to undefined */
     uint8_t is_lexical : 1; /* global let/const definition */
     uint8_t is_const   : 1; /* const definition */
+    int var_idx;   /* function object index if cpool_idx >= 0 */
     int scope_level;    /* scope of definition */
-    JSAtom var_name;  /* variable name */
-} JSGlobalVar;
+    JSAtom var_name;  /* variable name if cpool_idx < 0 */
+} JSHoistedDef;
 
 typedef struct RelocEntry {
     struct RelocEntry *next;
@@ -19963,7 +18698,6 @@ typedef struct JSFunctionDef {
     BOOL has_home_object; /* TRUE if the home object is available */
     BOOL has_prototype; /* true if a prototype field is necessary */
     BOOL has_simple_parameter_list;
-    BOOL has_parameter_expressions; /* if true, an argument scope is created */
     BOOL has_use_strict; /* to reject directive in special cases */
     BOOL has_eval_call; /* true if the function contains a call to eval() */
     BOOL has_arguments_binding; /* true if the 'arguments' binding is
@@ -19977,7 +18711,6 @@ typedef struct JSFunctionDef {
     BOOL arguments_allowed; /* true if the 'arguments' identifier is allowed */
     BOOL is_derived_class_constructor;
     BOOL in_function_body;
-    BOOL backtrace_barrier;
     JSFunctionKindEnum func_kind : 8;
     JSParseFunctionEnum func_type : 8;
     uint8_t js_mode; /* bitmap of JS_MODE_x */
@@ -19991,10 +18724,7 @@ typedef struct JSFunctionDef {
     int arg_count; /* number of arguments */
     int defined_arg_count;
     int var_object_idx; /* -1 if none */
-    int arg_var_object_idx; /* -1 if none (var object for the argument scope) */
     int arguments_var_idx; /* -1 if none */
-    int arguments_arg_idx; /* argument variable definition in argument scope, 
-                              -1 if none */
     int func_var_idx; /* variable containing the current function (-1
                          if none, only used if is_func_expr is true) */
     int eval_ret_idx; /* variable containing the return value of the eval, -1 if none */
@@ -20010,11 +18740,10 @@ typedef struct JSFunctionDef {
     int scope_count;    /* number of entries used in the fd->scopes array */
     JSVarScope *scopes;
     JSVarScope def_scope_array[4];
-    int body_scope; /* scope of the body of the function or eval */
 
-    int global_var_count;
-    int global_var_size;
-    JSGlobalVar *global_vars;
+    int hoisted_def_count;
+    int hoisted_def_size;
+    JSHoistedDef *hoisted_def;
 
     DynBuf byte_code;
     int last_opcode_pos; /* -1 if no last opcode */
@@ -20028,8 +18757,8 @@ typedef struct JSFunctionDef {
 
     /* constant pool (strings, functions, numbers) */
     JSValue *cpool;
-    int cpool_count;
-    int cpool_size;
+    uint32_t cpool_count;
+    uint32_t cpool_size;
 
     /* list of variables in the closure */
     int closure_var_count;
@@ -20099,7 +18828,6 @@ typedef struct JSParseState {
     JSFunctionDef *cur_func;
     BOOL is_module; /* parsing a module */
     BOOL allow_html_comments;
-    BOOL ext_json; /* true if accepting JSON superset */
 } JSParseState;
 
 typedef struct JSOpCode {
@@ -20161,15 +18889,14 @@ static void free_token(JSParseState *s, JSToken *token)
         JS_FreeAtom(s->ctx, token->u.ident.atom);
         break;
     default:
-        if (token->val >= TOK_FIRST_KEYWORD &&
-            token->val <= TOK_LAST_KEYWORD) {
+        if (token->val >= TOK_FIRST_KEYWORD && token->val <= TOK_LAST_KEYWORD)
             JS_FreeAtom(s->ctx, token->u.ident.atom);
-        }
+
         break;
     }
 }
 
-static void __attribute((unused)) dump_token(JSParseState *s,
+static void __maybe_unused dump_token(JSParseState *s,
                                              const JSToken *token)
 {
     switch(token->val) {
@@ -20230,20 +18957,16 @@ static void __attribute((unused)) dump_token(JSParseState *s,
     }
 }
 
-int __attribute__((format(printf, 2, 3))) js_parse_error(JSParseState *s, const char *fmt, ...)
+int __js_printf_like(2, 3) js_parse_error(JSParseState *s, const char *fmt, ...)
 {
     JSContext *ctx = s->ctx;
     va_list ap;
-    int backtrace_flags;
-    
+
     va_start(ap, fmt);
-    JS_ThrowError2(ctx, JS_SYNTAX_ERROR, fmt, ap, FALSE);
+    JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);
     va_end(ap);
-    backtrace_flags = 0;
-    if (s->cur_func && s->cur_func->backtrace_barrier)
-        backtrace_flags = JS_BACKTRACE_FLAG_SINGLE_LEVEL;
-    build_backtrace(ctx, ctx->rt->current_exception, s->filename, s->line_num,
-                    backtrace_flags);
+
+    build_backtrace(ctx, ctx->current_exception, s->filename, s->line_num, NULL);
     return -1;
 }
 
@@ -20378,8 +19101,6 @@ static __exception int js_parse_string(JSParseState *s, int sep,
         }
         if (c == '\\') {
             c = *p;
-            /* XXX: need a specific JSON case to avoid
-               accepting invalid escapes */
             switch(c) {
             case '\0':
                 if (p >= s->buf_end)
@@ -20403,23 +19124,18 @@ static __exception int js_parse_string(JSParseState *s, int sep,
                     s->line_num++;
                 continue;
             default:
-                if (c >= '0' && c <= '9') {
+                if (c >= '0' && c <= '7') {
                     if (!s->cur_func)
-                        goto invalid_escape; /* JSON case */
+                        goto invalid_octal; /* JSON case */
                     if (!(s->cur_func->js_mode & JS_MODE_STRICT) && sep != '`')
                         goto parse_escape;
                     if (c == '0' && !(p[1] >= '0' && p[1] <= '9')) {
                         p++;
                         c = '\0';
                     } else {
-                        if (c >= '8' || sep == '`') {
-                            /* Note: according to ES2021, \8 and \9 are not
-                               accepted in strict mode or in templates. */
-                            goto invalid_escape;
-                        } else {
-                            if (do_throw)
-                                js_parse_error(s, "octal escape sequences are not allowed in strict mode");
-                        }
+                    invalid_octal:
+                        if (do_throw)
+                            js_parse_error(s, "invalid octal syntax in strict mode");
                         goto fail;
                     }
                 } else if (c >= 0x80) {
@@ -20436,7 +19152,6 @@ static __exception int js_parse_string(JSParseState *s, int sep,
                 parse_escape:
                     ret = lre_parse_escape(&p, TRUE);
                     if (ret == -1) {
-                    invalid_escape:
                         if (do_throw)
                             js_parse_error(s, "malformed escape sequence in string literal");
                         goto fail;
@@ -20580,93 +19295,13 @@ static __exception int js_parse_regexp(JSParseState *s)
     return -1;
 }
 
-static __exception int ident_realloc(JSContext *ctx, char **pbuf, size_t *psize,
-                                     char *static_buf)
-{
-    char *buf, *new_buf;
-    size_t size, new_size;
-    
-    buf = *pbuf;
-    size = *psize;
-    if (size >= (SIZE_MAX / 3) * 2)
-        new_size = SIZE_MAX;
-    else
-        new_size = size + (size >> 1);
-    if (buf == static_buf) {
-        new_buf = js_malloc(ctx, new_size);
-        if (!new_buf)
-            return -1;
-        memcpy(new_buf, buf, size);
-    } else {
-        new_buf = js_realloc(ctx, buf, new_size);
-        if (!new_buf)
-            return -1;
-    }
-    *pbuf = new_buf;
-    *psize = new_size;
-    return 0;
-}
-
-/* 'c' is the first character. Return JS_ATOM_NULL in case of error */
-static JSAtom parse_ident(JSParseState *s, const uint8_t **pp,
-                          BOOL *pident_has_escape, int c, BOOL is_private)
-{
-    const uint8_t *p, *p1;
-    char ident_buf[128], *buf;
-    size_t ident_size, ident_pos;
-    JSAtom atom;
-    
-    p = *pp;
-    buf = ident_buf;
-    ident_size = sizeof(ident_buf);
-    ident_pos = 0;
-    if (is_private)
-        buf[ident_pos++] = '#';
-    for(;;) {
-        p1 = p;
-        
-        if (c < 128) {
-            buf[ident_pos++] = c;
-        } else {
-            ident_pos += unicode_to_utf8((uint8_t*)buf + ident_pos, c);
-        }
-        c = *p1++;
-        if (c == '\\' && *p1 == 'u') {
-            c = lre_parse_escape(&p1, TRUE);
-            *pident_has_escape = TRUE;
-        } else if (c >= 128) {
-            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
-        }
-        if (!lre_js_is_ident_next(c))
-            break;
-        p = p1;
-        if (unlikely(ident_pos >= ident_size - UTF8_CHAR_LEN_MAX)) {
-            if (ident_realloc(s->ctx, &buf, &ident_size, ident_buf)) {
-                atom = JS_ATOM_NULL;
-                goto done;
-            }
-        }
-    }
-    atom = JS_NewAtomLen(s->ctx, buf, ident_pos);
- done:
-    if (unlikely(buf != ident_buf))
-        js_free(s->ctx, buf);
-    *pp = p;
-    return atom;
-}
-
-
 static __exception int next_token(JSParseState *s)
 {
     const uint8_t *p;
     int c;
+    char buf[4096], *q;
     BOOL ident_has_escape;
-    JSAtom atom;
-    
-    if (js_check_stack_overflow(s->ctx->rt, 0)) {
-        return js_parse_error(s, "stack overflow");
-    }
-    
+
     free_token(s, &s->token);
 
     p = s->last_ptr = s->buf_ptr;
@@ -20678,18 +19313,23 @@ static __exception int next_token(JSParseState *s)
     c = *p;
     switch(c) {
     case 0:
-        if (p >= s->buf_end) {
-            s->token.val = TOK_EOF;
-        } else {
-            goto def_token;
-        }
+        s->token.val = TOK_EOF;
         break;
     case '`':
+        if (!s->cur_func) {
+            /* JSON does not accept templates */
+            goto def_token;
+        }
         if (js_parse_template_part(s, p + 1))
             goto fail;
         p = s->buf_ptr;
         break;
     case '\'':
+        if (!s->cur_func) {
+            /* JSON does not accept single quoted strings */
+            goto def_token;
+        }
+        /* fall through */
     case '\"':
         if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p))
             goto fail;
@@ -20707,6 +19347,11 @@ static __exception int next_token(JSParseState *s)
         goto redo;
     case '\f':
     case '\v':
+        if (!s->cur_func) {
+            /* JSONWhitespace does not match <VT>, nor <FF> */
+            goto def_token;
+        }
+        /* fall through */
     case ' ':
     case '\t':
         p++;
@@ -20735,8 +19380,6 @@ static __exception int next_token(JSParseState *s)
                     c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
                     if (c == CP_LS || c == CP_PS) {
                         s->got_lf = TRUE; /* considered as LF for ASI */
-                    } else if (c == -1) {
-                        p++; /* skip invalid UTF-8 */
                     }
                 } else {
                     p++;
@@ -20755,11 +19398,8 @@ static __exception int next_token(JSParseState *s)
                 if (*p >= 0x80) {
                     c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
                     /* LS or PS are considered as line terminator */
-                    if (c == CP_LS || c == CP_PS) {
+                    if (c == CP_LS || c == CP_PS)
                         break;
-                    } else if (c == -1) {
-                        p++; /* skip invalid UTF-8 */
-                    }
                 } else {
                     p++;
                 }
@@ -20787,43 +19427,105 @@ static __exception int next_token(JSParseState *s)
             }
         }
         goto def_token;
-    case 'a': case 'b': case 'c': case 'd':
-    case 'e': case 'f': case 'g': case 'h':
-    case 'i': case 'j': case 'k': case 'l':
-    case 'm': case 'n': case 'o': case 'p':
-    case 'q': case 'r': case 's': case 't':
-    case 'u': case 'v': case 'w': case 'x':
-    case 'y': case 'z': 
-    case 'A': case 'B': case 'C': case 'D':
-    case 'E': case 'F': case 'G': case 'H':
-    case 'I': case 'J': case 'K': case 'L':
-    case 'M': case 'N': case 'O': case 'P':
-    case 'Q': case 'R': case 'S': case 'T':
-    case 'U': case 'V': case 'W': case 'X':
-    case 'Y': case 'Z': 
+    case 'a':
+    case 'b':
+    case 'c':
+    case 'd':
+    case 'e':
+    case 'f':
+    case 'g':
+    case 'h':
+    case 'i':
+    case 'j':
+    case 'k':
+    case 'l':
+    case 'm':
+    case 'n':
+    case 'o':
+    case 'p':
+    case 'q':
+    case 'r':
+    case 's':
+    case 't':
+    case 'u':
+    case 'v':
+    case 'w':
+    case 'x':
+    case 'y':
+    case 'z':
+    case 'A':
+    case 'B':
+    case 'C':
+    case 'D':
+    case 'E':
+    case 'F':
+    case 'G':
+    case 'H':
+    case 'I':
+    case 'J':
+    case 'K':
+    case 'L':
+    case 'M':
+    case 'N':
+    case 'O':
+    case 'P':
+    case 'Q':
+    case 'R':
+    case 'S':
+    case 'T':
+    case 'U':
+    case 'V':
+    case 'W':
+    case 'X':
+    case 'Y':
+    case 'Z':
     case '_':
     case '$':
         /* identifier */
         p++;
         ident_has_escape = FALSE;
     has_ident:
-        atom = parse_ident(s, &p, &ident_has_escape, c, FALSE);
-        if (atom == JS_ATOM_NULL)
-            goto fail;
-        s->token.u.ident.atom = atom;
+        q = buf;
+        for(;;) {
+            const uint8_t *p1 = p;
+
+            if (c < 128) {
+                *q++ = c;
+            } else {
+                q += unicode_to_utf8((uint8_t*)q, c);
+            }
+            c = *p1++;
+            if (c == '\\' && *p1 == 'u') {
+                c = lre_parse_escape(&p1, TRUE);
+                ident_has_escape = TRUE;
+            } else if (c >= 128) {
+                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
+            }
+            /* XXX: check if c >= 0 and c <= 0x10FFFF */
+            if (!lre_js_is_ident_next(c))
+                break;
+            p = p1;
+            if ((q - buf) >= sizeof(buf) - UTF8_CHAR_LEN_MAX) {
+                js_parse_error(s, "identifier too long");
+                goto fail;
+            }
+        }
+        *q = '\0';
+        s->token.u.ident.atom = JS_NewAtomLen(s->ctx, buf, q - buf);
         s->token.u.ident.has_escape = ident_has_escape;
         s->token.u.ident.is_reserved = FALSE;
         if (s->token.u.ident.atom <= JS_ATOM_LAST_KEYWORD ||
             (s->token.u.ident.atom <= JS_ATOM_LAST_STRICT_KEYWORD &&
-             (s->cur_func->js_mode & JS_MODE_STRICT)) ||
-            (s->token.u.ident.atom == JS_ATOM_yield &&
+             s->cur_func && (s->cur_func->js_mode & JS_MODE_STRICT)) ||
+            (s->token.u.ident.atom == JS_ATOM_yield && s->cur_func &&
              ((s->cur_func->func_kind & JS_FUNC_GENERATOR) ||
               (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
                !s->cur_func->in_function_body && s->cur_func->parent &&
                (s->cur_func->parent->func_kind & JS_FUNC_GENERATOR)))) ||
             (s->token.u.ident.atom == JS_ATOM_await &&
              (s->is_module ||
-              (((s->cur_func->func_kind & JS_FUNC_ASYNC) ||
+              (s->cur_func &&
+               ((s->cur_func->func_kind & JS_FUNC_ASYNC) ||
                 (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
                  !s->cur_func->in_function_body && s->cur_func->parent &&
                  (s->cur_func->parent->func_kind & JS_FUNC_ASYNC))))))) {
@@ -20843,6 +19545,8 @@ static __exception int next_token(JSParseState *s)
         {
             const uint8_t *p1;
             p++;
+            q = buf;
+            *q++ = '#';
             p1 = p;
             c = *p1++;
             if (c == '\\' && *p1 == 'u') {
@@ -20855,11 +19559,31 @@ static __exception int next_token(JSParseState *s)
                 goto fail;
             }
             p = p1;
-            ident_has_escape = FALSE; /* not used */
-            atom = parse_ident(s, &p, &ident_has_escape, c, TRUE);
-            if (atom == JS_ATOM_NULL)
-                goto fail;
-            s->token.u.ident.atom = atom;
+            for(;;) {
+                if (c < 128) {
+                    *q++ = c;
+                } else {
+                    q += unicode_to_utf8((uint8_t*)q, c);
+                }
+                p1 = p;
+                c = *p1++;
+                if (c == '\\' && *p1 == 'u') {
+                    c = lre_parse_escape(&p1, TRUE);
+                    ident_has_escape = TRUE;
+                } else if (c >= 128) {
+                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
+                }
+                /* XXX: check if c >= 0 and c <= 0x10FFFF */
+                if (!lre_js_is_ident_next(c))
+                    break;
+                p = p1;
+                if ((q - buf) >= sizeof(buf) - UTF8_CHAR_LEN_MAX) {
+                    js_parse_error(s, "private name too long");
+                    goto fail;
+                }
+            }
+            *q = '\0';
+            s->token.u.ident.atom = JS_NewAtomLen(s->ctx, buf, q - buf);
             s->token.val = TOK_PRIVATE_NAME;
         }
         break;
@@ -20876,52 +19600,130 @@ static __exception int next_token(JSParseState *s)
         }
         break;
     case '0':
-        /* in strict mode, octal literals are not accepted */
-        if (is_digit(p[1]) && (s->cur_func->js_mode & JS_MODE_STRICT)) {
+        /* in strict or JSON parsing mode, octal literals are not accepted */
+        if (isdigit(p[1]) && (!s->cur_func ||
+                               (s->cur_func->js_mode & JS_MODE_STRICT))) {
             js_parse_error(s, "octal literals are deprecated in strict mode");
             goto fail;
         }
         goto parse_number;
-    case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8':
-    case '9': 
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+    case '9':
         /* number */
     parse_number:
+#ifdef CONFIG_BIGNUM
+        {
+            const uint8_t *p1;
+            int flags;
+            slimb_t exponent;
+            JSValue val;
+
+            s->token.val = TOK_NUMBER;
+            s->token.u.num.val = JS_UNDEFINED;
+            s->token.u.num.exponent = 0;
+            if (!s->cur_func) {
+                /* JSON: use current float precision */
+                flags = BF_ATOF_THROW;
+                if (is_bignum_mode(s->ctx))
+                    flags |= BF_ATOF_INT_PREC_INF;
+                else
+                    flags |= BF_ATOF_FLOAT64;
+                val = js_atof(s->ctx, (const char *)p, (const char **)&p,
+                              10, flags);
+                if (JS_IsException(val))
+                    goto bad_number;
+            } else {
+                bf_t r_s, *r = &r_s;
+                BOOL bigint_mode, is_bigint, is_bigfloat;
+                int res;
+
+                bigint_mode = (s->cur_func->js_mode & JS_MODE_BIGINT) != 0;
+                flags = BF_ATOF_BIN_OCT | BF_ATOF_LEGACY_OCTAL |
+                    BF_ATOF_UNDERSCORE_SEP | BF_ATOF_INT_PREC_INF | BF_RNDZ;
+                if (!bigint_mode)
+                    flags |= BF_ATOF_ONLY_DEC_FLOAT;
+                p += skip_spaces((char *)p);
+                bf_init(s->ctx->bf_ctx, r);
+                res = bf_atof2(r, &exponent, (const char *)p,
+                               (const char **)&p, 0, BF_PREC_INF, flags);
+                if (bf_is_nan(r)) {
+                    bf_delete(r);
+                    goto bad_number;
+                }
+                is_bigint = FALSE;
+                is_bigfloat = FALSE;
+                if (*p == 'n') {
+                    if (!(res & BF_ATOF_ST_INTEGER) ||
+                        (res & BF_ATOF_ST_LEGACY_OCTAL)) {
+                        bf_delete(r);
+                        goto bad_number;
+                    }
+                    p++;
+                    is_bigint = TRUE;
+                } else if (*p == 'l') {
+                    p++;
+                    is_bigfloat = TRUE;
+                }
+                if ((res & BF_ATOF_ST_INTEGER) && !is_bigfloat &&
+                    (bigint_mode || is_bigint)) {
+                    /* in bigint mode: small integer or bigint
+                       in legacy mode: always a bigint */
+                    val = JS_NewBigInt2(s->ctx, r, bigint_mode ^ 1);
+                } else {
+                    /* `n` suffix is implied in math mode */
+                    if (s->cur_func->js_mode & JS_MODE_MATH)
+                        is_bigfloat = TRUE;
+                    if (is_bigfloat) {
+                        /* infinite precision */
+                        val = JS_NewBigFloat(s->ctx, r);
+                        s->token.u.num.exponent = exponent;
+                    } else {
+                        double d;
+                        d = bf_mul_pow10_to_float64(s->ctx, r, exponent);
+                        bf_delete(r);
+                        val = JS_NewFloat64(s->ctx, d);
+                    }
+                }
+            }
+            s->token.u.num.val = val;
+            if (lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
+            bad_number:
+                js_parse_error(s, "invalid number literal");
+                goto fail;
+            }
+        }
+#else
         {
             JSValue ret;
             const uint8_t *p1;
             int flags, radix;
-            flags = ATOD_ACCEPT_BIN_OCT | ATOD_ACCEPT_LEGACY_OCTAL |
-                ATOD_ACCEPT_UNDERSCORES;
-#ifdef CONFIG_BIGNUM
-            flags |= ATOD_ACCEPT_SUFFIX;
-            if (s->cur_func->js_mode & JS_MODE_MATH) {
-                flags |= ATOD_MODE_BIGINT;
-                if (s->cur_func->js_mode & JS_MODE_MATH)
-                    flags |= ATOD_TYPE_BIG_FLOAT;
+            if (!s->cur_func) {
+                flags = ATOD_THROW;
+                radix = 10;
+            } else {
+                flags = ATOD_ACCEPT_BIN_OCT | ATOD_THROW | ATOD_ACCEPT_LEGACY_OCTAL |
+                    ATOD_ACCEPT_UNDERSCORES;
+                radix = 0;
             }
-#endif
-            radix = 0;
-#ifdef CONFIG_BIGNUM
-            s->token.u.num.exponent = 0;
-            ret = js_atof2(s->ctx, (const char *)p, (const char **)&p, radix,
-                           flags, &s->token.u.num.exponent);
-#else
-            ret = js_atof(s->ctx, (const char *)p, (const char **)&p, radix,
+            ret = js_atod(s->ctx, (const char *)p, (const char **)&p, radix,
                           flags);
-#endif
-            if (JS_IsException(ret))
-                goto fail;
             /* reject `10instanceof Number` */
-            if (JS_VALUE_IS_NAN(ret) ||
+            if (JS_IsException(ret) ||
                 lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
-                JS_FreeValue(s->ctx, ret);
                 js_parse_error(s, "invalid number literal");
                 goto fail;
             }
             s->token.val = TOK_NUMBER;
             s->token.u.num.val = ret;
         }
+#endif
         break;
     case '*':
         if (p[1] == '=') {
@@ -21054,13 +19856,8 @@ static __exception int next_token(JSParseState *s)
             p += 2;
             s->token.val = TOK_AND_ASSIGN;
         } else if (p[1] == '&') {
-            if (p[2] == '=') {
-                p += 3;
-                s->token.val = TOK_LAND_ASSIGN;
-            } else {
-                p += 2;
-                s->token.val = TOK_LAND;
-            }
+            p += 2;
+            s->token.val = TOK_LAND;
         } else {
             goto def_token;
         }
@@ -21071,7 +19868,7 @@ static __exception int next_token(JSParseState *s)
     case '^':
         if (p[1] == '=') {
             p += 2;
-            if (s->cur_func->js_mode & JS_MODE_MATH)
+            if (s->cur_func && (s->cur_func->js_mode & JS_MODE_MATH))
                 s->token.val = TOK_MATH_POW_ASSIGN;
             else
                 s->token.val = TOK_XOR_ASSIGN;
@@ -21085,7 +19882,7 @@ static __exception int next_token(JSParseState *s)
             }
         } else {
             p++;
-            if (s->cur_func->js_mode & JS_MODE_MATH)
+            if (s->cur_func && (s->cur_func->js_mode & JS_MODE_MATH))
                 s->token.val = TOK_MATH_POW;
             else
                 s->token.val = '^';
@@ -21106,29 +19903,8 @@ static __exception int next_token(JSParseState *s)
             p += 2;
             s->token.val = TOK_OR_ASSIGN;
         } else if (p[1] == '|') {
-            if (p[2] == '=') {
-                p += 3;
-                s->token.val = TOK_LOR_ASSIGN;
-            } else {
-                p += 2;
-                s->token.val = TOK_LOR;
-            }
-        } else {
-            goto def_token;
-        }
-        break;
-    case '?':
-        if (p[1] == '?') {
-            if (p[2] == '=') {
-                p += 3;
-                s->token.val = TOK_DOUBLE_QUESTION_MARK_ASSIGN;
-            } else {
-                p += 2;
-                s->token.val = TOK_DOUBLE_QUESTION_MARK;
-            }
-        } else if (p[1] == '.' && !(p[2] >= '0' && p[2] <= '9')) {
             p += 2;
-            s->token.val = TOK_QUESTION_MARK_DOT;
+            s->token.val = TOK_LOR;
         } else {
             goto def_token;
         }
@@ -21140,12 +19916,24 @@ static __exception int next_token(JSParseState *s)
             switch(c) {
             case CP_PS:
             case CP_LS:
-                /* XXX: should avoid incrementing line_number, but
-                   needed to handle HTML comments */
+                if (!s->cur_func) {
+                    /* <PS> and <LS> are not JSONWhitespace */
+                    goto def_token;
+                } else {
+                    /* XXX: should avoid incrementing line_number, but
+                       needed to handle HTML comments */
+                    goto line_terminator; 
                 goto line_terminator; 
+                    goto line_terminator; 
+                }
             default:
                 if (lre_is_space(c)) {
-                    goto redo;
+                    if (!s->cur_func) {
+                        /* category z spaces are not JSONWhitespace */
+                        goto def_token;
+                    } else {
+                        goto redo;
+                    }
                 } else if (lre_js_is_ident_first(c)) {
                     ident_has_escape = FALSE;
                     goto has_ident;
@@ -21170,234 +19958,6 @@ static __exception int next_token(JSParseState *s)
     return -1;
 }
 
-/* 'c' is the first character. Return JS_ATOM_NULL in case of error */
-static JSAtom json_parse_ident(JSParseState *s, const uint8_t **pp, int c)
-{
-    const uint8_t *p;
-    char ident_buf[128], *buf;
-    size_t ident_size, ident_pos;
-    JSAtom atom;
-    
-    p = *pp;
-    buf = ident_buf;
-    ident_size = sizeof(ident_buf);
-    ident_pos = 0;
-    for(;;) {
-        buf[ident_pos++] = c;
-        c = *p;
-        if (c >= 128 ||
-            !((lre_id_continue_table_ascii[c >> 5] >> (c & 31)) & 1))
-            break;
-        p++;
-        if (unlikely(ident_pos >= ident_size - UTF8_CHAR_LEN_MAX)) {
-            if (ident_realloc(s->ctx, &buf, &ident_size, ident_buf)) {
-                atom = JS_ATOM_NULL;
-                goto done;
-            }
-        }
-    }
-    atom = JS_NewAtomLen(s->ctx, buf, ident_pos);
- done:
-    if (unlikely(buf != ident_buf))
-        js_free(s->ctx, buf);
-    *pp = p;
-    return atom;
-}
-
-static __exception int json_next_token(JSParseState *s)
-{
-    const uint8_t *p;
-    int c;
-    JSAtom atom;
-    
-    if (js_check_stack_overflow(s->ctx->rt, 0)) {
-        return js_parse_error(s, "stack overflow");
-    }
-    
-    free_token(s, &s->token);
-
-    p = s->last_ptr = s->buf_ptr;
-    s->last_line_num = s->token.line_num;
- redo:
-    s->token.line_num = s->line_num;
-    s->token.ptr = p;
-    c = *p;
-    switch(c) {
-    case 0:
-        if (p >= s->buf_end) {
-            s->token.val = TOK_EOF;
-        } else {
-            goto def_token;
-        }
-        break;
-    case '\'':
-        if (!s->ext_json) {
-            /* JSON does not accept single quoted strings */
-            goto def_token;
-        }
-        /* fall through */
-    case '\"':
-        if (js_parse_string(s, c, TRUE, p + 1, &s->token, &p))
-            goto fail;
-        break;
-    case '\r':  /* accept DOS and MAC newline sequences */
-        if (p[1] == '\n') {
-            p++;
-        }
-        /* fall thru */
-    case '\n':
-        p++;
-        s->line_num++;
-        goto redo;
-    case '\f':
-    case '\v':
-        if (!s->ext_json) {
-            /* JSONWhitespace does not match <VT>, nor <FF> */
-            goto def_token;
-        }
-        /* fall through */
-    case ' ':
-    case '\t':
-        p++;
-        goto redo;
-    case '/':
-        if (!s->ext_json) {
-            /* JSON does not accept comments */
-            goto def_token;
-        }
-        if (p[1] == '*') {
-            /* comment */
-            p += 2;
-            for(;;) {
-                if (*p == '\0' && p >= s->buf_end) {
-                    js_parse_error(s, "unexpected end of comment");
-                    goto fail;
-                }
-                if (p[0] == '*' && p[1] == '/') {
-                    p += 2;
-                    break;
-                }
-                if (*p == '\n') {
-                    s->line_num++;
-                    p++;
-                } else if (*p == '\r') {
-                    p++;
-                } else if (*p >= 0x80) {
-                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
-                    if (c == -1) {
-                        p++; /* skip invalid UTF-8 */
-                    }
-                } else {
-                    p++;
-                }
-            }
-            goto redo;
-        } else if (p[1] == '/') {
-            /* line comment */
-            p += 2;
-            for(;;) {
-                if (*p == '\0' && p >= s->buf_end)
-                    break;
-                if (*p == '\r' || *p == '\n')
-                    break;
-                if (*p >= 0x80) {
-                    c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
-                    /* LS or PS are considered as line terminator */
-                    if (c == CP_LS || c == CP_PS) {
-                        break;
-                    } else if (c == -1) {
-                        p++; /* skip invalid UTF-8 */
-                    }
-                } else {
-                    p++;
-                }
-            }
-            goto redo;
-        } else {
-            goto def_token;
-        }
-        break;
-    case 'a': case 'b': case 'c': case 'd':
-    case 'e': case 'f': case 'g': case 'h':
-    case 'i': case 'j': case 'k': case 'l':
-    case 'm': case 'n': case 'o': case 'p':
-    case 'q': case 'r': case 's': case 't':
-    case 'u': case 'v': case 'w': case 'x':
-    case 'y': case 'z': 
-    case 'A': case 'B': case 'C': case 'D':
-    case 'E': case 'F': case 'G': case 'H':
-    case 'I': case 'J': case 'K': case 'L':
-    case 'M': case 'N': case 'O': case 'P':
-    case 'Q': case 'R': case 'S': case 'T':
-    case 'U': case 'V': case 'W': case 'X':
-    case 'Y': case 'Z': 
-    case '_':
-    case '$':
-        /* identifier : only pure ascii characters are accepted */
-        p++;
-        atom = json_parse_ident(s, &p, c);
-        if (atom == JS_ATOM_NULL)
-            goto fail;
-        s->token.u.ident.atom = atom;
-        s->token.u.ident.has_escape = FALSE;
-        s->token.u.ident.is_reserved = FALSE;
-        s->token.val = TOK_IDENT;
-        break;
-    case '+':
-        if (!s->ext_json || !is_digit(p[1]))
-            goto def_token;
-        goto parse_number;
-    case '0':
-        if (is_digit(p[1]))
-            goto def_token;
-        goto parse_number;
-    case '-':
-        if (!is_digit(p[1]))
-            goto def_token;
-        goto parse_number;
-    case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8':
-    case '9': 
-        /* number */
-    parse_number:
-        {
-            JSValue ret;
-            int flags, radix;
-            if (!s->ext_json) {
-                flags = 0;
-                radix = 10;
-            } else {
-                flags = ATOD_ACCEPT_BIN_OCT;
-                radix = 0;
-            }
-            ret = js_atof(s->ctx, (const char *)p, (const char **)&p, radix,
-                          flags);
-            if (JS_IsException(ret))
-                goto fail;
-            s->token.val = TOK_NUMBER;
-            s->token.u.num.val = ret;
-        }
-        break;
-    default:
-        if (c >= 128) {
-            js_parse_error(s, "unexpected character");
-            goto fail;
-        }
-    def_token:
-        s->token.val = c;
-        p++;
-        break;
-    }
-    s->buf_ptr = p;
-
-    //    dump_token(s, &s->token);
-    return 0;
-
- fail:
-    s->token.val = TOK_ERROR;
-    return -1;
-}
-
 /* only used for ':' and '=>', 'let' or 'function' look-ahead. *pp is
    only set if TOK_IMPORT is returned */
 /* XXX: handle all unicode cases */
@@ -21458,12 +20018,6 @@ static int simple_next_token(const uint8_t **pp, BOOL no_line_terminator)
                     }
                 } else if (c == 'o' && *p == 'f' && !lre_js_is_ident_next(p[1])) {
                     return TOK_OF;
-                } else if (c == 'e' &&
-                           p[0] == 'x' && p[1] == 'p' && p[2] == 'o' &&
-                           p[3] == 'r' && p[4] == 't' &&
-                           !lre_js_is_ident_next(p[5])) {
-                    *pp = p + 5;
-                    return TOK_EXPORT;
                 } else if (c == 'f' && p[0] == 'u' && p[1] == 'n' &&
                          p[2] == 'c' && p[3] == 't' && p[4] == 'i' &&
                          p[5] == 'o' && p[6] == 'n' && !lre_js_is_ident_next(p[7])) {
@@ -21487,21 +20041,16 @@ static int peek_token(JSParseState *s, BOOL no_line_terminator)
    (heuristic). 'input' must be a zero terminated.
 
    Heuristic: skip comments and expect 'import' keyword not followed
-   by '(' or '.' or export keyword.
+   by '(' or '.'
 */
 BOOL JS_DetectModule(const char *input, size_t input_len)
 {
     const uint8_t *p = (const uint8_t *)input;
     int tok;
-    switch(simple_next_token(&p, FALSE)) {
-    case TOK_IMPORT:
-        tok = simple_next_token(&p, FALSE);
-        return (tok != '.' && tok != '(');
-    case TOK_EXPORT:
-        return TRUE;
-    default:
+    if (simple_next_token(&p, FALSE) != TOK_IMPORT)
         return FALSE;
-    }
+    tok = simple_next_token(&p, FALSE);
+    return (tok != '.' && tok != '(');
 }
 
 static inline int get_prev_opcode(JSFunctionDef *fd) {
@@ -21519,7 +20068,7 @@ static BOOL js_is_live_code(JSParseState *s) {
     case OP_return_undef:
     case OP_return_async:
     case OP_throw:
-    case OP_throw_error:
+    case OP_throw_var:
     case OP_goto:
 #if SHORT_OPCODES
     case OP_goto8:
@@ -21585,10 +20134,20 @@ static int new_label_fd(JSFunctionDef *fd, int label)
     LabelSlot *ls;
 
     if (label < 0) {
-        if (js_resize_array(fd->ctx, (void *)&fd->label_slots,
-                            sizeof(fd->label_slots[0]),
-                            &fd->label_size, fd->label_count + 1))
-            return -1;
+        if (fd->label_count >= fd->label_size) {
+            int new_size;
+            size_t slack;
+            LabelSlot *new_tab;
+
+            /* XXX: potential arithmetic overflow */
+            new_size = fd->label_size * 3 / 2 + 4;
+            new_tab = js_realloc2(fd->ctx, fd->label_slots, new_size * sizeof(*new_tab), &slack);
+            if (!new_tab)
+                return -1;
+            new_size += slack / sizeof(*new_tab);
+            fd->label_slots = new_tab;
+            fd->label_size = new_size;
+        }
         label = fd->label_count++;
         ls = &fd->label_slots[label];
         ls->ref_count = 0;
@@ -21636,10 +20195,19 @@ static int emit_goto(JSParseState *s, int opcode, int label)
 static int cpool_add(JSParseState *s, JSValue val)
 {
     JSFunctionDef *fd = s->cur_func;
-    
-    if (js_resize_array(s->ctx, (void *)&fd->cpool, sizeof(fd->cpool[0]),
-                        &fd->cpool_size, fd->cpool_count + 1))
-        return -1;
+    if (fd->cpool_count >= fd->cpool_size) {
+        int new_size;
+        size_t slack;
+        JSValue *new_tab;
+        /* XXX: potential arithmetic overflow */
+        new_size = max_int(fd->cpool_count + 1, fd->cpool_size * 3 / 2);
+        new_tab = js_realloc2(s->ctx, fd->cpool, new_size * sizeof(JSValue), &slack);
+        if (!new_tab)
+            return -1;
+        new_size += slack / sizeof(*new_tab);
+        fd->cpool = new_tab;
+        fd->cpool_size = new_size;
+    }
     fd->cpool[fd->cpool_count++] = val;
     return fd->cpool_count - 1;
 }
@@ -21691,21 +20259,6 @@ static int find_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
     return find_arg(ctx, fd, name);
 }
 
-/* find a variable declaration in a given scope */
-static int find_var_in_scope(JSContext *ctx, JSFunctionDef *fd,
-                             JSAtom name, int scope_level)
-{
-    int scope_idx;
-    for(scope_idx = fd->scopes[scope_level].first; scope_idx >= 0;
-        scope_idx = fd->vars[scope_idx].scope_next) {
-        if (fd->vars[scope_idx].scope_level != scope_level)
-            break;
-        if (fd->vars[scope_idx].var_name == name)
-            return scope_idx;
-    }
-    return -1;
-}
-
 /* return true if scope == parent_scope or if scope is a child of
    parent_scope */
 static BOOL is_child_scope(JSContext *ctx, JSFunctionDef *fd,
@@ -21727,7 +20280,7 @@ static int find_var_in_child_scope(JSContext *ctx, JSFunctionDef *fd,
     for(i = 0; i < fd->var_count; i++) {
         JSVarDef *vd = &fd->vars[i];
         if (vd->var_name == name && vd->scope_level == 0) {
-            if (is_child_scope(ctx, fd, vd->scope_next,
+            if (is_child_scope(ctx, fd, vd->func_pool_or_scope_idx,
                                scope_level))
                 return i;
         }
@@ -21736,11 +20289,11 @@ static int find_var_in_child_scope(JSContext *ctx, JSFunctionDef *fd,
 }
 
 
-static JSGlobalVar *find_global_var(JSFunctionDef *fd, JSAtom name)
+static JSHoistedDef *find_hoisted_def(JSFunctionDef *fd, JSAtom name)
 {
     int i;
-    for(i = 0; i < fd->global_var_count; i++) {
-        JSGlobalVar *hf = &fd->global_vars[i];
+    for(i = 0; i < fd->hoisted_def_count; i++) {
+        JSHoistedDef *hf = &fd->hoisted_def[i];
         if (hf->var_name == name)
             return hf;
     }
@@ -21748,9 +20301,9 @@ static JSGlobalVar *find_global_var(JSFunctionDef *fd, JSAtom name)
 
 }
 
-static JSGlobalVar *find_lexical_global_var(JSFunctionDef *fd, JSAtom name)
+static JSHoistedDef *find_lexical_hoisted_def(JSFunctionDef *fd, JSAtom name)
 {
-    JSGlobalVar *hf = find_global_var(fd, name);
+    JSHoistedDef *hf = find_hoisted_def(fd, name);
     if (hf && hf->is_lexical)
         return hf;
     else
@@ -21770,7 +20323,7 @@ static int find_lexical_decl(JSContext *ctx, JSFunctionDef *fd, JSAtom name,
     }
 
     if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_GLOBAL) {
-        if (find_lexical_global_var(fd, name))
+        if (find_lexical_hoisted_def(fd, name))
             return GLOBAL_VAR_OFFSET;
     }
     return -1;
@@ -21853,13 +20406,21 @@ static int add_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
         JS_ThrowInternalError(ctx, "too many local variables");
         return -1;
     }
-    if (js_resize_array(ctx, (void **)&fd->vars, sizeof(fd->vars[0]),
-                        &fd->var_size, fd->var_count + 1))
-        return -1;
+    if ((fd->var_count + 1) > fd->var_size) {
+        int new_size;
+        size_t slack;
+        JSVarDef *new_buf;
+        new_size = max_int(fd->var_count + 1, fd->var_size * 3 / 2);
+        new_buf = js_realloc2(ctx, fd->vars, new_size * sizeof(*fd->vars), &slack);
+        if (!new_buf)
+            return -1;
+        new_size += slack / sizeof(*new_buf);
+        fd->vars = new_buf;
+        fd->var_size = new_size;
+    }
     vd = &fd->vars[fd->var_count++];
     memset(vd, 0, sizeof(*vd));
     vd->var_name = JS_DupAtom(ctx, name);
-    vd->func_pool_idx = -1;
     return fd->var_count - 1;
 }
 
@@ -21883,47 +20444,22 @@ static int add_func_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
     int idx = fd->func_var_idx;
     if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
         fd->func_var_idx = idx;
-        fd->vars[idx].var_kind = JS_VAR_FUNCTION_NAME;
+        fd->vars[idx].is_func_var = TRUE;
         if (fd->js_mode & JS_MODE_STRICT)
             fd->vars[idx].is_const = TRUE;
     }
     return idx;
 }
 
-static int add_arguments_var(JSContext *ctx, JSFunctionDef *fd)
+static int add_arguments_var(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
 {
     int idx = fd->arguments_var_idx;
-    if (idx < 0 && (idx = add_var(ctx, fd, JS_ATOM_arguments)) >= 0) {
+    if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
         fd->arguments_var_idx = idx;
     }
     return idx;
 }
 
-/* add an argument definition in the argument scope. Only needed when
-   "eval()" may be called in the argument scope. Return 0 if OK. */
-static int add_arguments_arg(JSContext *ctx, JSFunctionDef *fd)
-{
-    int idx;
-    if (fd->arguments_arg_idx < 0) {
-        idx = find_var_in_scope(ctx, fd, JS_ATOM_arguments, ARG_SCOPE_INDEX);
-        if (idx < 0) {
-            /* XXX: the scope links are not fully updated. May be an
-               issue if there are child scopes of the argument
-               scope */
-            idx = add_var(ctx, fd, JS_ATOM_arguments);
-            if (idx < 0)
-                return -1;
-            fd->vars[idx].scope_next = fd->scopes[ARG_SCOPE_INDEX].first;
-            fd->scopes[ARG_SCOPE_INDEX].first = idx;
-            fd->vars[idx].scope_level = ARG_SCOPE_INDEX;
-            fd->vars[idx].is_lexical = TRUE;
-
-            fd->arguments_arg_idx = idx;
-        }
-    }
-    return 0;
-}
-
 static int add_arg(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
 {
     JSVarDef *vd;
@@ -21933,33 +20469,56 @@ static int add_arg(JSContext *ctx, JSFunctionDef *fd, JSAtom name)
         JS_ThrowInternalError(ctx, "too many arguments");
         return -1;
     }
-    if (js_resize_array(ctx, (void **)&fd->args, sizeof(fd->args[0]),
-                        &fd->arg_size, fd->arg_count + 1))
-        return -1;
+    if ((fd->arg_count + 1) > fd->arg_size) {
+        int new_size;
+        size_t slack;
+        JSVarDef *new_buf;
+        new_size = max_int(fd->arg_count + 1, fd->arg_size * 3 / 2);
+        new_buf = js_realloc2(ctx, fd->args, new_size * sizeof(*fd->args), &slack);
+        if (!new_buf)
+            return -1;
+        new_size += slack / sizeof(*new_buf);
+        fd->args = new_buf;
+        fd->arg_size = new_size;
+    }
     vd = &fd->args[fd->arg_count++];
     memset(vd, 0, sizeof(*vd));
     vd->var_name = JS_DupAtom(ctx, name);
-    vd->func_pool_idx = -1;
     return fd->arg_count - 1;
 }
 
-/* add a global variable definition */
-static JSGlobalVar *add_global_var(JSContext *ctx, JSFunctionDef *s,
-                                     JSAtom name)
+/* add a Hoisted definition for a function (cpool_idx >= 0) or a
+   global variable (cpool_idx = -1) */
+static JSHoistedDef *add_hoisted_def(JSContext *ctx,
+                                     JSFunctionDef *s, int cpool_idx,
+                                     JSAtom name, int var_idx, BOOL is_lexical)
 {
-    JSGlobalVar *hf;
+    JSHoistedDef *hf;
 
-    if (js_resize_array(ctx, (void **)&s->global_vars,
-                        sizeof(s->global_vars[0]),
-                        &s->global_var_size, s->global_var_count + 1))
-        return NULL;
-    hf = &s->global_vars[s->global_var_count++];
-    hf->cpool_idx = -1;
-    hf->force_init = FALSE;
-    hf->is_lexical = FALSE;
+    if (s->hoisted_def_count >= s->hoisted_def_size) {
+        int new_size;
+        size_t slack;
+        JSHoistedDef *new_tab;
+        new_size = max_int(s->hoisted_def_count + 1,
+                           s->hoisted_def_size * 3 / 2);
+        new_tab = js_realloc2(ctx, s->hoisted_def, new_size * sizeof(s->hoisted_def[0]), &slack);
+        if (!new_tab)
+            return NULL;
+        new_size += slack / sizeof(*new_tab);
+        s->hoisted_def = new_tab;
+        s->hoisted_def_size = new_size;
+    }
+    hf = &s->hoisted_def[s->hoisted_def_count++];
+    hf->cpool_idx = cpool_idx;
+    hf->force_init = 0;
+    hf->is_lexical = is_lexical;
     hf->is_const = FALSE;
+    hf->var_idx = var_idx;
     hf->scope_level = s->scope_level;
-    hf->var_name = JS_DupAtom(ctx, name);
+    hf->var_name = JS_ATOM_NULL;
+    if (name != JS_ATOM_NULL) {
+        hf->var_name = JS_DupAtom(ctx, name);
+    }
     return hf;
 }
 
@@ -22004,7 +20563,7 @@ static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
                     goto redef_lex_error;
                 }
             } else {
-                if (fd->scope_level == fd->body_scope) {
+                if (fd->scope_level == 1) {
                 redef_lex_error:
                     /* redefining a scoped var in the same scope: error */
                     return js_parse_error(s, "invalid redefinition of lexical identifier");
@@ -22013,7 +20572,7 @@ static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
         }
         if (var_def_type != JS_VAR_DEF_FUNCTION_DECL &&
             var_def_type != JS_VAR_DEF_NEW_FUNCTION_DECL &&
-            fd->scope_level == fd->body_scope &&
+            fd->scope_level == 1 &&
             find_arg(ctx, fd, name) >= 0) {
             /* lexical variable redefines a parameter name */
             return js_parse_error(s, "invalid redefinition of parameter name");
@@ -22024,8 +20583,8 @@ static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
         }
         
         if (fd->is_global_var) {
-            JSGlobalVar *hf;
-            hf = find_global_var(fd, name);
+            JSHoistedDef *hf;
+            hf = find_hoisted_def(fd, name);
             if (hf && is_child_scope(ctx, fd, hf->scope_level,
                                      fd->scope_level)) {
                 return js_parse_error(s, "invalid redefinition of global identifier");
@@ -22035,12 +20594,11 @@ static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
         if (fd->is_eval &&
             (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||
              fd->eval_type == JS_EVAL_TYPE_MODULE) &&
-            fd->scope_level == fd->body_scope) {
-            JSGlobalVar *hf;
-            hf = add_global_var(s->ctx, fd, name);
+            fd->scope_level == 1) {
+            JSHoistedDef *hf;
+            hf = add_hoisted_def(s->ctx, fd, -1, name, -1, TRUE);
             if (!hf)
                 return -1;
-            hf->is_lexical = TRUE;
             hf->is_const = (var_def_type == JS_VAR_DEF_CONST);
             idx = GLOBAL_VAR_OFFSET;
         } else {
@@ -22072,13 +20630,13 @@ static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
             return js_parse_error(s, "invalid redefinition of lexical identifier");
         }
         if (fd->is_global_var) {
-            JSGlobalVar *hf;
-            hf = find_global_var(fd, name);
+            JSHoistedDef *hf;
+            hf = find_hoisted_def(fd, name);
             if (hf && hf->is_lexical && hf->scope_level == fd->scope_level &&
                 fd->eval_type == JS_EVAL_TYPE_MODULE) {
                 goto invalid_lexical_redefinition;
             }
-            hf = add_global_var(s->ctx, fd, name);
+            hf = add_hoisted_def(s->ctx, fd, -1, name, -1, FALSE);
             if (!hf)
                 return -1;
             idx = GLOBAL_VAR_OFFSET;
@@ -22091,7 +20649,7 @@ static int define_var(JSParseState *s, JSFunctionDef *fd, JSAtom name,
             if (idx >= 0) {
                 if (name == JS_ATOM_arguments && fd->has_arguments_binding)
                     fd->arguments_var_idx = idx;
-                fd->vars[idx].scope_next = fd->scope_level;
+                fd->vars[idx].func_pool_or_scope_idx = fd->scope_level;
             }
         }
         break;
@@ -22133,9 +20691,8 @@ static __exception int js_parse_function_decl2(JSParseState *s,
                                                int function_line_num,
                                                JSParseExportEnum export_flag,
                                                JSFunctionDef **pfd);
-static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags);
-static __exception int js_parse_assign_expr(JSParseState *s);
-static __exception int js_parse_unary(JSParseState *s, int parse_flags);
+static __exception int js_parse_assign_expr(JSParseState *s, int in_accepted);
+static __exception int js_parse_unary(JSParseState *s, int exponentiation_flag);
 static void push_break_entry(JSFunctionDef *fd, BlockEnv *be,
                              JSAtom label_name,
                              int label_break, int label_cont,
@@ -22242,7 +20799,7 @@ static __exception int js_parse_template(JSParseState *s, int call, int *argc)
             goto done;
         if (next_token(s))
             return -1;
-        if (js_parse_expr(s))
+        if (js_parse_assign_expr(s, TRUE))
             return -1;
         depth++;
         if (s->token.val != '}') {
@@ -22250,8 +20807,7 @@ static __exception int js_parse_template(JSParseState *s, int call, int *argc)
         }
         /* XXX: should convert to string at this stage? */
         free_token(s, &s->token);
-        /* Resume TOK_TEMPLATE parsing (s->token.line_num and
-         * s->token.ptr are OK) */
+        /* Resume TOK_TEMPLATE parsing (s->token.line_num and s->token.ptr are OK) */
         s->got_lf = FALSE;
         s->last_line_num = s->token.line_num;
         if (js_parse_template_part(s, s->buf_ptr))
@@ -22371,11 +20927,10 @@ static int __exception js_parse_property_name(JSParseState *s,
 #ifdef CONFIG_BIGNUM
         if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
-            val = s->ctx->rt->bigfloat_ops.
-                mul_pow10_to_float64(s->ctx, &p->num,
-                                     s->token.u.num.exponent);
-            if (JS_IsException(val))
-                goto fail;
+            double d;
+            d = bf_mul_pow10_to_float64(s->ctx, &p->num,
+                                        s->token.u.num.exponent);
+            val = __JS_NewFloat64(s->ctx, d);
             name = JS_ValueToAtom(s->ctx, val);
             JS_FreeValue(s->ctx, val);
         } else
@@ -22467,9 +21022,8 @@ static BOOL is_regexp_allowed(int tok)
     }
 }
 
-#define SKIP_HAS_SEMI       (1 << 0)
-#define SKIP_HAS_ELLIPSIS   (1 << 1)
-#define SKIP_HAS_ASSIGNMENT (1 << 2)
+#define SKIP_HAS_SEMI      (1 << 0)
+#define SKIP_HAS_ELLIPSIS  (1 << 1)
 
 /* XXX: improve speed with early bailout */
 /* XXX: no longer works if regexps are present. Could use previous
@@ -22480,7 +21034,7 @@ static int js_parse_skip_parens_token(JSParseState *s, int *pbits, BOOL no_line_
     size_t level = 0;
     JSParsePos pos;
     int last_tok, tok = TOK_EOF;
-    int c, tok_len, bits = 0;
+    int tok_len, bits = 0;
 
     /* protect from underflow */
     state[level++] = 0;
@@ -22505,30 +21059,8 @@ static int js_parse_skip_parens_token(JSParseState *s, int *pbits, BOOL no_line_
                 goto done;
             break;
         case '}':
-            c = state[--level];
-            if (c == '`') {
-                /* continue the parsing of the template */
-                free_token(s, &s->token);
-                /* Resume TOK_TEMPLATE parsing (s->token.line_num and
-                 * s->token.ptr are OK) */
-                s->got_lf = FALSE;
-                s->last_line_num = s->token.line_num;
-                if (js_parse_template_part(s, s->buf_ptr))
-                    goto done;
-                goto handle_template;
-            } else if (c != '{') {
+            if (state[--level] != '{')
                 goto done;
-            }
-            break;
-        case TOK_TEMPLATE:
-        handle_template:
-            if (s->token.u.str.sep != '`') {
-                /* '${' inside the template : closing '}' and continue
-                   parsing the template */
-                if (level >= sizeof(state))
-                    goto done;
-                state[level++] = '`';
-            } 
             break;
         case TOK_EOF:
             goto done;
@@ -22542,10 +21074,7 @@ static int js_parse_skip_parens_token(JSParseState *s, int *pbits, BOOL no_line_
                 bits |= SKIP_HAS_ELLIPSIS;
             }
             break;
-        case '=':
-            bits |= SKIP_HAS_ASSIGNMENT;
-            break;
-            
+
         case TOK_DIV_ASSIGN:
             tok_len = 2;
             goto parse_regexp;
@@ -22660,7 +21189,7 @@ static __exception int js_parse_object_literal(JSParseState *s)
         if (s->token.val == TOK_ELLIPSIS) {
             if (next_token(s))
                 return -1;
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 return -1;
             emit_op(s, OP_null);  /* dummy excludeList */
             emit_op(s, OP_copy_data_properties);
@@ -22719,7 +21248,7 @@ static __exception int js_parse_object_literal(JSParseState *s)
         } else {
             if (js_parse_expect(s, ':'))
                 goto fail;
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 goto fail;
             if (name == JS_ATOM_NULL) {
                 set_object_name_computed(s);
@@ -22754,25 +21283,10 @@ static __exception int js_parse_object_literal(JSParseState *s)
     return -1;
 }
 
-/* allow the 'in' binary operator */
-#define PF_IN_ACCEPTED  (1 << 0) 
-/* allow function calls parsing in js_parse_postfix_expr() */
-#define PF_POSTFIX_CALL (1 << 1) 
-/* allow arrow functions parsing in js_parse_postfix_expr() */
-#define PF_ARROW_FUNC   (1 << 2) 
-/* allow the exponentiation operator in js_parse_unary() */
-#define PF_POW_ALLOWED  (1 << 3) 
-/* forbid the exponentiation operator in js_parse_unary() */
-#define PF_POW_FORBIDDEN (1 << 4) 
-
-static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags);
-
-static __exception int js_parse_left_hand_side_expr(JSParseState *s)
-{
-    return js_parse_postfix_expr(s, PF_POSTFIX_CALL);
-}
+static __exception int js_parse_postfix_expr(JSParseState *s,
+                                             BOOL accept_lparen);
 
-/* XXX: could generate specific bytecode */
+/* XXX: is there is nicer solution ? */
 static __exception int js_parse_class_default_ctor(JSParseState *s,
                                                    BOOL has_super,
                                                    JSFunctionDef **pfd)
@@ -22785,8 +21299,7 @@ static __exception int js_parse_class_default_ctor(JSParseState *s,
     
     js_parse_get_pos(s, &pos);
     if (has_super) {
-        /* spec change: no argument evaluation */
-        str = "(){super(...arguments);}";
+        str = "(...a){super(...a);}";
         func_type = JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
     } else {
         str = "(){}";
@@ -22975,7 +21488,8 @@ static __exception int js_parse_class(JSParseState *s, BOOL is_class_expr,
         class_flags = JS_DEFINE_CLASS_HAS_HERITAGE;
         if (next_token(s))
             goto fail;
-        if (js_parse_left_hand_side_expr(s))
+        /* XXX: the grammar only allows LeftHandSideExpression */
+        if (js_parse_postfix_expr(s, TRUE))
             goto fail;
     } else {
         emit_op(s, OP_undefined);
@@ -23027,25 +21541,16 @@ static __exception int js_parse_class(JSParseState *s, BOOL is_class_expr,
             continue;
         }
         is_static = (s->token.val == TOK_STATIC);
-        prop_type = -1;
         if (is_static) {
             if (next_token(s))
                 goto fail;
-            /* allow "static" field name */
-            if (s->token.val == ';' || s->token.val == '=') {
-                is_static = FALSE;
-                name = JS_DupAtom(ctx, JS_ATOM_static);
-                prop_type = PROP_TYPE_IDENT;
-            }
         }
         if (is_static)
             emit_op(s, OP_swap);
         start_ptr = s->token.ptr;
-        if (prop_type < 0) {
-            prop_type = js_parse_property_name(s, &name, TRUE, FALSE, TRUE);
-            if (prop_type < 0)
-                goto fail;
-        }
+        prop_type = js_parse_property_name(s, &name, TRUE, FALSE, TRUE);
+        if (prop_type < 0)
+            goto fail;
         is_private = prop_type & PROP_TYPE_PRIVATE;
         prop_type &= ~PROP_TYPE_PRIVATE;
         
@@ -23182,7 +21687,7 @@ static __exception int js_parse_class(JSParseState *s, BOOL is_class_expr,
             if (s->token.val == '=') {
                 if (next_token(s))
                     goto fail;
-                if (js_parse_assign_expr(s))
+                if (js_parse_assign_expr(s, TRUE))
                     goto fail;
             } else {
                 emit_op(s, OP_undefined);
@@ -23386,7 +21891,7 @@ static __exception int js_parse_array_literal(JSParseState *s)
     while (s->token.val != ']' && idx < 32) {
         if (s->token.val == ',' || s->token.val == TOK_ELLIPSIS)
             break;
-        if (js_parse_assign_expr(s))
+        if (js_parse_assign_expr(s, TRUE))
             return -1;
         idx++;
         /* accept trailing comma */
@@ -23407,7 +21912,7 @@ static __exception int js_parse_array_literal(JSParseState *s)
             break;
         need_length = TRUE;
         if (s->token.val != ',') {
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 return -1;
             emit_op(s, OP_define_field);
             emit_u32(s, __JS_AtomFromUInt32(idx));
@@ -23442,7 +21947,7 @@ static __exception int js_parse_array_literal(JSParseState *s)
         if (s->token.val == TOK_ELLIPSIS) {
             if (next_token(s))
                 return -1;
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 return -1;
 #if 1
             emit_op(s, OP_append);
@@ -23474,7 +21979,7 @@ static __exception int js_parse_array_literal(JSParseState *s)
         } else {
             need_length = TRUE;
             if (s->token.val != ',') {
-                if (js_parse_assign_expr(s))
+                if (js_parse_assign_expr(s, TRUE))
                     return -1;
                 /* a idx val */
                 emit_op(s, OP_define_array_el);
@@ -23520,6 +22025,15 @@ static BOOL has_with_scope(JSFunctionDef *s, int scope_level)
     return FALSE;
 }
 
+typedef struct JSLValue {
+    int opcode;
+    int scope;
+    int label;
+    int depth;
+    int tok;
+    JSAtom name;
+} JSLValue;
+
 static __exception int get_lvalue(JSParseState *s, int *popcode, int *pscope,
                                   JSAtom *pname, int *plabel, int *pdepth, BOOL keep,
                                   int tok)
@@ -23644,112 +22158,84 @@ static __exception int get_lvalue(JSParseState *s, int *popcode, int *pscope,
     return 0;
 }
 
-typedef enum {
-    PUT_LVALUE_NOKEEP, /* [depth] v -> */
-    PUT_LVALUE_NOKEEP_DEPTH, /* [depth] v -> , keep depth (currently
-                                just disable optimizations) */
-    PUT_LVALUE_KEEP_TOP,  /* [depth] v -> v */
-    PUT_LVALUE_KEEP_SECOND, /* [depth] v0 v -> v0 */
-    PUT_LVALUE_NOKEEP_BOTTOM, /* v [depth] -> */
-} PutLValueEnum;
-
-/* name has a live reference. 'is_let' is only used with opcode =
-   OP_scope_get_var which is never generated by get_lvalue(). */
+/* if special = TRUE: specific post inc/dec case */
+/* name has a live reference */
 static void put_lvalue(JSParseState *s, int opcode, int scope,
-                       JSAtom name, int label, PutLValueEnum special,
-                       BOOL is_let)
+                       JSAtom name, int label, BOOL special)
 {
     switch(opcode) {
     case OP_get_field:
+        if (!special)
+            emit_op(s, OP_insert2); /* obj v -> v obj v */
+        else
+            emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */
+        emit_op(s, OP_put_field);
+        emit_u32(s, name);  /* name has refcount */
+        break;
     case OP_scope_get_private_field:
-        /* depth = 1 */
-        switch(special) {
-        case PUT_LVALUE_NOKEEP:
-        case PUT_LVALUE_NOKEEP_DEPTH:
-            break;
-        case PUT_LVALUE_KEEP_TOP:
+        if (!special)
             emit_op(s, OP_insert2); /* obj v -> v obj v */
-            break;
-        case PUT_LVALUE_KEEP_SECOND:
+        else
             emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */
-            break;
-        case PUT_LVALUE_NOKEEP_BOTTOM:
-            emit_op(s, OP_swap);
-            break;
-        default:
-            abort();
-        }
+        emit_op(s, OP_scope_put_private_field);
+        emit_u32(s, name);  /* name has refcount */
+        emit_u16(s, scope);
         break;
     case OP_get_array_el:
+        if (!special)
+            emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */
+        else
+            emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */
+        emit_op(s, OP_put_array_el);
+        break;
     case OP_get_ref_value:
-        /* depth = 2 */
-        if (opcode == OP_get_ref_value) {
-            JS_FreeAtom(s->ctx, name);
-            emit_label(s, label);
-        }
-        switch(special) {
-        case PUT_LVALUE_NOKEEP:
-            emit_op(s, OP_nop); /* will trigger optimization */
-            break;
-        case PUT_LVALUE_NOKEEP_DEPTH:
-            break;
-        case PUT_LVALUE_KEEP_TOP:
+        JS_FreeAtom(s->ctx, name);
+        emit_label(s, label);
+        if (!special)
             emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */
-            break;
-        case PUT_LVALUE_KEEP_SECOND:
+        else
             emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */
-            break;
-        case PUT_LVALUE_NOKEEP_BOTTOM:
-            emit_op(s, OP_rot3l);
-            break;
-        default:
-            abort();
-        }
+        emit_op(s, OP_put_ref_value);
         break;
     case OP_get_super_value:
-        /* depth = 3 */
-        switch(special) {
-        case PUT_LVALUE_NOKEEP:
-        case PUT_LVALUE_NOKEEP_DEPTH:
-            break;
-        case PUT_LVALUE_KEEP_TOP:
+        if (!special)
             emit_op(s, OP_insert4); /* this obj prop v -> v this obj prop v */
-            break;
-        case PUT_LVALUE_KEEP_SECOND:
+        else
             emit_op(s, OP_perm5); /* this obj prop v0 v -> v0 this obj prop v */
-            break;
-        case PUT_LVALUE_NOKEEP_BOTTOM:
-            emit_op(s, OP_rot4l);
-            break;
-        default:
-            abort();
-        }
+        emit_op(s, OP_put_super_value);
         break;
     default:
-        break;
+        abort();
     }
-    
+}
+
+static void put_lvalue_nokeep(JSParseState *s, int opcode, int scope,
+                              JSAtom name, int label, int var_tok)
+{
     switch(opcode) {
     case OP_scope_get_var:  /* val -- */
-        assert(special == PUT_LVALUE_NOKEEP ||
-               special == PUT_LVALUE_NOKEEP_DEPTH);
-        emit_op(s, is_let ? OP_scope_put_var_init : OP_scope_put_var);
+        emit_op(s, (var_tok == TOK_CONST || var_tok == TOK_LET) ?
+                OP_scope_put_var_init : OP_scope_put_var);
         emit_u32(s, name);  /* has refcount */
         emit_u16(s, scope);
         break;
-    case OP_get_field:
+    case OP_get_field:      /* obj val -- */
         emit_op(s, OP_put_field);
-        emit_u32(s, name);  /* name has refcount */
+        emit_u32(s, name);  /* has refcount */
         break;
     case OP_scope_get_private_field:
         emit_op(s, OP_scope_put_private_field);
-        emit_u32(s, name);  /* name has refcount */
+        emit_u32(s, name);  /* has refcount */
         emit_u16(s, scope);
         break;
-    case OP_get_array_el:
+    case OP_get_array_el:   /* obj prop val -- */
         emit_op(s, OP_put_array_el);
         break;
-    case OP_get_ref_value:
+    case OP_get_ref_value:   /* obj prop val -- */
+        /* XXX: currently this reference is never optimized */
+        JS_FreeAtom(s->ctx, name);
+        emit_label(s, label);
+        //emit_op(s, OP_nop);   /* emit 2 bytes for optimizer */
         emit_op(s, OP_put_ref_value);
         break;
     case OP_get_super_value:
@@ -23860,7 +22346,7 @@ duplicate:
     return js_parse_error(s, "duplicate parameter names not allowed in this context");
 }
 
-static JSAtom js_parse_destructuring_var(JSParseState *s, int tok, int is_arg)
+static JSAtom js_parse_destructing_var(JSParseState *s, int tok, int is_arg)
 {
     JSAtom name;
 
@@ -23882,9 +22368,7 @@ fail:
     return JS_ATOM_NULL;
 }
 
-/* Return -1 if error, 0 if no initializer, 1 if an initializer is
-   present at the top level. */
-static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
+static int js_parse_destructing_element(JSParseState *s, int tok, int is_arg,
                                         int hasval, int has_ellipsis,
                                         BOOL allow_initializer)
 {
@@ -23892,8 +22376,7 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
     int start_addr, assign_addr;
     JSAtom prop_name, var_name;
     int opcode, scope, tok1, skip_bits;
-    BOOL has_initializer;
-    
+
     if (has_ellipsis < 0) {
         /* pre-parse destructuration target for spread detection */
         js_parse_skip_parens_token(s, &skip_bits, FALSE);
@@ -23938,7 +22421,7 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                 if (next_token(s))
                     return -1;
                 if (tok) {
-                    var_name = js_parse_destructuring_var(s, tok, is_arg);
+                    var_name = js_parse_destructing_var(s, tok, is_arg);
                     if (var_name == JS_ATOM_NULL)
                         return -1;
                     opcode = OP_scope_get_var;
@@ -23946,7 +22429,7 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                     label_lvalue = -1;
                     depth_lvalue = 0;
                 } else {
-                    if (js_parse_left_hand_side_expr(s))
+                    if (js_parse_postfix_expr(s, TRUE))
                         return -1;
 
                     if (get_lvalue(s, &opcode, &scope, &var_name,
@@ -24002,7 +22485,7 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                         emit_op(s, OP_get_field2);
                         emit_u32(s, prop_name);
                     }
-                    if (js_parse_destructuring_element(s, tok, is_arg, TRUE, -1, TRUE) < 0)
+                    if (js_parse_destructing_element(s, tok, is_arg, TRUE, -1, TRUE))
                         return -1;
                     if (s->token.val == '}')
                         break;
@@ -24035,11 +22518,11 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                     emit_op(s, OP_dup);
                 }
                 if (tok) {
-                    var_name = js_parse_destructuring_var(s, tok, is_arg);
+                    var_name = js_parse_destructing_var(s, tok, is_arg);
                     if (var_name == JS_ATOM_NULL)
                         goto prop_error;
                 } else {
-                    if (js_parse_left_hand_side_expr(s))
+                    if (js_parse_postfix_expr(s, TRUE))
                         goto prop_error;
                 lvalue:
                     if (get_lvalue(s, &opcode, &scope, &var_name,
@@ -24137,16 +22620,14 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                 if (next_token(s))
                     goto var_error;
                 emit_op(s, OP_drop);
-                if (js_parse_assign_expr(s))
+                if (js_parse_assign_expr(s, TRUE))
                     goto var_error;
                 if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
                     set_object_name(s, var_name);
                 emit_label(s, label_hasval);
             }
             /* store value into lvalue object */
-            put_lvalue(s, opcode, scope, var_name, label_lvalue,
-                       PUT_LVALUE_NOKEEP_DEPTH,
-                       (tok == TOK_CONST || tok == TOK_LET));
+            put_lvalue_nokeep(s, opcode, scope, var_name, label_lvalue, tok);
             if (s->token.val == '}')
                 break;
             /* accept a trailing comma before the '}' */
@@ -24201,13 +22682,13 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                     emit_u8(s, 0);
                     emit_op(s, OP_drop);
                 }
-                if (js_parse_destructuring_element(s, tok, is_arg, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
+                if (js_parse_destructing_element(s, tok, is_arg, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE))
                     return -1;
             } else {
                 var_name = JS_ATOM_NULL;
                 enum_depth = 0;
                 if (tok) {
-                    var_name = js_parse_destructuring_var(s, tok, is_arg);
+                    var_name = js_parse_destructing_var(s, tok, is_arg);
                     if (var_name == JS_ATOM_NULL)
                         goto var_error;
                     if (js_define_var(s, var_name, tok))
@@ -24215,7 +22696,7 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                     opcode = OP_scope_get_var;
                     scope = s->cur_func->scope_level;
                 } else {
-                    if (js_parse_left_hand_side_expr(s))
+                    if (js_parse_postfix_expr(s, TRUE))
                         return -1;
                     if (get_lvalue(s, &opcode, &scope, &var_name,
                                    &label_lvalue, &enum_depth, FALSE, '[')) {
@@ -24239,16 +22720,15 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
                     if (next_token(s))
                         goto var_error;
                     emit_op(s, OP_drop);
-                    if (js_parse_assign_expr(s))
+                    if (js_parse_assign_expr(s, TRUE))
                         goto var_error;
                     if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
                         set_object_name(s, var_name);
                     emit_label(s, label_hasval);
                 }
                 /* store value into lvalue object */
-                put_lvalue(s, opcode, scope, var_name,
-                           label_lvalue, PUT_LVALUE_NOKEEP_DEPTH,
-                           (tok == TOK_CONST || tok == TOK_LET));
+                put_lvalue_nokeep(s, opcode, scope, var_name,
+                                  label_lvalue, tok);
             }
             if (s->token.val == ']')
                 break;
@@ -24274,26 +22754,18 @@ static int js_parse_destructuring_element(JSParseState *s, int tok, int is_arg,
         emit_label(s, label_parse);
         if (hasval)
             emit_op(s, OP_drop);
-        if (js_parse_assign_expr(s))
+        if (js_parse_assign_expr(s, TRUE))
             return -1;
         emit_goto(s, OP_goto, label_assign);
         emit_label(s, label_done);
-        has_initializer = TRUE;
     } else {
-        /* normally hasval is true except if
-           js_parse_skip_parens_token() was wrong in the parsing */
-        //        assert(hasval);
-        if (!hasval) {
-            js_parse_error(s, "too complicated destructuring expression");
-            return -1;
-        }
+        assert(hasval);
         /* remove test and decrement label ref count */
         memset(s->cur_func->byte_code.buf + start_addr, OP_nop,
                assign_addr - start_addr);
         s->cur_func->label_slots[label_parse].ref_count--;
-        has_initializer = FALSE;
     }
-    return has_initializer;
+    return 0;
 
  prop_error:
     JS_FreeAtom(s->ctx, prop_name);
@@ -24309,30 +22781,10 @@ typedef enum FuncCallType {
     FUNC_CALL_TEMPLATE,
 } FuncCallType;
 
-static void optional_chain_test(JSParseState *s, int *poptional_chaining_label,
-                                int drop_count)
-{
-    int label_next, i;
-    if (*poptional_chaining_label < 0)
-        *poptional_chaining_label = new_label(s);
-   /* XXX: could be more efficient with a specific opcode */
-    emit_op(s, OP_dup);
-    emit_op(s, OP_is_undefined_or_null);
-    label_next = emit_goto(s, OP_if_false, -1);
-    for(i = 0; i < drop_count; i++)
-        emit_op(s, OP_drop);
-    emit_op(s, OP_undefined);
-    emit_goto(s, OP_goto, *poptional_chaining_label);
-    emit_label(s, label_next);
-}
-
-/* allowed parse_flags: PF_POSTFIX_CALL, PF_ARROW_FUNC */
-static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
+static __exception int js_parse_postfix_expr(JSParseState *s, BOOL accept_lparen)
 {
     FuncCallType call_type;
-    int optional_chaining_label;
-    BOOL accept_lparen = (parse_flags & PF_POSTFIX_CALL) != 0;
-    
+
     call_type = FUNC_CALL_NORMAL;
     switch(s->token.val) {
     case TOK_NUMBER:
@@ -24346,6 +22798,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
             } else
 #ifdef CONFIG_BIGNUM
             if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {
+                bf_t r_s, *r = &r_s;
                 slimb_t e;
                 int ret;
 
@@ -24359,9 +22812,9 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                     emit_op(s, OP_push_i32);
                     emit_u32(s, e);
                 } else {
-                    val = JS_NewBigInt64_1(s->ctx, e);
-                    if (JS_IsException(val))
-                        return -1;
+                    bf_init(s->ctx->bf_ctx, r);
+                    bf_set_si(r, e);
+                    val = JS_NewBigInt(s->ctx, r);
                     ret = emit_push_const(s, val, 0);
                     JS_FreeValue(s->ctx, val);
                     if (ret < 0)
@@ -24397,7 +22850,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
     parse_regexp:
         {
             JSValue str;
-            int ret, backtrace_flags;
+            int ret;
             if (!s->ctx->compile_regexp)
                 return js_parse_error(s, "RegExp are not supported");
             /* the previous token is '/' or '/=', so no need to free */
@@ -24408,12 +22861,8 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                                          s->token.u.regexp.flags);
             if (JS_IsException(str)) {
                 /* add the line number info */
-                backtrace_flags = 0;
-                if (s->cur_func && s->cur_func->backtrace_barrier)
-                    backtrace_flags = JS_BACKTRACE_FLAG_SINGLE_LEVEL;
-                build_backtrace(s->ctx, s->ctx->rt->current_exception,
-                                s->filename, s->token.line_num,
-                                backtrace_flags);
+                build_backtrace(s->ctx, s->ctx->current_exception,
+                                s->filename, s->token.line_num, NULL);
                 return -1;
             }
             ret = emit_push_const(s, str, 0);
@@ -24429,8 +22878,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
         }
         break;
     case '(':
-        if ((parse_flags & PF_ARROW_FUNC) &&
-            js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
+        if (js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
             if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
                                        JS_FUNC_NORMAL, JS_ATOM_NULL,
                                        s->token.ptr, s->token.line_num))
@@ -24478,8 +22926,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
             if (s->token.u.ident.is_reserved) {
                 return js_parse_error_reserved_identifier(s);
             }
-            if ((parse_flags & PF_ARROW_FUNC) &&
-                peek_token(s, TRUE) == TOK_ARROW) {
+            if (peek_token(s, TRUE) == TOK_ARROW) {
                 if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
                                            JS_FUNC_NORMAL, JS_ATOM_NULL,
                                            s->token.ptr, s->token.line_num))
@@ -24498,11 +22945,10 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                                                JS_FUNC_ASYNC, JS_ATOM_NULL,
                                                source_ptr, source_line_num))
                         return -1;
-                } else if ((parse_flags & PF_ARROW_FUNC) &&
-                           ((s->token.val == '(' &&
-                             js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||
-                            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
-                             peek_token(s, TRUE) == TOK_ARROW))) {
+                } else if ((s->token.val == '(' &&
+                            js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||
+                           (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
+                            peek_token(s, TRUE) == TOK_ARROW)) {
                     if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
                                                JS_FUNC_ASYNC, JS_ATOM_NULL,
                                                source_ptr, source_line_num))
@@ -24532,7 +22978,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
         {
             int skip_bits;
             if (js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
-                if (js_parse_destructuring_element(s, 0, 0, FALSE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
+                if (js_parse_destructing_element(s, 0, 0, FALSE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE))
                     return -1;
             } else {
                 if (s->token.val == '{') {
@@ -24561,7 +23007,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
             emit_atom(s, JS_ATOM_new_target);
             emit_u16(s, 0);
         } else {
-            if (js_parse_postfix_expr(s, 0))
+            if (js_parse_postfix_expr(s, FALSE))
                 return -1;
             accept_lparen = TRUE;
             if (s->token.val != '(') {
@@ -24614,7 +23060,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                 return -1;
             if (!accept_lparen)
                 return js_parse_error(s, "invalid use of 'import()'");
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 return -1;
             if (js_parse_expect(s, ')'))
                 return -1;
@@ -24626,55 +23072,35 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                               (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
     }
 
-    optional_chaining_label = -1;
     for(;;) {
         JSFunctionDef *fd = s->cur_func;
-        BOOL has_optional_chain = FALSE;
-        
-        if (s->token.val == TOK_QUESTION_MARK_DOT) {
-            /* optional chaining */
-            if (next_token(s))
-                return -1;
-            has_optional_chain = TRUE;
-            if (s->token.val == '(' && accept_lparen) {
-                goto parse_func_call;
-            } else if (s->token.val == '[') {
-                goto parse_array_access;
-            } else {
-                goto parse_property;
-            }
-        } else if (s->token.val == TOK_TEMPLATE &&
-                   call_type == FUNC_CALL_NORMAL) {
-            if (optional_chaining_label >= 0) {
-                return js_parse_error(s, "template literal cannot appear in an optional chain");
-            }
+
+        if (s->token.val == TOK_TEMPLATE && call_type == FUNC_CALL_NORMAL) {
             call_type = FUNC_CALL_TEMPLATE;
-            goto parse_func_call2;
-        } else if (s->token.val == '(' && accept_lparen) {
-            int opcode, arg_count, drop_count;
+            goto parse_func_call;
+        }
+        if (s->token.val == '(' && accept_lparen) {
+            int opcode;
+            int arg_count;
 
             /* function call */
-        parse_func_call:
             if (next_token(s))
                 return -1;
 
             if (call_type == FUNC_CALL_NORMAL) {
-            parse_func_call2:
+            parse_func_call:
                 switch(opcode = get_prev_opcode(fd)) {
                 case OP_get_field:
                     /* keep the object on the stack */
                     fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
-                    drop_count = 2;
                     break;
                 case OP_scope_get_private_field:
                     /* keep the object on the stack */
                     fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_private_field2;
-                    drop_count = 2;
                     break;
                 case OP_get_array_el:
                     /* keep the object on the stack */
                     fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
-                    drop_count = 2;
                     break;
                 case OP_scope_get_var:
                     {
@@ -24682,7 +23108,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                         int scope;
                         name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
                         scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
-                        if (name == JS_ATOM_eval && call_type == FUNC_CALL_NORMAL && !has_optional_chain) {
+                        if (name == JS_ATOM_eval && call_type == FUNC_CALL_NORMAL) {
                             /* direct 'eval' */
                             opcode = OP_eval;
                         } else {
@@ -24699,24 +23125,17 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                                 fd->byte_code.buf[fd->last_opcode_pos] = opcode;
                             }
                         }
-                        drop_count = 1;
                     }
                     break;
                 case OP_get_super_value:
                     fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el;
                     /* on stack: this func_obj */
                     opcode = OP_get_array_el;
-                    drop_count = 2;
                     break;
                 default:
                     opcode = OP_invalid;
-                    drop_count = 1;
                     break;
                 }
-                if (has_optional_chain) {
-                    optional_chain_test(s, &optional_chaining_label,
-                                        drop_count);
-                }
             } else {
                 opcode = OP_invalid;
             }
@@ -24730,7 +23149,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                 emit_atom(s, JS_ATOM_this_active_func);
                 emit_u16(s, 0);
 
-                emit_op(s, OP_get_super);
+                emit_op(s, OP_get_super_ctor);
 
                 emit_op(s, OP_scope_get_var);
                 emit_atom(s, JS_ATOM_new_target);
@@ -24747,7 +23166,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                 }
                 if (s->token.val == TOK_ELLIPSIS)
                     break;
-                if (js_parse_assign_expr(s))
+                if (js_parse_assign_expr(s, TRUE))
                     return -1;
                 arg_count++;
                 if (s->token.val == ')')
@@ -24767,7 +23186,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                     if (s->token.val == TOK_ELLIPSIS) {
                         if (next_token(s))
                             return -1;
-                        if (js_parse_assign_expr(s))
+                        if (js_parse_assign_expr(s, TRUE))
                             return -1;
 #if 1
                         /* XXX: could pass is_last indicator? */
@@ -24798,7 +23217,7 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                         emit_op(s, OP_nip1);
 #endif
                     } else {
-                        if (js_parse_assign_expr(s))
+                        if (js_parse_assign_expr(s, TRUE))
                             return -1;
                         /* array idx val */
                         emit_op(s, OP_define_array_el);
@@ -24900,15 +23319,11 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
         } else if (s->token.val == '.') {
             if (next_token(s))
                 return -1;
-        parse_property:
             if (s->token.val == TOK_PRIVATE_NAME) {
                 /* private class field */
                 if (get_prev_opcode(fd) == OP_get_super) {
                     return js_parse_error(s, "private class field forbidden after super");
                 }
-                if (has_optional_chain) {
-                    optional_chain_test(s, &optional_chaining_label, 1);
-                }
                 emit_op(s, OP_scope_get_private_field);
                 emit_atom(s, s->token.u.ident.atom);
                 emit_u16(s, s->cur_func->scope_level);
@@ -24926,9 +23341,6 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                         return -1;
                     emit_op(s, OP_get_super_value);
                 } else {
-                    if (has_optional_chain) {
-                        optional_chain_test(s, &optional_chaining_label, 1);
-                    }
                     emit_op(s, OP_get_field);
                     emit_atom(s, s->token.u.ident.atom);
                 }
@@ -24937,14 +23349,9 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
                 return -1;
         } else if (s->token.val == '[') {
             int prev_op;
-
-        parse_array_access:
-            prev_op = get_prev_opcode(fd);
-            if (has_optional_chain) {
-                optional_chain_test(s, &optional_chaining_label, 1);
-            }
             if (next_token(s))
                 return -1;
+            prev_op = get_prev_opcode(fd);
             if (js_parse_expr(s))
                 return -1;
             if (js_parse_expect(s, ']'))
@@ -24954,12 +23361,20 @@ static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
             } else {
                 emit_op(s, OP_get_array_el);
             }
+        } else if (!s->got_lf && (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
+            int opcode, op, scope, label;
+            JSAtom name;
+            op = s->token.val;
+            if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
+                return -1;
+            emit_op(s, OP_post_dec + op - TOK_DEC);
+            put_lvalue(s, opcode, scope, name, label, TRUE);
+            if (next_token(s))
+                return -1;
         } else {
             break;
         }
     }
-    if (optional_chaining_label >= 0)
-        emit_label(s, optional_chaining_label);
     return 0;
 }
 
@@ -24971,7 +23386,7 @@ static __exception int js_parse_delete(JSParseState *s)
 
     if (next_token(s))
         return -1;
-    if (js_parse_unary(s, PF_POW_FORBIDDEN))
+    if (js_parse_unary(s, -1))
         return -1;
     switch(opcode = get_prev_opcode(fd)) {
     case OP_get_field:
@@ -25010,9 +23425,9 @@ static __exception int js_parse_delete(JSParseState *s)
     case OP_scope_get_private_field:
         return js_parse_error(s, "cannot delete a private class field");
     case OP_get_super_value:
-        emit_op(s, OP_throw_error);
+        emit_op(s, OP_throw_var);
         emit_atom(s, JS_ATOM_NULL);
-        emit_u8(s, JS_THROW_ERROR_DELETE_SUPER);
+        emit_u8(s, JS_THROW_VAR_DELETE_SUPER);
         break;
     default:
     ret_true:
@@ -25023,8 +23438,7 @@ static __exception int js_parse_delete(JSParseState *s)
     return 0;
 }
 
-/* allowed parse_flags: PF_ARROW_FUNC, PF_POW_ALLOWED, PF_POW_FORBIDDEN */
-static __exception int js_parse_unary(JSParseState *s, int parse_flags)
+static __exception int js_parse_unary(JSParseState *s, int exponentiation_flag)
 {
     int op;
 
@@ -25037,7 +23451,7 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
         op = s->token.val;
         if (next_token(s))
             return -1;
-        if (js_parse_unary(s, PF_POW_FORBIDDEN))
+        if (js_parse_unary(s, -1))
             return -1;
         switch(op) {
         case '-':
@@ -25059,7 +23473,7 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
         default:
             abort();
         }
-        parse_flags = 0;
+        exponentiation_flag = 0;
         break;
     case TOK_DEC:
     case TOK_INC:
@@ -25069,13 +23483,13 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
             op = s->token.val;
             if (next_token(s))
                 return -1;
+            /* XXX: should parse LeftHandSideExpression */
             if (js_parse_unary(s, 0))
                 return -1;
             if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
                 return -1;
             emit_op(s, OP_dec + op - TOK_DEC);
-            put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP,
-                       FALSE);
+            put_lvalue(s, opcode, scope, name, label, FALSE);
         }
         break;
     case TOK_TYPEOF:
@@ -25083,7 +23497,7 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
             JSFunctionDef *fd;
             if (next_token(s))
                 return -1;
-            if (js_parse_unary(s, PF_POW_FORBIDDEN))
+            if (js_parse_unary(s, -1))
                 return -1;
             /* reference access should not return an exception, so we
                patch the get_var */
@@ -25092,13 +23506,13 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
                 fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_var_undef;
             }
             emit_op(s, OP_typeof);
-            parse_flags = 0;
+            exponentiation_flag = 0;
         }
         break;
     case TOK_DELETE:
         if (js_parse_delete(s))
             return -1;
-        parse_flags = 0;
+        exponentiation_flag = 0;
         break;
     case TOK_AWAIT:
         if (!(s->cur_func->func_kind & JS_FUNC_ASYNC))
@@ -25107,47 +23521,36 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
             return js_parse_error(s, "await in default expression");
         if (next_token(s))
             return -1;
-        if (js_parse_unary(s, PF_POW_FORBIDDEN))
+        if (js_parse_unary(s, -1))
             return -1;
         emit_op(s, OP_await);
-        parse_flags = 0;
+        exponentiation_flag = 0;
         break;
     default:
-        if (js_parse_postfix_expr(s, (parse_flags & PF_ARROW_FUNC) |
-                                  PF_POSTFIX_CALL))
+        if (js_parse_postfix_expr(s, TRUE))
             return -1;
-        if (!s->got_lf &&
-            (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
-            int opcode, op, scope, label;
-            JSAtom name;
-            op = s->token.val;
-            if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
-                return -1;
-            emit_op(s, OP_post_dec + op - TOK_DEC);
-            put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,
-                       FALSE);
-            if (next_token(s))
-                return -1;        
-        }
         break;
     }
-    if (parse_flags & (PF_POW_ALLOWED | PF_POW_FORBIDDEN)) {
+    if (exponentiation_flag) {
 #ifdef CONFIG_BIGNUM
         if (s->token.val == TOK_POW || s->token.val == TOK_MATH_POW) {
             /* Extended exponentiation syntax rules: we extend the ES7
                grammar in order to have more intuitive semantics:
                -2**2 evaluates to -4. */
             if (!(s->cur_func->js_mode & JS_MODE_MATH)) {
-                if (parse_flags & PF_POW_FORBIDDEN) {
+                if (exponentiation_flag < 0) {
                     JS_ThrowSyntaxError(s->ctx, "unparenthesized unary expression can't appear on the left-hand side of '**'");
                     return -1;
                 }
             }
             if (next_token(s))
                 return -1;
-            if (js_parse_unary(s, PF_POW_ALLOWED))
+            if (js_parse_unary(s, 1))
                 return -1;
-            emit_op(s, OP_pow);
+            if (s->cur_func->js_mode & JS_MODE_MATH)
+                emit_op(s, OP_math_pow);
+            else
+                emit_op(s, OP_pow);
         }
 #else
         if (s->token.val == TOK_POW) {
@@ -25156,13 +23559,13 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
                regarding the precedence of prefix operators and the
                postifx exponential, ES7 specifies that -2**2 is a
                syntax error. */
-            if (parse_flags & PF_POW_FORBIDDEN) {
+            if (exponentiation_flag < 0) {
                 JS_ThrowSyntaxError(s->ctx, "unparenthesized unary expression can't appear on the left-hand side of '**'");
                 return -1;
             }
             if (next_token(s))
                 return -1;
-            if (js_parse_unary(s, PF_POW_ALLOWED))
+            if (js_parse_unary(s, 1))
                 return -1;
             emit_op(s, OP_pow);
         }
@@ -25171,17 +23574,15 @@ static __exception int js_parse_unary(JSParseState *s, int parse_flags)
     return 0;
 }
 
-/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
 static __exception int js_parse_expr_binary(JSParseState *s, int level,
-                                            int parse_flags)
+                                            BOOL in_accepted)
 {
     int op, opcode;
 
     if (level == 0) {
-        return js_parse_unary(s, (parse_flags & PF_ARROW_FUNC) |
-                              PF_POW_ALLOWED);
+        return js_parse_unary(s, 1);
     }
-    if (js_parse_expr_binary(s, level - 1, parse_flags))
+    if (js_parse_expr_binary(s, level - 1, in_accepted))
         return -1;
     for(;;) {
         op = s->token.val;
@@ -25192,7 +23593,12 @@ static __exception int js_parse_expr_binary(JSParseState *s, int level,
                 opcode = OP_mul;
                 break;
             case '/':
-                opcode = OP_div;
+#ifdef CONFIG_BIGNUM
+                if (s->cur_func->js_mode & JS_MODE_MATH)
+                    opcode = OP_math_div;
+                else
+#endif
+                    opcode = OP_div;
                 break;
             case '%':
 #ifdef CONFIG_BIGNUM
@@ -25251,7 +23657,7 @@ static __exception int js_parse_expr_binary(JSParseState *s, int level,
                 opcode = OP_instanceof;
                 break;
             case TOK_IN:
-                if (parse_flags & PF_IN_ACCEPTED) {
+                if (in_accepted) {
                     opcode = OP_in;
                 } else {
                     return 0;
@@ -25311,24 +23717,23 @@ static __exception int js_parse_expr_binary(JSParseState *s, int level,
         }
         if (next_token(s))
             return -1;
-        if (js_parse_expr_binary(s, level - 1, parse_flags & ~PF_ARROW_FUNC))
+        if (js_parse_expr_binary(s, level - 1, in_accepted))
             return -1;
         emit_op(s, opcode);
     }
     return 0;
 }
 
-/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
 static __exception int js_parse_logical_and_or(JSParseState *s, int op,
-                                               int parse_flags)
+                                               BOOL in_accepted)
 {
     int label1;
 
     if (op == TOK_LAND) {
-        if (js_parse_expr_binary(s, 8, parse_flags))
+        if (js_parse_expr_binary(s, 8, in_accepted))
             return -1;
     } else {
-        if (js_parse_logical_and_or(s, TOK_LAND, parse_flags))
+        if (js_parse_logical_and_or(s, TOK_LAND, in_accepted))
             return -1;
     }
     if (s->token.val == op) {
@@ -25342,18 +23747,14 @@ static __exception int js_parse_logical_and_or(JSParseState *s, int op,
             emit_op(s, OP_drop);
 
             if (op == TOK_LAND) {
-                if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
+                if (js_parse_expr_binary(s, 8, in_accepted))
                     return -1;
             } else {
-                if (js_parse_logical_and_or(s, TOK_LAND,
-                                            parse_flags & ~PF_ARROW_FUNC))
+                if (js_parse_logical_and_or(s, TOK_LAND, in_accepted))
                     return -1;
             }
-            if (s->token.val != op) {
-                if (s->token.val == TOK_DOUBLE_QUESTION_MARK)
-                    return js_parse_error(s, "cannot mix ?? with && or ||");
+            if (s->token.val != op)
                 break;
-            }
         }
 
         emit_label(s, label1);
@@ -25361,46 +23762,18 @@ static __exception int js_parse_logical_and_or(JSParseState *s, int op,
     return 0;
 }
 
-static __exception int js_parse_coalesce_expr(JSParseState *s, int parse_flags)
-{
-    int label1;
-    
-    if (js_parse_logical_and_or(s, TOK_LOR, parse_flags))
-        return -1;
-    if (s->token.val == TOK_DOUBLE_QUESTION_MARK) {
-        label1 = new_label(s);
-        for(;;) {
-            if (next_token(s))
-                return -1;
-            
-            emit_op(s, OP_dup);
-            emit_op(s, OP_is_undefined_or_null);
-            emit_goto(s, OP_if_false, label1);
-            emit_op(s, OP_drop);
-            
-            if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
-                return -1;
-            if (s->token.val != TOK_DOUBLE_QUESTION_MARK)
-                break;
-        }
-        emit_label(s, label1);
-    }
-    return 0;
-}
-
-/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
-static __exception int js_parse_cond_expr(JSParseState *s, int parse_flags)
+static __exception int js_parse_cond_expr(JSParseState *s, BOOL in_accepted)
 {
     int label1, label2;
 
-    if (js_parse_coalesce_expr(s, parse_flags))
+    if (js_parse_logical_and_or(s, TOK_LOR, in_accepted))
         return -1;
     if (s->token.val == '?') {
         if (next_token(s))
             return -1;
         label1 = emit_goto(s, OP_if_false, -1);
 
-        if (js_parse_assign_expr(s))
+        if (js_parse_assign_expr(s, TRUE))
             return -1;
         if (js_parse_expect(s, ':'))
             return -1;
@@ -25409,7 +23782,7 @@ static __exception int js_parse_cond_expr(JSParseState *s, int parse_flags)
 
         emit_label(s, label1);
 
-        if (js_parse_assign_expr2(s, parse_flags & PF_IN_ACCEPTED))
+        if (js_parse_assign_expr(s, in_accepted))
             return -1;
 
         emit_label(s, label2);
@@ -25419,16 +23792,14 @@ static __exception int js_parse_cond_expr(JSParseState *s, int parse_flags)
 
 static void emit_return(JSParseState *s, BOOL hasval);
 
-/* allowed parse_flags: PF_IN_ACCEPTED */
-static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)
+static __exception int js_parse_assign_expr(JSParseState *s, BOOL in_accepted)
 {
     int opcode, op, scope;
     JSAtom name0 = JS_ATOM_NULL;
     JSAtom name;
 
     if (s->token.val == TOK_YIELD) {
-        BOOL is_star = FALSE, is_async;
-        
+        BOOL is_star = FALSE;
         if (!(s->cur_func->func_kind & JS_FUNC_GENERATOR))
             return js_parse_error(s, "unexpected 'yield' keyword");
         if (!s->cur_func->in_function_body)
@@ -25445,120 +23816,109 @@ static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)
                 if (next_token(s))
                     return -1;
             }
-            if (js_parse_assign_expr2(s, parse_flags))
+            if (js_parse_assign_expr(s, in_accepted))
                 return -1;
         } else {
             emit_op(s, OP_undefined);
         }
-        is_async = (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR);
-
-        if (is_star) {
+        if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
             int label_loop, label_return, label_next;
             int label_return1, label_yield, label_throw, label_throw1;
             int label_throw2;
 
-            label_loop = new_label(s);
-            label_yield = new_label(s);
+            if (is_star) {
+                label_loop = new_label(s);
+                label_yield = new_label(s);
 
-            emit_op(s, is_async ? OP_for_await_of_start : OP_for_of_start);
+                emit_op(s, OP_for_await_of_start);
 
-            /* remove the catch offset (XXX: could avoid pushing back
-               undefined) */
-            emit_op(s, OP_drop);
-            emit_op(s, OP_undefined);
-            
-            emit_op(s, OP_undefined); /* initial value */
-            
-            emit_label(s, label_loop);
-            emit_op(s, OP_iterator_next);
-            if (is_async)
+                /* remove the catch offset (XXX: could avoid pushing back
+                   undefined) */
+                emit_op(s, OP_drop);
+                emit_op(s, OP_undefined);
+
+                emit_op(s, OP_undefined); /* initial value */
+
+                emit_label(s, label_loop);
+                emit_op(s, OP_async_iterator_next);
                 emit_op(s, OP_await);
-            emit_op(s, OP_iterator_check_object);
-            emit_op(s, OP_get_field2);
-            emit_atom(s, JS_ATOM_done);
-            label_next = emit_goto(s, OP_if_true, -1); /* end of loop */
-            emit_label(s, label_yield);
-            if (is_async) {
-                /* OP_async_yield_star takes the value as parameter */
-                emit_op(s, OP_get_field);
-                emit_atom(s, JS_ATOM_value);
+                emit_op(s, OP_iterator_get_value_done);
+                label_next = emit_goto(s, OP_if_true, -1); /* end of loop */
                 emit_op(s, OP_await);
+                emit_label(s, label_yield);
                 emit_op(s, OP_async_yield_star);
-            } else {
-                /* OP_yield_star takes (value, done) as parameter */
-                emit_op(s, OP_yield_star);
-            }
-            emit_op(s, OP_dup);
-            label_return = emit_goto(s, OP_if_true, -1);
-            emit_op(s, OP_drop);
-            emit_goto(s, OP_goto, label_loop);
-            
-            emit_label(s, label_return);
-            emit_op(s, OP_push_i32);
-            emit_u32(s, 2);
-            emit_op(s, OP_strict_eq);
-            label_throw = emit_goto(s, OP_if_true, -1);
-            
-            /* return handling */
-            if (is_async)
+                emit_op(s, OP_dup);
+                label_return = emit_goto(s, OP_if_true, -1);
+                emit_op(s, OP_drop);
+                emit_goto(s, OP_goto, label_loop);
+
+                emit_label(s, label_return);
+                emit_op(s, OP_push_i32);
+                emit_u32(s, 2);
+                emit_op(s, OP_strict_eq);
+                label_throw = emit_goto(s, OP_if_true, -1);
+
+                /* return handling */
                 emit_op(s, OP_await);
-            emit_op(s, OP_iterator_call);
-            emit_u8(s, 0);
-            label_return1 = emit_goto(s, OP_if_true, -1);
-            if (is_async)
+                emit_op(s, OP_async_iterator_get);
+                emit_u8(s, 0);
+                label_return1 = emit_goto(s, OP_if_true, -1);
                 emit_op(s, OP_await);
-            emit_op(s, OP_iterator_check_object);
-            emit_op(s, OP_get_field2);
-            emit_atom(s, JS_ATOM_done);
-            emit_goto(s, OP_if_false, label_yield);
-
-            emit_op(s, OP_get_field);
-            emit_atom(s, JS_ATOM_value);
-            
-            emit_label(s, label_return1);
-            emit_op(s, OP_nip);
-            emit_op(s, OP_nip);
-            emit_op(s, OP_nip);
-            emit_return(s, TRUE);
-            
-            /* throw handling */
-            emit_label(s, label_throw);
-            emit_op(s, OP_iterator_call);
-            emit_u8(s, 1);
-            label_throw1 = emit_goto(s, OP_if_true, -1);
-            if (is_async)
+                emit_op(s, OP_iterator_get_value_done);
+                /* XXX: the spec does not indicate that an await should be
+                   performed in case done = true, but the tests assume it */
+                emit_goto(s, OP_if_false, label_yield);
+
+                emit_label(s, label_return1);
+                emit_op(s, OP_nip);
+                emit_op(s, OP_nip);
+                emit_op(s, OP_nip);
+                emit_return(s, TRUE);
+
+                /* throw handling */
+                emit_label(s, label_throw);
+                emit_op(s, OP_async_iterator_get);
+                emit_u8(s, 1);
+                label_throw1 = emit_goto(s, OP_if_true, -1);
                 emit_op(s, OP_await);
-            emit_op(s, OP_iterator_check_object);
-            emit_op(s, OP_get_field2);
-            emit_atom(s, JS_ATOM_done);
-            emit_goto(s, OP_if_false, label_yield);
-            emit_goto(s, OP_goto, label_next);
-            /* close the iterator and throw a type error exception */
-            emit_label(s, label_throw1);
-            emit_op(s, OP_iterator_call);
-            emit_u8(s, 2);
-            label_throw2 = emit_goto(s, OP_if_true, -1);
-            if (is_async)
+                emit_op(s, OP_iterator_get_value_done);
+                emit_goto(s, OP_if_false, label_yield);
+                /* XXX: the spec does not indicate that an await should be
+                   performed in case done = true, but the tests assume it */
+                emit_op(s, OP_await);
+                emit_goto(s, OP_goto, label_next);
+                /* close the iterator and throw a type error exception */
+                emit_label(s, label_throw1);
+                emit_op(s, OP_async_iterator_get);
+                emit_u8(s, 0);
+                label_throw2 = emit_goto(s, OP_if_true, -1);
                 emit_op(s, OP_await);
-            emit_label(s, label_throw2);
+                emit_label(s, label_throw2);
+                emit_op(s, OP_async_iterator_get);
+                emit_u8(s, 2); /* throw the type error exception */
+                emit_op(s, OP_drop); /* never reached */
 
-            emit_op(s, OP_throw_error);
-            emit_atom(s, JS_ATOM_NULL);
-            emit_u8(s, JS_THROW_ERROR_ITERATOR_THROW);
-            
-            emit_label(s, label_next);
-            emit_op(s, OP_get_field);
-            emit_atom(s, JS_ATOM_value);
-            emit_op(s, OP_nip); /* keep the value associated with
-                                   done = true */
-            emit_op(s, OP_nip);
-            emit_op(s, OP_nip);
+                emit_label(s, label_next);
+                emit_op(s, OP_nip); /* keep the value associated with
+                                       done = true */
+                emit_op(s, OP_nip);
+                emit_op(s, OP_nip);
+            } else {
+                emit_op(s, OP_await);
+                emit_op(s, OP_yield);
+                label_next = emit_goto(s, OP_if_false, -1);
+                emit_return(s, TRUE);
+                emit_label(s, label_next);
+            }
         } else {
             int label_next;
-            
-            if (is_async)
-                emit_op(s, OP_await);
-            emit_op(s, OP_yield);
+            if (is_star) {
+                emit_op(s, OP_for_of_start);
+                emit_op(s, OP_drop);    /* drop the catch offset */
+                emit_op(s, OP_yield_star);
+            } else {
+                emit_op(s, OP_yield);
+            }
             label_next = emit_goto(s, OP_if_false, -1);
             emit_return(s, TRUE);
             emit_label(s, label_next);
@@ -25569,7 +23929,7 @@ static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)
         /* name0 is used to check for OP_set_name pattern, not duplicated */
         name0 = s->token.u.ident.atom;
     }
-    if (js_parse_cond_expr(s, parse_flags | PF_ARROW_FUNC))
+    if (js_parse_cond_expr(s, in_accepted))
         return -1;
 
     op = s->token.val;
@@ -25580,7 +23940,7 @@ static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)
         if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, (op != '='), op) < 0)
             return -1;
 
-        if (js_parse_assign_expr2(s, parse_flags)) {
+        if (js_parse_assign_expr(s, in_accepted)) {
             JS_FreeAtom(s->ctx, name);
             return -1;
         }
@@ -25601,82 +23961,26 @@ static __exception int js_parse_assign_expr2(JSParseState *s, int parse_flags)
             op = assign_opcodes[op - TOK_MUL_ASSIGN];
 #ifdef CONFIG_BIGNUM
             if (s->cur_func->js_mode & JS_MODE_MATH) {
-                if (op == OP_mod)
+                if (op == OP_div)
+                    op = OP_math_div;
+                else if (op == OP_mod)
                     op = OP_math_mod;
+                else if (op == OP_pow)
+                    op = OP_math_pow;
             }
 #endif
             emit_op(s, op);
         }
-        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
-    } else if (op >= TOK_LAND_ASSIGN && op <= TOK_DOUBLE_QUESTION_MARK_ASSIGN) {
-        int label, label1, depth_lvalue, label2;
-        
-        if (next_token(s))
-            return -1;
-        if (get_lvalue(s, &opcode, &scope, &name, &label,
-                       &depth_lvalue, TRUE, op) < 0)
-            return -1;
-
-        emit_op(s, OP_dup);
-        if (op == TOK_DOUBLE_QUESTION_MARK_ASSIGN)
-            emit_op(s, OP_is_undefined_or_null);
-        label1 = emit_goto(s, op == TOK_LOR_ASSIGN ? OP_if_true : OP_if_false,
-                           -1);
-        emit_op(s, OP_drop);
-        
-        if (js_parse_assign_expr2(s, parse_flags)) {
-            JS_FreeAtom(s->ctx, name);
-            return -1;
-        }
-
-        if (opcode == OP_get_ref_value && name == name0) {
-            set_object_name(s, name);
-        }
-        
-        switch(depth_lvalue) {
-        case 1:
-            emit_op(s, OP_insert2);
-            break;
-        case 2:
-            emit_op(s, OP_insert3);
-            break;
-        case 3:
-            emit_op(s, OP_insert4);
-            break;
-        default:
-            abort();
-        }
-
-        /* XXX: we disable the OP_put_ref_value optimization by not
-           using put_lvalue() otherwise depth_lvalue is not correct */
-        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_NOKEEP_DEPTH,
-                   FALSE);
-        label2 = emit_goto(s, OP_goto, -1);
-        
-        emit_label(s, label1);
-
-        /* remove the lvalue stack entries */
-        while (depth_lvalue != 0) {
-            emit_op(s, OP_nip);
-            depth_lvalue--;
-        }
-
-        emit_label(s, label2);
+        put_lvalue(s, opcode, scope, name, label, FALSE);
     }
     return 0;
 }
 
-static __exception int js_parse_assign_expr(JSParseState *s)
-{
-    return js_parse_assign_expr2(s, PF_IN_ACCEPTED);
-}
-
-/* allowed parse_flags: PF_IN_ACCEPTED */
-static __exception int js_parse_expr2(JSParseState *s, int parse_flags)
+static __exception int js_parse_expr2(JSParseState *s, BOOL in_accepted)
 {
     BOOL comma = FALSE;
     for(;;) {
-        if (js_parse_assign_expr2(s, parse_flags))
+        if (js_parse_assign_expr(s, in_accepted))
             return -1;
         if (comma) {
             /* prevent get_lvalue from using the last expression
@@ -25698,7 +24002,7 @@ static __exception int js_parse_expr2(JSParseState *s, int parse_flags)
 
 static __exception int js_parse_expr(JSParseState *s)
 {
-    return js_parse_expr2(s, PF_IN_ACCEPTED);
+    return js_parse_expr2(s, TRUE);
 }
 
 static void push_break_entry(JSFunctionDef *fd, BlockEnv *be,
@@ -25794,25 +24098,12 @@ static void emit_return(JSParseState *s, BOOL hasval)
             }
             emit_op(s, OP_iterator_close_return);
             if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
-                int label_next, label_next2;
-
-                emit_op(s, OP_drop); /* catch offset */
-                emit_op(s, OP_drop); /* next */
-                emit_op(s, OP_get_field2);
-                emit_atom(s, JS_ATOM_return);
-                /* stack: iter_obj return_func */
-                emit_op(s, OP_dup);
-                emit_op(s, OP_is_undefined_or_null);
+                int label_next;
+                emit_op(s, OP_async_iterator_close);
                 label_next = emit_goto(s, OP_if_true, -1);
-                emit_op(s, OP_call_method);
-                emit_u16(s, 0);
-                emit_op(s, OP_iterator_check_object);
                 emit_op(s, OP_await);
-                label_next2 = emit_goto(s, OP_goto, -1);
                 emit_label(s, label_next);
                 emit_op(s, OP_drop);
-                emit_label(s, label_next2);
-                emit_op(s, OP_drop);
             } else {
                 emit_op(s, OP_iterator_close);
             }
@@ -25847,8 +24138,6 @@ static void emit_return(JSParseState *s, BOOL hasval)
             label_return = -1;
         }
 
-        /* XXX: if this is not initialized, should throw the
-           ReferenceError in the caller realm */
         emit_op(s, OP_scope_get_var);
         emit_atom(s, JS_ATOM_this);
         emit_u16(s, 0);
@@ -25900,8 +24189,7 @@ static __exception int js_parse_block(JSParseState *s)
     return 0;
 }
 
-/* allowed parse_flags: PF_IN_ACCEPTED */
-static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
+static __exception int js_parse_var(JSParseState *s, BOOL in_accepted, int tok,
                                     BOOL export_flag)
 {
     JSContext *ctx = s->ctx;
@@ -25941,15 +24229,15 @@ static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
                     emit_u16(s, fd->scope_level);
                     if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') < 0)
                         goto var_error;
-                    if (js_parse_assign_expr2(s, parse_flags)) {
+                    if (js_parse_assign_expr(s, in_accepted)) {
                         JS_FreeAtom(ctx, name1);
                         goto var_error;
                     }
                     set_object_name(s, name);
-                    put_lvalue(s, opcode, scope, name1, label,
-                               PUT_LVALUE_NOKEEP, FALSE);
+                    put_lvalue(s, opcode, scope, name1, label, FALSE);
+                    emit_op(s, OP_drop);
                 } else {
-                    if (js_parse_assign_expr2(s, parse_flags))
+                    if (js_parse_assign_expr(s, in_accepted))
                         goto var_error;
                     set_object_name(s, name);
                     emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ?
@@ -25976,7 +24264,7 @@ static __exception int js_parse_var(JSParseState *s, int parse_flags, int tok,
             if ((s->token.val == '[' || s->token.val == '{')
             &&  js_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
                 emit_op(s, OP_undefined);
-                if (js_parse_destructuring_element(s, tok, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
+                if (js_parse_destructing_element(s, tok, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE))
                     return -1;
             } else {
                 return js_parse_error(s, "variable name expected");
@@ -26105,7 +24393,7 @@ static __exception int js_parse_for_in_of(JSParseState *s, int label_name,
 
         if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
             if (s->token.val == '[' || s->token.val == '{') {
-                if (js_parse_destructuring_element(s, tok, 0, TRUE, -1, FALSE) < 0)
+                if (js_parse_destructing_element(s, tok, 0, TRUE, -1, FALSE))
                     return -1;
                 has_destructuring = TRUE;
             } else {
@@ -26131,17 +24419,32 @@ static __exception int js_parse_for_in_of(JSParseState *s, int label_name,
         int skip_bits;
         if ((s->token.val == '[' || s->token.val == '{')
         &&  ((tok1 = js_parse_skip_parens_token(s, &skip_bits, FALSE)) == TOK_IN || tok1 == TOK_OF)) {
-            if (js_parse_destructuring_element(s, 0, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
+            if (js_parse_destructing_element(s, 0, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE))
                 return -1;
         } else {
-            int lvalue_label;
-            if (js_parse_left_hand_side_expr(s))
+            int lvalue_label, depth;
+            if (js_parse_postfix_expr(s, TRUE))
                 return -1;
             if (get_lvalue(s, &opcode, &scope, &var_name, &lvalue_label,
-                           NULL, FALSE, TOK_FOR))
+                           &depth, FALSE, TOK_FOR))
                 return -1;
-            put_lvalue(s, opcode, scope, var_name, lvalue_label,
-                       PUT_LVALUE_NOKEEP_BOTTOM, FALSE);
+            /* swap value and lvalue object and store it into lvalue object */
+            /* enum_rec val [depth] -- enum_rec */
+            switch(depth) {
+            case 1:
+                emit_op(s, OP_swap);
+                break;
+            case 2:
+                emit_op(s, OP_rot3l);
+                break;
+            case 3:
+                emit_op(s, OP_rot4l);
+                break;
+            default:
+                abort();
+            }
+            put_lvalue_nokeep(s, opcode, scope, var_name, lvalue_label,
+                              TOK_FOR /* not used */);
         }
         var_name = JS_ATOM_NULL;
     }
@@ -26155,7 +24458,7 @@ static __exception int js_parse_for_in_of(JSParseState *s, int label_name,
         /* parse and evaluate initializer prior to evaluating the
            object (only used with "for in" with a non lexical variable
            in non strict mode */
-        if (next_token(s) || js_parse_assign_expr2(s, 0)) {
+        if (next_token(s) || js_parse_assign_expr(s, FALSE)) {
             JS_FreeAtom(ctx, var_name);
             return -1;
         }
@@ -26188,7 +24491,7 @@ static __exception int js_parse_for_in_of(JSParseState *s, int label_name,
     if (next_token(s))
         return -1;
     if (is_for_of) {
-        if (js_parse_assign_expr(s))
+        if (js_parse_assign_expr(s, TRUE))
             return -1;
     } else {
         if (js_parse_expr(s))
@@ -26241,11 +24544,7 @@ static __exception int js_parse_for_in_of(JSParseState *s, int label_name,
     if (is_for_of) {
         if (is_async) {
             /* call the next method */
-            /* stack: iter_obj next catch_offset */
-            emit_op(s, OP_dup3);
-            emit_op(s, OP_drop);
-            emit_op(s, OP_call_method);
-            emit_u16(s, 0);
+            emit_op(s, OP_for_await_of_next);
             /* get the result of the promise */
             emit_op(s, OP_await);
             /* unwrap the value and done values */
@@ -26803,7 +25102,7 @@ static __exception int js_parse_statement_or_decl(JSParseState *s,
                     if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
                         if (s->token.val == '[' || s->token.val == '{') {
                             /* XXX: TOK_LET is not completely correct */
-                            if (js_parse_destructuring_element(s, TOK_LET, 0, TRUE, -1, TRUE) < 0)
+                            if (js_parse_destructing_element(s, TOK_LET, 0, TRUE, -1, TRUE))
                                 goto fail;
                         } else {
                             js_parse_error(s, "identifier expected");
@@ -26869,37 +25168,18 @@ static __exception int js_parse_statement_or_decl(JSParseState *s,
             }
             emit_label(s, label_finally);
             if (s->token.val == TOK_FINALLY) {
-                int saved_eval_ret_idx = 0; /* avoid warning */
-                
+                int saved_eval_ret_idx;
                 if (next_token(s))
                     goto fail;
                 /* on the stack: ret_value gosub_ret_value */
                 push_break_entry(s->cur_func, &block_env, JS_ATOM_NULL,
                                  -1, -1, 2);
-
-                if (s->cur_func->eval_ret_idx >= 0) {
-                    /* 'finally' updates eval_ret only if not a normal
-                       termination */
-                    saved_eval_ret_idx =
-                        add_var(s->ctx, s->cur_func, JS_ATOM__ret_);
-                    if (saved_eval_ret_idx < 0)
-                        goto fail;
-                    emit_op(s, OP_get_loc);
-                    emit_u16(s, s->cur_func->eval_ret_idx);
-                    emit_op(s, OP_put_loc);
-                    emit_u16(s, saved_eval_ret_idx);
-                    set_eval_ret_undefined(s);
-                }
-                
+                saved_eval_ret_idx = s->cur_func->eval_ret_idx;
+                s->cur_func->eval_ret_idx = -1;
+                /* 'finally' does not update eval_ret */
                 if (js_parse_block(s))
                     goto fail;
-
-                if (s->cur_func->eval_ret_idx >= 0) {
-                    emit_op(s, OP_get_loc);
-                    emit_u16(s, saved_eval_ret_idx);
-                    emit_op(s, OP_put_loc);
-                    emit_u16(s, s->cur_func->eval_ret_idx);
-                }
+                s->cur_func->eval_ret_idx = saved_eval_ret_idx;
                 pop_break_entry(s->cur_func);
             }
             emit_op(s, OP_ret);
@@ -27045,25 +25325,6 @@ static JSModuleDef *js_new_module_def(JSContext *ctx, JSAtom name)
     return m;
 }
 
-static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
-                               JS_MarkFunc *mark_func)
-{
-    int i;
-
-    for(i = 0; i < m->export_entries_count; i++) {
-        JSExportEntry *me = &m->export_entries[i];
-        if (me->export_type == JS_EXPORT_TYPE_LOCAL &&
-            me->u.local.var_ref) {
-            mark_func(rt, &me->u.local.var_ref->header);
-        }
-    }
-
-    JS_MarkValue(rt, m->module_ns, mark_func);
-    JS_MarkValue(rt, m->func_obj, mark_func);
-    JS_MarkValue(rt, m->eval_exception, mark_func);
-    JS_MarkValue(rt, m->meta_obj, mark_func);
-}
-
 static void js_free_module_def(JSContext *ctx, JSModuleDef *m)
 {
     int i;
@@ -27101,6 +25362,26 @@ static void js_free_module_def(JSContext *ctx, JSModuleDef *m)
     js_free(ctx, m);
 }
 
+static int js_resize_array(JSContext *ctx, void **parray, int elem_size,
+                           int *psize, int *pcount, int new_count)
+{
+    if (unlikely(new_count > *psize)) {
+        int new_size;
+        size_t slack;
+        void *new_array;
+        /* XXX: potential arithmetic overflow */
+        new_size = max_int(new_count, *psize * 3 / 2);
+        new_array = js_realloc2(ctx, *parray, new_size * elem_size, &slack);
+        if (!new_array)
+            return -1;
+        new_size += slack / elem_size;
+        *psize = new_size;
+        *parray = new_array;
+    }
+    *pcount = new_count;
+    return 0;
+}
+
 static int add_req_module_entry(JSContext *ctx, JSModuleDef *m,
                                 JSAtom module_name)
 {
@@ -27116,10 +25397,11 @@ static int add_req_module_entry(JSContext *ctx, JSModuleDef *m,
 
     if (js_resize_array(ctx, (void **)&m->req_module_entries,
                         sizeof(JSReqModuleEntry),
-                        &m->req_module_entries_size,
+                        &m->req_module_entries_size, &m->req_module_entries_count,
                         m->req_module_entries_count + 1))
         return -1;
-    rme = &m->req_module_entries[m->req_module_entries_count++];
+    i = m->req_module_entries_count - 1;
+    rme = &m->req_module_entries[i];
     rme->module_name = JS_DupAtom(ctx, module_name);
     rme->module = NULL;
     return i;
@@ -27151,17 +25433,18 @@ static JSExportEntry *add_export_entry2(JSContext *ctx,
             js_parse_error(s, "duplicate exported name '%s'",
                            JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name));
         } else {
-            JS_ThrowSyntaxErrorAtom(ctx, "duplicate exported name '%s'", export_name);
+            JS_ThrowSyntaxError(ctx, "duplicate exported name '%s'",
+                                JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name));
         }
         return NULL;
     }
 
     if (js_resize_array(ctx, (void **)&m->export_entries,
                         sizeof(JSExportEntry),
-                        &m->export_entries_size,
+                        &m->export_entries_size, &m->export_entries_count,
                         m->export_entries_count + 1))
         return NULL;
-    me = &m->export_entries[m->export_entries_count++];
+    me = &m->export_entries[m->export_entries_count - 1];
     memset(me, 0, sizeof(*me));
     me->local_name = JS_DupAtom(ctx, local_name);
     me->export_name = JS_DupAtom(ctx, export_name);
@@ -27184,10 +25467,10 @@ static int add_star_export_entry(JSContext *ctx, JSModuleDef *m,
 
     if (js_resize_array(ctx, (void **)&m->star_export_entries,
                         sizeof(JSStarExportEntry),
-                        &m->star_export_entries_size,
+                        &m->star_export_entries_size, &m->star_export_entries_count,
                         m->star_export_entries_count + 1))
         return -1;
-    se = &m->star_export_entries[m->star_export_entries_count++];
+    se = &m->star_export_entries[m->star_export_entries_count - 1];
     se->req_module_idx = req_module_idx;
     return 0;
 }
@@ -27324,20 +25607,32 @@ static JSModuleDef *js_find_loaded_module(JSContext *ctx, JSAtom name)
 
 /* return NULL in case of exception (e.g. module could not be loaded) */
 static JSModuleDef *js_host_resolve_imported_module(JSContext *ctx,
-                                                    const char *base_cname,
-                                                    const char *cname1)
+                                                    JSAtom base_module_name,
+                                                    JSAtom module_name1)
 {
     JSRuntime *rt = ctx->rt;
     JSModuleDef *m;
     char *cname;
+    const char *base_cname, *cname1;
     JSAtom module_name;
 
+    base_cname = JS_AtomToCString(ctx, base_module_name);
+    if (!base_cname)
+        return NULL;
+    cname1 = JS_AtomToCString(ctx, module_name1);
+    if (!cname1) {
+        JS_FreeCString(ctx, base_cname);
+        return NULL;
+    }
+
     if (!rt->module_normalize_func) {
         cname = js_default_module_normalize_name(ctx, base_cname, cname1);
     } else {
         cname = rt->module_normalize_func(ctx, base_cname, cname1,
                                           rt->module_loader_opaque);
     }
+    JS_FreeCString(ctx, base_cname);
+    JS_FreeCString(ctx, cname1);
     if (!cname)
         return NULL;
 
@@ -27371,27 +25666,6 @@ static JSModuleDef *js_host_resolve_imported_module(JSContext *ctx,
     return m;
 }
 
-static JSModuleDef *js_host_resolve_imported_module_atom(JSContext *ctx,
-                                                    JSAtom base_module_name,
-                                                    JSAtom module_name1)
-{
-    const char *base_cname, *cname;
-    JSModuleDef *m;
-    
-    base_cname = JS_AtomToCString(ctx, base_module_name);
-    if (!base_cname)
-        return NULL;
-    cname = JS_AtomToCString(ctx, module_name1);
-    if (!cname) {
-        JS_FreeCString(ctx, base_cname);
-        return NULL;
-    }
-    m = js_host_resolve_imported_module(ctx, base_cname, cname);
-    JS_FreeCString(ctx, base_cname);
-    JS_FreeCString(ctx, cname);
-    return m;
-}
-
 typedef struct JSResolveEntry {
     JSModuleDef *module;
     JSAtom name;
@@ -27422,9 +25696,10 @@ static int add_resolve_entry(JSContext *ctx, JSResolveState *s,
 
     if (js_resize_array(ctx, (void **)&s->array,
                         sizeof(JSResolveEntry),
-                        &s->size, s->count + 1))
+                        &s->size, &s->count,
+                        s->count + 1))
         return -1;
-    re = &s->array[s->count++];
+    re = &s->array[s->count - 1];
     re->module = m;
     re->name = JS_DupAtom(ctx, name);
     return 0;
@@ -27549,17 +25824,17 @@ static void js_resolve_export_throw_error(JSContext *ctx,
         break;
     default:
     case JS_RESOLVE_RES_NOT_FOUND:
-        JS_ThrowSyntaxError(ctx, "Could not find export '%s' in module '%s'",
+        JS_ThrowSyntaxError(ctx, "export '%s' in module '%s' is ambiguous",
                             JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
                             JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
         break;
     case JS_RESOLVE_RES_CIRCULAR:
-        JS_ThrowSyntaxError(ctx, "circular reference when looking for export '%s' in module '%s'",
+        JS_ThrowSyntaxError(ctx, "Could not find export '%s' in module '%s'",
                             JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
                             JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
         break;
     case JS_RESOLVE_RES_AMBIGUOUS:
-        JS_ThrowSyntaxError(ctx, "export '%s' in module '%s' is ambiguous",
+        JS_ThrowSyntaxError(ctx, "circular reference when looking for export '%s' in module '%s'",
                             JS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
                             JS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
         break;
@@ -27616,9 +25891,9 @@ static __exception int get_exported_names(JSContext *ctx,
             return 0;
     }
     if (js_resize_array(ctx, (void **)&s->modules, sizeof(s->modules[0]),
-                        &s->modules_size, s->modules_count + 1))
+                        &s->modules_size, &s->modules_count, s->modules_count + 1))
         return -1;
-    s->modules[s->modules_count++] = m;
+    s->modules[s->modules_count - 1] = m;
 
     for(i = 0; i < m->export_entries_count; i++) {
         JSExportEntry *me = &m->export_entries[i];
@@ -27627,10 +25902,9 @@ static __exception int get_exported_names(JSContext *ctx,
         j = find_exported_name(s, me->export_name);
         if (j < 0) {
             if (js_resize_array(ctx, (void **)&s->exported_names, sizeof(s->exported_names[0]),
-                                &s->exported_names_size,
-                                s->exported_names_count + 1))
+                                &s->exported_names_size, &s->exported_names_count, s->exported_names_count + 1))
                 return -1;
-            en = &s->exported_names[s->exported_names_count++];
+            en = &s->exported_names[s->exported_names_count - 1];
             en->export_name = me->export_name;
             /* avoid a second lookup for simple module exports */
             if (from_star || me->export_type != JS_EXPORT_TYPE_LOCAL)
@@ -27687,11 +25961,19 @@ static int exported_names_cmp(const void *p1, const void *p2, void *opaque)
 
 static JSValue js_get_module_ns(JSContext *ctx, JSModuleDef *m);
 
-static JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
-                                     void *opaque)
+static int js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
+                                 void *opaque)
 {
     JSModuleDef *m = opaque;
-    return js_get_module_ns(ctx, m);
+    JSValue val, this_val = JS_MKPTR(JS_TAG_OBJECT, p);
+    
+    val = js_get_module_ns(ctx, m);
+    if (JS_IsException(val))
+        return -1;
+    if (JS_DefinePropertyValue(ctx, this_val, atom, val,
+                               JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)
+        return -1;
+    return 0;
 }
 
 static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
@@ -27774,7 +26056,7 @@ static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
             /* the exported namespace must be created on demand */
             if (JS_DefineAutoInitProperty(ctx, obj,
                                           en->export_name,
-                                          JS_AUTOINIT_ID_MODULE_NS,
+                                          js_module_ns_autoinit,
                                           en->u.module, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)
                 goto fail;
             break;
@@ -27827,8 +26109,8 @@ static int js_resolve_module(JSContext *ctx, JSModuleDef *m)
     /* resolve each requested module */
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
-        m1 = js_host_resolve_imported_module_atom(ctx, m->module_name,
-                                                  rme->module_name);
+        m1 = js_host_resolve_imported_module(ctx, m->module_name,
+                                             rme->module_name);
         if (!m1)
             return -1;
         rme->module = m1;
@@ -27847,18 +26129,19 @@ static JSVarRef *js_create_module_var(JSContext *ctx, BOOL is_lexical)
     if (!var_ref)
         return NULL;
     var_ref->header.ref_count = 1;
+    var_ref->gc_header.mark = 0;
+    var_ref->link.prev = NULL;
+    var_ref->link.next = NULL;
     if (is_lexical)
         var_ref->value = JS_UNINITIALIZED;
     else
         var_ref->value = JS_UNDEFINED;
     var_ref->pvalue = &var_ref->value;
-    var_ref->is_detached = TRUE;
-    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
     return var_ref;
 }
 
 /* Create the <eval> function associated with the module */
-static int js_create_module_bytecode_function(JSContext *ctx, JSModuleDef *m)
+static int js_create_module_function(JSContext *ctx, JSModuleDef *m)
 {
     JSFunctionBytecode *b;
     int i;
@@ -27909,15 +26192,20 @@ static int js_create_module_bytecode_function(JSContext *ctx, JSModuleDef *m)
     return -1;
 }
 
-/* must be done before js_link_module() because of cyclic references */
-static int js_create_module_function(JSContext *ctx, JSModuleDef *m)
+/* Prepare a module to be executed by resolving all the imported
+   variables. */
+static int js_instantiate_module(JSContext *ctx, JSModuleDef *m)
 {
-    BOOL is_c_module;
     int i;
-    JSVarRef *var_ref;
-    
-    if (m->func_created)
+    JSImportEntry *mi;
+    JSModuleDef *m1;
+    JSVarRef **var_refs, *var_ref;
+    JSObject *p;
+    BOOL is_c_module;
+
+    if (m->instantiated)
         return 0;
+    m->instantiated = TRUE;
 
     is_c_module = (m->init_func != NULL);
 
@@ -27928,54 +26216,18 @@ static int js_create_module_function(JSContext *ctx, JSModuleDef *m)
             if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
                 var_ref = js_create_module_var(ctx, FALSE);
                 if (!var_ref)
-                    return -1;
+                    goto fail;
                 me->u.local.var_ref = var_ref;
             }
         }
     } else {
-        if (js_create_module_bytecode_function(ctx, m))
-            return -1;
-    }
-    m->func_created = TRUE;
-
-    /* do it on the dependencies */
-    
-    for(i = 0; i < m->req_module_entries_count; i++) {
-        JSReqModuleEntry *rme = &m->req_module_entries[i];
-        if (js_create_module_function(ctx, rme->module) < 0)
-            return -1;
-    }
-
-    return 0;
-}    
-
-    
-/* Prepare a module to be executed by resolving all the imported
-   variables. */
-static int js_link_module(JSContext *ctx, JSModuleDef *m)
-{
-    int i;
-    JSImportEntry *mi;
-    JSModuleDef *m1;
-    JSVarRef **var_refs, *var_ref;
-    JSObject *p;
-    BOOL is_c_module;
-    JSValue ret_val;
-    
-    if (m->instantiated)
-        return 0;
-    m->instantiated = TRUE;
-
-#ifdef DUMP_MODULE_RESOLVE
-    {
-        char buf1[ATOM_GET_STR_BUF_SIZE];
-        printf("start instantiating module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
+        if (js_create_module_function(ctx, m) < 0)
+            goto fail;
     }
-#endif
 
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
-        if (js_link_module(ctx, rme->module) < 0)
+        if (js_instantiate_module(ctx, rme->module) < 0)
             goto fail;
     }
 
@@ -28014,8 +26266,6 @@ static int js_link_module(JSContext *ctx, JSModuleDef *m)
     }
 #endif
 
-    is_c_module = (m->init_func != NULL);
-
     if (!is_c_module) {
         p = JS_VALUE_GET_OBJ(m->func_obj);
         var_refs = p->u.func.var_refs;
@@ -28094,12 +26344,6 @@ static int js_link_module(JSContext *ctx, JSModuleDef *m)
                 me->u.local.var_ref = var_ref;
             }
         }
-
-        /* initialize the global variables */
-        ret_val = JS_Call(ctx, m->func_obj, JS_TRUE, 0, NULL);
-        if (JS_IsException(ret_val))
-            goto fail;
-        JS_FreeValue(ctx, ret_val);
     }
 
 #ifdef DUMP_MODULE_RESOLVE
@@ -28110,9 +26354,8 @@ static int js_link_module(JSContext *ctx, JSModuleDef *m)
     return -1;
 }
 
-/* return JS_ATOM_NULL if the name cannot be found. Only works with
-   not striped bytecode functions. */
-JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels)
+/* warning: the returned atom is not allocated */
+static JSAtom js_get_script_or_module_name(JSContext *ctx)
 {
     JSStackFrame *sf;
     JSFunctionBytecode *b;
@@ -28120,23 +26363,15 @@ JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels)
     /* XXX: currently we just use the filename of the englobing
        function. It does not work for eval(). Need to add a
        ScriptOrModule info in JSFunctionBytecode */
-    sf = ctx->rt->current_stack_frame;
-    if (!sf)
-        return JS_ATOM_NULL;
-    while (n_stack_levels-- > 0) {
-        sf = sf->prev_frame;
-        if (!sf)
-            return JS_ATOM_NULL;
-    }
-    if (JS_VALUE_GET_TAG(sf->cur_func) != JS_TAG_OBJECT)
-        return JS_ATOM_NULL;
+    sf = ctx->current_stack_frame;
+    assert(sf != NULL);
+    assert(JS_VALUE_GET_TAG(sf->cur_func) == JS_TAG_OBJECT);
     p = JS_VALUE_GET_OBJ(sf->cur_func);
-    if (!js_class_has_bytecode(p->class_id))
-        return JS_ATOM_NULL;
+    assert(js_class_has_bytecode(p->class_id));
     b = p->u.func.function_bytecode;
     if (!b->has_debug)
         return JS_ATOM_NULL;
-    return JS_DupAtom(ctx, b->debug.filename);
+    return b->debug.filename;
 }
 
 JSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m)
@@ -28163,14 +26398,13 @@ static JSValue js_import_meta(JSContext *ctx)
     JSAtom filename;
     JSModuleDef *m;
     
-    filename = JS_GetScriptOrModuleName(ctx, 0);
+    filename = js_get_script_or_module_name(ctx);
     if (filename == JS_ATOM_NULL)
         goto fail;
 
     /* XXX: inefficient, need to add a module or script pointer in
        JSFunctionBytecode */
     m = js_find_loaded_module(ctx, filename);
-    JS_FreeAtom(ctx, filename);
     if (!m) {
     fail:
         JS_ThrowTypeError(ctx, "import.meta not supported in this context");
@@ -28179,109 +26413,68 @@ static JSValue js_import_meta(JSContext *ctx)
     return JS_GetImportMeta(ctx, m);
 }
 
-/* used by os.Worker() and import() */
-JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
-                          const char *filename)
+static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
 {
     JSModuleDef *m;
-    JSValue ret, func_obj;
+    JSAtom basename, filename;
+    JSValue promise, resolving_funcs[2];
+    JSValue specifierString, ret, func_obj, err, ns;
+    
+    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
+    if (JS_IsException(promise))
+        return promise;
     
+    basename = js_get_script_or_module_name(ctx);
+    if (basename == JS_ATOM_NULL) {
+        JS_ThrowTypeError(ctx, "no function filename for import()");
+        goto exception;
+    }
+
+    specifierString = JS_ToString(ctx, specifier);
+    if (JS_IsException(specifierString))
+        goto exception;
+    filename = JS_ValueToAtom(ctx, specifierString);
+    JS_FreeValue(ctx, specifierString);
+    if (filename == JS_ATOM_NULL)
+        goto exception;
+                     
     m = js_host_resolve_imported_module(ctx, basename, filename);
-    if (!m)
-        return NULL;
+    JS_FreeAtom(ctx, filename);
+    if (!m) {
+        goto exception;
+    }
     
     if (js_resolve_module(ctx, m) < 0) {
         js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
-        return NULL;
+        goto exception;
     }
 
     /* Evaluate the module code */
     func_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
     ret = JS_EvalFunction(ctx, func_obj);
     if (JS_IsException(ret))
-        return NULL;
-    JS_FreeValue(ctx, ret);
-    return m;
-}
-
-static JSValue js_dynamic_import_job(JSContext *ctx,
-                                     int argc, JSValueConst *argv)
-{
-    JSValueConst *resolving_funcs = argv;
-    JSValueConst basename_val = argv[2];
-    JSValueConst specifier = argv[3];
-    JSModuleDef *m;
-    const char *basename = NULL, *filename;
-    JSValue ret, err, ns;
-
-    if (!JS_IsString(basename_val)) {
-        JS_ThrowTypeError(ctx, "no function filename for import()");
-        goto exception;
-    }
-    basename = JS_ToCString(ctx, basename_val);
-    if (!basename)
-        goto exception;
-
-    filename = JS_ToCString(ctx, specifier);
-    if (!filename)
-        goto exception;
-                     
-    m = JS_RunModule(ctx, basename, filename);
-    JS_FreeCString(ctx, filename);
-    if (!m)
         goto exception;
+    JS_FreeValue(ctx, ret);
 
     /* return the module namespace */
     ns = js_get_module_ns(ctx, m);
-    if (JS_IsException(ns))
+    if (JS_IsException(ret))
         goto exception;
 
     ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
                    1, (JSValueConst *)&ns);
     JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
     JS_FreeValue(ctx, ns);
-    JS_FreeCString(ctx, basename);
-    return JS_UNDEFINED;
- exception:
+    JS_FreeValue(ctx, resolving_funcs[0]);
+    JS_FreeValue(ctx, resolving_funcs[1]);
+    return promise;
 
+ exception:
     err = JS_GetException(ctx);
     ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
                    1, (JSValueConst *)&err);
     JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
     JS_FreeValue(ctx, err);
-    JS_FreeCString(ctx, basename);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
-{
-    JSAtom basename;
-    JSValue promise, resolving_funcs[2], basename_val;
-    JSValueConst args[4];
-
-    basename = JS_GetScriptOrModuleName(ctx, 0);
-    if (basename == JS_ATOM_NULL)
-        basename_val = JS_NULL;
-    else
-        basename_val = JS_AtomToValue(ctx, basename);
-    JS_FreeAtom(ctx, basename);
-    if (JS_IsException(basename_val))
-        return basename_val;
-    
-    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
-    if (JS_IsException(promise)) {
-        JS_FreeValue(ctx, basename_val);
-        return promise;
-    }
-
-    args[0] = resolving_funcs[0];
-    args[1] = resolving_funcs[1];
-    args[2] = basename_val;
-    args[3] = specifier;
-    
-    JS_EnqueueJob(ctx, js_dynamic_import_job, 4, args);
-
-    JS_FreeValue(ctx, basename_val);
     JS_FreeValue(ctx, resolving_funcs[0]);
     JS_FreeValue(ctx, resolving_funcs[1]);
     return promise;
@@ -28336,7 +26529,7 @@ static JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)
     if (JS_IsException(ret_val)) {
         /* save the thrown exception value */
         m->eval_has_exception = TRUE;
-        m->eval_exception = JS_DupValue(ctx, ctx->rt->current_exception);
+        m->eval_exception = JS_DupValue(ctx, ctx->current_exception);
     }
     m->eval_mark = FALSE;
     m->evaluated = TRUE;
@@ -28499,7 +26692,7 @@ static __exception int js_parse_export(JSParseState *s)
                                            s->token.ptr, s->token.line_num,
                                            JS_PARSE_EXPORT_DEFAULT, NULL);
         } else {
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 return -1;
         }
         /* set the name of anonymous functions */
@@ -28560,10 +26753,10 @@ static int add_import(JSParseState *s, JSModuleDef *m,
         return -1;
     if (js_resize_array(ctx, (void **)&m->import_entries,
                         sizeof(JSImportEntry),
-                        &m->import_entries_size,
+                        &m->import_entries_size, &m->import_entries_count,
                         m->import_entries_count + 1))
         return -1;
-    mi = &m->import_entries[m->import_entries_count++];
+    mi = &m->import_entries[m->import_entries_count - 1];
     mi->import_name = JS_DupAtom(ctx, import_name);
     mi->var_idx = var_idx;
     return 0;
@@ -28616,10 +26809,6 @@ static __exception int js_parse_import(JSParseState *s)
                 return js_parse_error(s, "expecting 'as'");
             if (next_token(s))
                 return -1;
-            if (!token_is_ident(s->token.val)) {
-                js_parse_error(s, "identifier expected");
-                return -1;
-            }
             local_name = JS_DupAtom(ctx, s->token.u.ident.atom);
             import_name = JS_ATOM__star_;
             if (next_token(s))
@@ -28742,9 +26931,7 @@ static JSFunctionDef *js_new_function_def(JSContext *ctx,
     fd->last_opcode_pos = -1;
     fd->func_name = JS_ATOM_NULL;
     fd->var_object_idx = -1;
-    fd->arg_var_object_idx = -1;
     fd->arguments_var_idx = -1;
-    fd->arguments_arg_idx = -1;
     fd->func_var_idx = -1;
     fd->eval_ret_idx = -1;
     fd->this_var_idx = -1;
@@ -28753,14 +26940,13 @@ static JSFunctionDef *js_new_function_def(JSContext *ctx,
     fd->home_object_var_idx = -1;
 
     /* XXX: should distinguish arg, var and var object and body scopes */
+    fd->scope_level = 0;  /* 0: var/arg scope, 1:body scope */
+    fd->scope_first = -1;
     fd->scopes = fd->def_scope_array;
     fd->scope_size = countof(fd->def_scope_array);
     fd->scope_count = 1;
     fd->scopes[0].first = -1;
     fd->scopes[0].parent = -1;
-    fd->scope_level = 0;  /* 0: var/arg scope */
-    fd->scope_first = -1;
-    fd->body_scope = -1;
 
     fd->filename = JS_NewAtom(ctx, filename);
     fd->line_num = line_num;
@@ -28841,10 +27027,10 @@ static void js_free_function_def(JSContext *ctx, JSFunctionDef *fd)
     }
     js_free(ctx, fd->args);
 
-    for(i = 0; i < fd->global_var_count; i++) {
-        JS_FreeAtom(ctx, fd->global_vars[i].var_name);
+    for(i = 0; i < fd->hoisted_def_count; i++) {
+        JS_FreeAtom(ctx, fd->hoisted_def[i].var_name);
     }
-    js_free(ctx, fd->global_vars);
+    js_free(ctx, fd->hoisted_def);
 
     for(i = 0; i < fd->closure_var_count; i++) {
         JSClosureVar *cv = &fd->closure_var[i];
@@ -29297,10 +27483,20 @@ static int add_closure_var(JSContext *ctx, JSFunctionDef *s,
         return -1;
     }
 
-    if (js_resize_array(ctx, (void **)&s->closure_var,
-                        sizeof(s->closure_var[0]),
-                        &s->closure_var_size, s->closure_var_count + 1))
-        return -1;
+    if (s->closure_var_count >= s->closure_var_size) {
+        JSClosureVar *new_tab;
+        int new_size;
+        size_t slack;
+        new_size = max_int(s->closure_var_count + 1,
+                           s->closure_var_size * 3 / 2);
+        new_tab = js_realloc2(ctx, s->closure_var,
+                              new_size * sizeof(JSClosureVar), &slack);
+        if (!new_tab)
+            return -1;
+        new_size += slack / sizeof(*new_tab);
+        s->closure_var = new_tab;
+        s->closure_var_size = new_size;
+    }
     cv = &s->closure_var[s->closure_var_count++];
     cv->is_local = is_local;
     cv->is_arg = is_arg;
@@ -29378,7 +27574,7 @@ static BOOL can_opt_put_ref_value(const uint8_t *bc_buf, int pos)
     return (bc_buf[pos + 1] == OP_put_ref_value &&
             (opcode == OP_insert3 ||
              opcode == OP_perm4 ||
-             opcode == OP_nop ||
+             //opcode == OP_nop ||
              opcode == OP_rot3l));
 }
 
@@ -29388,7 +27584,7 @@ static BOOL can_opt_put_global_ref_value(const uint8_t *bc_buf, int pos)
     return (bc_buf[pos + 1] == OP_put_ref_value &&
             (opcode == OP_insert3 ||
              opcode == OP_perm4 ||
-             opcode == OP_nop ||
+             //opcode == OP_nop ||
              opcode == OP_rot3l));
 }
 
@@ -29470,22 +27666,20 @@ static int optimize_scope_make_global_ref(JSContext *ctx, JSFunctionDef *s,
     end_pos = label_pos + 2;
     op = bc_buf[label_pos];
     if (is_strict) {
-        if (op != OP_nop) {
-            switch(op) {
-            case OP_insert3:
-                op = OP_insert2;
-                break;
-            case OP_perm4:
-                op = OP_perm3;
-                break;
-            case OP_rot3l:
-                op = OP_swap;
-                break;
-            default:
-                abort();
-            }
-            bc_buf[pos++] = op;
+        switch(op) {
+        case OP_insert3:
+            op = OP_insert2;
+            break;
+        case OP_perm4:
+            op = OP_perm3;
+            break;
+        case OP_rot3l:
+            op = OP_swap;
+            break;
+        default:
+            abort();
         }
+        bc_buf[pos++] = op;
     } else {
         if (op == OP_insert3)
             bc_buf[pos++] = OP_dup;
@@ -29528,27 +27722,19 @@ static int resolve_pseudo_var(JSContext *ctx, JSFunctionDef *s,
     switch(var_name) {
     case JS_ATOM_home_object:
         /* 'home_object' pseudo variable */
-        if (s->home_object_var_idx < 0)
-            s->home_object_var_idx = add_var(ctx, s, var_name);
-        var_idx = s->home_object_var_idx;
+        var_idx = s->home_object_var_idx = add_var(ctx, s, var_name);
         break;
     case JS_ATOM_this_active_func:
         /* 'this.active_func' pseudo variable */
-        if (s->this_active_func_var_idx < 0)
-            s->this_active_func_var_idx = add_var(ctx, s, var_name);
-        var_idx = s->this_active_func_var_idx;
+        var_idx = s->this_active_func_var_idx = add_var(ctx, s, var_name);
         break;
     case JS_ATOM_new_target:
         /* 'new.target' pseudo variable */
-        if (s->new_target_var_idx < 0)
-            s->new_target_var_idx = add_var(ctx, s, var_name);
-        var_idx = s->new_target_var_idx;
+        var_idx = s->new_target_var_idx = add_var(ctx, s, var_name);
         break;
     case JS_ATOM_this:
         /* 'this' pseudo variable */
-        if (s->this_var_idx < 0)
-            s->this_var_idx = add_var_this(ctx, s);
-        var_idx = s->this_var_idx;
+        var_idx = s->this_var_idx = add_var_this(ctx, s);
         break;
     default:
         var_idx = -1;
@@ -29557,32 +27743,18 @@ static int resolve_pseudo_var(JSContext *ctx, JSFunctionDef *s,
     return var_idx;
 }
 
-/* test if 'var_name' is in the variable object on the stack. If is it
-   the case, handle it and jump to 'label_done' */
-static void var_object_test(JSContext *ctx, JSFunctionDef *s,
-                            JSAtom var_name, int op, DynBuf *bc,
-                            int *plabel_done, BOOL is_with)
-{
-    dbuf_putc(bc, get_with_scope_opcode(op));
-    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
-    *plabel_done = new_label_fd(s, *plabel_done);
-    dbuf_put_u32(bc, *plabel_done);
-    dbuf_putc(bc, is_with);
-    update_label(s, *plabel_done, 1);
-    s->jump_size++;
-}
-    
 /* return the position of the next opcode */
 static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                              JSAtom var_name, int scope_level, int op,
                              DynBuf *bc, uint8_t *bc_buf,
-                             LabelSlot *ls, int pos_next)
+                             LabelSlot *ls, int pos_next, int arg_valid)
 {
     int idx, var_idx, is_put;
     int label_done;
+    BOOL is_func_var = FALSE;
     JSFunctionDef *fd;
     JSVarDef *vd;
-    BOOL is_pseudo_var, is_arg_scope;
+    BOOL is_pseudo_var;
 
     label_done = -1;
 
@@ -29600,11 +27772,12 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
         if (vd->var_name == var_name) {
             if (op == OP_scope_put_var || op == OP_scope_make_ref) {
                 if (vd->is_const) {
-                    dbuf_putc(bc, OP_throw_error);
+                    dbuf_putc(bc, OP_throw_var);
                     dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                     dbuf_putc(bc, JS_THROW_VAR_RO);
                     goto done;
                 }
+                is_func_var = vd->is_func_var;
             }
             var_idx = idx;
             break;
@@ -29612,16 +27785,33 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
         if (vd->var_name == JS_ATOM__with_ && !is_pseudo_var) {
             dbuf_putc(bc, OP_get_loc);
             dbuf_put_u16(bc, idx);
-            var_object_test(ctx, s, var_name, op, bc, &label_done, 1);
+            dbuf_putc(bc, get_with_scope_opcode(op));
+            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
+            label_done = new_label_fd(s, label_done);
+            dbuf_put_u32(bc, label_done);
+            dbuf_putc(bc, 1);
+            update_label(s, label_done, 1);
+            s->jump_size++;
         }
         idx = vd->scope_next;
     }
-    is_arg_scope = (idx == ARG_SCOPE_END);
     if (var_idx < 0) {
-        /* argument scope: variables are not visible but pseudo
-           variables are visible */
-        if (!is_arg_scope) {
-            var_idx = find_var(ctx, s, var_name);
+        /* XXX: scoping issues:
+           should not resolve vars from the function body during argument parse,
+           `arguments` and function-name should not be hidden by later vars.
+         */
+        var_idx = find_var(ctx, s, var_name);
+        if (var_idx >= 0) {
+            if (scope_level == 0
+            &&  (var_idx & ARGUMENT_VAR_OFFSET)
+            &&  (var_idx - ARGUMENT_VAR_OFFSET) >= arg_valid) {
+                /* referring to an uninitialized argument */
+                dbuf_putc(bc, OP_throw_var);
+                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
+                dbuf_putc(bc, JS_THROW_VAR_UNINITIALIZED);
+            }
+            if (!(var_idx & ARGUMENT_VAR_OFFSET))
+                is_func_var = s->vars[var_idx].is_func_var;
         }
 
         if (var_idx < 0 && is_pseudo_var)
@@ -29630,31 +27820,21 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
         if (var_idx < 0 && var_name == JS_ATOM_arguments &&
             s->has_arguments_binding) {
             /* 'arguments' pseudo variable */
-            var_idx = add_arguments_var(ctx, s);
+            var_idx = add_arguments_var(ctx, s, var_name);
         }
         if (var_idx < 0 && s->is_func_expr && var_name == s->func_name) {
             /* add a new variable with the function name */
             var_idx = add_func_var(ctx, s, var_name);
+            is_func_var = TRUE;
         }
     }
     if (var_idx >= 0) {
-        if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
-            !(var_idx & ARGUMENT_VAR_OFFSET) &&
-            s->vars[var_idx].is_const) {
-            /* only happens when assigning a function expression name
-               in strict mode */
-            dbuf_putc(bc, OP_throw_error);
-            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
-            dbuf_putc(bc, JS_THROW_VAR_RO);
-            goto done;
-        }
         /* OP_scope_put_var_init is only used to initialize a
            lexical variable, so it is never used in a with or var object. It
            can be used with a closure (module global variable case). */
         switch (op) {
         case OP_scope_make_ref:
-            if (!(var_idx & ARGUMENT_VAR_OFFSET) &&
-                s->vars[var_idx].var_kind == JS_VAR_FUNCTION_NAME) {
+            if (is_func_var) {
                 /* Create a dummy object reference for the func_var */
                 dbuf_putc(bc, OP_object);
                 dbuf_putc(bc, OP_get_loc);
@@ -29702,6 +27882,7 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
             if (var_idx & ARGUMENT_VAR_OFFSET) {
                 dbuf_putc(bc, OP_get_arg + is_put);
                 dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
+                /* XXX: should test if argument reference needs TDZ check */
             } else {
                 if (is_put) {
                     if (s->vars[var_idx].is_lexical) {
@@ -29734,32 +27915,41 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
         goto done;
     }
     /* check eval object */
-    if (!is_arg_scope && s->var_object_idx >= 0 && !is_pseudo_var) {
+    if (s->var_object_idx >= 0 && !is_pseudo_var) {
         dbuf_putc(bc, OP_get_loc);
         dbuf_put_u16(bc, s->var_object_idx);
-        var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
-    }
-    /* check eval object in argument scope */
-    if (s->arg_var_object_idx >= 0 && !is_pseudo_var) {
-        dbuf_putc(bc, OP_get_loc);
-        dbuf_put_u16(bc, s->arg_var_object_idx);
-        var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
+        dbuf_putc(bc, get_with_scope_opcode(op));
+        dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
+        label_done = new_label_fd(s, label_done);
+        dbuf_put_u32(bc, label_done);
+        dbuf_putc(bc, 0);
+        update_label(s, label_done, 1);
+        s->jump_size++;
     }
-
     /* check parent scopes */
     for (fd = s; fd->parent;) {
         scope_level = fd->parent_scope_level;
         fd = fd->parent;
+        if (scope_level == 0) {
+            /* function is defined as part of the argument parsing: hide vars
+               from the function body.
+               XXX: variables created from argument destructuring might need
+               to be visible, should refine this method.
+             */
+            var_idx = find_arg(ctx, fd, var_name);
+            goto check_idx;
+        }
         for (idx = fd->scopes[scope_level].first; idx >= 0;) {
             vd = &fd->vars[idx];
             if (vd->var_name == var_name) {
                 if (op == OP_scope_put_var || op == OP_scope_make_ref) {
                     if (vd->is_const) {
-                        dbuf_putc(bc, OP_throw_error);
+                        dbuf_putc(bc, OP_throw_var);
                         dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                         dbuf_putc(bc, JS_THROW_VAR_RO);
                         goto done;
                     }
+                    is_func_var = vd->is_func_var;
                 }
                 var_idx = idx;
                 break;
@@ -29769,19 +27959,26 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                 if (idx >= 0) {
                     dbuf_putc(bc, OP_get_var_ref);
                     dbuf_put_u16(bc, idx);
-                    var_object_test(ctx, s, var_name, op, bc, &label_done, 1);
+                    dbuf_putc(bc, get_with_scope_opcode(op));
+                    dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
+                    label_done = new_label_fd(s, label_done);
+                    dbuf_put_u32(bc, label_done);
+                    dbuf_putc(bc, 1);
+                    update_label(s, label_done, 1);
+                    s->jump_size++;
                 }
             }
             idx = vd->scope_next;
         }
-        is_arg_scope = (idx == ARG_SCOPE_END);
         if (var_idx >= 0)
             break;
-        
-        if (!is_arg_scope) {
-            var_idx = find_var(ctx, fd, var_name);
-            if (var_idx >= 0)
-                break;
+
+        var_idx = find_var(ctx, fd, var_name);
+    check_idx:
+        if (var_idx >= 0) {
+            if (!(var_idx & ARGUMENT_VAR_OFFSET))
+                is_func_var = fd->vars[var_idx].is_func_var;
+            break;
         }
         if (is_pseudo_var) {
             var_idx = resolve_pseudo_var(ctx, fd, var_name);
@@ -29789,39 +27986,33 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                 break;
         }
         if (var_name == JS_ATOM_arguments && fd->has_arguments_binding) {
-            var_idx = add_arguments_var(ctx, fd);
+            var_idx = add_arguments_var(ctx, fd, var_name);
             break;
         }
         if (fd->is_func_expr && fd->func_name == var_name) {
             /* add a new variable with the function name */
             var_idx = add_func_var(ctx, fd, var_name);
+            is_func_var = TRUE;
             break;
         }
 
         /* check eval object */
-        if (!is_arg_scope && fd->var_object_idx >= 0 && !is_pseudo_var) {
-            vd = &fd->vars[fd->var_object_idx];
-            vd->is_captured = 1;
+        if (fd->var_object_idx >= 0 && !is_pseudo_var) {
+            fd->vars[fd->var_object_idx].is_captured = 1;
             idx = get_closure_var(ctx, s, fd, FALSE,
-                                  fd->var_object_idx, vd->var_name,
+                                  fd->var_object_idx, JS_ATOM__var_,
                                   FALSE, FALSE, JS_VAR_NORMAL);
             dbuf_putc(bc, OP_get_var_ref);
             dbuf_put_u16(bc, idx);
-            var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
+            dbuf_putc(bc, get_with_scope_opcode(op));
+            dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
+            label_done = new_label_fd(s, label_done);
+            dbuf_put_u32(bc, label_done);
+            dbuf_putc(bc, 0);
+            update_label(s, label_done, 1);
+            s->jump_size++;
         }
 
-        /* check eval object in argument scope */
-        if (fd->arg_var_object_idx >= 0 && !is_pseudo_var) {
-            vd = &fd->vars[fd->arg_var_object_idx];
-            vd->is_captured = 1;
-            idx = get_closure_var(ctx, s, fd, FALSE,
-                                  fd->arg_var_object_idx, vd->var_name,
-                                  FALSE, FALSE, JS_VAR_NORMAL);
-            dbuf_putc(bc, OP_get_var_ref);
-            dbuf_put_u16(bc, idx);
-            var_object_test(ctx, s, var_name, op, bc, &label_done, 0);
-        }
-        
         if (fd->is_eval)
             break; /* it it necessarily the top level function */
     }
@@ -29846,7 +28037,6 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                 }
                 goto has_idx;
             } else if ((cv->var_name == JS_ATOM__var_ ||
-                        cv->var_name == JS_ATOM__arg_var_ ||
                         cv->var_name == JS_ATOM__with_) && !is_pseudo_var) {
                 int is_with = (cv->var_name == JS_ATOM__with_);
                 if (fd != s) {
@@ -29860,7 +28050,13 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
                 }
                 dbuf_putc(bc, OP_get_var_ref);
                 dbuf_put_u16(bc, idx);
-                var_object_test(ctx, s, var_name, op, bc, &label_done, is_with);
+                dbuf_putc(bc, get_with_scope_opcode(op));
+                dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
+                label_done = new_label_fd(s, label_done);
+                dbuf_put_u32(bc, label_done);
+                dbuf_putc(bc, is_with);
+                update_label(s, label_done, 1);
+                s->jump_size++;
             }
         }
     }
@@ -29885,14 +28081,14 @@ static int resolve_scope_var(JSContext *ctx, JSFunctionDef *s,
         has_idx:
             if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
                 s->closure_var[idx].is_const) {
-                dbuf_putc(bc, OP_throw_error);
+                dbuf_putc(bc, OP_throw_var);
                 dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
                 dbuf_putc(bc, JS_THROW_VAR_RO);
                 goto done;
             }
             switch (op) {
             case OP_scope_make_ref:
-                if (s->closure_var[idx].var_kind == JS_VAR_FUNCTION_NAME) {
+                if (is_func_var) {
                     /* Create a dummy object reference for the func_var */
                     dbuf_putc(bc, OP_object);
                     dbuf_putc(bc, OP_get_var_ref);
@@ -30056,6 +28252,8 @@ static int resolve_scope_private_field1(JSContext *ctx,
         }
         scope_level = fd->parent_scope_level;
         if (!fd->parent) {
+            char buf[ATOM_GET_STR_BUF_SIZE];
+
             if (fd->is_eval) {
                 /* closure of the eval function (top level) */
                 for (idx = 0; idx < fd->closure_var_count; idx++) {
@@ -30078,8 +28276,8 @@ static int resolve_scope_private_field1(JSContext *ctx,
                 }
             }
             /* XXX: no line number info */
-            JS_ThrowSyntaxErrorAtom(ctx, "undefined private field '%s'",
-                                    var_name);
+            JS_ThrowSyntaxError(ctx, "undefined private field %s",
+                                JS_AtomGetStr(ctx, buf, sizeof(buf), var_name));
             return -1;
         } else {
             fd = fd->parent;
@@ -30132,7 +28330,7 @@ static int resolve_scope_private_field(JSContext *ctx, JSFunctionDef *s,
             break;
         case JS_VAR_PRIVATE_SETTER:
             /* XXX: add clearer error message */
-            dbuf_putc(bc, OP_throw_error);
+            dbuf_putc(bc, OP_throw_var);
             dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
             dbuf_putc(bc, JS_THROW_VAR_RO);
             break;
@@ -30149,7 +28347,7 @@ static int resolve_scope_private_field(JSContext *ctx, JSFunctionDef *s,
         case JS_VAR_PRIVATE_METHOD:
         case JS_VAR_PRIVATE_GETTER:
             /* XXX: add clearer error message */
-            dbuf_putc(bc, OP_throw_error);
+            dbuf_putc(bc, OP_throw_var);
             dbuf_put_u32(bc, JS_DupAtom(ctx, var_name));
             dbuf_putc(bc, JS_THROW_VAR_RO);
             break;
@@ -30201,33 +28399,17 @@ static void mark_eval_captured_variables(JSContext *ctx, JSFunctionDef *s,
     }
 }
 
-/* XXX: should handle the argument scope generically */
-static BOOL is_var_in_arg_scope(const JSVarDef *vd)
-{
-    return (vd->var_name == JS_ATOM_home_object ||
-            vd->var_name == JS_ATOM_this_active_func ||
-            vd->var_name == JS_ATOM_new_target ||
-            vd->var_name == JS_ATOM_this ||
-            vd->var_name == JS_ATOM__arg_var_ ||
-            vd->var_kind == JS_VAR_FUNCTION_NAME);
-}
-
 static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
 {
     JSFunctionDef *fd;
     JSVarDef *vd;
     int i, scope_level, scope_idx;
-    BOOL has_arguments_binding, has_this_binding, is_arg_scope;
+    BOOL has_arguments_binding, has_this_binding;
 
     /* in non strict mode, variables are created in the caller's
        environment object */
     if (!s->is_eval && !(s->js_mode & JS_MODE_STRICT)) {
         s->var_object_idx = add_var(ctx, s, JS_ATOM__var_);
-        if (s->has_parameter_expressions) {
-            /* an additional variable object is needed for the
-               argument scope */
-            s->arg_var_object_idx = add_var(ctx, s, JS_ATOM__arg_var_);
-        }
     }
 
     /* eval can potentially use 'arguments' so we must define it */
@@ -30243,14 +28425,8 @@ static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
             s->home_object_var_idx = add_var(ctx, s, JS_ATOM_home_object);
     }
     has_arguments_binding = s->has_arguments_binding;
-    if (has_arguments_binding) {
-        add_arguments_var(ctx, s);
-        /* also add an arguments binding in the argument scope to
-           raise an error if a direct eval in the argument scope tries
-           to redefine it */
-        if (s->has_parameter_expressions && !(s->js_mode & JS_MODE_STRICT))
-            add_arguments_arg(ctx, s);
-    }
+    if (has_arguments_binding)
+        add_arguments_var(ctx, s, JS_ATOM_arguments);
     if (s->is_func_expr && s->func_name != JS_ATOM_NULL)
         add_func_var(ctx, s, s->func_name);
 
@@ -30267,6 +28443,7 @@ static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
         fd = fd->parent;
         if (!fd)
             break;
+        scope_idx = fd->scopes[scope_level].first;
         /* add 'this' if it was not previously added */
         if (!has_this_binding && fd->has_this_binding) {
             if (fd->this_var_idx < 0)
@@ -30281,7 +28458,7 @@ static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
         }
         /* add 'arguments' if it was not previously added */
         if (!has_arguments_binding && fd->has_arguments_binding) {
-            add_arguments_var(ctx, fd);
+            add_arguments_var(ctx, fd, JS_ATOM_arguments);
             has_arguments_binding = TRUE;
         }
         /* add function name */
@@ -30289,7 +28466,6 @@ static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
             add_func_var(ctx, fd, fd->func_name);
 
         /* add lexical variables */
-        scope_idx = fd->scopes[scope_level].first;
         while (scope_idx >= 0) {
             vd = &fd->vars[scope_idx];
             vd->is_captured = 1;
@@ -30297,37 +28473,24 @@ static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
                             vd->var_name, vd->is_const, vd->is_lexical, vd->var_kind);
             scope_idx = vd->scope_next;
         }
-        is_arg_scope = (scope_idx == ARG_SCOPE_END);
-        if (!is_arg_scope) {
-            /* add unscoped variables */
-            for(i = 0; i < fd->arg_count; i++) {
-                vd = &fd->args[i];
-                if (vd->var_name != JS_ATOM_NULL) {
-                    get_closure_var(ctx, s, fd,
-                                    TRUE, i, vd->var_name, FALSE, FALSE,
-                                    JS_VAR_NORMAL);
-                }
-            }
-            for(i = 0; i < fd->var_count; i++) {
-                vd = &fd->vars[i];
-                /* do not close top level last result */
-                if (vd->scope_level == 0 &&
-                    vd->var_name != JS_ATOM__ret_ &&
-                    vd->var_name != JS_ATOM_NULL) {
-                    get_closure_var(ctx, s, fd,
-                                    FALSE, i, vd->var_name, FALSE, FALSE,
-                                    JS_VAR_NORMAL);
-                }
+        /* add unscoped variables */
+        for(i = 0; i < fd->arg_count; i++) {
+            vd = &fd->args[i];
+            if (vd->var_name != JS_ATOM_NULL) {
+                get_closure_var(ctx, s, fd,
+                                TRUE, i, vd->var_name, FALSE, FALSE,
+                                JS_VAR_NORMAL);
             }
-        } else {
-            for(i = 0; i < fd->var_count; i++) {
-                vd = &fd->vars[i];
-                /* do not close top level last result */
-                if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {
-                    get_closure_var(ctx, s, fd,
-                                    FALSE, i, vd->var_name, FALSE, FALSE,
-                                    JS_VAR_NORMAL);
-                }
+        }
+        for(i = 0; i < fd->var_count; i++) {
+            vd = &fd->vars[i];
+            /* do not close top level last result */
+            if (vd->scope_level == 0 &&
+                vd->var_name != JS_ATOM__ret_ &&
+                vd->var_name != JS_ATOM_NULL) {
+                get_closure_var(ctx, s, fd,
+                                FALSE, i, vd->var_name, FALSE, FALSE,
+                                JS_VAR_NORMAL);
             }
         }
         if (fd->is_eval) {
@@ -30345,18 +28508,6 @@ static void add_eval_variables(JSContext *ctx, JSFunctionDef *s)
     }
 }
 
-static void set_closure_from_var(JSContext *ctx, JSClosureVar *cv,
-                                 JSVarDef *vd, int var_idx)
-{
-    cv->is_local = TRUE;
-    cv->is_arg = FALSE;
-    cv->is_const = vd->is_const;
-    cv->is_lexical = vd->is_lexical;
-    cv->var_kind = vd->var_kind;
-    cv->var_idx = var_idx;
-    cv->var_name = JS_DupAtom(ctx, vd->var_name);
-}
-
 /* for direct eval compilation: add references to the variables of the
    calling function */
 static __exception int add_closure_variables(JSContext *ctx, JSFunctionDef *s,
@@ -30364,8 +28515,7 @@ static __exception int add_closure_variables(JSContext *ctx, JSFunctionDef *s,
 {
     int i, count;
     JSVarDef *vd;
-    BOOL is_arg_scope;
-    
+
     count = b->arg_count + b->var_count + b->closure_var_count;
     s->closure_var = NULL;
     s->closure_var_count = 0;
@@ -30380,41 +28530,41 @@ static __exception int add_closure_variables(JSContext *ctx, JSFunctionDef *s,
         vd = &b->vardefs[b->arg_count + i];
         if (vd->scope_level > 0) {
             JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
-            set_closure_from_var(ctx, cv, vd, i);
+            cv->is_local = TRUE;
+            cv->is_arg = FALSE;
+            cv->is_const = vd->is_const;
+            cv->is_lexical = vd->is_lexical;
+            cv->var_kind = vd->var_kind;
+            cv->var_idx = i;
+            cv->var_name = JS_DupAtom(ctx, vd->var_name);
         }
         i = vd->scope_next;
     }
-    is_arg_scope = (i == ARG_SCOPE_END);
-    if (!is_arg_scope) {
-        /* Add argument variables */
-        for(i = 0; i < b->arg_count; i++) {
+    /* Add argument variables */
+    for(i = 0; i < b->arg_count; i++) {
+        JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
+        vd = &b->vardefs[i];
+        cv->is_local = TRUE;
+        cv->is_arg = TRUE;
+        cv->is_const = FALSE;
+        cv->is_lexical = FALSE;
+        cv->var_kind = JS_VAR_NORMAL;
+        cv->var_idx = i;
+        cv->var_name = JS_DupAtom(ctx, vd->var_name);
+    }
+    /* Add local non lexical variables */
+    for(i = 0; i < b->var_count; i++) {
+        vd = &b->vardefs[b->arg_count + i];
+        if (vd->scope_level == 0 && vd->var_name != JS_ATOM__ret_) {
             JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
-            vd = &b->vardefs[i];
             cv->is_local = TRUE;
-            cv->is_arg = TRUE;
+            cv->is_arg = FALSE;
             cv->is_const = FALSE;
             cv->is_lexical = FALSE;
             cv->var_kind = JS_VAR_NORMAL;
             cv->var_idx = i;
             cv->var_name = JS_DupAtom(ctx, vd->var_name);
         }
-        /* Add local non lexical variables */
-        for(i = 0; i < b->var_count; i++) {
-            vd = &b->vardefs[b->arg_count + i];
-            if (vd->scope_level == 0 && vd->var_name != JS_ATOM__ret_) {
-                JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
-                set_closure_from_var(ctx, cv, vd, i);
-            }
-        }
-    } else {
-        /* only add pseudo variables */
-        for(i = 0; i < b->var_count; i++) {
-            vd = &b->vardefs[b->arg_count + i];
-            if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {
-                JSClosureVar *cv = &s->closure_var[s->closure_var_count++];
-                set_closure_from_var(ctx, cv, vd, i);
-            }
-        }
     }
     for(i = 0; i < b->closure_var_count; i++) {
         JSClosureVar *cv0 = &b->closure_var[i];
@@ -30572,93 +28722,59 @@ static BOOL code_match(CodeContext *s, int pos, ...)
 
 static void instantiate_hoisted_definitions(JSContext *ctx, JSFunctionDef *s, DynBuf *bc)
 {
-    int i, idx, label_next = -1;
-
-    /* add the hoisted functions in arguments and local variables */
-    for(i = 0; i < s->arg_count; i++) {
-        JSVarDef *vd = &s->args[i];
-        if (vd->func_pool_idx >= 0) {
-            dbuf_putc(bc, OP_fclosure);
-            dbuf_put_u32(bc, vd->func_pool_idx);
-            dbuf_putc(bc, OP_put_arg);
-            dbuf_put_u16(bc, i);
-        }
-    }
-    for(i = 0; i < s->var_count; i++) {
-        JSVarDef *vd = &s->vars[i];
-        if (vd->scope_level == 0 && vd->func_pool_idx >= 0) {
-            dbuf_putc(bc, OP_fclosure);
-            dbuf_put_u32(bc, vd->func_pool_idx);
-            dbuf_putc(bc, OP_put_loc);
-            dbuf_put_u16(bc, i);
-        }
-    }
+    int i, idx, var_idx;
 
-    /* the module global variables must be initialized before
-       evaluating the module so that the exported functions are
-       visible if there are cyclic module references */
-    if (s->module) {
-        label_next = new_label_fd(s, -1);
-        
-        /* if 'this' is true, initialize the global variables and return */
-        dbuf_putc(bc, OP_push_this);
-        dbuf_putc(bc, OP_if_false);
-        dbuf_put_u32(bc, label_next);
-        update_label(s, label_next, 1);
-        s->jump_size++;
-    }
-    
-    /* add the global variables (only happens if s->is_global_var is
-       true) */
-    for(i = 0; i < s->global_var_count; i++) {
-        JSGlobalVar *hf = &s->global_vars[i];
+    /* add the hoisted functions and variables */
+    for(i = 0; i < s->hoisted_def_count; i++) {
+        JSHoistedDef *hf = &s->hoisted_def[i];
         int has_closure = 0;
         BOOL force_init = hf->force_init;
-        /* we are in an eval, so the closure contains all the
-           enclosing variables */
-        /* If the outer function has a variable environment,
-           create a property for the variable there */
-        for(idx = 0; idx < s->closure_var_count; idx++) {
-            JSClosureVar *cv = &s->closure_var[idx];
-            if (cv->var_name == hf->var_name) {
-                has_closure = 2;
-                force_init = FALSE;
-                break;
-            }
-            if (cv->var_name == JS_ATOM__var_ ||
-                cv->var_name == JS_ATOM__arg_var_) {
-                dbuf_putc(bc, OP_get_var_ref);
-                dbuf_put_u16(bc, idx);
-                has_closure = 1;
-                force_init = TRUE;
-                break;
+        if (s->is_global_var && hf->var_name != JS_ATOM_NULL) {
+            /* we are in an eval, so the closure contains all the
+               enclosing variables */
+            /* If the outer function has a variable environment,
+               create a property for the variable there */
+            for(idx = 0; idx < s->closure_var_count; idx++) {
+                JSClosureVar *cv = &s->closure_var[idx];
+                if (cv->var_name == hf->var_name) {
+                    has_closure = 2;
+                    force_init = FALSE;
+                    break;
+                }
+                if (cv->var_name == JS_ATOM__var_) {
+                    dbuf_putc(bc, OP_get_var_ref);
+                    dbuf_put_u16(bc, idx);
+                    has_closure = 1;
+                    force_init = TRUE;
+                    break;
+                }
             }
-        }
-        if (!has_closure) {
-            int flags;
-            
-            flags = 0;
-            if (s->eval_type != JS_EVAL_TYPE_GLOBAL)
-                flags |= JS_PROP_CONFIGURABLE;
-            if (hf->cpool_idx >= 0 && !hf->is_lexical) {
-                /* global function definitions need a specific handling */
-                dbuf_putc(bc, OP_fclosure);
-                dbuf_put_u32(bc, hf->cpool_idx);
-                
-                dbuf_putc(bc, OP_define_func);
-                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
-                dbuf_putc(bc, flags);
-                
-                goto done_global_var;
-            } else {
-                if (hf->is_lexical) {
-                    flags |= DEFINE_GLOBAL_LEX_VAR;
-                    if (!hf->is_const)
-                        flags |= JS_PROP_WRITABLE;
+            if (!has_closure) {
+                int flags;
+
+                flags = 0;
+                if (s->eval_type != JS_EVAL_TYPE_GLOBAL)
+                    flags |= JS_PROP_CONFIGURABLE;
+                if (hf->cpool_idx >= 0 && !hf->is_lexical) {
+                    /* global function definitions need a specific handling */
+                    dbuf_putc(bc, OP_fclosure);
+                    dbuf_put_u32(bc, hf->cpool_idx);
+
+                    dbuf_putc(bc, OP_define_func);
+                    dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
+                    dbuf_putc(bc, flags);
+
+                    goto done_hoisted_def;
+                } else {
+                    if (hf->is_lexical) {
+                        flags |= DEFINE_GLOBAL_LEX_VAR;
+                        if (!hf->is_const)
+                            flags |= JS_PROP_WRITABLE;
+                    }
+                    dbuf_putc(bc, OP_define_var);
+                    dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
+                    dbuf_putc(bc, flags);
                 }
-                dbuf_putc(bc, OP_define_var);
-                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
-                dbuf_putc(bc, flags);
             }
         }
         if (hf->cpool_idx >= 0 || force_init) {
@@ -30673,35 +28789,37 @@ static void instantiate_hoisted_definitions(JSContext *ctx, JSFunctionDef *s, Dy
             } else {
                 dbuf_putc(bc, OP_undefined);
             }
-            if (has_closure == 2) {
-                dbuf_putc(bc, OP_put_var_ref);
-                dbuf_put_u16(bc, idx);
-            } else if (has_closure == 1) {
-                dbuf_putc(bc, OP_define_field);
-                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
-                dbuf_putc(bc, OP_drop);
+            if (s->is_global_var) {
+                if (has_closure == 2) {
+                    dbuf_putc(bc, OP_put_var_ref);
+                    dbuf_put_u16(bc, idx);
+                } else if (has_closure == 1) {
+                    dbuf_putc(bc, OP_define_field);
+                    dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
+                    dbuf_putc(bc, OP_drop);
+                } else {
+                    /* XXX: Check if variable is writable and enumerable */
+                    dbuf_putc(bc, OP_put_var);
+                    dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
+                }
             } else {
-                /* XXX: Check if variable is writable and enumerable */
-                dbuf_putc(bc, OP_put_var);
-                dbuf_put_u32(bc, JS_DupAtom(ctx, hf->var_name));
+                var_idx = hf->var_idx;
+                if (var_idx & ARGUMENT_VAR_OFFSET) {
+                    dbuf_putc(bc, OP_put_arg);
+                    dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
+                } else {
+                    dbuf_putc(bc, OP_put_loc);
+                    dbuf_put_u16(bc, var_idx);
+                }
             }
         }
-    done_global_var:
+    done_hoisted_def:
         JS_FreeAtom(ctx, hf->var_name);
     }
-
-    if (s->module) {
-        dbuf_putc(bc, OP_return_undef);
-        
-        dbuf_putc(bc, OP_label);
-        dbuf_put_u32(bc, label_next);
-        s->label_slots[label_next].pos2 = bc->size;
-    }
-
-    js_free(ctx, s->global_vars);
-    s->global_vars = NULL;
-    s->global_var_count = 0;
-    s->global_var_size = 0;
+    js_free(ctx, s->hoisted_def);
+    s->hoisted_def = NULL;
+    s->hoisted_def_count = 0;
+    s->hoisted_def_size = 0;
 }
 
 static int skip_dead_code(JSFunctionDef *s, const uint8_t *bc_buf, int bc_len,
@@ -30781,7 +28899,7 @@ static int get_label_pos(JSFunctionDef *s, int label)
    variables when necessary */
 static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
 {
-    int pos, pos_next, bc_len, op, len, i, idx, line_num;
+    int pos, pos_next, bc_len, op, len, i, idx, arg_valid, line_num;
     uint8_t *bc_buf;
     JSAtom var_name;
     DynBuf bc_out;
@@ -30794,43 +28912,47 @@ static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
 
     /* first pass for runtime checks (must be done before the
        variables are created) */
-    for(i = 0; i < s->global_var_count; i++) {
-        JSGlobalVar *hf = &s->global_vars[i];
-        int flags;
-        
-        /* check if global variable (XXX: simplify) */
-        for(idx = 0; idx < s->closure_var_count; idx++) {
-            JSClosureVar *cv = &s->closure_var[idx];
-            if (cv->var_name == hf->var_name) {
-                if (s->eval_type == JS_EVAL_TYPE_DIRECT &&
-                    cv->is_lexical) {
-                    /* Check if a lexical variable is
-                       redefined as 'var'. XXX: Could abort
-                       compilation here, but for consistency
-                       with the other checks, we delay the
-                       error generation. */
-                    dbuf_putc(&bc_out, OP_throw_error);
-                    dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
-                    dbuf_putc(&bc_out, JS_THROW_VAR_REDECL);
+    if (s->is_global_var) {
+        for(i = 0; i < s->hoisted_def_count; i++) {
+            JSHoistedDef *hf = &s->hoisted_def[i];
+            int flags;
+
+            if (hf->var_name != JS_ATOM_NULL) {
+                /* check if global variable (XXX: simplify) */
+                for(idx = 0; idx < s->closure_var_count; idx++) {
+                    JSClosureVar *cv = &s->closure_var[idx];
+                    if (cv->var_name == hf->var_name) {
+                        if (s->eval_type == JS_EVAL_TYPE_DIRECT &&
+                            cv->is_lexical) {
+                            /* Check if a lexical variable is
+                               redefined as 'var'. XXX: Could abort
+                               compilation here, but for consistency
+                               with the other checks, we delay the
+                               error generation. */
+                            dbuf_putc(&bc_out, OP_throw_var);
+                            dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
+                            dbuf_putc(&bc_out, JS_THROW_VAR_REDECL);
+                        }
+                        goto next;
+                    }
+                    if (cv->var_name == JS_ATOM__var_)
+                        goto next;
                 }
-                goto next;
+
+                dbuf_putc(&bc_out, OP_check_define_var);
+                dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
+                flags = 0;
+                if (hf->is_lexical)
+                    flags |= DEFINE_GLOBAL_LEX_VAR;
+                if (hf->cpool_idx >= 0)
+                    flags |= DEFINE_GLOBAL_FUNC_VAR;
+                dbuf_putc(&bc_out, flags);
             }
-            if (cv->var_name == JS_ATOM__var_ ||
-                cv->var_name == JS_ATOM__arg_var_)
-                goto next;
+        next: ;
         }
-        
-        dbuf_putc(&bc_out, OP_check_define_var);
-        dbuf_put_u32(&bc_out, JS_DupAtom(ctx, hf->var_name));
-        flags = 0;
-        if (hf->is_lexical)
-            flags |= DEFINE_GLOBAL_LEX_VAR;
-        if (hf->cpool_idx >= 0)
-            flags |= DEFINE_GLOBAL_FUNC_VAR;
-        dbuf_putc(&bc_out, flags);
-    next: ;
     }
 
+    arg_valid = 0;
     line_num = 0; /* avoid warning */
     for (pos = 0; pos < bc_len; pos = pos_next) {
         op = bc_buf[pos];
@@ -30842,6 +28964,9 @@ static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
             s->line_number_size++;
             goto no_change;
 
+        case OP_set_arg_valid_upto:
+            arg_valid = get_u16(bc_buf + pos + 1);
+            break;
         case OP_eval: /* convert scope index to adjusted variable index */
             {
                 int call_argc = get_u16(bc_buf + pos + 1);
@@ -30867,7 +28992,7 @@ static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
             var_name = get_u32(bc_buf + pos + 1);
             scope = get_u16(bc_buf + pos + 5);
             pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,
-                                         NULL, NULL, pos_next);
+                                         NULL, NULL, pos_next, arg_valid);
             JS_FreeAtom(ctx, var_name);
             break;
         case OP_scope_make_ref:
@@ -30880,7 +29005,7 @@ static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
                 ls = &s->label_slots[label];
                 ls->ref_count--;  /* always remove label reference */
                 pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,
-                                             bc_buf, ls, pos_next);
+                                             bc_buf, ls, pos_next, arg_valid);
                 JS_FreeAtom(ctx, var_name);
             }
             break;
@@ -30961,7 +29086,7 @@ static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
         case OP_return:
         case OP_return_undef:
         case OP_throw:
-        case OP_throw_error:
+        case OP_throw_var:
         case OP_ret:
             if (OPTIMIZE) {
                 /* remove dead code */
@@ -30995,27 +29120,25 @@ static __exception int resolve_variables(JSContext *ctx, JSFunctionDef *s)
             {
                 int scope_idx, scope = get_u16(bc_buf + pos + 1);
 
-                if (scope == s->body_scope) {
+                if (scope == 1) {
                     instantiate_hoisted_definitions(ctx, s, &bc_out);
                 }
 
                 for(scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
                     JSVarDef *vd = &s->vars[scope_idx];
                     if (vd->scope_level == scope) {
-                        if (scope_idx != s->arguments_arg_idx) {
-                            if (vd->var_kind == JS_VAR_FUNCTION_DECL ||
-                                vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) {
-                                /* Initialize lexical variable upon entering scope */
-                                dbuf_putc(&bc_out, OP_fclosure);
-                                dbuf_put_u32(&bc_out, vd->func_pool_idx);
-                                dbuf_putc(&bc_out, OP_put_loc);
-                                dbuf_put_u16(&bc_out, scope_idx);
-                            } else {
-                                /* XXX: should check if variable can be used
-                                   before initialization */
-                                dbuf_putc(&bc_out, OP_set_loc_uninitialized);
-                                dbuf_put_u16(&bc_out, scope_idx);
-                            }
+                        if (vd->var_kind == JS_VAR_FUNCTION_DECL ||
+                            vd->var_kind == JS_VAR_NEW_FUNCTION_DECL) {
+                            /* Initialize lexical variable upon entering scope */
+                            dbuf_putc(&bc_out, OP_fclosure);
+                            dbuf_put_u32(&bc_out, vd->func_pool_or_scope_idx);
+                            dbuf_putc(&bc_out, OP_put_loc);
+                            dbuf_put_u16(&bc_out, scope_idx);
+                        } else {
+                            /* XXX: should check if variable can be used
+                               before initialization */
+                            dbuf_putc(&bc_out, OP_set_loc_uninitialized);
+                            dbuf_put_u16(&bc_out, scope_idx);
                         }
                         scope_idx = vd->scope_next;
                     } else {
@@ -31418,8 +29541,6 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
             dbuf_putc(&bc_out, OP_special_object);
             dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS);
         }
-        if (s->arguments_arg_idx >= 0)
-            put_short_code(&bc_out, OP_set_loc, s->arguments_arg_idx);
         put_short_code(&bc_out, OP_put_loc, s->arguments_var_idx);
     }
     /* initialize a reference to the current function if needed */
@@ -31434,11 +29555,6 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
         dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
         put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
     }
-    if (s->arg_var_object_idx >= 0) {
-        dbuf_putc(&bc_out, OP_special_object);
-        dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
-        put_short_code(&bc_out, OP_put_loc, s->arg_var_object_idx);
-    }
 
     for (pos = 0; pos < bc_len; pos = pos_next) {
         int val;
@@ -31446,6 +29562,20 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
         len = opcode_info[op].size;
         pos_next = pos + len;
         switch(op) {
+        case OP_close_var_object:
+            {
+                if (s->var_object_idx >= 0) {
+                    /* close the var object and create a new one */
+                    add_pc2line_info(s, bc_out.size, line_num);
+                    dbuf_putc(&bc_out, OP_close_loc);
+                    dbuf_put_u16(&bc_out, s->var_object_idx);
+                    dbuf_putc(&bc_out, OP_special_object);
+                    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
+                    put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
+                }
+            }
+            break;
+
         case OP_line_num:
             /* line number info (for debug). We put it in a separate
                compressed table to reduce memory usage and get better
@@ -31506,7 +29636,7 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
         case OP_return_undef:
         case OP_return_async:
         case OP_throw:
-        case OP_throw_error:
+        case OP_throw_var:
             pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
             goto no_change;
 
@@ -32070,20 +30200,20 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
             }
             goto no_change;
 
-#if SHORT_OPCODES
         case OP_typeof:
             if (OPTIMIZE) {
                 /* simplify typeof tests */
                 if (code_match(&cc, pos_next, OP_push_atom_value, M4(OP_strict_eq, OP_strict_neq, OP_eq, OP_neq), -1)) {
                     if (cc.line_num >= 0) line_num = cc.line_num;
                     int op1 = (cc.op == OP_strict_eq || cc.op == OP_eq) ? OP_strict_eq : OP_strict_neq;
+#if SHORT_OPCODES
                     int op2 = -1;
                     switch (cc.atom) {
                     case JS_ATOM_undefined:
-                        op2 = OP_typeof_is_undefined;
+                        op2 = OP_is_undefined;
                         break;
                     case JS_ATOM_function:
-                        op2 = OP_typeof_is_function;
+                        op2 = OP_is_function;
                         break;
                     }
                     if (op2 >= 0) {
@@ -32107,10 +30237,19 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
                             goto has_label;
                         }
                     }
+#endif
+                    if (cc.atom == JS_ATOM_undefined) {
+                        /* transform typeof(s) == "undefined" into s === void 0 */
+                        add_pc2line_info(s, bc_out.size, line_num);
+                        dbuf_putc(&bc_out, OP_undefined);
+                        dbuf_putc(&bc_out, op1);
+                        JS_FreeAtom(ctx, cc.atom);
+                        pos_next = cc.pos;
+                        break;
+                    }
                 }
             }
             goto no_change;
-#endif
 
         default:
         no_change:
@@ -32227,91 +30366,56 @@ static __exception int resolve_labels(JSContext *ctx, JSFunctionDef *s)
 /* compute the maximum stack size needed by the function */
 
 typedef struct StackSizeState {
-    int bc_len;
     int stack_len_max;
     uint16_t *stack_level_tab;
-    int *pc_stack;
-    int pc_stack_len;
-    int pc_stack_size;
 } StackSizeState;
 
-/* 'op' is only used for error indication */
-static __exception int ss_check(JSContext *ctx, StackSizeState *s,
-                                int pos, int op, int stack_len)
+static __exception int compute_stack_size_rec(JSContext *ctx,
+                                              JSFunctionDef *fd,
+                                              StackSizeState *s,
+                                              int pos, int op, int stack_len)
 {
-    if ((unsigned)pos >= s->bc_len) {
-        JS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)", op, pos);
-        return -1;
-    }
+    int bc_len, diff, n_pop, pos_next;
+    const JSOpCode *oi;
+    const uint8_t *bc_buf;
+
     if (stack_len > s->stack_len_max) {
         s->stack_len_max = stack_len;
-        if (s->stack_len_max > JS_STACK_SIZE_MAX) {
-            JS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
-            return -1;
-        }
+        if (s->stack_len_max > JS_STACK_SIZE_MAX)
+            goto stack_overflow;
     }
-    if (s->stack_level_tab[pos] != 0xffff) {
-        /* already explored: check that the stack size is consistent */
-        if (s->stack_level_tab[pos] != stack_len) {
-            JS_ThrowInternalError(ctx, "unconsistent stack size: %d %d (pc=%d)",
-                                  s->stack_level_tab[pos], stack_len, pos);
-            return -1;
+    bc_buf = fd->byte_code.buf;
+    bc_len = fd->byte_code.size;
+    for(;;) {
+        if ((unsigned)pos >= bc_len)
+            goto buf_overflow;
+#if 0
+        printf("%5d: %d\n", pos, stack_len);
+#endif
+        if (s->stack_level_tab[pos] != 0xffff) {
+            /* already explored: check that the stack size is consistent */
+            if (s->stack_level_tab[pos] != stack_len) {
+                JS_ThrowInternalError(ctx, "unconsistent stack size: %d %d (pc=%d)",
+                                      s->stack_level_tab[pos], stack_len, pos);
+                return -1;
+            } else {
+                return 0;
+            }
         } else {
-            return 0;
+            s->stack_level_tab[pos] = stack_len;
         }
-    }
 
-    /* mark as explored and store the stack size */
-    s->stack_level_tab[pos] = stack_len;
-
-    /* queue the new PC to explore */
-    if (js_resize_array(ctx, (void **)&s->pc_stack, sizeof(s->pc_stack[0]),
-                        &s->pc_stack_size, s->pc_stack_len + 1))
-        return -1;
-    s->pc_stack[s->pc_stack_len++] = pos;
-    return 0;
-}
-
-static __exception int compute_stack_size(JSContext *ctx,
-                                          JSFunctionDef *fd,
-                                          int *pstack_size)
-{
-    StackSizeState s_s, *s = &s_s;
-    int i, diff, n_pop, pos_next, stack_len, pos, op;
-    const JSOpCode *oi;
-    const uint8_t *bc_buf;
-
-    bc_buf = fd->byte_code.buf;
-    s->bc_len = fd->byte_code.size;
-    /* bc_len > 0 */
-    s->stack_level_tab = js_malloc(ctx, sizeof(s->stack_level_tab[0]) *
-                                   s->bc_len);
-    if (!s->stack_level_tab)
-        return -1;
-    for(i = 0; i < s->bc_len; i++)
-        s->stack_level_tab[i] = 0xffff;
-    s->stack_len_max = 0;
-    s->pc_stack = NULL;
-    s->pc_stack_len = 0;
-    s->pc_stack_size = 0;
-
-    /* breadth-first graph exploration */
-    if (ss_check(ctx, s, 0, OP_invalid, 0))
-        goto fail;
-
-    while (s->pc_stack_len > 0) {
-        pos = s->pc_stack[--s->pc_stack_len];
-        stack_len = s->stack_level_tab[pos];
         op = bc_buf[pos];
         if (op == 0 || op >= OP_COUNT) {
             JS_ThrowInternalError(ctx, "invalid opcode (op=%d, pc=%d)", op, pos);
-            goto fail;
+            return -1;
         }
         oi = &short_opcode_info(op);
         pos_next = pos + oi->size;
-        if (pos_next > s->bc_len) {
+        if (pos_next > bc_len) {
+        buf_overflow:
             JS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)", op, pos);
-            goto fail;
+            return -1;
         }
         n_pop = oi->n_pop;
         /* call pops a variable number of arguments */
@@ -32327,15 +30431,13 @@ static __exception int compute_stack_size(JSContext *ctx,
 
         if (stack_len < n_pop) {
             JS_ThrowInternalError(ctx, "stack underflow (op=%d, pc=%d)", op, pos);
-            goto fail;
+            return -1;
         }
         stack_len += oi->n_push - n_pop;
         if (stack_len > s->stack_len_max) {
             s->stack_len_max = stack_len;
-            if (s->stack_len_max > JS_STACK_SIZE_MAX) {
-                JS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
-                goto fail;
-            }
+            if (s->stack_len_max > JS_STACK_SIZE_MAX)
+                goto stack_overflow;
         }
         switch(op) {
         case OP_tail_call:
@@ -32344,9 +30446,9 @@ static __exception int compute_stack_size(JSContext *ctx,
         case OP_return_undef:
         case OP_return_async:
         case OP_throw:
-        case OP_throw_error:
+        case OP_throw_var:
         case OP_ret:
-            goto done_insn;
+            goto done;
         case OP_goto:
             diff = get_u32(bc_buf + pos + 1);
             pos_next = pos + 1 + diff;
@@ -32363,72 +30465,88 @@ static __exception int compute_stack_size(JSContext *ctx,
         case OP_if_true8:
         case OP_if_false8:
             diff = (int8_t)bc_buf[pos + 1];
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len))
-                goto fail;
+            if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len))
+                return -1;
             break;
 #endif
         case OP_if_true:
         case OP_if_false:
         case OP_catch:
             diff = get_u32(bc_buf + pos + 1);
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len))
-                goto fail;
+            if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len))
+                return -1;
             break;
         case OP_gosub:
             diff = get_u32(bc_buf + pos + 1);
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len + 1))
-                goto fail;
+            if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len + 1))
+                return -1;
             break;
         case OP_with_get_var:
         case OP_with_delete_var:
             diff = get_u32(bc_buf + pos + 5);
-            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 1))
-                goto fail;
+            if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op, stack_len + 1))
+                return -1;
             break;
         case OP_with_make_ref:
         case OP_with_get_ref:
         case OP_with_get_ref_undef:
             diff = get_u32(bc_buf + pos + 5);
-            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 2))
-                goto fail;
+            if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op, stack_len + 2))
+                return -1;
             break;
         case OP_with_put_var:
             diff = get_u32(bc_buf + pos + 5);
-            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len - 1))
-                goto fail;
+            if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op, stack_len - 1))
+                return -1;
             break;
 
         default:
             break;
         }
-        if (ss_check(ctx, s, pos_next, op, stack_len))
-            goto fail;
-    done_insn: ;
+        pos = pos_next;
     }
-    js_free(ctx, s->stack_level_tab);
-    js_free(ctx, s->pc_stack);
-    *pstack_size = s->stack_len_max;
+ done:
     return 0;
- fail:
-    js_free(ctx, s->stack_level_tab);
-    js_free(ctx, s->pc_stack);
-    *pstack_size = 0;
+
+ stack_overflow:
+    JS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
     return -1;
 }
 
+static __exception int compute_stack_size(JSContext *ctx,
+                                          JSFunctionDef *fd,
+                                          int *pstack_size)
+{
+    StackSizeState s_s, *s = &s_s;
+    int bc_len, i, ret;
+
+    bc_len = fd->byte_code.size;
+    /* bc_len > 0 */
+    s->stack_level_tab = js_malloc(ctx, sizeof(s->stack_level_tab[0]) * bc_len);
+    if (!s->stack_level_tab)
+        return -1;
+    for(i = 0; i < bc_len; i++)
+        s->stack_level_tab[i] = 0xffff;
+    s->stack_len_max = 0;
+    ret = compute_stack_size_rec(ctx, fd, s, 0, OP_invalid, 0);
+    js_free(ctx, s->stack_level_tab);
+    *pstack_size = s->stack_len_max;
+    return ret;
+}
+
 static int add_module_variables(JSContext *ctx, JSFunctionDef *fd)
 {
     int i, idx;
     JSModuleDef *m = fd->module;
     JSExportEntry *me;
-    JSGlobalVar *hf;
+    JSHoistedDef *hf;
 
     /* The imported global variables were added as closure variables
        in js_parse_import(). We add here the module global
        variables. */
 
-    for(i = 0; i < fd->global_var_count; i++) {
-        hf = &fd->global_vars[i];
+    for(i = 0; i < fd->hoisted_def_count; i++) {
+        hf = &fd->hoisted_def[i];
         if (add_closure_var(ctx, fd, TRUE, FALSE, i, hf->var_name, hf->is_const,
                             hf->is_lexical, FALSE) < 0)
             return -1;
@@ -32440,8 +30558,9 @@ static int add_module_variables(JSContext *ctx, JSFunctionDef *fd)
         if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
             idx = find_closure_var(ctx, fd, me->local_name);
             if (idx < 0) {
-                JS_ThrowSyntaxErrorAtom(ctx, "exported variable '%s' does not exist",
-                                        me->local_name);
+                char buf1[ATOM_GET_STR_BUF_SIZE];
+                JS_ThrowSyntaxError(ctx, "exported variable '%s' does not exist",
+                                    JS_AtomGetStr(ctx, buf1, sizeof(buf1), me->local_name));
                 return -1;
             }
             me->u.local.var_idx = idx;
@@ -32466,10 +30585,6 @@ static JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)
     for (scope = 0; scope < fd->scope_count; scope++) {
         fd->scopes[scope].first = -1;
     }
-    if (fd->has_parameter_expressions) {
-        /* special end of variable list marker for the argument scope */
-        fd->scopes[ARG_SCOPE_INDEX].first = ARG_SCOPE_END;
-    }
     for (idx = 0; idx < fd->var_count; idx++) {
         JSVarDef *vd = &fd->vars[idx];
         vd->scope_next = fd->scopes[vd->scope_level].first;
@@ -32477,12 +30592,12 @@ static JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)
     }
     for (scope = 2; scope < fd->scope_count; scope++) {
         JSVarScope *sd = &fd->scopes[scope];
-        if (sd->first < 0)
+        if (sd->first == -1)
             sd->first = fd->scopes[sd->parent].first;
     }
     for (idx = 0; idx < fd->var_count; idx++) {
         JSVarDef *vd = &fd->vars[idx];
-        if (vd->scope_next < 0 && vd->scope_level > 1) {
+        if (vd->scope_next == -1 && vd->scope_level > 1) {
             scope = fd->scopes[vd->scope_level].parent;
             vd->scope_next = fd->scopes[scope].first;
         }
@@ -32569,6 +30684,7 @@ static JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)
     if (!b)
         goto fail;
     b->header.ref_count = 1;
+    b->gc_header.mark = 0;
 
     b->byte_code_buf = (void *)((uint8_t*)b + byte_code_offset);
     b->byte_code_len = fd->byte_code.size;
@@ -32655,11 +30771,7 @@ static JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)
     b->super_call_allowed = fd->super_call_allowed;
     b->super_allowed = fd->super_allowed;
     b->arguments_allowed = fd->arguments_allowed;
-    b->backtrace_barrier = fd->backtrace_barrier;
-    b->realm = JS_DupContext(ctx);
 
-    add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
-    
 #if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
     if (!(fd->js_mode & JS_MODE_STRIP)) {
         js_dump_function_bytecode(ctx, b);
@@ -32703,8 +30815,6 @@ static void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b)
         JSClosureVar *cv = &b->closure_var[i];
         JS_FreeAtomRT(rt, cv->var_name);
     }
-    if (b->realm)
-        JS_FreeContext(b->realm);
 
     JS_FreeAtomRT(rt, b->func_name);
     if (b->has_debug) {
@@ -32712,13 +30822,7 @@ static void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b)
         js_free_rt(rt, b->debug.pc2line_buf);
         js_free_rt(rt, b->debug.source);
     }
-
-    remove_gc_object(&b->header);
-    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && b->header.ref_count != 0) {
-        list_add_tail(&b->header.link, &rt->gc_zero_ref_count_list);
-    } else {
-        js_free_rt(rt, b);
-    }
+    js_free_rt(rt, b);
 }
 
 static __exception int js_parse_directives(JSParseState *s)
@@ -32809,8 +30913,11 @@ static __exception int js_parse_directives(JSParseState *s)
         }
 #endif
 #ifdef CONFIG_BIGNUM
-        else if (s->ctx->bignum_ext && !strcmp(str, "use math")) {
-            s->cur_func->js_mode |= JS_MODE_MATH;
+        else if (!strcmp(str, "use bigint")) {
+            s->cur_func->js_mode |= JS_MODE_BIGINT;
+        }
+        else if (!strcmp(str, "use math")) {
+            s->cur_func->js_mode |= JS_MODE_BIGINT | JS_MODE_MATH;
         }
 #endif
     }
@@ -32854,8 +30961,7 @@ static int js_parse_function_check_names(JSParseState *s, JSFunctionDef *fd,
                 /* Check if argument name duplicates a destructuring parameter */
                 /* XXX: should have a flag for such variables */
                 for (i = 0; i < fd->var_count; i++) {
-                    if (fd->vars[i].var_name == name &&
-                        fd->vars[i].scope_level == 0)
+                    if (fd->vars[i].var_name == name)
                         goto duplicate;
                 }
             }
@@ -32964,8 +31070,8 @@ static __exception int js_parse_function_decl2(JSParseState *s,
 
     if (fd->is_eval && fd->eval_type == JS_EVAL_TYPE_MODULE &&
         (func_type == JS_PARSE_FUNC_STATEMENT || func_type == JS_PARSE_FUNC_VAR)) {
-        JSGlobalVar *hf;
-        hf = find_global_var(fd, func_name);
+        JSHoistedDef *hf;
+        hf = find_hoisted_def(fd, func_name);
         /* XXX: should check scope chain */
         if (hf && hf->scope_level == fd->scope_level) {
             js_parse_error(s, "invalid redefinition of global identifier in module code");
@@ -32975,23 +31081,21 @@ static __exception int js_parse_function_decl2(JSParseState *s,
     }
 
     if (func_type == JS_PARSE_FUNC_VAR) {
+        /* Create lexical name here so function closure contains it */
         if (!(fd->js_mode & JS_MODE_STRICT)
-        && func_kind == JS_FUNC_NORMAL
         &&  find_lexical_decl(ctx, fd, func_name, fd->scope_first, FALSE) < 0
         &&  !((func_idx = find_var(ctx, fd, func_name)) >= 0 && (func_idx & ARGUMENT_VAR_OFFSET))
         &&  !(func_name == JS_ATOM_arguments && fd->has_arguments_binding)) {
             create_func_var = TRUE;
         }
-        /* Create the lexical name here so that the function closure
-           contains it */
         if (fd->is_eval &&
             (fd->eval_type == JS_EVAL_TYPE_GLOBAL ||
              fd->eval_type == JS_EVAL_TYPE_MODULE) &&
-            fd->scope_level == fd->body_scope) {
+            fd->scope_level == 1) {
             /* avoid creating a lexical variable in the global
                scope. XXX: check annex B */
-            JSGlobalVar *hf;
-            hf = find_global_var(fd, func_name);
+            JSHoistedDef *hf;
+            hf = find_hoisted_def(fd, func_name);
             /* XXX: should check scope chain */
             if (hf && hf->scope_level == fd->scope_level) {
                 js_parse_error(s, "invalid redefinition of global identifier");
@@ -33066,7 +31170,6 @@ static __exception int js_parse_function_decl2(JSParseState *s,
     
     /* parse arguments */
     fd->has_simple_parameter_list = TRUE;
-    fd->has_parameter_expressions = FALSE;
     has_opt_arg = FALSE;
     if (func_type == JS_PARSE_FUNC_ARROW && s->token.val == TOK_IDENT) {
         JSAtom name;
@@ -33079,30 +31182,13 @@ static __exception int js_parse_function_decl2(JSParseState *s,
             goto fail;
         fd->defined_arg_count = 1;
     } else {
-        if (s->token.val == '(') {
-            int skip_bits;
-            /* if there is an '=' inside the parameter list, we
-               consider there is a parameter expression inside */
-            js_parse_skip_parens_token(s, &skip_bits, FALSE);
-            if (skip_bits & SKIP_HAS_ASSIGNMENT)
-                fd->has_parameter_expressions = TRUE;
-            if (next_token(s))
-                goto fail;
-        } else {
-            if (js_parse_expect(s, '('))
-                goto fail;
-        }
+        if (js_parse_expect(s, '('))
+            goto fail;
 
-        if (fd->has_parameter_expressions) {
-            fd->scope_level = -1; /* force no parent scope */
-            if (push_scope(s) < 0)
-                return -1;
-        }
-        
         while (s->token.val != ')') {
             JSAtom name;
             BOOL rest = FALSE;
-            int idx, has_initializer;
+            int idx;
 
             if (s->token.val == TOK_ELLIPSIS) {
                 fd->has_simple_parameter_list = FALSE;
@@ -33121,13 +31207,15 @@ static __exception int js_parse_function_decl2(JSParseState *s,
                     emit_op(s, OP_get_arg);
                     emit_u16(s, idx);
                 }
-                has_initializer = js_parse_destructuring_element(s, fd->has_parameter_expressions ? TOK_LET : TOK_VAR, 1, TRUE, -1, TRUE);
-                if (has_initializer < 0)
+                if (js_parse_destructing_element(s, TOK_VAR, 1, TRUE, -1, TRUE))
                     goto fail;
-                if (has_initializer)
-                    has_opt_arg = TRUE;
-                if (!has_opt_arg)
-                    fd->defined_arg_count++;
+                /* Close var object: necessary if direct eval call
+                   occurred in the assignment expression or if any
+                   variable was captured and a later direct eval call
+                   may instantiate it in the var object.
+                   The next pass will generate the capture if required.
+                 */
+                emit_op(s, OP_close_var_object);
             } else if (s->token.val == TOK_IDENT) {
                 if (s->token.u.ident.is_reserved) {
                     js_parse_error_reserved_identifier(s);
@@ -33138,11 +31226,6 @@ static __exception int js_parse_function_decl2(JSParseState *s,
                     js_parse_error_reserved_identifier(s);
                     goto fail;
                 }
-                if (fd->has_parameter_expressions) {
-                    if (define_var(s, fd, name, JS_VAR_DEF_LET) < 0)
-                        goto fail;
-                }
-                /* XXX: could avoid allocating an argument if rest is true */
                 idx = add_arg(ctx, fd, name);
                 if (idx < 0)
                     goto fail;
@@ -33151,55 +31234,72 @@ static __exception int js_parse_function_decl2(JSParseState *s,
                 if (rest) {
                     emit_op(s, OP_rest);
                     emit_u16(s, idx);
-                    if (fd->has_parameter_expressions) {
-                        emit_op(s, OP_dup);
-                        emit_op(s, OP_scope_put_var_init);
-                        emit_atom(s, name);
-                        emit_u16(s, fd->scope_level);
-                    }
                     emit_op(s, OP_put_arg);
                     emit_u16(s, idx);
                     fd->has_simple_parameter_list = FALSE;
                     has_opt_arg = TRUE;
                 } else if (s->token.val == '=') {
-                    int label;
-                    
                     fd->has_simple_parameter_list = FALSE;
                     has_opt_arg = TRUE;
 
                     if (next_token(s))
                         goto fail;
 
-                    label = new_label(s);
-                    emit_op(s, OP_get_arg);
-                    emit_u16(s, idx);
-                    emit_op(s, OP_dup);
-                    emit_op(s, OP_undefined);
-                    emit_op(s, OP_strict_eq);
-                    emit_goto(s, OP_if_false, label);
-                    emit_op(s, OP_drop);
-                    if (js_parse_assign_expr(s))
-                        goto fail;
-                    set_object_name(s, name);
-                    emit_op(s, OP_dup);
-                    emit_op(s, OP_put_arg);
-                    emit_u16(s, idx);
-                    emit_label(s, label);
-                    emit_op(s, OP_scope_put_var_init);
-                    emit_atom(s, name);
-                    emit_u16(s, fd->scope_level);
-                } else {
-                    if (!has_opt_arg) {
-                        fd->defined_arg_count++;
+                    /* optimize `x = void 0` default value: no code needed */
+                    if (s->token.val == TOK_VOID) {
+                        JSParsePos pos;
+                        js_parse_get_pos(s, &pos);
+                        if (next_token(s))
+                            goto fail;
+                        if (s->token.val == TOK_NUMBER) {
+                            if (next_token(s))
+                                goto fail;
+                            if (s->token.val == ',') {
+                                if (next_token(s))
+                                    goto fail;
+                                continue;
+                            }
+                            if (s->token.val == ')') {
+                                continue;
+                            }
+                        }
+                        if (js_parse_seek_token(s, &pos))
+                            goto fail;
                     }
-                    if (fd->has_parameter_expressions) {
-                        /* copy the argument to the argument scope */
+#if 0
+                    /* XXX: not correct for eval code */
+                    /* Check for a default value of `undefined`
+                       to omit default argument processing */
+                    if (s->token.val == TOK_IDENT &&
+                        s->token.u.ident.atom == JS_ATOM_undefined &&
+                        fd->parent == NULL &&
+                        ((tok = peek_token(s, FALSE)) == ',' || tok == ')')) {
+                        if (next_token(s))  /* ignore undefined token */
+                            goto fail;
+                    } else
+#endif
+                    {
+                        int label = new_label(s);
+                        if (idx > 0) {
+                            emit_op(s, OP_set_arg_valid_upto);
+                            emit_u16(s, idx);
+                        }
                         emit_op(s, OP_get_arg);
                         emit_u16(s, idx);
-                        emit_op(s, OP_scope_put_var_init);
-                        emit_atom(s, name);
-                        emit_u16(s, fd->scope_level);
+                        emit_op(s, OP_undefined);
+                        emit_op(s, OP_strict_eq);
+                        emit_goto(s, OP_if_false, label);
+                        if (js_parse_assign_expr(s, TRUE))
+                            goto fail;
+                        set_object_name(s, name);
+                        emit_op(s, OP_put_arg);
+                        emit_u16(s, idx);
+                        /* Close var object: see above comment. */
+                        emit_op(s, OP_close_var_object);
+                        emit_label(s, label);
                     }
+                } else if (!has_opt_arg) {
+                    fd->defined_arg_count++;
                 }
             } else {
                 js_parse_error(s, "missing formal parameter");
@@ -33209,10 +31309,10 @@ static __exception int js_parse_function_decl2(JSParseState *s,
                 js_parse_expect(s, ')');
                 goto fail;
             }
-            if (s->token.val == ')')
-                break;
-            if (js_parse_expect(s, ','))
-                goto fail;
+            if (s->token.val == ',') {
+                if (next_token(s))
+                    goto fail;
+            }
         }
         if ((func_type == JS_PARSE_FUNC_GETTER && fd->arg_count != 0) ||
             (func_type == JS_PARSE_FUNC_SETTER && fd->arg_count != 1)) {
@@ -33221,41 +31321,6 @@ static __exception int js_parse_function_decl2(JSParseState *s,
         }
     }
 
-    if (fd->has_parameter_expressions) {
-        int idx;
-
-        /* Copy the variables in the argument scope to the variable
-           scope (see FunctionDeclarationInstantiation() in spec). The
-           normal arguments are already present, so no need to copy
-           them. */
-        idx = fd->scopes[fd->scope_level].first;
-        while (idx >= 0) {
-            JSVarDef *vd = &fd->vars[idx];
-            if (vd->scope_level != fd->scope_level)
-                break;
-            if (find_var(ctx, fd, vd->var_name) < 0) {
-                if (add_var(ctx, fd, vd->var_name) < 0)
-                    goto fail;
-                vd = &fd->vars[idx]; /* fd->vars may have been reallocated */
-                emit_op(s, OP_scope_get_var);
-                emit_atom(s, vd->var_name);
-                emit_u16(s, fd->scope_level);
-                emit_op(s, OP_scope_put_var);
-                emit_atom(s, vd->var_name);
-                emit_u16(s, 0);
-            }
-            idx = vd->scope_next;
-        }
-        
-        /* the argument scope has no parent, hence we don't use pop_scope(s) */
-        emit_op(s, OP_leave_scope);
-        emit_u16(s, fd->scope_level);
-
-        /* set the variable scope as the current scope */
-        fd->scope_level = 0;
-        fd->scope_first = fd->scopes[fd->scope_level].first;
-    }
-    
     if (next_token(s))
         goto fail;
 
@@ -33267,8 +31332,7 @@ static __exception int js_parse_function_decl2(JSParseState *s,
     /* in generators, yield expression is forbidden during the parsing
        of the arguments */
     fd->in_function_body = TRUE;
-    push_scope(s);  /* enter body scope */
-    fd->body_scope = fd->scope_level;
+    push_scope(s);  /* enter body scope: fd->scope_level = 1 */
 
     if (s->token.val == TOK_ARROW) {
         if (next_token(s))
@@ -33278,7 +31342,7 @@ static __exception int js_parse_function_decl2(JSParseState *s,
             if (js_parse_function_check_names(s, fd, func_name))
                 goto fail;
 
-            if (js_parse_assign_expr(s))
+            if (js_parse_assign_expr(s, TRUE))
                 goto fail;
 
             if (func_kind != JS_FUNC_NORMAL)
@@ -33360,10 +31424,10 @@ done:
             emit_u32(s, idx);
             if (create_func_var) {
                 if (s->cur_func->is_global_var) {
-                    JSGlobalVar *hf;
+                    JSHoistedDef *hf;
                     /* the global variable must be defined at the start of the
                        function */
-                    hf = add_global_var(ctx, s->cur_func, func_name);
+                    hf = add_hoisted_def(ctx, s->cur_func, -1, func_name, -1, FALSE);
                     if (!hf)
                         goto fail;
                     /* it is considered as defined at the top level
@@ -33393,7 +31457,7 @@ done:
             }
             if (lexical_func_idx >= 0) {
                 /* lexical variable will be initialized upon entering scope */
-                s->cur_func->vars[lexical_func_idx].func_pool_idx = idx;
+                s->cur_func->vars[lexical_func_idx].func_pool_or_scope_idx = idx;
                 emit_op(s, OP_drop);
             } else {
                 /* store function object into its lexical name */
@@ -33409,23 +31473,17 @@ done:
                 if (var_idx < 0)
                     goto fail;
                 /* the variable will be assigned at the top of the function */
-                if (var_idx & ARGUMENT_VAR_OFFSET) {
-                    s->cur_func->args[var_idx - ARGUMENT_VAR_OFFSET].func_pool_idx = idx;
-                } else {
-                    s->cur_func->vars[var_idx].func_pool_idx = idx;
-                }
+                if (!add_hoisted_def(ctx, s->cur_func, idx, JS_ATOM_NULL, var_idx, FALSE))
+                    goto fail;
             } else {
                 JSAtom func_var_name;
-                JSGlobalVar *hf;
                 if (func_name == JS_ATOM_NULL)
                     func_var_name = JS_ATOM__default_; /* export default */
                 else
                     func_var_name = func_name;
                 /* the variable will be assigned at the top of the function */
-                hf = add_global_var(ctx, s->cur_func, func_var_name);
-                if (!hf)
+                if (!add_hoisted_def(ctx, s->cur_func, idx, func_var_name, -1, FALSE))
                     goto fail;
-                hf->cpool_idx = idx;
                 if (export_flag != JS_PARSE_EXPORT_NONE) {
                     if (!add_export_entry(s, s->cur_func->module, func_var_name,
                                           export_flag == JS_PARSE_EXPORT_NAMED ? func_var_name : JS_ATOM_default, JS_EXPORT_TYPE_LOCAL))
@@ -33525,9 +31583,7 @@ static JSValue JS_EvalFunctionInternal(JSContext *ctx, JSValue fun_obj,
         m = JS_VALUE_GET_PTR(fun_obj);
         /* the module refcount should be >= 2 */
         JS_FreeValue(ctx, fun_obj);
-        if (js_create_module_function(ctx, m) < 0)
-            goto fail;
-        if (js_link_module(ctx, m) < 0)
+        if (js_instantiate_module(ctx, m) < 0)
             goto fail;
         ret_val = js_evaluate_module(ctx, m);
         if (JS_IsException(ret_val)) {
@@ -33559,11 +31615,8 @@ static void skip_shebang(JSParseState *s)
                 break;
             } else if (*p >= 0x80) {
                 c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
-                if (c == CP_LS || c == CP_PS) {
+                if (c == CP_LS || c == CP_PS)
                     break;
-                } else if (c == -1) {
-                    p++; /* skip invalid UTF-8 */
-                }
             } else {
                 p++;
             }
@@ -33593,7 +31646,7 @@ static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
     m = NULL;
     if (eval_type == JS_EVAL_TYPE_DIRECT) {
         JSObject *p;
-        sf = ctx->rt->current_stack_frame;
+        sf = ctx->current_stack_frame;
         assert(sf != NULL);
         assert(JS_VALUE_GET_TAG(sf->cur_func) == JS_TAG_OBJECT);
         p = JS_VALUE_GET_OBJ(sf->cur_func);
@@ -33626,7 +31679,6 @@ static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
     s->cur_func = fd;
     fd->eval_type = eval_type;
     fd->has_this_binding = (eval_type != JS_EVAL_TYPE_DIRECT);
-    fd->backtrace_barrier = ((flags & JS_EVAL_FLAG_BACKTRACE_BARRIER) != 0);
     if (eval_type == JS_EVAL_TYPE_DIRECT) {
         fd->new_target_allowed = b->new_target_allowed;
         fd->super_call_allowed = b->super_call_allowed;
@@ -33649,8 +31701,7 @@ static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
     s->allow_html_comments = !s->is_module;
 
     push_scope(s); /* body scope */
-    fd->body_scope = fd->scope_level;
-    
+
     err = js_parse_program(s);
     if (err) {
     fail:
@@ -33713,27 +31764,19 @@ static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
 
 }
 
-JSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,
-                    const char *input, size_t input_len,
-                    const char *filename, int eval_flags)
+JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
+                const char *filename, int eval_flags)
 {
     int eval_type = eval_flags & JS_EVAL_TYPE_MASK;
     JSValue ret;
 
     assert(eval_type == JS_EVAL_TYPE_GLOBAL ||
            eval_type == JS_EVAL_TYPE_MODULE);
-    ret = JS_EvalInternal(ctx, this_obj, input, input_len, filename,
+    ret = JS_EvalInternal(ctx, ctx->global_obj, input, input_len, filename,
                           eval_flags, -1);
     return ret;
 }
 
-JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
-                const char *filename, int eval_flags)
-{
-    return JS_EvalThis(ctx, ctx->global_obj, input, input_len, filename,
-                       eval_flags);
-}
-
 int JS_ResolveModule(JSContext *ctx, JSValueConst obj)
 {
     if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
@@ -33746,110 +31789,6 @@ int JS_ResolveModule(JSContext *ctx, JSValueConst obj)
     return 0;
 }
 
-/*******************************************************************/
-/* object list */
-
-typedef struct {
-    JSObject *obj;
-    uint32_t hash_next; /* -1 if no next entry */
-} JSObjectListEntry;
-
-/* XXX: reuse it to optimize weak references */
-typedef struct {
-    JSObjectListEntry *object_tab;
-    int object_count;
-    int object_size;
-    uint32_t *hash_table;
-    uint32_t hash_size;
-} JSObjectList;
-
-static void js_object_list_init(JSObjectList *s)
-{
-    memset(s, 0, sizeof(*s));
-}
-
-static uint32_t js_object_list_get_hash(JSObject *p, uint32_t hash_size)
-{
-    return ((uintptr_t)p * 3163) & (hash_size - 1);
-}
-
-static int js_object_list_resize_hash(JSContext *ctx, JSObjectList *s,
-                                 uint32_t new_hash_size)
-{
-    JSObjectListEntry *e;
-    uint32_t i, h, *new_hash_table;
-
-    new_hash_table = js_malloc(ctx, sizeof(new_hash_table[0]) * new_hash_size);
-    if (!new_hash_table)
-        return -1;
-    js_free(ctx, s->hash_table);
-    s->hash_table = new_hash_table;
-    s->hash_size = new_hash_size;
-    
-    for(i = 0; i < s->hash_size; i++) {
-        s->hash_table[i] = -1;
-    }
-    for(i = 0; i < s->object_count; i++) {
-        e = &s->object_tab[i];
-        h = js_object_list_get_hash(e->obj, s->hash_size); 
-        e->hash_next = s->hash_table[h];
-        s->hash_table[h] = i;
-    }
-    return 0;
-}
-
-/* the reference count of 'obj' is not modified. Return 0 if OK, -1 if
-   memory error */
-static int js_object_list_add(JSContext *ctx, JSObjectList *s, JSObject *obj)
-{
-    JSObjectListEntry *e;
-    uint32_t h, new_hash_size;
-    
-    if (js_resize_array(ctx, (void *)&s->object_tab,
-                        sizeof(s->object_tab[0]),
-                        &s->object_size, s->object_count + 1))
-        return -1;
-    if (unlikely((s->object_count + 1) >= s->hash_size)) {
-        new_hash_size = max_uint32(s->hash_size, 4);
-        while (new_hash_size <= s->object_count)
-            new_hash_size *= 2;
-        if (js_object_list_resize_hash(ctx, s, new_hash_size))
-            return -1;
-    }
-    e = &s->object_tab[s->object_count++];
-    h = js_object_list_get_hash(obj, s->hash_size); 
-    e->obj = obj;
-    e->hash_next = s->hash_table[h];
-    s->hash_table[h] = s->object_count - 1;
-    return 0;
-}
-
-/* return -1 if not present or the object index */
-static int js_object_list_find(JSContext *ctx, JSObjectList *s, JSObject *obj)
-{
-    JSObjectListEntry *e;
-    uint32_t h, p;
-
-    /* must test empty size because there is no hash table */
-    if (s->object_count == 0)
-        return -1;
-    h = js_object_list_get_hash(obj, s->hash_size); 
-    p = s->hash_table[h];
-    while (p != -1) {
-        e = &s->object_tab[p];
-        if (e->obj == obj)
-            return p;
-        p = e->hash_next;
-    }
-    return -1;
-}
-
-static void js_object_list_end(JSContext *ctx, JSObjectList *s)
-{
-    js_free(ctx, s->object_tab);
-    js_free(ctx, s->hash_table);
-}
-
 /*******************************************************************/
 /* binary object writer & reader */
 
@@ -33865,16 +31804,9 @@ typedef enum BCTagEnum {
     BC_TAG_ARRAY,
     BC_TAG_BIG_INT,
     BC_TAG_BIG_FLOAT,
-    BC_TAG_BIG_DECIMAL,
     BC_TAG_TEMPLATE_OBJECT,
     BC_TAG_FUNCTION_BYTECODE,
     BC_TAG_MODULE,
-    BC_TAG_TYPED_ARRAY,
-    BC_TAG_ARRAY_BUFFER,
-    BC_TAG_SHARED_ARRAY_BUFFER,
-    BC_TAG_DATE,
-    BC_TAG_OBJECT_VALUE,
-    BC_TAG_OBJECT_REFERENCE,
 } BCTagEnum;
 
 #ifdef CONFIG_BIGNUM
@@ -33892,21 +31824,14 @@ typedef enum BCTagEnum {
 typedef struct BCWriterState {
     JSContext *ctx;
     DynBuf dbuf;
-    BOOL byte_swap : 8;
-    BOOL allow_bytecode : 8;
-    BOOL allow_sab : 8;
-    BOOL allow_reference : 8;
+    BOOL byte_swap;
+    BOOL allow_bytecode;
     uint32_t first_atom;
     uint32_t *atom_to_idx;
     int atom_to_idx_size;
     JSAtom *idx_to_atom;
     int idx_to_atom_count;
     int idx_to_atom_size;
-    uint8_t **sab_tab;
-    int sab_tab_len;
-    int sab_tab_size;
-    /* list of referenced objects (used if allow_reference = TRUE) */
-    JSObjectList object_list;
 } BCWriterState;
 
 #ifdef DUMP_READ_OBJECT
@@ -33921,18 +31846,11 @@ static const char * const bc_tag_str[] = {
     "string",
     "object",
     "array",
-    "bigint",
-    "bigfloat",
-    "bigdecimal",
+    "big_int",
+    "big_float",
     "template",
     "function",
     "module",
-    "TypedArray",
-    "ArrayBuffer",
-    "SharedArrayBuffer",
-    "Date",
-    "ObjectValue",
-    "ObjectReference",
 };
 #endif
 
@@ -33992,20 +31910,36 @@ static int bc_atom_to_idx(BCWriterState *s, uint32_t *pres, JSAtom atom)
         return 0;
     }
     if (atom >= s->atom_to_idx_size) {
-        int old_size, i;
-        old_size = s->atom_to_idx_size;
-        if (js_resize_array(s->ctx, (void **)&s->atom_to_idx,
-                            sizeof(s->atom_to_idx[0]), &s->atom_to_idx_size,
-                            atom + 1))
-            return -1;
-        /* XXX: could add a specific js_resize_array() function to do it */
-        for(i = old_size; i < s->atom_to_idx_size; i++)
-            s->atom_to_idx[i] = 0;
+        size_t new_size, i, slack;
+        uint32_t *new_tab;
+        /* XXX: potential arithmetic overflow */
+        new_size = s->atom_to_idx_size * 3 / 2;
+        if ((atom + 1) > new_size)
+            new_size = atom + 1;
+        new_tab = js_realloc2(s->ctx, s->atom_to_idx,
+                              new_size * sizeof(s->atom_to_idx[0]), &slack);
+        if (!new_tab)
+            goto fail;
+        new_size += slack / sizeof(*new_tab);
+        for(i = s->atom_to_idx_size; i < new_size; i++)
+            new_tab[i] = 0;
+        s->atom_to_idx = new_tab;
+        s->atom_to_idx_size = new_size;
+    }
+    if ((s->idx_to_atom_count + 1) > s->idx_to_atom_size) {
+        size_t new_size, slack;
+        JSAtom *new_tab;
+        new_size = s->idx_to_atom_size * 3 / 2;
+        if ((s->idx_to_atom_count + 1) > new_size)
+            new_size = s->idx_to_atom_count + 1;
+        new_tab = js_realloc2(s->ctx, s->idx_to_atom,
+                              new_size * sizeof(s->idx_to_atom[0]), &slack);
+        if (!new_tab)
+            goto fail;
+        new_size += slack / sizeof(*new_tab);
+        s->idx_to_atom = new_tab;
+        s->idx_to_atom_size = new_size;
     }
-    if (js_resize_array(s->ctx, (void **)&s->idx_to_atom,
-                        sizeof(s->idx_to_atom[0]),
-                        &s->idx_to_atom_size, s->idx_to_atom_count + 1))
-        goto fail;
 
     v = s->idx_to_atom_count++;
     s->idx_to_atom[v] = atom + s->first_atom;
@@ -34151,413 +32085,10 @@ static void JS_WriteString(BCWriterState *s, JSString *p)
     }
 }
 
-#ifdef CONFIG_BIGNUM
-static int JS_WriteBigNum(BCWriterState *s, JSValueConst obj)
-{
-    uint32_t tag, tag1;
-    int64_t e;
-    JSBigFloat *bf = JS_VALUE_GET_PTR(obj);
-    bf_t *a = &bf->num;
-    size_t len, i, n1, j;
-    limb_t v;
-
-    tag = JS_VALUE_GET_TAG(obj);
-    switch(tag) {
-    case JS_TAG_BIG_INT:
-        tag1 = BC_TAG_BIG_INT;
-        break;
-    case JS_TAG_BIG_FLOAT:
-        tag1 = BC_TAG_BIG_FLOAT;
-        break;
-    case JS_TAG_BIG_DECIMAL:
-        tag1 = BC_TAG_BIG_DECIMAL;
-        break;
-    default:
-        abort();
-    }
-    bc_put_u8(s, tag1);
-
-    /* sign + exponent */
-    if (a->expn == BF_EXP_ZERO)
-        e = 0;
-    else if (a->expn == BF_EXP_INF)
-        e = 1;
-    else if (a->expn == BF_EXP_NAN)
-        e = 2;
-    else if (a->expn >= 0)
-        e = a->expn + 3;
-    else
-        e = a->expn;
-    e = (e << 1) | a->sign;
-    if (e < INT32_MIN || e > INT32_MAX) {
-        JS_ThrowInternalError(s->ctx, "bignum exponent is too large");
-        return -1;
-    }
-    bc_put_sleb128(s, e);
-
-    /* mantissa */
-    if (a->len != 0) {
-        if (tag != JS_TAG_BIG_DECIMAL) {
-            i = 0;
-            while (i < a->len && a->tab[i] == 0)
-                i++;
-            assert(i < a->len);
-            v = a->tab[i];
-            n1 = sizeof(limb_t);
-            while ((v & 0xff) == 0) {
-                n1--;
-                v >>= 8;
-            }
-            i++;
-            len = (a->len - i) * sizeof(limb_t) + n1;
-            if (len > INT32_MAX) {
-                JS_ThrowInternalError(s->ctx, "bignum is too large");
-                return -1;
-            }
-            bc_put_leb128(s, len);
-            /* always saved in byte based little endian representation */
-            for(j = 0; j < n1; j++) {
-                dbuf_putc(&s->dbuf, v >> (j * 8));
-            }
-            for(; i < a->len; i++) {
-                limb_t v = a->tab[i];
-#if LIMB_BITS == 32
-#ifdef WORDS_BIGENDIAN
-                v = bswap32(v);
-#endif
-                dbuf_put_u32(&s->dbuf, v);
-#else
-#ifdef WORDS_BIGENDIAN
-                v = bswap64(v);
-#endif
-                dbuf_put_u64(&s->dbuf, v);
-#endif
-            }
-        } else {
-            int bpos, d;
-            uint8_t v8;
-            size_t i0;
-            
-            /* little endian BCD */
-            i = 0;
-            while (i < a->len && a->tab[i] == 0)
-                i++;
-            assert(i < a->len);
-            len = a->len * LIMB_DIGITS;
-            v = a->tab[i];
-            j = 0;
-            while ((v % 10) == 0) {
-                j++;
-                v /= 10;
-            }
-            len -= j;
-            assert(len > 0);
-            if (len > INT32_MAX) {
-                JS_ThrowInternalError(s->ctx, "bignum is too large");
-                return -1;
-            }
-            bc_put_leb128(s, len);
-            
-            bpos = 0;
-            v8 = 0;
-            i0 = i;
-            for(; i < a->len; i++) {
-                if (i != i0) {
-                    v = a->tab[i];
-                    j = 0;
-                }
-                for(; j < LIMB_DIGITS; j++) {
-                    d = v % 10;
-                    v /= 10;
-                    if (bpos == 0) {
-                        v8 = d;
-                        bpos = 1;
-                    } else {
-                        dbuf_putc(&s->dbuf, v8 | (d << 4));
-                        bpos = 0;
-                    }
-                }
-            }
-            /* flush the last digit */
-            if (bpos) {
-                dbuf_putc(&s->dbuf, v8);
-            }
-        }
-    }
-    return 0;
-}
-#endif /* CONFIG_BIGNUM */
-
-static int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj);
-
-static int JS_WriteFunctionTag(BCWriterState *s, JSValueConst obj)
-{
-    JSFunctionBytecode *b = JS_VALUE_GET_PTR(obj);
-    uint32_t flags;
-    int idx, i;
-    
-    bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);
-    flags = idx = 0;
-    bc_set_flags(&flags, &idx, b->has_prototype, 1);
-    bc_set_flags(&flags, &idx, b->has_simple_parameter_list, 1);
-    bc_set_flags(&flags, &idx, b->is_derived_class_constructor, 1);
-    bc_set_flags(&flags, &idx, b->need_home_object, 1);
-    bc_set_flags(&flags, &idx, b->func_kind, 2);
-    bc_set_flags(&flags, &idx, b->new_target_allowed, 1);
-    bc_set_flags(&flags, &idx, b->super_call_allowed, 1);
-    bc_set_flags(&flags, &idx, b->super_allowed, 1);
-    bc_set_flags(&flags, &idx, b->arguments_allowed, 1);
-    bc_set_flags(&flags, &idx, b->has_debug, 1);
-    bc_set_flags(&flags, &idx, b->backtrace_barrier, 1);
-    assert(idx <= 16);
-    bc_put_u16(s, flags);
-    bc_put_u8(s, b->js_mode);
-    bc_put_atom(s, b->func_name);
-    
-    bc_put_leb128(s, b->arg_count);
-    bc_put_leb128(s, b->var_count);
-    bc_put_leb128(s, b->defined_arg_count);
-    bc_put_leb128(s, b->stack_size);
-    bc_put_leb128(s, b->closure_var_count);
-    bc_put_leb128(s, b->cpool_count);
-    bc_put_leb128(s, b->byte_code_len);
-    if (b->vardefs) {
-        /* XXX: this field is redundant */
-        bc_put_leb128(s, b->arg_count + b->var_count);
-        for(i = 0; i < b->arg_count + b->var_count; i++) {
-            JSVarDef *vd = &b->vardefs[i];
-            bc_put_atom(s, vd->var_name);
-            bc_put_leb128(s, vd->scope_level);
-            bc_put_leb128(s, vd->scope_next + 1);
-            flags = idx = 0;
-            bc_set_flags(&flags, &idx, vd->var_kind, 4);
-            bc_set_flags(&flags, &idx, vd->is_const, 1);
-            bc_set_flags(&flags, &idx, vd->is_lexical, 1);
-            bc_set_flags(&flags, &idx, vd->is_captured, 1);
-            assert(idx <= 8);
-            bc_put_u8(s, flags);
-        }
-    } else {
-        bc_put_leb128(s, 0);
-    }
-    
-    for(i = 0; i < b->closure_var_count; i++) {
-        JSClosureVar *cv = &b->closure_var[i];
-        bc_put_atom(s, cv->var_name);
-        bc_put_leb128(s, cv->var_idx);
-        flags = idx = 0;
-        bc_set_flags(&flags, &idx, cv->is_local, 1);
-        bc_set_flags(&flags, &idx, cv->is_arg, 1);
-        bc_set_flags(&flags, &idx, cv->is_const, 1);
-        bc_set_flags(&flags, &idx, cv->is_lexical, 1);
-        bc_set_flags(&flags, &idx, cv->var_kind, 4);
-        assert(idx <= 8);
-        bc_put_u8(s, flags);
-    }
-    
-    if (JS_WriteFunctionBytecode(s, b->byte_code_buf, b->byte_code_len))
-        goto fail;
-    
-    if (b->has_debug) {
-        bc_put_atom(s, b->debug.filename);
-        bc_put_leb128(s, b->debug.line_num);
-        bc_put_leb128(s, b->debug.pc2line_len);
-        dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);
-    }
-    
-    for(i = 0; i < b->cpool_count; i++) {
-        if (JS_WriteObjectRec(s, b->cpool[i]))
-            goto fail;
-    }
-    return 0;
- fail:
-    return -1;
-}
-
-static int JS_WriteModule(BCWriterState *s, JSValueConst obj)
-{
-    JSModuleDef *m = JS_VALUE_GET_PTR(obj);
-    int i;
-    
-    bc_put_u8(s, BC_TAG_MODULE);
-    bc_put_atom(s, m->module_name);
-    
-    bc_put_leb128(s, m->req_module_entries_count);
-    for(i = 0; i < m->req_module_entries_count; i++) {
-        JSReqModuleEntry *rme = &m->req_module_entries[i];
-        bc_put_atom(s, rme->module_name);
-    }
-    
-    bc_put_leb128(s, m->export_entries_count);
-    for(i = 0; i < m->export_entries_count; i++) {
-        JSExportEntry *me = &m->export_entries[i];
-        bc_put_u8(s, me->export_type);
-        if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
-            bc_put_leb128(s, me->u.local.var_idx);
-        } else {
-            bc_put_leb128(s, me->u.req_module_idx);
-            bc_put_atom(s, me->local_name);
-        }
-        bc_put_atom(s, me->export_name);
-    }
-    
-    bc_put_leb128(s, m->star_export_entries_count);
-    for(i = 0; i < m->star_export_entries_count; i++) {
-        JSStarExportEntry *se = &m->star_export_entries[i];
-        bc_put_leb128(s, se->req_module_idx);
-    }
-    
-    bc_put_leb128(s, m->import_entries_count);
-    for(i = 0; i < m->import_entries_count; i++) {
-        JSImportEntry *mi = &m->import_entries[i];
-        bc_put_leb128(s, mi->var_idx);
-        bc_put_atom(s, mi->import_name);
-        bc_put_leb128(s, mi->req_module_idx);
-    }
-    
-    if (JS_WriteObjectRec(s, m->func_obj))
-        goto fail;
-    return 0;
- fail:
-    return -1;
-}
-
-static int JS_WriteArray(BCWriterState *s, JSValueConst obj)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(obj);
-    uint32_t i, len;
-    JSValue val;
-    int ret;
-    BOOL is_template;
-    
-    if (s->allow_bytecode && !p->extensible) {
-        /* not extensible array: we consider it is a
-           template when we are saving bytecode */
-        bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT);
-        is_template = TRUE;
-    } else {
-        bc_put_u8(s, BC_TAG_ARRAY);
-        is_template = FALSE;
-    }
-    if (js_get_length32(s->ctx, &len, obj))
-        goto fail1;
-    bc_put_leb128(s, len);
-    for(i = 0; i < len; i++) {
-        val = JS_GetPropertyUint32(s->ctx, obj, i);
-        if (JS_IsException(val))
-            goto fail1;
-        ret = JS_WriteObjectRec(s, val);
-        JS_FreeValue(s->ctx, val);
-        if (ret)
-            goto fail1;
-    }
-    if (is_template) {
-        val = JS_GetProperty(s->ctx, obj, JS_ATOM_raw);
-        if (JS_IsException(val))
-            goto fail1;
-        ret = JS_WriteObjectRec(s, val);
-        JS_FreeValue(s->ctx, val);
-        if (ret)
-            goto fail1;
-    }
-    return 0;
- fail1:
-    return -1;
-}
-
-static int JS_WriteObjectTag(BCWriterState *s, JSValueConst obj)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(obj);
-    uint32_t i, prop_count;
-    JSShape *sh;
-    JSShapeProperty *pr;
-    int pass;
-    JSAtom atom;
-
-    bc_put_u8(s, BC_TAG_OBJECT);
-    prop_count = 0;
-    sh = p->shape;
-    for(pass = 0; pass < 2; pass++) {
-        if (pass == 1)
-            bc_put_leb128(s, prop_count);
-        for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
-            atom = pr->atom;
-            if (atom != JS_ATOM_NULL &&
-                JS_AtomIsString(s->ctx, atom) &&
-                (pr->flags & JS_PROP_ENUMERABLE)) {
-                if (pr->flags & JS_PROP_TMASK) {
-                    JS_ThrowTypeError(s->ctx, "only value properties are supported");
-                    goto fail;
-                }
-                if (pass == 0) {
-                    prop_count++;
-                } else {
-                    bc_put_atom(s, atom);
-                    if (JS_WriteObjectRec(s, p->prop[i].u.value))
-                        goto fail;
-                }
-            }
-        }
-    }
-    return 0;
- fail:
-    return -1;
-}
-
-static int JS_WriteTypedArray(BCWriterState *s, JSValueConst obj)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(obj);
-    JSTypedArray *ta = p->u.typed_array;
-
-    bc_put_u8(s, BC_TAG_TYPED_ARRAY);
-    bc_put_u8(s, p->class_id - JS_CLASS_UINT8C_ARRAY);
-    bc_put_leb128(s, p->u.array.count);
-    bc_put_leb128(s, ta->offset);
-    if (JS_WriteObjectRec(s, JS_MKPTR(JS_TAG_OBJECT, ta->buffer)))
-        return -1;
-    return 0;
-}
-
-static int JS_WriteArrayBuffer(BCWriterState *s, JSValueConst obj)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(obj);
-    JSArrayBuffer *abuf = p->u.array_buffer;
-    if (abuf->detached) {
-        JS_ThrowTypeErrorDetachedArrayBuffer(s->ctx);
-        return -1;
-    }
-    bc_put_u8(s, BC_TAG_ARRAY_BUFFER);
-    bc_put_leb128(s, abuf->byte_length);
-    dbuf_put(&s->dbuf, abuf->data, abuf->byte_length);
-    return 0;
-}
-
-static int JS_WriteSharedArrayBuffer(BCWriterState *s, JSValueConst obj)
-{
-    JSObject *p = JS_VALUE_GET_OBJ(obj);
-    JSArrayBuffer *abuf = p->u.array_buffer;
-    assert(!abuf->detached); /* SharedArrayBuffer are never detached */
-    bc_put_u8(s, BC_TAG_SHARED_ARRAY_BUFFER);
-    bc_put_leb128(s, abuf->byte_length);
-    bc_put_u64(s, (uintptr_t)abuf->data);
-    if (js_resize_array(s->ctx, (void **)&s->sab_tab, sizeof(s->sab_tab[0]),
-                        &s->sab_tab_size, s->sab_tab_len + 1))
-        return -1;
-    /* keep the SAB pointer so that the user can clone it or free it */
-    s->sab_tab[s->sab_tab_len++] = abuf->data;
-    return 0;
-}
-
 static int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj)
 {
-    uint32_t tag;
-
-    if (js_check_stack_overflow(s->ctx->rt, 0)) {
-        JS_ThrowStackOverflow(s->ctx);
-        return -1;
-    }
+    uint32_t tag = JS_VALUE_GET_NORM_TAG(obj);
 
-    tag = JS_VALUE_GET_NORM_TAG(obj);
     switch(tag) {
     case JS_TAG_NULL:
         bc_put_u8(s, BC_TAG_NULL);
@@ -34588,90 +32119,291 @@ static int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj)
         }
         break;
     case JS_TAG_FUNCTION_BYTECODE:
-        if (!s->allow_bytecode)
-            goto invalid_tag;
-        if (JS_WriteFunctionTag(s, obj))
-            goto fail;
+        {
+            JSFunctionBytecode *b = JS_VALUE_GET_PTR(obj);
+            uint32_t flags;
+            int idx, i;
+
+            if (!s->allow_bytecode)
+                goto invalid_tag;
+            bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);
+            flags = idx = 0;
+            bc_set_flags(&flags, &idx, b->has_prototype, 1);
+            bc_set_flags(&flags, &idx, b->has_simple_parameter_list, 1);
+            bc_set_flags(&flags, &idx, b->is_derived_class_constructor, 1);
+            bc_set_flags(&flags, &idx, b->need_home_object, 1);
+            bc_set_flags(&flags, &idx, b->func_kind, 2);
+            bc_set_flags(&flags, &idx, b->new_target_allowed, 1);
+            bc_set_flags(&flags, &idx, b->super_call_allowed, 1);
+            bc_set_flags(&flags, &idx, b->super_allowed, 1);
+            bc_set_flags(&flags, &idx, b->arguments_allowed, 1);
+            bc_set_flags(&flags, &idx, b->has_debug, 1);
+            assert(idx <= 16);
+            bc_put_u16(s, flags);
+            bc_put_u8(s, b->js_mode);
+            bc_put_atom(s, b->func_name);
+
+            bc_put_leb128(s, b->arg_count);
+            bc_put_leb128(s, b->var_count);
+            bc_put_leb128(s, b->defined_arg_count);
+            bc_put_leb128(s, b->stack_size);
+            bc_put_leb128(s, b->closure_var_count);
+            bc_put_leb128(s, b->cpool_count);
+            bc_put_leb128(s, b->byte_code_len);
+            if (b->vardefs) {
+                bc_put_leb128(s, b->arg_count + b->var_count);
+                for(i = 0; i < b->arg_count + b->var_count; i++) {
+                    JSVarDef *vd = &b->vardefs[i];
+                    bc_put_atom(s, vd->var_name);
+                    bc_put_leb128(s, vd->scope_level);
+                    bc_put_leb128(s, vd->scope_next + 1);
+                    flags = idx = 0;
+                    bc_set_flags(&flags, &idx, vd->var_kind, 4);
+                    bc_set_flags(&flags, &idx, vd->is_func_var, 1);
+                    bc_set_flags(&flags, &idx, vd->is_const, 1);
+                    bc_set_flags(&flags, &idx, vd->is_lexical, 1);
+                    bc_set_flags(&flags, &idx, vd->is_captured, 1);
+                    assert(idx <= 8);
+                    bc_put_u8(s, flags);
+                }
+            } else {
+                bc_put_leb128(s, 0);
+            }
+
+            for(i = 0; i < b->closure_var_count; i++) {
+                JSClosureVar *cv = &b->closure_var[i];
+                bc_put_atom(s, cv->var_name);
+                bc_put_leb128(s, cv->var_idx);
+                flags = idx = 0;
+                bc_set_flags(&flags, &idx, cv->is_local, 1);
+                bc_set_flags(&flags, &idx, cv->is_arg, 1);
+                bc_set_flags(&flags, &idx, cv->is_const, 1);
+                bc_set_flags(&flags, &idx, cv->is_lexical, 1);
+                bc_set_flags(&flags, &idx, cv->var_kind, 4);
+                assert(idx <= 8);
+                bc_put_u8(s, flags);
+            }
+
+            if (JS_WriteFunctionBytecode(s, b->byte_code_buf, b->byte_code_len))
+                goto fail;
+
+            if (b->has_debug) {
+                bc_put_atom(s, b->debug.filename);
+                bc_put_leb128(s, b->debug.line_num);
+                bc_put_leb128(s, b->debug.pc2line_len);
+                dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);
+            }
+
+            for(i = 0; i < b->cpool_count; i++) {
+                if (JS_WriteObjectRec(s, b->cpool[i]))
+                    goto fail;
+            }
+        }
         break;
     case JS_TAG_MODULE:
-        if (!s->allow_bytecode)
-            goto invalid_tag;
-        if (JS_WriteModule(s, obj))
-            goto fail;
+        {
+            JSModuleDef *m = JS_VALUE_GET_PTR(obj);
+            int i;
+
+            if (!s->allow_bytecode)
+                goto invalid_tag;
+            bc_put_u8(s, BC_TAG_MODULE);
+            bc_put_atom(s, m->module_name);
+
+            bc_put_leb128(s, m->req_module_entries_count);
+            for(i = 0; i < m->req_module_entries_count; i++) {
+                JSReqModuleEntry *rme = &m->req_module_entries[i];
+                bc_put_atom(s, rme->module_name);
+            }
+
+            bc_put_leb128(s, m->export_entries_count);
+            for(i = 0; i < m->export_entries_count; i++) {
+                JSExportEntry *me = &m->export_entries[i];
+                bc_put_u8(s, me->export_type);
+                if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
+                    bc_put_leb128(s, me->u.local.var_idx);
+                } else {
+                    bc_put_leb128(s, me->u.req_module_idx);
+                    bc_put_atom(s, me->local_name);
+                }
+                bc_put_atom(s, me->export_name);
+            }
+
+            bc_put_leb128(s, m->star_export_entries_count);
+            for(i = 0; i < m->star_export_entries_count; i++) {
+                JSStarExportEntry *se = &m->star_export_entries[i];
+                bc_put_leb128(s, se->req_module_idx);
+            }
+
+            bc_put_leb128(s, m->import_entries_count);
+            for(i = 0; i < m->import_entries_count; i++) {
+                JSImportEntry *mi = &m->import_entries[i];
+                bc_put_leb128(s, mi->var_idx);
+                bc_put_atom(s, mi->import_name);
+                bc_put_leb128(s, mi->req_module_idx);
+            }
+
+            if (JS_WriteObjectRec(s, m->func_obj))
+                goto fail;
+        }
         break;
     case JS_TAG_OBJECT:
         {
             JSObject *p = JS_VALUE_GET_OBJ(obj);
-            int ret, idx;
-            
-            if (s->allow_reference) {
-                idx = js_object_list_find(s->ctx, &s->object_list, p);
-                if (idx >= 0) {
-                    bc_put_u8(s, BC_TAG_OBJECT_REFERENCE);
-                    bc_put_leb128(s, idx);
-                    break;
+            uint32_t i, prop_count, len;
+            JSShape *sh;
+            JSShapeProperty *pr;
+            JSValue val;
+            int ret, pass;
+            BOOL is_template;
+            JSAtom atom;
+
+            if (p->class_id != JS_CLASS_ARRAY &&
+                p->class_id != JS_CLASS_OBJECT) {
+                JS_ThrowTypeError(s->ctx, "unsupported object class");
+                goto fail;
+            }
+            if (p->tmp_mark) {
+                JS_ThrowTypeError(s->ctx, "circular reference");
+                goto fail;
+            }
+            p->tmp_mark = 1;
+            if (p->class_id == JS_CLASS_ARRAY) {
+                if (s->allow_bytecode && !p->extensible) {
+                    /* not extensible array: we consider it is a
+                       template when we are saving bytecode */
+                    bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT);
+                    is_template = TRUE;
                 } else {
-                    if (js_object_list_add(s->ctx, &s->object_list, p))
-                        goto fail;
+                    bc_put_u8(s, BC_TAG_ARRAY);
+                    is_template = FALSE;
                 }
-            } else {
-                if (p->tmp_mark) {
-                    JS_ThrowTypeError(s->ctx, "circular reference");
-                    goto fail;
+                if (js_get_length32(s->ctx, &len, obj))
+                    goto fail1;
+                bc_put_leb128(s, len);
+                for(i = 0; i < len; i++) {
+                    val = JS_GetPropertyUint32(s->ctx, obj, i);
+                    if (JS_IsException(val))
+                        goto fail1;
+                    ret = JS_WriteObjectRec(s, val);
+                    JS_FreeValue(s->ctx, val);
+                    if (ret)
+                        goto fail1;
                 }
-                p->tmp_mark = 1;
-            }
-            switch(p->class_id) {
-            case JS_CLASS_ARRAY:
-                ret = JS_WriteArray(s, obj);
-                break;
-            case JS_CLASS_OBJECT:
-                ret = JS_WriteObjectTag(s, obj);
-                break;
-            case JS_CLASS_ARRAY_BUFFER:
-                ret = JS_WriteArrayBuffer(s, obj);
-                break;
-            case JS_CLASS_SHARED_ARRAY_BUFFER:
-                if (!s->allow_sab)
-                    goto invalid_tag;
-                ret = JS_WriteSharedArrayBuffer(s, obj);
-                break;
-            case JS_CLASS_DATE:
-                bc_put_u8(s, BC_TAG_DATE);
-                ret = JS_WriteObjectRec(s, p->u.object_data);
-                break;
-            case JS_CLASS_NUMBER:
-            case JS_CLASS_STRING:
-            case JS_CLASS_BOOLEAN:
-#ifdef CONFIG_BIGNUM
-            case JS_CLASS_BIG_INT:
-            case JS_CLASS_BIG_FLOAT:
-            case JS_CLASS_BIG_DECIMAL:
-#endif
-                bc_put_u8(s, BC_TAG_OBJECT_VALUE);
-                ret = JS_WriteObjectRec(s, p->u.object_data);
-                break;
-            default:
-                if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&
-                    p->class_id <= JS_CLASS_FLOAT64_ARRAY) {
-                    ret = JS_WriteTypedArray(s, obj);
-                } else {
-                    JS_ThrowTypeError(s->ctx, "unsupported object class");
-                    ret = -1;
+                if (is_template) {
+                    val = JS_GetProperty(s->ctx, obj, JS_ATOM_raw);
+                    if (JS_IsException(val))
+                        goto fail1;
+                    ret = JS_WriteObjectRec(s, val);
+                    JS_FreeValue(s->ctx, val);
+                    if (ret)
+                        goto fail1;
+                }
+            } else {
+                bc_put_u8(s, BC_TAG_OBJECT);
+                prop_count = 0;
+                sh = p->shape;
+                for(pass = 0; pass < 2; pass++) {
+                    if (pass == 1)
+                        bc_put_leb128(s, prop_count);
+                    for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
+                        atom = pr->atom;
+                        if (atom != JS_ATOM_NULL &&
+                            JS_AtomIsString(s->ctx, atom) &&
+                            (pr->flags & JS_PROP_ENUMERABLE)) {
+                            if (pr->flags & JS_PROP_TMASK) {
+                                JS_ThrowTypeError(s->ctx, "only value properties are supported");
+                                goto fail;
+                            }
+                            if (pass == 0) {
+                                prop_count++;
+                            } else {
+                                bc_put_atom(s, atom);
+                                if (JS_WriteObjectRec(s, p->prop[i].u.value)) {
+                                fail1:
+                                    p->tmp_mark = 0;
+                                    goto fail;
+                                }
+                            }
+                        }
+                    }
                 }
-                break;
             }
             p->tmp_mark = 0;
-            if (ret)
-                goto fail;
         }
         break;
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
-    case JS_TAG_BIG_DECIMAL:
-        if (JS_WriteBigNum(s, obj))
-            goto fail;
+        {
+            int32_t e;
+            JSBigFloat *bf = JS_VALUE_GET_PTR(obj);
+            bf_t *a = &bf->num;
+            size_t len, i, n1, j;
+            limb_t v;
+
+            bc_put_u8(s, tag == JS_TAG_BIG_INT ? BC_TAG_BIG_INT :
+                      BC_TAG_BIG_FLOAT);
+            if (a->len != 0) {
+                i = 0;
+                while (i < a->len && a->tab[i] == 0)
+                    i++;
+                assert(i < a->len);
+                v = a->tab[i];
+                n1 = sizeof(limb_t);
+                while ((v & 0xff) == 0) {
+                    n1--;
+                    v >>= 8;
+                }
+                i++;
+                len = (a->len - i) * sizeof(limb_t) + n1;
+                if (len > INT32_MAX) {
+                    JS_ThrowInternalError(s->ctx, "bignum is too large");
+                    goto fail;
+                }
+                /* XXX: it would be slightly more efficient to put the
+                   sign in the MSB of the mantissa */
+                bc_put_leb128(s, len * 2 + a->sign);
+                /* always saved in byte based little endian representation */
+                for(j = 0; j < n1; j++) {
+                    dbuf_putc(&s->dbuf, v >> (j * 8));
+                }
+                for(; i < a->len; i++) {
+                    limb_t v = a->tab[i];
+#if LIMB_BITS == 32
+#ifdef WORDS_BIGENDIAN
+                    v = bswap32(v);
+#endif
+                    dbuf_put_u32(&s->dbuf, v);
+#else
+#ifdef WORDS_BIGENDIAN
+                    v = bswap64(v);
+#endif
+                    dbuf_put_u64(&s->dbuf, v);
+#endif
+                }
+#if LIMB_BITS != 32
+                if (a->expn <= INT32_MIN || a->expn >= (INT32_MAX - 1)) {
+                    JS_ThrowInternalError(s->ctx, "bignum exponent is too large");
+                    goto fail;
+                }
+#endif
+                bc_put_sleb128(s, a->expn);
+            } else {
+                bc_put_leb128(s, a->sign); /* length + sign */
+                if (tag == JS_TAG_BIG_FLOAT) {
+                    /* special numbers */
+                    if (a->expn == BF_EXP_ZERO) {
+                        e = 0;
+                    } else if (a->expn == BF_EXP_INF) {
+                        e = 1;
+                    } else {
+                        e = 2;
+                    }
+                    bc_put_u8(s, e);
+                }
+            }
+        }
         break;
 #endif
     default:
@@ -34725,8 +32457,8 @@ static int JS_WriteObjectAtoms(BCWriterState *s)
     return -1;
 }
 
-uint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,
-                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len)
+uint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,
+                        int flags)
 {
     BCWriterState ss, *s = &ss;
 
@@ -34735,48 +32467,29 @@ uint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,
     /* XXX: byte swapped output is untested */
     s->byte_swap = ((flags & JS_WRITE_OBJ_BSWAP) != 0);
     s->allow_bytecode = ((flags & JS_WRITE_OBJ_BYTECODE) != 0);
-    s->allow_sab = ((flags & JS_WRITE_OBJ_SAB) != 0);
-    s->allow_reference = ((flags & JS_WRITE_OBJ_REFERENCE) != 0);
     /* XXX: could use a different version when bytecode is included */
     if (s->allow_bytecode)
         s->first_atom = JS_ATOM_END;
     else
         s->first_atom = 1;
     js_dbuf_init(ctx, &s->dbuf);
-    js_object_list_init(&s->object_list);
-    
+
     if (JS_WriteObjectRec(s, obj))
         goto fail;
     if (JS_WriteObjectAtoms(s))
         goto fail;
-    js_object_list_end(ctx, &s->object_list);
     js_free(ctx, s->atom_to_idx);
     js_free(ctx, s->idx_to_atom);
     *psize = s->dbuf.size;
-    if (psab_tab)
-        *psab_tab = s->sab_tab;
-    if (psab_tab_len)
-        *psab_tab_len = s->sab_tab_len;
     return s->dbuf.buf;
  fail:
-    js_object_list_end(ctx, &s->object_list);
     js_free(ctx, s->atom_to_idx);
     js_free(ctx, s->idx_to_atom);
     dbuf_free(&s->dbuf);
     *psize = 0;
-    if (psab_tab)
-        *psab_tab = NULL;
-    if (psab_tab_len)
-        *psab_tab_len = 0;
     return NULL;
 }
 
-uint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,
-                        int flags)
-{
-    return JS_WriteObject2(ctx, psize, obj, flags, NULL, NULL);
-}
-
 typedef struct BCReaderState {
     JSContext *ctx;
     const uint8_t *buf_start, *ptr, *buf_end;
@@ -34784,15 +32497,8 @@ typedef struct BCReaderState {
     uint32_t idx_to_atom_count;
     JSAtom *idx_to_atom;
     int error_state;
-    BOOL allow_sab : 8;
-    BOOL allow_bytecode : 8;
-    BOOL is_rom_data : 8;
-    BOOL allow_reference : 8;
-    /* object references */
-    JSObject **objects;
-    int objects_count;
-    int objects_size;
-    
+    BOOL allow_bytecode;
+    BOOL is_rom_data;
 #ifdef DUMP_READ_OBJECT
     const uint8_t *ptr_last;
     int level;
@@ -34905,835 +32611,164 @@ static int bc_get_sleb128(BCReaderState *s, int32_t *pval)
     return 0;
 }
 
-/* XXX: used to read an `int` with a positive value */
-static int bc_get_leb128_int(BCReaderState *s, int *pval)
-{
-    return bc_get_leb128(s, (uint32_t *)pval);
-}
-
-static int bc_get_leb128_u16(BCReaderState *s, uint16_t *pval)
-{
-    uint32_t val;
-    if (bc_get_leb128(s, &val)) {
-        *pval = 0;
-        return -1;
-    }
-    *pval = val;
-    return 0;
-}
-
-static int bc_get_buf(BCReaderState *s, uint8_t *buf, uint32_t buf_len)
-{
-    if (buf_len != 0) {
-        if (unlikely(!buf || s->buf_end - s->ptr < buf_len))
-            return bc_read_error_end(s);
-        memcpy(buf, s->ptr, buf_len);
-        s->ptr += buf_len;
-    }
-    return 0;
-}
-
-static int bc_idx_to_atom(BCReaderState *s, JSAtom *patom, uint32_t idx)
-{
-    JSAtom atom;
-
-    if (__JS_AtomIsTaggedInt(idx)) {
-        atom = idx;
-    } else if (idx < s->first_atom) {
-        atom = JS_DupAtom(s->ctx, idx);
-    } else {
-        idx -= s->first_atom;
-        if (idx >= s->idx_to_atom_count) {
-            JS_ThrowSyntaxError(s->ctx, "invalid atom index (pos=%u)",
-                                (unsigned int)(s->ptr - s->buf_start));
-            *patom = JS_ATOM_NULL;
-            return s->error_state = -1;
-        }
-        atom = JS_DupAtom(s->ctx, s->idx_to_atom[idx]);
-    }
-    *patom = atom;
-    return 0;
-}
-
-static int bc_get_atom(BCReaderState *s, JSAtom *patom)
-{
-    uint32_t v;
-    if (bc_get_leb128(s, &v))
-        return -1;
-    if (v & 1) {
-        *patom = __JS_AtomFromUInt32(v >> 1);
-        return 0;
-    } else {
-        return bc_idx_to_atom(s, patom, v >> 1);
-    }
-}
-
-static JSString *JS_ReadString(BCReaderState *s)
-{
-    uint32_t len;
-    size_t size;
-    BOOL is_wide_char;
-    JSString *p;
-
-    if (bc_get_leb128(s, &len))
-        return NULL;
-    is_wide_char = len & 1;
-    len >>= 1;
-    p = js_alloc_string(s->ctx, len, is_wide_char);
-    if (!p) {
-        s->error_state = -1;
-        return NULL;
-    }
-    size = (size_t)len << is_wide_char;
-    if ((s->buf_end - s->ptr) < size) {
-        bc_read_error_end(s);
-        js_free_string(s->ctx->rt, p);
-        return NULL;
-    }
-    memcpy(p->u.str8, s->ptr, size);
-    s->ptr += size;
-    if (!is_wide_char) {
-        p->u.str8[size] = '\0'; /* add the trailing zero for 8 bit strings */
-    }
-#ifdef DUMP_READ_OBJECT
-    JS_DumpString(s->ctx->rt, p); printf("\n");
-#endif
-    return p;
-}
-
-static uint32_t bc_get_flags(uint32_t flags, int *pidx, int n)
-{
-    uint32_t val;
-    /* XXX: this does not work for n == 32 */
-    val = (flags >> *pidx) & ((1U << n) - 1);
-    *pidx += n;
-    return val;
-}
-
-static int JS_ReadFunctionBytecode(BCReaderState *s, JSFunctionBytecode *b,
-                                   int byte_code_offset, uint32_t bc_len)
-{
-    uint8_t *bc_buf;
-    int pos, len, op;
-    JSAtom atom;
-    uint32_t idx;
-
-    if (s->is_rom_data) {
-        /* directly use the input buffer */
-        if (unlikely(s->buf_end - s->ptr < bc_len))
-            return bc_read_error_end(s);
-        bc_buf = (uint8_t *)s->ptr;
-        s->ptr += bc_len;
-    } else {
-        bc_buf = (void *)((uint8_t*)b + byte_code_offset);
-        if (bc_get_buf(s, bc_buf, bc_len))
-            return -1;
-    }
-    b->byte_code_buf = bc_buf;
-
-    pos = 0;
-    while (pos < bc_len) {
-        op = bc_buf[pos];
-        len = short_opcode_info(op).size;
-        switch(short_opcode_info(op).fmt) {
-        case OP_FMT_atom:
-        case OP_FMT_atom_u8:
-        case OP_FMT_atom_u16:
-        case OP_FMT_atom_label_u8:
-        case OP_FMT_atom_label_u16:
-            idx = get_u32(bc_buf + pos + 1);
-            if (s->is_rom_data) {
-                /* just increment the reference count of the atom */
-                JS_DupAtom(s->ctx, (JSAtom)idx);
-            } else {
-                if (bc_idx_to_atom(s, &atom, idx)) {
-                    /* Note: the atoms will be freed up to this position */
-                    b->byte_code_len = pos;
-                    return -1;
-                }
-                put_u32(bc_buf + pos + 1, atom);
-#ifdef DUMP_READ_OBJECT
-                bc_read_trace(s, "at %d, fixup atom: ", pos + 1); print_atom(s->ctx, atom); printf("\n");
-#endif
-            }
-            break;
-        default:
-            break;
-        }
-        pos += len;
-    }
-    return 0;
-}
-
-#ifdef CONFIG_BIGNUM
-static JSValue JS_ReadBigNum(BCReaderState *s, int tag)
-{
-    JSValue obj = JS_UNDEFINED;
-    uint8_t v8;
-    int32_t e;
-    uint32_t len;
-    limb_t l, i, n, j;
-    JSBigFloat *p;
-    limb_t v;
-    bf_t *a;
-    int bpos, d;
-    
-    p = js_new_bf(s->ctx);
-    if (!p)
-        goto fail;
-    switch(tag) {
-    case BC_TAG_BIG_INT:
-        obj = JS_MKPTR(JS_TAG_BIG_INT, p);
-        break;
-    case BC_TAG_BIG_FLOAT:
-        obj = JS_MKPTR(JS_TAG_BIG_FLOAT, p);
-        break;
-    case BC_TAG_BIG_DECIMAL:
-        obj = JS_MKPTR(JS_TAG_BIG_DECIMAL, p);
-        break;
-    default:
-        abort();
-    }
-
-    /* sign + exponent */
-    if (bc_get_sleb128(s, &e))
-        goto fail;
-
-    a = &p->num;
-    a->sign = e & 1;
-    e >>= 1;
-    if (e == 0)
-        a->expn = BF_EXP_ZERO;
-    else if (e == 1)
-        a->expn = BF_EXP_INF;
-    else if (e == 2)
-        a->expn = BF_EXP_NAN;
-    else if (e >= 3)
-        a->expn = e - 3;
-    else
-        a->expn = e;
-
-    /* mantissa */
-    if (a->expn != BF_EXP_ZERO &&
-        a->expn != BF_EXP_INF &&
-        a->expn != BF_EXP_NAN) {
-        if (bc_get_leb128(s, &len))
-            goto fail;
-        bc_read_trace(s, "len=%" PRId64 "\n", (int64_t)len);
-        if (len == 0) {
-            JS_ThrowInternalError(s->ctx, "invalid bignum length");
-            goto fail;
-        }
-        if (tag != BC_TAG_BIG_DECIMAL)
-            l = (len + sizeof(limb_t) - 1) / sizeof(limb_t);
-        else
-            l = (len + LIMB_DIGITS - 1) / LIMB_DIGITS;
-        if (bf_resize(a, l)) {
-            JS_ThrowOutOfMemory(s->ctx);
-            goto fail;
-        }
-        if (tag != BC_TAG_BIG_DECIMAL) {
-            n = len & (sizeof(limb_t) - 1);
-            if (n != 0) {
-                v = 0;
-                for(i = 0; i < n; i++) {
-                    if (bc_get_u8(s, &v8))
-                        goto fail;
-                    v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);
-                }
-                a->tab[0] = v;
-                i = 1;
-            } else {
-                i = 0;
-            }
-            for(; i < l; i++) {
-#if LIMB_BITS == 32
-                if (bc_get_u32(s, &v))
-                    goto fail;
-#ifdef WORDS_BIGENDIAN
-                v = bswap32(v);
-#endif
-#else
-                if (bc_get_u64(s, &v))
-                    goto fail;
-#ifdef WORDS_BIGENDIAN
-                v = bswap64(v);
-#endif
-#endif
-                a->tab[i] = v;
-            }
-        } else {
-            bpos = 0;
-            for(i = 0; i < l; i++) {
-                if (i == 0 && (n = len % LIMB_DIGITS) != 0) {
-                    j = LIMB_DIGITS - n;
-                } else {
-                    j = 0;
-                }
-                v = 0;
-                for(; j < LIMB_DIGITS; j++) {
-                    if (bpos == 0) {
-                        if (bc_get_u8(s, &v8))
-                            goto fail;
-                        d = v8 & 0xf;
-                        bpos = 1;
-                    } else {
-                        d = v8 >> 4;
-                        bpos = 0;
-                    }
-                    if (d >= 10) {
-                        JS_ThrowInternalError(s->ctx, "invalid digit");
-                        goto fail;
-                    }
-                    v += mp_pow_dec[j] * d;
-                }
-                a->tab[i] = v;
-            }
-        }
-    }
-    bc_read_trace(s, "}\n");
-    return obj;
- fail:
-    JS_FreeValue(s->ctx, obj);
-    return JS_EXCEPTION;
-}
-#endif /* CONFIG_BIGNUM */
-
-static JSValue JS_ReadObjectRec(BCReaderState *s);
-
-static int BC_add_object_ref1(BCReaderState *s, JSObject *p)
-{
-    if (s->allow_reference) {
-        if (js_resize_array(s->ctx, (void *)&s->objects,
-                            sizeof(s->objects[0]),
-                            &s->objects_size, s->objects_count + 1))
-            return -1;
-        s->objects[s->objects_count++] = p;
-    }
-    return 0;
-}
-
-static int BC_add_object_ref(BCReaderState *s, JSValueConst obj)
-{
-    return BC_add_object_ref1(s, JS_VALUE_GET_OBJ(obj));
-}
-
-static JSValue JS_ReadFunctionTag(BCReaderState *s)
-{
-    JSContext *ctx = s->ctx;
-    JSFunctionBytecode bc, *b;
-    JSValue obj = JS_UNDEFINED;
-    uint16_t v16;
-    uint8_t v8;
-    int idx, i, local_count;
-    int function_size, cpool_offset, byte_code_offset;
-    int closure_var_offset, vardefs_offset;
-
-    memset(&bc, 0, sizeof(bc));
-    bc.header.ref_count = 1;
-    //bc.gc_header.mark = 0;
-
-    if (bc_get_u16(s, &v16))
-        goto fail;
-    idx = 0;
-    bc.has_prototype = bc_get_flags(v16, &idx, 1);
-    bc.has_simple_parameter_list = bc_get_flags(v16, &idx, 1);
-    bc.is_derived_class_constructor = bc_get_flags(v16, &idx, 1);
-    bc.need_home_object = bc_get_flags(v16, &idx, 1);
-    bc.func_kind = bc_get_flags(v16, &idx, 2);
-    bc.new_target_allowed = bc_get_flags(v16, &idx, 1);
-    bc.super_call_allowed = bc_get_flags(v16, &idx, 1);
-    bc.super_allowed = bc_get_flags(v16, &idx, 1);
-    bc.arguments_allowed = bc_get_flags(v16, &idx, 1);
-    bc.has_debug = bc_get_flags(v16, &idx, 1);
-    bc.backtrace_barrier = bc_get_flags(v16, &idx, 1);
-    bc.read_only_bytecode = s->is_rom_data;
-    if (bc_get_u8(s, &v8))
-        goto fail;
-    bc.js_mode = v8;
-    if (bc_get_atom(s, &bc.func_name))  //@ atom leak if failure
-        goto fail;
-    if (bc_get_leb128_u16(s, &bc.arg_count))
-        goto fail;
-    if (bc_get_leb128_u16(s, &bc.var_count))
-        goto fail;
-    if (bc_get_leb128_u16(s, &bc.defined_arg_count))
-        goto fail;
-    if (bc_get_leb128_u16(s, &bc.stack_size))
-        goto fail;
-    if (bc_get_leb128_int(s, &bc.closure_var_count))
-        goto fail;
-    if (bc_get_leb128_int(s, &bc.cpool_count))
-        goto fail;
-    if (bc_get_leb128_int(s, &bc.byte_code_len))
-        goto fail;
-    if (bc_get_leb128_int(s, &local_count))
-        goto fail;
-
-    if (bc.has_debug) {
-        function_size = sizeof(*b);
-    } else {
-        function_size = offsetof(JSFunctionBytecode, debug);
-    }
-    cpool_offset = function_size;
-    function_size += bc.cpool_count * sizeof(*bc.cpool);
-    vardefs_offset = function_size;
-    function_size += local_count * sizeof(*bc.vardefs);
-    closure_var_offset = function_size;
-    function_size += bc.closure_var_count * sizeof(*bc.closure_var);
-    byte_code_offset = function_size;
-    if (!bc.read_only_bytecode) {
-        function_size += bc.byte_code_len;
-    }
-
-    b = js_mallocz(ctx, function_size);
-    if (!b)
-        return JS_EXCEPTION;
-            
-    memcpy(b, &bc, offsetof(JSFunctionBytecode, debug));
-    b->header.ref_count = 1;
-    if (local_count != 0) {
-        b->vardefs = (void *)((uint8_t*)b + vardefs_offset);
-    }
-    if (b->closure_var_count != 0) {
-        b->closure_var = (void *)((uint8_t*)b + closure_var_offset);
-    }
-    if (b->cpool_count != 0) {
-        b->cpool = (void *)((uint8_t*)b + cpool_offset);
-    }
-    
-    add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
-            
-    obj = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);
-
-#ifdef DUMP_READ_OBJECT
-    bc_read_trace(s, "name: "); print_atom(s->ctx, b->func_name); printf("\n");
-#endif
-    bc_read_trace(s, "args=%d vars=%d defargs=%d closures=%d cpool=%d\n",
-                  b->arg_count, b->var_count, b->defined_arg_count,
-                  b->closure_var_count, b->cpool_count);
-    bc_read_trace(s, "stack=%d bclen=%d locals=%d\n",
-                  b->stack_size, b->byte_code_len, local_count);
-
-    if (local_count != 0) {
-        bc_read_trace(s, "vars {\n");
-        for(i = 0; i < local_count; i++) {
-            JSVarDef *vd = &b->vardefs[i];
-            if (bc_get_atom(s, &vd->var_name))
-                goto fail;
-            if (bc_get_leb128_int(s, &vd->scope_level))
-                goto fail;
-            if (bc_get_leb128_int(s, &vd->scope_next))
-                goto fail;
-            vd->scope_next--;
-            if (bc_get_u8(s, &v8))
-                goto fail;
-            idx = 0;
-            vd->var_kind = bc_get_flags(v8, &idx, 4);
-            vd->is_const = bc_get_flags(v8, &idx, 1);
-            vd->is_lexical = bc_get_flags(v8, &idx, 1);
-            vd->is_captured = bc_get_flags(v8, &idx, 1);
-#ifdef DUMP_READ_OBJECT
-            bc_read_trace(s, "name: "); print_atom(s->ctx, vd->var_name); printf("\n");
-#endif
-        }
-        bc_read_trace(s, "}\n");
-    }
-    if (b->closure_var_count != 0) {
-        bc_read_trace(s, "closure vars {\n");
-        for(i = 0; i < b->closure_var_count; i++) {
-            JSClosureVar *cv = &b->closure_var[i];
-            int var_idx;
-            if (bc_get_atom(s, &cv->var_name))
-                goto fail;
-            if (bc_get_leb128_int(s, &var_idx))
-                goto fail;
-            cv->var_idx = var_idx;
-            if (bc_get_u8(s, &v8))
-                goto fail;
-            idx = 0;
-            cv->is_local = bc_get_flags(v8, &idx, 1);
-            cv->is_arg = bc_get_flags(v8, &idx, 1);
-            cv->is_const = bc_get_flags(v8, &idx, 1);
-            cv->is_lexical = bc_get_flags(v8, &idx, 1);
-            cv->var_kind = bc_get_flags(v8, &idx, 4);
-#ifdef DUMP_READ_OBJECT
-            bc_read_trace(s, "name: "); print_atom(s->ctx, cv->var_name); printf("\n");
-#endif
-        }
-        bc_read_trace(s, "}\n");
-    }
-    {
-        bc_read_trace(s, "bytecode {\n");
-        if (JS_ReadFunctionBytecode(s, b, byte_code_offset, b->byte_code_len))
-            goto fail;
-        bc_read_trace(s, "}\n");
-    }
-    if (b->has_debug) {
-        /* read optional debug information */
-        bc_read_trace(s, "debug {\n");
-        if (bc_get_atom(s, &b->debug.filename))
-            goto fail;
-        if (bc_get_leb128_int(s, &b->debug.line_num))
-            goto fail;
-        if (bc_get_leb128_int(s, &b->debug.pc2line_len))
-            goto fail;
-        if (b->debug.pc2line_len) {
-            b->debug.pc2line_buf = js_mallocz(ctx, b->debug.pc2line_len);
-            if (!b->debug.pc2line_buf)
-                goto fail;
-            if (bc_get_buf(s, b->debug.pc2line_buf, b->debug.pc2line_len))
-                goto fail;
-        }
-#ifdef DUMP_READ_OBJECT
-        bc_read_trace(s, "filename: "); print_atom(s->ctx, b->debug.filename); printf("\n");
-#endif
-        bc_read_trace(s, "}\n");
-    }
-    if (b->cpool_count != 0) {
-        bc_read_trace(s, "cpool {\n");
-        for(i = 0; i < b->cpool_count; i++) {
-            JSValue val;
-            val = JS_ReadObjectRec(s);
-            if (JS_IsException(val))
-                goto fail;
-            b->cpool[i] = val;
-        }
-        bc_read_trace(s, "}\n");
-    }
-    b->realm = JS_DupContext(ctx);
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
-static JSValue JS_ReadModule(BCReaderState *s)
-{
-    JSContext *ctx = s->ctx;
-    JSValue obj;
-    JSModuleDef *m = NULL;
-    JSAtom module_name;
-    int i;
-    uint8_t v8;
-    
-    if (bc_get_atom(s, &module_name))
-        goto fail;
-#ifdef DUMP_READ_OBJECT
-    bc_read_trace(s, "name: "); print_atom(s->ctx, module_name); printf("\n");
-#endif
-    m = js_new_module_def(ctx, module_name);
-    if (!m)
-        goto fail;
-    obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
-    if (bc_get_leb128_int(s, &m->req_module_entries_count))
-        goto fail;
-    if (m->req_module_entries_count != 0) {
-        m->req_module_entries_size = m->req_module_entries_count;
-        m->req_module_entries = js_mallocz(ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size);
-        if (!m->req_module_entries)
-            goto fail;
-        for(i = 0; i < m->req_module_entries_count; i++) {
-            JSReqModuleEntry *rme = &m->req_module_entries[i];
-            if (bc_get_atom(s, &rme->module_name))
-                goto fail;
-        }
-    }
-
-    if (bc_get_leb128_int(s, &m->export_entries_count))
-        goto fail;
-    if (m->export_entries_count != 0) {
-        m->export_entries_size = m->export_entries_count;
-        m->export_entries = js_mallocz(ctx, sizeof(m->export_entries[0]) * m->export_entries_size);
-        if (!m->export_entries)
-            goto fail;
-        for(i = 0; i < m->export_entries_count; i++) {
-            JSExportEntry *me = &m->export_entries[i];
-            if (bc_get_u8(s, &v8))
-                goto fail;
-            me->export_type = v8;
-            if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
-                if (bc_get_leb128_int(s, &me->u.local.var_idx))
-                    goto fail;
-            } else {
-                if (bc_get_leb128_int(s, &me->u.req_module_idx))
-                    goto fail;
-                if (bc_get_atom(s, &me->local_name))
-                    goto fail;
-            }
-            if (bc_get_atom(s, &me->export_name))
-                goto fail;
-        }
-    }
-
-    if (bc_get_leb128_int(s, &m->star_export_entries_count))
-        goto fail;
-    if (m->star_export_entries_count != 0) {
-        m->star_export_entries_size = m->star_export_entries_count;
-        m->star_export_entries = js_mallocz(ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size);
-        if (!m->star_export_entries)
-            goto fail;
-        for(i = 0; i < m->star_export_entries_count; i++) {
-            JSStarExportEntry *se = &m->star_export_entries[i];
-            if (bc_get_leb128_int(s, &se->req_module_idx))
-                goto fail;
-        }
-    }
-
-    if (bc_get_leb128_int(s, &m->import_entries_count))
-        goto fail;
-    if (m->import_entries_count != 0) {
-        m->import_entries_size = m->import_entries_count;
-        m->import_entries = js_mallocz(ctx, sizeof(m->import_entries[0]) * m->import_entries_size);
-        if (!m->import_entries)
-            goto fail;
-        for(i = 0; i < m->import_entries_count; i++) {
-            JSImportEntry *mi = &m->import_entries[i];
-            if (bc_get_leb128_int(s, &mi->var_idx))
-                goto fail;
-            if (bc_get_atom(s, &mi->import_name))
-                goto fail;
-            if (bc_get_leb128_int(s, &mi->req_module_idx))
-                goto fail;
-        }
-    }
+/* XXX: used to read an `int` with a positive value */
+static int bc_get_leb128_int(BCReaderState *s, int *pval)
+{
+    return bc_get_leb128(s, (uint32_t *)pval);
+}
 
-    m->func_obj = JS_ReadObjectRec(s);
-    if (JS_IsException(m->func_obj))
-        goto fail;
-    return obj;
- fail:
-    if (m) {
-        js_free_module_def(ctx, m);
+static int bc_get_leb128_u16(BCReaderState *s, uint16_t *pval)
+{
+    uint32_t val;
+    if (bc_get_leb128(s, &val)) {
+        *pval = 0;
+        return -1;
     }
-    return JS_EXCEPTION;
+    *pval = val;
+    return 0;
 }
 
-static JSValue JS_ReadObjectTag(BCReaderState *s)
+static int bc_get_buf(BCReaderState *s, uint8_t *buf, uint32_t buf_len)
 {
-    JSContext *ctx = s->ctx;
-    JSValue obj;
-    uint32_t prop_count, i;
-    JSAtom atom;
-    JSValue val;
-    int ret;
-    
-    obj = JS_NewObject(ctx);
-    if (BC_add_object_ref(s, obj))
-        goto fail;
-    if (bc_get_leb128(s, &prop_count))
-        goto fail;
-    for(i = 0; i < prop_count; i++) {
-        if (bc_get_atom(s, &atom))
-            goto fail;
-#ifdef DUMP_READ_OBJECT
-        bc_read_trace(s, "propname: "); print_atom(s->ctx, atom); printf("\n");
-#endif
-        val = JS_ReadObjectRec(s);
-        if (JS_IsException(val)) {
-            JS_FreeAtom(ctx, atom);
-            goto fail;
-        }
-        ret = JS_DefinePropertyValue(ctx, obj, atom, val, JS_PROP_C_W_E);
-        JS_FreeAtom(ctx, atom);
-        if (ret < 0)
-            goto fail;
+    if (buf_len != 0) {
+        if (unlikely(!buf || s->buf_end - s->ptr < buf_len))
+            return bc_read_error_end(s);
+        memcpy(buf, s->ptr, buf_len);
+        s->ptr += buf_len;
     }
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
+    return 0;
 }
 
-static JSValue JS_ReadArray(BCReaderState *s, int tag)
+static int bc_idx_to_atom(BCReaderState *s, JSAtom *patom, uint32_t idx)
 {
-    JSContext *ctx = s->ctx;
-    JSValue obj;
-    uint32_t len, i;
-    JSValue val;
-    int ret, prop_flags;
-    BOOL is_template;
+    JSAtom atom;
 
-    obj = JS_NewArray(ctx);
-    if (BC_add_object_ref(s, obj))
-        goto fail;
-    is_template = (tag == BC_TAG_TEMPLATE_OBJECT);
-    if (bc_get_leb128(s, &len))
-        goto fail;
-    for(i = 0; i < len; i++) {
-        val = JS_ReadObjectRec(s);
-        if (JS_IsException(val))
-            goto fail;
-        if (is_template)
-            prop_flags = JS_PROP_ENUMERABLE;
-        else
-            prop_flags = JS_PROP_C_W_E;
-        ret = JS_DefinePropertyValueUint32(ctx, obj, i, val,
-                                           prop_flags);
-        if (ret < 0)
-            goto fail;
-    }
-    if (is_template) {
-        val = JS_ReadObjectRec(s);
-        if (JS_IsException(val))
-            goto fail;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_raw, val, 0);
-            if (ret < 0)
-                goto fail;
+    if (__JS_AtomIsTaggedInt(idx)) {
+        atom = idx;
+    } else if (idx < s->first_atom) {
+        atom = JS_DupAtom(s->ctx, idx);
+    } else {
+        idx -= s->first_atom;
+        if (idx >= s->idx_to_atom_count) {
+            JS_ThrowSyntaxError(s->ctx, "invalid atom index (pos=%u)",
+                                (unsigned int)(s->ptr - s->buf_start));
+            *patom = JS_ATOM_NULL;
+            return s->error_state = -1;
         }
-        JS_PreventExtensions(ctx, obj);
+        atom = JS_DupAtom(s->ctx, s->idx_to_atom[idx]);
     }
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
+    *patom = atom;
+    return 0;
 }
 
-static JSValue JS_ReadTypedArray(BCReaderState *s)
+static int bc_get_atom(BCReaderState *s, JSAtom *patom)
 {
-    JSContext *ctx = s->ctx;
-    JSValue obj = JS_UNDEFINED, array_buffer = JS_UNDEFINED;
-    uint8_t array_tag;
-    JSValueConst args[3];
-    uint32_t offset, len, idx;
-    
-    if (bc_get_u8(s, &array_tag))
-        return JS_EXCEPTION;
-    if (array_tag >= JS_TYPED_ARRAY_COUNT)
-        return JS_ThrowTypeError(ctx, "invalid typed array");
-    if (bc_get_leb128(s, &len))
-        return JS_EXCEPTION;
-    if (bc_get_leb128(s, &offset))
-        return JS_EXCEPTION;
-    /* XXX: this hack could be avoided if the typed array could be
-       created before the array buffer */
-    idx = s->objects_count;
-    if (BC_add_object_ref1(s, NULL))
-        goto fail;
-    array_buffer = JS_ReadObjectRec(s);
-    if (JS_IsException(array_buffer))
-        return JS_EXCEPTION;
-    if (!js_get_array_buffer(ctx, array_buffer)) {
-        JS_FreeValue(ctx, array_buffer);
-        return JS_EXCEPTION;
-    }
-    args[0] = array_buffer;
-    args[1] = JS_NewInt64(ctx, offset);
-    args[2] = JS_NewInt64(ctx, len);
-    obj = js_typed_array_constructor(ctx, JS_UNDEFINED,
-                                     3, args,
-                                     JS_CLASS_UINT8C_ARRAY + array_tag);
-    if (JS_IsException(obj))
-        goto fail;
-    if (s->allow_reference) {
-        s->objects[idx] = JS_VALUE_GET_OBJ(obj);
+    uint32_t v;
+    if (bc_get_leb128(s, &v))
+        return -1;
+    if (v & 1) {
+        *patom = __JS_AtomFromUInt32(v >> 1);
+        return 0;
+    } else {
+        return bc_idx_to_atom(s, patom, v >> 1);
     }
-    JS_FreeValue(ctx, array_buffer);
-    return obj;
- fail:
-    JS_FreeValue(ctx, array_buffer);
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
 }
 
-static JSValue JS_ReadArrayBuffer(BCReaderState *s)
+static JSString *JS_ReadString(BCReaderState *s)
 {
-    JSContext *ctx = s->ctx;
-    uint32_t byte_length;
-    JSValue obj;
-    
-    if (bc_get_leb128(s, &byte_length))
-        return JS_EXCEPTION;
-    if (unlikely(s->buf_end - s->ptr < byte_length)) {
+    uint32_t len;
+    size_t size;
+    BOOL is_wide_char;
+    JSString *p;
+
+    if (bc_get_leb128(s, &len))
+        return NULL;
+    is_wide_char = len & 1;
+    len >>= 1;
+    p = js_alloc_string(s->ctx, len, is_wide_char);
+    if (!p) {
+        s->error_state = -1;
+        return NULL;
+    }
+    size = (size_t)len << is_wide_char;
+    if ((s->buf_end - s->ptr) < size) {
         bc_read_error_end(s);
-        return JS_EXCEPTION;
+        js_free_string(s->ctx->rt, p);
+        return NULL;
     }
-    obj = JS_NewArrayBufferCopy(ctx, s->ptr, byte_length);
-    if (JS_IsException(obj))
-        goto fail;
-    if (BC_add_object_ref(s, obj))
-        goto fail;
-    s->ptr += byte_length;
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
+    memcpy(p->u.str8, s->ptr, size);
+    s->ptr += size;
+    if (!is_wide_char) {
+        p->u.str8[size] = '\0'; /* add the trailing zero for 8 bit strings */
+    }
+#ifdef DUMP_READ_OBJECT
+    bc_read_trace(s, "string: "); JS_DumpString(s->ctx->rt, p); printf("\n");
+#endif
+    return p;
 }
 
-static JSValue JS_ReadSharedArrayBuffer(BCReaderState *s)
+static uint32_t bc_get_flags(uint32_t flags, int *pidx, int n)
 {
-    JSContext *ctx = s->ctx;
-    uint32_t byte_length;
-    uint8_t *data_ptr;
-    JSValue obj;
-    uint64_t u64;
-    
-    if (bc_get_leb128(s, &byte_length))
-        return JS_EXCEPTION;
-    if (bc_get_u64(s, &u64))
-        return JS_EXCEPTION;
-    data_ptr = (uint8_t *)(uintptr_t)u64;
-    /* the SharedArrayBuffer is cloned */
-    obj = js_array_buffer_constructor3(ctx, JS_UNDEFINED, byte_length,
-                                       JS_CLASS_SHARED_ARRAY_BUFFER,
-                                       data_ptr,
-                                       NULL, NULL, FALSE);
-    if (JS_IsException(obj))
-        goto fail;
-    if (BC_add_object_ref(s, obj))
-        goto fail;
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
+    uint32_t val;
+    /* XXX: this does not work for n == 32 */
+    val = (flags >> *pidx) & ((1U << n) - 1);
+    *pidx += n;
+    return val;
 }
 
-static JSValue JS_ReadDate(BCReaderState *s)
+static int JS_ReadFunctionBytecode(BCReaderState *s, JSFunctionBytecode *b,
+                                   int byte_code_offset, uint32_t bc_len)
 {
-    JSContext *ctx = s->ctx;
-    JSValue val, obj = JS_UNDEFINED;
+    uint8_t *bc_buf;
+    int pos, len, op;
+    JSAtom atom;
+    uint32_t idx;
 
-    val = JS_ReadObjectRec(s);
-    if (JS_IsException(val))
-        goto fail;
-    if (!JS_IsNumber(val)) {
-        JS_ThrowTypeError(ctx, "Number tag expected for date");
-        goto fail;
+    if (s->is_rom_data) {
+        /* directly use the input buffer */
+        if (unlikely(s->buf_end - s->ptr < bc_len))
+            return bc_read_error_end(s);
+        bc_buf = (uint8_t *)s->ptr;
+        s->ptr += bc_len;
+    } else {
+        bc_buf = (void *)((uint8_t*)b + byte_code_offset);
+        if (bc_get_buf(s, bc_buf, bc_len))
+            return -1;
     }
-    obj = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_DATE],
-                                 JS_CLASS_DATE);
-    if (JS_IsException(obj))
-        goto fail;
-    if (BC_add_object_ref(s, obj))
-        goto fail;
-    JS_SetObjectData(ctx, obj, val);
-    return obj;
- fail:
-    JS_FreeValue(ctx, val);
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
-static JSValue JS_ReadObjectValue(BCReaderState *s)
-{
-    JSContext *ctx = s->ctx;
-    JSValue val, obj = JS_UNDEFINED;
+    b->byte_code_buf = bc_buf;
 
-    val = JS_ReadObjectRec(s);
-    if (JS_IsException(val))
-        goto fail;
-    obj = JS_ToObject(ctx, val);
-    if (JS_IsException(obj))
-        goto fail;
-    if (BC_add_object_ref(s, obj))
-        goto fail;
-    JS_FreeValue(ctx, val);
-    return obj;
- fail:
-    JS_FreeValue(ctx, val);
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
+    pos = 0;
+    while (pos < bc_len) {
+        op = bc_buf[pos];
+        len = short_opcode_info(op).size;
+        switch(short_opcode_info(op).fmt) {
+        case OP_FMT_atom:
+        case OP_FMT_atom_u8:
+        case OP_FMT_atom_u16:
+        case OP_FMT_atom_label_u8:
+        case OP_FMT_atom_label_u16:
+            idx = get_u32(bc_buf + pos + 1);
+            if (s->is_rom_data) {
+                /* just increment the reference count of the atom */
+                JS_DupAtom(s->ctx, (JSAtom)idx);
+            } else {
+                if (bc_idx_to_atom(s, &atom, idx)) {
+                    /* Note: the atoms will be freed up to this position */
+                    b->byte_code_len = pos;
+                    return -1;
+                }
+                put_u32(bc_buf + pos + 1, atom);
+#ifdef DUMP_READ_OBJECT
+                bc_read_trace(s, "at %d, fixup atom: ", pos + 1); print_atom(s->ctx, atom); printf("\n");
+#endif
+            }
+            break;
+        default:
+            break;
+        }
+        pos += len;
+    }
+    return 0;
 }
 
 static JSValue JS_ReadObjectRec(BCReaderState *s)
@@ -35741,24 +32776,23 @@ static JSValue JS_ReadObjectRec(BCReaderState *s)
     JSContext *ctx = s->ctx;
     uint8_t tag;
     JSValue obj = JS_UNDEFINED;
-
-    if (js_check_stack_overflow(ctx->rt, 0))
-        return JS_ThrowStackOverflow(ctx);
+    JSModuleDef *m = NULL;
 
     if (bc_get_u8(s, &tag))
         return JS_EXCEPTION;
 
-    bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
-
     switch(tag) {
     case BC_TAG_NULL:
+        bc_read_trace(s, "null\n");
         obj = JS_NULL;
         break;
     case BC_TAG_UNDEFINED:
+        bc_read_trace(s, "undefined\n");
         obj = JS_UNDEFINED;
         break;
     case BC_TAG_BOOL_FALSE:
     case BC_TAG_BOOL_TRUE:
+        bc_read_trace(s, "%s\n", bc_tag_str[tag]);
         obj = JS_NewBool(ctx, tag - BC_TAG_BOOL_FALSE);
         break;
     case BC_TAG_INT32:
@@ -35766,7 +32800,7 @@ static JSValue JS_ReadObjectRec(BCReaderState *s)
             int32_t val;
             if (bc_get_sleb128(s, &val))
                 return JS_EXCEPTION;
-            bc_read_trace(s, "%d\n", val);
+            bc_read_trace(s, "int32 %d\n", val);
             obj = JS_NewInt32(ctx, val);
         }
         break;
@@ -35775,7 +32809,7 @@ static JSValue JS_ReadObjectRec(BCReaderState *s)
             JSFloat64Union u;
             if (bc_get_u64(s, &u.u64))
                 return JS_EXCEPTION;
-            bc_read_trace(s, "%g\n", u.d);
+            bc_read_trace(s, "float64 %g\n", u.d);
             obj = __JS_NewFloat64(ctx, u.d);
         }
         break;
@@ -35789,68 +32823,450 @@ static JSValue JS_ReadObjectRec(BCReaderState *s)
         }
         break;
     case BC_TAG_FUNCTION_BYTECODE:
-        if (!s->allow_bytecode)
-            goto invalid_tag;
-        obj = JS_ReadFunctionTag(s);
+        {
+            JSFunctionBytecode bc, *b;
+            uint16_t v16;
+            uint8_t v8;
+            int idx, i, local_count;
+            int function_size, cpool_offset, byte_code_offset;
+            int closure_var_offset, vardefs_offset;
+
+            if (!s->allow_bytecode)
+                goto invalid_tag;
+            bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
+
+            memset(&bc, 0, sizeof(bc));
+            bc.header.ref_count = 1;
+            //bc.gc_header.mark = 0;
+
+            if (bc_get_u16(s, &v16))
+                goto fail;
+            idx = 0;
+            bc.has_prototype = bc_get_flags(v16, &idx, 1);
+            bc.has_simple_parameter_list = bc_get_flags(v16, &idx, 1);
+            bc.is_derived_class_constructor = bc_get_flags(v16, &idx, 1);
+            bc.need_home_object = bc_get_flags(v16, &idx, 1);
+            bc.func_kind = bc_get_flags(v16, &idx, 2);
+            bc.new_target_allowed = bc_get_flags(v16, &idx, 1);
+            bc.super_call_allowed = bc_get_flags(v16, &idx, 1);
+            bc.super_allowed = bc_get_flags(v16, &idx, 1);
+            bc.arguments_allowed = bc_get_flags(v16, &idx, 1);
+            bc.has_debug = bc_get_flags(v16, &idx, 1);
+            bc.read_only_bytecode = s->is_rom_data;
+            if (bc_get_u8(s, &v8))
+                goto fail;
+            bc.js_mode = v8;
+            if (bc_get_atom(s, &bc.func_name))  //@ atom leak if failure
+                goto fail;
+            if (bc_get_leb128_u16(s, &bc.arg_count))
+                goto fail;
+            if (bc_get_leb128_u16(s, &bc.var_count))
+                goto fail;
+            if (bc_get_leb128_u16(s, &bc.defined_arg_count))
+                goto fail;
+            if (bc_get_leb128_u16(s, &bc.stack_size))
+                goto fail;
+            if (bc_get_leb128_int(s, &bc.closure_var_count))
+                goto fail;
+            if (bc_get_leb128_int(s, &bc.cpool_count))
+                goto fail;
+            if (bc_get_leb128_int(s, &bc.byte_code_len))
+                goto fail;
+            if (bc_get_leb128_int(s, &local_count))
+                goto fail;
+
+            if (bc.has_debug) {
+                function_size = sizeof(*b);
+            } else {
+                function_size = offsetof(JSFunctionBytecode, debug);
+            }
+            cpool_offset = function_size;
+            function_size += bc.cpool_count * sizeof(*bc.cpool);
+            vardefs_offset = function_size;
+            function_size += local_count * sizeof(*bc.vardefs);
+            closure_var_offset = function_size;
+            function_size += bc.closure_var_count * sizeof(*bc.closure_var);
+            byte_code_offset = function_size;
+            if (!bc.read_only_bytecode) {
+                function_size += bc.byte_code_len;
+            }
+
+            b = js_mallocz(ctx, function_size);
+            if (!b)
+                return JS_EXCEPTION;
+
+            memcpy(b, &bc, offsetof(JSFunctionBytecode, debug));
+            obj = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);
+
+#ifdef DUMP_READ_OBJECT
+            bc_read_trace(s, "name: "); print_atom(s->ctx, b->func_name); printf("\n");
+#endif
+            bc_read_trace(s, "args=%d vars=%d defargs=%d closures=%d cpool=%d\n",
+                          b->arg_count, b->var_count, b->defined_arg_count,
+                          b->closure_var_count, b->cpool_count);
+            bc_read_trace(s, "stack=%d bclen=%d locals=%d\n",
+                          b->stack_size, b->byte_code_len, local_count);
+
+            if (local_count != 0) {
+                bc_read_trace(s, "vars {\n");
+                b->vardefs = (void *)((uint8_t*)b + vardefs_offset);
+                for(i = 0; i < local_count; i++) {
+                    JSVarDef *vd = &b->vardefs[i];
+                    if (bc_get_atom(s, &vd->var_name))
+                        goto fail;
+                    if (bc_get_leb128_int(s, &vd->scope_level))
+                        goto fail;
+                    if (bc_get_leb128_int(s, &vd->scope_next))
+                        goto fail;
+                    vd->scope_next--;
+                    if (bc_get_u8(s, &v8))
+                        goto fail;
+                    idx = 0;
+                    vd->var_kind = bc_get_flags(v8, &idx, 4);
+                    vd->is_func_var = bc_get_flags(v8, &idx, 1);
+                    vd->is_const = bc_get_flags(v8, &idx, 1);
+                    vd->is_lexical = bc_get_flags(v8, &idx, 1);
+                    vd->is_captured = bc_get_flags(v8, &idx, 1);
+#ifdef DUMP_READ_OBJECT
+                    bc_read_trace(s, "name: "); print_atom(s->ctx, vd->var_name); printf("\n");
+#endif
+                }
+                bc_read_trace(s, "}\n");
+            }
+            if (b->closure_var_count != 0) {
+                bc_read_trace(s, "closure vars {\n");
+                b->closure_var = (void *)((uint8_t*)b + closure_var_offset);
+                for(i = 0; i < b->closure_var_count; i++) {
+                    JSClosureVar *cv = &b->closure_var[i];
+                    int var_idx;
+                    if (bc_get_atom(s, &cv->var_name))
+                        goto fail;
+                    if (bc_get_leb128_int(s, &var_idx))
+                        goto fail;
+                    cv->var_idx = var_idx;
+                    if (bc_get_u8(s, &v8))
+                        goto fail;
+                    idx = 0;
+                    cv->is_local = bc_get_flags(v8, &idx, 1);
+                    cv->is_arg = bc_get_flags(v8, &idx, 1);
+                    cv->is_const = bc_get_flags(v8, &idx, 1);
+                    cv->is_lexical = bc_get_flags(v8, &idx, 1);
+                    cv->var_kind = bc_get_flags(v8, &idx, 4);
+#ifdef DUMP_READ_OBJECT
+                    bc_read_trace(s, "name: "); print_atom(s->ctx, cv->var_name); printf("\n");
+#endif
+                }
+                bc_read_trace(s, "}\n");
+            }
+            {
+                bc_read_trace(s, "bytecode {\n");
+                if (JS_ReadFunctionBytecode(s, b, byte_code_offset, b->byte_code_len))
+                    goto fail;
+                bc_read_trace(s, "}\n");
+            }
+            if (b->has_debug) {
+                /* read optional debug information */
+                bc_read_trace(s, "debug {\n");
+                if (bc_get_atom(s, &b->debug.filename))
+                    goto fail;
+                if (bc_get_leb128_int(s, &b->debug.line_num))
+                    goto fail;
+                if (bc_get_leb128_int(s, &b->debug.pc2line_len))
+                    goto fail;
+                if (b->debug.pc2line_len) {
+                    b->debug.pc2line_buf = js_mallocz(ctx, b->debug.pc2line_len);
+                    if (!b->debug.pc2line_buf)
+                        goto fail;
+                    if (bc_get_buf(s, b->debug.pc2line_buf, b->debug.pc2line_len))
+                        goto fail;
+                }
+#ifdef DUMP_READ_OBJECT
+                bc_read_trace(s, "filename: "); print_atom(s->ctx, b->debug.filename); printf("\n");
+#endif
+                bc_read_trace(s, "}\n");
+            }
+            if (b->cpool_count != 0) {
+                bc_read_trace(s, "cpool {\n");
+                b->cpool = (void *)((uint8_t*)b + cpool_offset);
+                for(i = 0; i < b->cpool_count; i++) {
+                    JSValue val;
+                    val = JS_ReadObjectRec(s);
+                    if (JS_IsException(val))
+                        goto fail;
+                    b->cpool[i] = val;
+                }
+                bc_read_trace(s, "}\n");
+            }
+            bc_read_trace(s, "}\n");
+        }
         break;
     case BC_TAG_MODULE:
-        if (!s->allow_bytecode)
-            goto invalid_tag;
-        obj = JS_ReadModule(s);
+        {
+            JSAtom module_name;
+            int i;
+            uint8_t v8;
+
+            if (!s->allow_bytecode)
+                goto invalid_tag;
+            bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
+            if (bc_get_atom(s, &module_name))
+                goto fail;
+#ifdef DUMP_READ_OBJECT
+            bc_read_trace(s, "name: "); print_atom(s->ctx, module_name); printf("\n");
+#endif
+            m = js_new_module_def(ctx, module_name);
+            if (!m)
+                goto fail;
+            obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
+            if (bc_get_leb128_int(s, &m->req_module_entries_count))
+                goto fail;
+            if (m->req_module_entries_count != 0) {
+                m->req_module_entries_size = m->req_module_entries_count;
+                m->req_module_entries = js_mallocz(ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size);
+                if (!m->req_module_entries)
+                    goto fail;
+                for(i = 0; i < m->req_module_entries_count; i++) {
+                    JSReqModuleEntry *rme = &m->req_module_entries[i];
+                    if (bc_get_atom(s, &rme->module_name))
+                        goto fail;
+                }
+            }
+
+            if (bc_get_leb128_int(s, &m->export_entries_count))
+                goto fail;
+            if (m->export_entries_count != 0) {
+                m->export_entries_size = m->export_entries_count;
+                m->export_entries = js_mallocz(ctx, sizeof(m->export_entries[0]) * m->export_entries_size);
+                if (!m->export_entries)
+                    goto fail;
+                for(i = 0; i < m->export_entries_count; i++) {
+                    JSExportEntry *me = &m->export_entries[i];
+                    if (bc_get_u8(s, &v8))
+                        goto fail;
+                    me->export_type = v8;
+                    if (me->export_type == JS_EXPORT_TYPE_LOCAL) {
+                        if (bc_get_leb128_int(s, &me->u.local.var_idx))
+                            goto fail;
+                    } else {
+                        if (bc_get_leb128_int(s, &me->u.req_module_idx))
+                            goto fail;
+                        if (bc_get_atom(s, &me->local_name))
+                            goto fail;
+                    }
+                    if (bc_get_atom(s, &me->export_name))
+                        goto fail;
+                }
+            }
+
+            if (bc_get_leb128_int(s, &m->star_export_entries_count))
+                goto fail;
+            if (m->star_export_entries_count != 0) {
+                m->star_export_entries_size = m->star_export_entries_count;
+                m->star_export_entries = js_mallocz(ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size);
+                if (!m->star_export_entries)
+                    goto fail;
+                for(i = 0; i < m->star_export_entries_count; i++) {
+                    JSStarExportEntry *se = &m->star_export_entries[i];
+                    if (bc_get_leb128_int(s, &se->req_module_idx))
+                        goto fail;
+                }
+            }
+
+            if (bc_get_leb128_int(s, &m->import_entries_count))
+                goto fail;
+            if (m->import_entries_count != 0) {
+                m->import_entries_size = m->import_entries_count;
+                m->import_entries = js_mallocz(ctx, sizeof(m->import_entries[0]) * m->import_entries_size);
+                if (!m->import_entries)
+                    goto fail;
+                for(i = 0; i < m->import_entries_count; i++) {
+                    JSImportEntry *mi = &m->import_entries[i];
+                    if (bc_get_leb128_int(s, &mi->var_idx))
+                        goto fail;
+                    if (bc_get_atom(s, &mi->import_name))
+                        goto fail;
+                    if (bc_get_leb128_int(s, &mi->req_module_idx))
+                        goto fail;
+                }
+            }
+
+            m->func_obj = JS_ReadObjectRec(s);
+            if (JS_IsException(m->func_obj))
+                goto fail;
+            bc_read_trace(s, "}\n");
+        }
         break;
     case BC_TAG_OBJECT:
-        obj = JS_ReadObjectTag(s);
+        {
+            uint32_t prop_count, i;
+            JSAtom atom;
+            JSValue val;
+            int ret;
+
+            bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
+
+            obj = JS_NewObject(ctx);
+            if (bc_get_leb128(s, &prop_count))
+                goto fail;
+            for(i = 0; i < prop_count; i++) {
+                if (bc_get_atom(s, &atom))
+                    goto fail;
+#ifdef DUMP_READ_OBJECT
+                bc_read_trace(s, "propname: "); print_atom(s->ctx, atom); printf("\n");
+#endif
+                val = JS_ReadObjectRec(s);
+                if (JS_IsException(val)) {
+                    JS_FreeAtom(ctx, atom);
+                    goto fail;
+                }
+                ret = JS_DefinePropertyValue(ctx, obj, atom, val, JS_PROP_C_W_E);
+                JS_FreeAtom(ctx, atom);
+                if (ret < 0)
+                    goto fail;
+            }
+            bc_read_trace(s, "}\n");
+        }
         break;
     case BC_TAG_ARRAY:
     case BC_TAG_TEMPLATE_OBJECT:
-        obj = JS_ReadArray(s, tag);
-        break;
-    case BC_TAG_TYPED_ARRAY:
-        obj = JS_ReadTypedArray(s);
-        break;
-    case BC_TAG_ARRAY_BUFFER:
-        obj = JS_ReadArrayBuffer(s);
-        break;
-    case BC_TAG_SHARED_ARRAY_BUFFER:
-        if (!s->allow_sab || !ctx->rt->sab_funcs.sab_dup)
-            goto invalid_tag;
-        obj = JS_ReadSharedArrayBuffer(s);
-        break;
-    case BC_TAG_DATE:
-        obj = JS_ReadDate(s);
-        break;
-    case BC_TAG_OBJECT_VALUE:
-        obj = JS_ReadObjectValue(s);
+        {
+            uint32_t len, i;
+            JSValue val;
+            int ret, prop_flags;
+            BOOL is_template;
+
+            bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
+
+            obj = JS_NewArray(ctx);
+            is_template = (tag == BC_TAG_TEMPLATE_OBJECT);
+            if (bc_get_leb128(s, &len))
+                goto fail;
+            for(i = 0; i < len; i++) {
+                val = JS_ReadObjectRec(s);
+                if (JS_IsException(val))
+                    goto fail;
+                if (is_template)
+                    prop_flags = JS_PROP_ENUMERABLE;
+                else
+                    prop_flags = JS_PROP_C_W_E;
+                ret = JS_DefinePropertyValueUint32(ctx, obj, i, val,
+                                                   prop_flags);
+                if (ret < 0)
+                    goto fail;
+            }
+            if (is_template) {
+                val = JS_ReadObjectRec(s);
+                if (JS_IsException(val))
+                    goto fail;
+                if (!JS_IsUndefined(val)) {
+                    ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_raw, val, 0);
+                    if (ret < 0)
+                        goto fail;
+                }
+                JS_PreventExtensions(ctx, obj);
+            }
+            bc_read_trace(s, "}\n");
+        }
         break;
 #ifdef CONFIG_BIGNUM
     case BC_TAG_BIG_INT:
     case BC_TAG_BIG_FLOAT:
-    case BC_TAG_BIG_DECIMAL:
-        obj = JS_ReadBigNum(s, tag);
-        break;
-#endif
-    case BC_TAG_OBJECT_REFERENCE:
         {
-            uint32_t val;
-            if (!s->allow_reference)
-                return JS_ThrowSyntaxError(ctx, "object references are not allowed");
-            if (bc_get_leb128(s, &val))
-                return JS_EXCEPTION;
-            bc_read_trace(s, "%u\n", val);
-            if (val >= s->objects_count) {
-                return JS_ThrowSyntaxError(ctx, "invalid object reference (%u >= %u)",
-                                           val, s->objects_count);
+            uint8_t sign, v8;
+            int32_t e;
+            uint32_t len;
+            limb_t l, i, n;
+            JSBigFloat *p;
+            bf_t *a;
+
+            bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
+
+            if (bc_get_leb128(s, &len))
+                goto fail;
+            sign = len & 1;
+            len >>= 1;
+            p = js_new_bf(s->ctx);
+            if (!p)
+                goto fail;
+            if (tag == BC_TAG_BIG_INT)
+                obj = JS_MKPTR(JS_TAG_BIG_INT, p);
+            else
+                obj = JS_MKPTR(JS_TAG_BIG_FLOAT, p);
+            l = (len + sizeof(limb_t) - 1) / sizeof(limb_t);
+            a = &p->num;
+            bf_resize(a, l);
+            a->sign = sign;
+            if (len == 0) {
+                if (tag == BC_TAG_BIG_INT) {
+                    a->expn = BF_EXP_ZERO;
+                } else {
+                    if (bc_get_u8(s, &v8))
+                        goto fail;
+                    switch(v8) {
+                    case 0:
+                        a->expn = BF_EXP_ZERO;
+                        break;
+                    case 1:
+                        a->expn = BF_EXP_INF;
+                        break;
+                    default:
+                    case 2:
+                        a->expn = BF_EXP_NAN;
+                        break;
+                    }
+                }
+            } else {
+                n = len & (sizeof(limb_t) - 1);
+                if (n != 0) {
+                    limb_t v;
+                    v = 0;
+                    for(i = 0; i < n; i++) {
+                        if (bc_get_u8(s, &v8))
+                            goto fail;
+                        v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);
+                    }
+                    a->tab[0] = v;
+                    i = 1;
+                } else {
+                    i = 0;
+                }
+                for(; i < l; i++) {
+                    limb_t v;
+#if LIMB_BITS == 32
+                    if (bc_get_u32(s, &v))
+                        goto fail;
+#ifdef WORDS_BIGENDIAN
+                    v = bswap32(v);
+#endif
+#else
+                    if (bc_get_u64(s, &v))
+                        goto fail;
+#ifdef WORDS_BIGENDIAN
+                    v = bswap64(v);
+#endif
+#endif
+                    a->tab[i] = v;
+                }
+                if (bc_get_sleb128(s, &e))
+                    goto fail;
+                a->expn = e;
             }
-            obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, s->objects[val]));
+            bc_read_trace(s, "}\n");
         }
         break;
+#endif
     default:
     invalid_tag:
         return JS_ThrowSyntaxError(ctx, "invalid tag (tag=%d pos=%u)",
                                    tag, (unsigned int)(s->ptr - s->buf_start));
     }
-    bc_read_trace(s, "}\n");
     return obj;
+ fail:
+    if (m) {
+        js_free_module_def(ctx, m);
+    }
+    JS_FreeValue(ctx, obj);
+    return JS_EXCEPTION;
 }
 
 static int JS_ReadObjectAtoms(BCReaderState *s)
@@ -35903,11 +33319,10 @@ static void bc_reader_free(BCReaderState *s)
         }
         js_free(s->ctx, s->idx_to_atom);
     }
-    js_free(s->ctx, s->objects);
 }
 
 JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
-                       int flags)
+                      int flags)
 {
     BCReaderState ss, *s = &ss;
     JSValue obj;
@@ -35922,8 +33337,6 @@ JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
     s->ptr = buf;
     s->allow_bytecode = ((flags & JS_READ_OBJ_BYTECODE) != 0);
     s->is_rom_data = ((flags & JS_READ_OBJ_ROM_DATA) != 0);
-    s->allow_sab = ((flags & JS_READ_OBJ_SAB) != 0);
-    s->allow_reference = ((flags & JS_READ_OBJ_REFERENCE) != 0);
     if (s->allow_bytecode)
         s->first_atom = JS_ATOM_END;
     else
@@ -35984,39 +33397,16 @@ static JSAtom find_atom(JSContext *ctx, const char *name)
     return atom;
 }
 
-static JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,
-                                               JSAtom atom, void *opaque)
+static int JS_InstantiateFunctionListItem(JSContext *ctx, JSObject *p,
+                                          JSAtom atom, void *opaque)
 {
     const JSCFunctionListEntry *e = opaque;
-    JSValue val;
-
-    switch(e->def_type) {
-    case JS_DEF_CFUNC:
-        val = JS_NewCFunction2(ctx, e->u.func.cfunc.generic,
-                               e->name, e->u.func.length, e->u.func.cproto, e->magic);
-        break;
-    case JS_DEF_PROP_STRING:
-        val = JS_NewAtomString(ctx, e->u.str);
-        break;
-    case JS_DEF_OBJECT:
-        val = JS_NewObject(ctx);
-        JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);
-        break;
-    default:
-        abort();
-    }
-    return val;
-}
-
-static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
-                                          JSAtom atom,
-                                          const JSCFunctionListEntry *e)
-{
+    JSValueConst obj = JS_MKPTR(JS_TAG_OBJECT, p);
     JSValue val;
     int prop_flags = e->prop_flags;
 
     switch(e->def_type) {
-    case JS_DEF_ALIAS: /* using autoinit for aliases is not safe */
+    case JS_DEF_ALIAS:
         {
             JSAtom atom1 = find_atom(ctx, e->u.alias.name);
             switch (e->u.alias.base) {
@@ -36033,16 +33423,12 @@ static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
                 abort();
             }
             JS_FreeAtom(ctx, atom1);
-            if (atom == JS_ATOM_Symbol_toPrimitive) {
-                /* Symbol.toPrimitive functions are not writable */
-                prop_flags = JS_PROP_CONFIGURABLE;
-            } else if (atom == JS_ATOM_Symbol_hasInstance) {
-                /* Function.prototype[Symbol.hasInstance] is not writable nor configurable */
-                prop_flags = 0;
-            }
+            goto setval;
         }
-        break;
     case JS_DEF_CFUNC:
+        val = JS_NewCFunction2(ctx, e->u.func.cfunc.generic,
+                               e->name, e->u.func.length, e->u.func.cproto, e->magic);
+    setval:
         if (atom == JS_ATOM_Symbol_toPrimitive) {
             /* Symbol.toPrimitive functions are not writable */
             prop_flags = JS_PROP_CONFIGURABLE;
@@ -36050,10 +33436,8 @@ static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
             /* Function.prototype[Symbol.hasInstance] is not writable nor configurable */
             prop_flags = 0;
         }
-        JS_DefineAutoInitProperty(ctx, obj, atom, JS_AUTOINIT_ID_PROP,
-                                  (void *)e, prop_flags);
-        return 0;
-    case JS_DEF_CGETSET: /* XXX: use autoinit again ? */
+        break;
+    case JS_DEF_CGETSET:
     case JS_DEF_CGETSET_MAGIC:
         {
             JSValue getter, setter;
@@ -36077,6 +33461,9 @@ static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
             return 0;
         }
         break;
+    case JS_DEF_PROP_STRING:
+        val = JS_NewAtomString(ctx, e->u.str);
+        break;
     case JS_DEF_PROP_INT32:
         val = JS_NewInt32(ctx, e->u.i32);
         break;
@@ -36089,11 +33476,10 @@ static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
     case JS_DEF_PROP_UNDEFINED:
         val = JS_UNDEFINED;
         break;
-    case JS_DEF_PROP_STRING:
     case JS_DEF_OBJECT:
-        JS_DefineAutoInitProperty(ctx, obj, atom, JS_AUTOINIT_ID_PROP,
-                                  (void *)e, prop_flags);
-        return 0;
+        val = JS_NewObject(ctx);
+        JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);
+        break;
     default:
         abort();
     }
@@ -36104,12 +33490,36 @@ static int JS_InstantiateFunctionListItem(JSContext *ctx, JSValueConst obj,
 void JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,
                                 const JSCFunctionListEntry *tab, int len)
 {
-    int i;
+    int i, prop_flags;
 
     for (i = 0; i < len; i++) {
         const JSCFunctionListEntry *e = &tab[i];
         JSAtom atom = find_atom(ctx, e->name);
-        JS_InstantiateFunctionListItem(ctx, obj, atom, e);
+
+        switch (e->def_type) {
+        case JS_DEF_CFUNC:
+        case JS_DEF_CGETSET:
+        case JS_DEF_CGETSET_MAGIC:
+        case JS_DEF_PROP_STRING:
+        case JS_DEF_ALIAS:
+        case JS_DEF_OBJECT:
+            prop_flags = JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE | (e->prop_flags & JS_PROP_ENUMERABLE);
+            JS_DefineAutoInitProperty(ctx, obj, atom,
+                                      JS_InstantiateFunctionListItem,
+                                      (void *)e, prop_flags);
+            break;
+        case JS_DEF_PROP_INT32:
+        case JS_DEF_PROP_INT64:
+        case JS_DEF_PROP_DOUBLE:
+        case JS_DEF_PROP_UNDEFINED:
+            {
+                JSObject *p = JS_VALUE_GET_OBJ(obj);
+                JS_InstantiateFunctionListItem(ctx, p, atom, (void *)e);
+            }
+            break;
+        default:
+            abort();
+        }
         JS_FreeAtom(ctx, atom);
     }
 }
@@ -36150,10 +33560,6 @@ int JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,
         case JS_DEF_PROP_DOUBLE:
             val = __JS_NewFloat64(ctx, e->u.f64);
             break;
-        case JS_DEF_OBJECT:
-            val = JS_NewObject(ctx);
-            JS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab, e->u.prop_list.len);
-            break;
         default:
             abort();
         }
@@ -36234,14 +33640,49 @@ static JSValue js_global_isNaN(JSContext *ctx, JSValueConst this_val,
     return JS_NewBool(ctx, isnan(d));
 }
 
+#ifdef CONFIG_BIGNUM
+static BOOL js_number_is_finite(JSContext *ctx, JSValueConst val)
+{
+    BOOL res;
+    uint32_t tag;
+
+    tag = JS_VALUE_GET_NORM_TAG(val);
+    switch(tag) {
+    case JS_TAG_FLOAT64:
+        res = isfinite(JS_VALUE_GET_FLOAT64(val));
+        break;
+    case JS_TAG_BIG_FLOAT:
+        {
+            JSBigFloat *p = JS_VALUE_GET_PTR(val);
+            res = bf_is_finite(&p->num);
+        }
+        break;
+    default:
+        res = TRUE;
+        break;
+    }
+    return res;
+}
+#endif
+
 static JSValue js_global_isFinite(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
 {
     BOOL res;
+#ifdef CONFIG_BIGNUM
+    JSValue val;
+
+    val = JS_ToNumber(ctx, argv[0]);
+    if (JS_IsException(val))
+        return val;
+    res = js_number_is_finite(ctx, val);
+    JS_FreeValue(ctx, val);
+#else
     double d;
     if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))
         return JS_EXCEPTION;
     res = isfinite(d);
+#endif
     return JS_NewBool(ctx, res);
 }
 
@@ -36261,20 +33702,27 @@ static JSValue JS_ToObject(JSContext *ctx, JSValueConst val)
     case JS_TAG_EXCEPTION:
         return JS_DupValue(ctx, val);
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_INT:
+        if (is_bignum_mode(ctx))
+            obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_INT);
+        else
+            obj = JS_NewObjectClass(ctx, JS_CLASS_NUMBER);
+        goto set_value;
     case JS_TAG_BIG_INT:
         obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_INT);
         goto set_value;
+    case JS_TAG_FLOAT64:
+        obj = JS_NewObjectClass(ctx, JS_CLASS_NUMBER);
+        goto set_value;
     case JS_TAG_BIG_FLOAT:
         obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_FLOAT);
         goto set_value;
-    case JS_TAG_BIG_DECIMAL:
-        obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_DECIMAL);
-        goto set_value;
-#endif
+#else
     case JS_TAG_INT:
     case JS_TAG_FLOAT64:
         obj = JS_NewObjectClass(ctx, JS_CLASS_NUMBER);
         goto set_value;
+#endif
     case JS_TAG_STRING:
         /* XXX: should call the string constructor */
         {
@@ -36416,7 +33864,7 @@ static __exception int JS_ObjectDefineProperties(JSContext *ctx,
     if (JS_IsException(props))
         return -1;
     p = JS_VALUE_GET_OBJ(props);
-    if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p, JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK) < 0)
+    if (JS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p, JS_GPN_ENUM_ONLY | JS_GPN_STRING_MASK) < 0)
         goto exception;
     for(i = 0; i < len; i++) {
         JS_FreeValue(ctx, desc);
@@ -36493,7 +33941,7 @@ static JSValue js_object_getPrototypeOf(JSContext *ctx, JSValueConst this_val,
             JS_VALUE_GET_TAG(val) == JS_TAG_UNDEFINED)
             return JS_ThrowTypeErrorNotAnObject(ctx);
     }
-    return JS_GetPrototype(ctx, val);
+    return JS_DupValue(ctx, JS_GetPrototype(ctx, val));
 }
 
 static JSValue js_object_setPrototypeOf(JSContext *ctx, JSValueConst this_val,
@@ -36847,13 +34295,10 @@ static JSValue js_object_preventExtensions(JSContext *ctx, JSValueConst this_val
     ret = JS_PreventExtensions(ctx, obj);
     if (ret < 0)
         return JS_EXCEPTION;
-    if (reflect) {
+    if (reflect)
         return JS_NewBool(ctx, ret);
-    } else {
-        if (!ret)
-            return JS_ThrowTypeError(ctx, "proxy preventExtensions handler returned false");
+    else
         return JS_DupValue(ctx, obj);
-    }
 }
 
 static JSValue js_object_hasOwnProperty(JSContext *ctx, JSValueConst this_val,
@@ -36989,13 +34434,6 @@ static JSValue js_object_seal(JSContext *ctx, JSValueConst this_val,
     if (!JS_IsObject(obj))
         return JS_DupValue(ctx, obj);
 
-    res = JS_PreventExtensions(ctx, obj);
-    if (res < 0)
-        return JS_EXCEPTION;
-    if (!res) {
-        return JS_ThrowTypeError(ctx, "proxy preventExtensions handler returned false");
-    }
-    
     p = JS_VALUE_GET_OBJ(obj);
     flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK;
     if (JS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
@@ -37021,7 +34459,7 @@ static JSValue js_object_seal(JSContext *ctx, JSValueConst this_val,
             goto exception;
     }
     js_free_prop_enum(ctx, props, len);
-    return JS_DupValue(ctx, obj);
+    return js_object_preventExtensions(ctx, JS_UNDEFINED, 1, argv, 0);
 
  exception:
     js_free_prop_enum(ctx, props, len);
@@ -37287,7 +34725,7 @@ static JSValue js_object_get___proto__(JSContext *ctx, JSValueConst this_val)
     val = JS_ToObject(ctx, this_val);
     if (JS_IsException(val))
         return val;
-    ret = JS_GetPrototype(ctx, val);
+    ret = JS_DupValue(ctx, JS_GetPrototype(ctx, val));
     JS_FreeValue(ctx, val);
     return ret;
 }
@@ -37308,9 +34746,9 @@ static JSValue js_object_set___proto__(JSContext *ctx, JSValueConst this_val,
 static JSValue js_object_isPrototypeOf(JSContext *ctx, JSValueConst this_val,
                                        int argc, JSValueConst *argv)
 {
-    JSValue obj, v1;
+    JSValue obj;
     JSValueConst v;
-    int res;
+    int max_depth = 1000, res = -1;
 
     v = argv[0];
     if (!JS_IsObject(v))
@@ -37318,29 +34756,27 @@ static JSValue js_object_isPrototypeOf(JSContext *ctx, JSValueConst this_val,
     obj = JS_ToObject(ctx, this_val);
     if (JS_IsException(obj))
         return JS_EXCEPTION;
-    v1 = JS_DupValue(ctx, v);
-    for(;;) {
-        v1 = JS_GetPrototypeFree(ctx, v1);
-        if (JS_IsException(v1))
+    while (--max_depth > 0) {
+        v = JS_GetPrototype(ctx, v);
+        if (JS_IsException(v))
             goto exception;
-        if (JS_IsNull(v1)) {
+        if (JS_IsNull(v)) {
             res = FALSE;
             break;
         }
-        if (JS_VALUE_GET_OBJ(obj) == JS_VALUE_GET_OBJ(v1)) {
+        if (js_strict_eq2(ctx, JS_DupValue(ctx, obj), JS_DupValue(ctx, v),
+                          JS_EQ_STRICT)) {
             res = TRUE;
             break;
         }
-        /* avoid infinite loop (possible with proxies) */
-        if (js_poll_interrupts(ctx))
-            goto exception;
     }
-    JS_FreeValue(ctx, v1);
     JS_FreeValue(ctx, obj);
-    return JS_NewBool(ctx, res);
+    if (res < 0)
+        return JS_ThrowInternalError(ctx, "prototype chain cycle");
+    else
+        return JS_NewBool(ctx, res);
 
 exception:
-    JS_FreeValue(ctx, v1);
     JS_FreeValue(ctx, obj);
     return JS_EXCEPTION;
 }
@@ -37380,6 +34816,7 @@ static JSValue js_object___lookupGetter__(JSContext *ctx, JSValueConst this_val,
                                           int argc, JSValueConst *argv, int setter)
 {
     JSValue obj, res = JS_EXCEPTION;
+    JSValueConst v;
     JSAtom prop = JS_ATOM_NULL;
     JSPropertyDescriptor desc;
     int has_prop;
@@ -37391,8 +34828,8 @@ static JSValue js_object___lookupGetter__(JSContext *ctx, JSValueConst this_val,
     if (unlikely(prop == JS_ATOM_NULL))
         goto exception;
 
-    for (;;) {
-        has_prop = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(obj), prop);
+    for (v = obj;;) {
+        has_prop = JS_GetOwnPropertyInternal(ctx, &desc, JS_VALUE_GET_OBJ(v), prop);
         if (has_prop < 0)
             goto exception;
         if (has_prop) {
@@ -37403,16 +34840,13 @@ static JSValue js_object___lookupGetter__(JSContext *ctx, JSValueConst this_val,
             js_free_desc(ctx, &desc);
             break;
         }
-        obj = JS_GetPrototypeFree(ctx, obj);
-        if (JS_IsException(obj))
+        v = JS_GetPrototype(ctx, v);
+        if (JS_IsException(v))
             goto exception;
-        if (JS_IsNull(obj)) {
+        if (JS_IsNull(v)) {
             res = JS_UNDEFINED;
             break;
         }
-        /* avoid infinite loop (possible with proxies) */
-        if (js_poll_interrupts(ctx))
-            goto exception;
     }
 
 exception:
@@ -37478,12 +34912,59 @@ static JSValue js_function_proto(JSContext *ctx, JSValueConst this_val,
     return JS_UNDEFINED;
 }
 
+/* insert a '\n' at unicode character position 'pos' in the source of
+   'func_obj' */
+static int patch_function_constructor_source(JSContext *ctx,
+                                             JSValueConst func_obj,
+                                             size_t pos)
+{
+    JSObject *p;
+    JSFunctionBytecode *b;
+    char *r, *r_end, *new_source;
+    int c;
+    size_t idx, len;
+    
+    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
+        return 0;
+    p = JS_VALUE_GET_OBJ(func_obj);
+    if (!js_class_has_bytecode(p->class_id))
+        return 0;
+    b = p->u.func.function_bytecode;
+    if (!b->has_debug)
+        return 0;
+    r = b->debug.source;
+    r_end = b->debug.source + b->debug.source_len;
+    idx = 0;
+    while (r < r_end) {
+        if (idx == pos) {
+            /* add the '\n' */
+            new_source = js_realloc(ctx, b->debug.source,
+                                    b->debug.source_len + 2);
+            if (!new_source)
+                return -1;
+            len = r - b->debug.source;
+            memmove(new_source + len + 1, new_source + len,
+                    b->debug.source_len + 1 - len);
+            new_source[len] = '\n';
+            b->debug.source = new_source;
+            b->debug.source_len++;
+            break;
+        }
+        c = unicode_from_utf8((const uint8_t *)r, UTF8_CHAR_LEN_MAX,
+                              (const uint8_t **)&r);
+        if (c < 0)
+            break;
+        idx++;
+    }
+    return 0;
+}
+                                             
 /* XXX: add a specific eval mode so that Function("}), ({") is rejected */
 static JSValue js_function_constructor(JSContext *ctx, JSValueConst new_target,
                                        int argc, JSValueConst *argv, int magic)
 {
     JSFunctionKindEnum func_kind = magic;
-    int i, n, ret;
+    int i, n, ret, func_start_pos;
     JSValue s, proto, obj = JS_UNDEFINED;
     StringBuffer b_s, *b = &b_s;
 
@@ -37508,7 +34989,13 @@ static JSValue js_function_constructor(JSContext *ctx, JSValueConst new_target,
         if (string_buffer_concat_value(b, argv[i]))
             goto fail;
     }
-    string_buffer_puts8(b, "\n) {\n");
+    string_buffer_puts8(b, "\n) {");
+    /* Annex B HTML comments: We don't add a '\n' after "{" so that
+       "-->" is not considered as an HTML comment. It is necessary
+       because in the spec the function body is parsed separately. */
+    /* XXX: find a simpler way or be deliberately incompatible to
+       simplify the code ? */
+    func_start_pos = b->len - 1; /* the leading '(' is not in the source */
     if (n >= 0) {
         if (string_buffer_concat_value(b, argv[n]))
             goto fail;
@@ -37522,23 +35009,19 @@ static JSValue js_function_constructor(JSContext *ctx, JSValueConst new_target,
     JS_FreeValue(ctx, s);
     if (JS_IsException(obj))
         goto fail1;
+    if (patch_function_constructor_source(ctx, obj, func_start_pos) < 0)
+        goto fail1;
     if (!JS_IsUndefined(new_target)) {
         /* set the prototype */
-        proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype);
+        proto = js_get_prototype_from_ctor(ctx, new_target, JS_UNDEFINED);
         if (JS_IsException(proto))
             goto fail1;
-        if (!JS_IsObject(proto)) {
-            JSContext *realm;
+        if (!JS_IsUndefined(proto)) {
+            ret = JS_SetPrototypeInternal(ctx, obj, proto, TRUE);
             JS_FreeValue(ctx, proto);
-            realm = JS_GetFunctionRealm(ctx, new_target);
-            if (!realm)
+            if (ret < 0)
                 goto fail1;
-            proto = JS_DupValue(ctx, realm->class_proto[func_kind_to_class_id[func_kind]]);
         }
-        ret = JS_SetPrototypeInternal(ctx, obj, proto, TRUE);
-        JS_FreeValue(ctx, proto);
-        if (ret < 0)
-            goto fail1;
     }
     return obj;
 
@@ -37596,10 +35079,6 @@ static JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,
     }
     if (js_get_length32(ctx, &len, array_arg))
         return NULL;
-    if (len > JS_MAX_LOCAL_VARS) {
-        JS_ThrowInternalError(ctx, "too many arguments");
-        return NULL;
-    }
     /* avoid allocating 0 bytes */
     tab = js_mallocz(ctx, sizeof(tab[0]) * max_uint32(1, len));
     if (!tab)
@@ -37625,8 +35104,6 @@ static JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,
     return tab;
 }
 
-/* magic value: 0 = normal apply, 1 = apply for constructor, 2 =
-   Reflect.apply */
 static JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv, int magic)
 {
@@ -37638,14 +35115,14 @@ static JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,
         return JS_EXCEPTION;
     this_arg = argv[0];
     array_arg = argv[1];
-    if ((JS_VALUE_GET_TAG(array_arg) == JS_TAG_UNDEFINED ||
-         JS_VALUE_GET_TAG(array_arg) == JS_TAG_NULL) && magic != 2) {
+    if (JS_VALUE_GET_TAG(array_arg) == JS_TAG_UNDEFINED ||
+        JS_VALUE_GET_TAG(array_arg) == JS_TAG_NULL) {
         return JS_Call(ctx, this_val, this_arg, 0, NULL);
     }
     tab = build_arg_list(ctx, &len, array_arg);
     if (!tab)
         return JS_EXCEPTION;
-    if (magic & 1) {
+    if (magic) {
         ret = JS_CallConstructor2(ctx, this_val, this_arg, len, (JSValueConst *)tab);
     } else {
         ret = JS_Call(ctx, this_val, this_arg, len, (JSValueConst *)tab);
@@ -37668,9 +35145,10 @@ static JSValue js_function_bind(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
 {
     JSBoundFunction *bf;
-    JSValue func_obj, name1, len_val;
+    JSValue func_obj, name1;
     JSObject *p;
-    int arg_count, i, ret;
+    int arg_count, i;
+    uint32_t len1;
 
     if (check_function(ctx, this_val))
         return JS_EXCEPTION;
@@ -37693,44 +35171,6 @@ static JSValue js_function_bind(JSContext *ctx, JSValueConst this_val,
     }
     p->u.bound_function = bf;
 
-    /* XXX: the spec could be simpler by only using GetOwnProperty */
-    ret = JS_GetOwnProperty(ctx, NULL, this_val, JS_ATOM_length);
-    if (ret < 0)
-        goto exception;
-    if (!ret) {
-        len_val = JS_NewInt32(ctx, 0);
-    } else {
-        len_val = JS_GetProperty(ctx, this_val, JS_ATOM_length);
-        if (JS_IsException(len_val))
-            goto exception;
-        if (JS_VALUE_GET_TAG(len_val) == JS_TAG_INT) {
-            /* most common case */
-            int len1 = JS_VALUE_GET_INT(len_val);
-            if (len1 <= arg_count)
-                len1 = 0;
-            else
-                len1 -= arg_count;
-            len_val = JS_NewInt32(ctx, len1);
-        } else if (JS_VALUE_GET_NORM_TAG(len_val) == JS_TAG_FLOAT64) {
-            double d = JS_VALUE_GET_FLOAT64(len_val);
-            if (isnan(d)) {
-                d = 0.0;
-            } else {
-                d = trunc(d);
-                if (d <= (double)arg_count)
-                    d = 0.0;
-                else
-                    d -= (double)arg_count; /* also converts -0 to +0 */
-            }
-            len_val = JS_NewFloat64(ctx, d);
-        } else {
-            JS_FreeValue(ctx, len_val);
-            len_val = JS_NewInt32(ctx, 0);
-        }
-    }
-    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length,
-                           len_val, JS_PROP_CONFIGURABLE);
-
     name1 = JS_GetProperty(ctx, this_val, JS_ATOM_name);
     if (JS_IsException(name1))
         goto exception;
@@ -37743,6 +35183,15 @@ static JSValue js_function_bind(JSContext *ctx, JSValueConst this_val,
         goto exception;
     JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name, name1,
                            JS_PROP_CONFIGURABLE);
+    if (js_get_length32(ctx, &len1, this_val))
+        goto exception;
+    if (len1 <= (uint32_t)arg_count)
+        len1 = 0;
+    else
+        len1 -= arg_count;
+    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length,
+                           JS_NewUint32(ctx, len1),
+                           JS_PROP_CONFIGURABLE);
     return func_obj;
  exception:
     JS_FreeValue(ctx, func_obj);
@@ -37770,22 +35219,27 @@ static JSValue js_function_toString(JSContext *ctx, JSValueConst this_val,
         JSValue name;
         const char *pref, *suff;
 
-        switch(func_kind) {
-        default:
-        case JS_FUNC_NORMAL:
-            pref = "function ";
-            break;
-        case JS_FUNC_GENERATOR:
-            pref = "function *";
-            break;
-        case JS_FUNC_ASYNC:
-            pref = "async function ";
-            break;
-        case JS_FUNC_ASYNC_GENERATOR:
-            pref = "async function *";
-            break;
+        if (p->is_class) {
+            pref = "class ";
+            suff = " {\n    [native code]\n}";
+        } else {
+            switch(func_kind) {
+            default:
+            case JS_FUNC_NORMAL:
+                pref = "function ";
+                break;
+            case JS_FUNC_GENERATOR:
+                pref = "function *";
+                break;
+            case JS_FUNC_ASYNC:
+                pref = "async function ";
+                break;
+            case JS_FUNC_ASYNC_GENERATOR:
+                pref = "async function *";
+                break;
+            }
+            suff = "() {\n    [native code]\n}";
         }
-        suff = "() {\n    [native code]\n}";
         name = JS_GetProperty(ctx, this_val, JS_ATOM_name);
         if (JS_IsUndefined(name))
             name = JS_AtomToString(ctx, JS_ATOM_empty_string);
@@ -37816,102 +35270,34 @@ static const JSCFunctionListEntry js_function_proto_funcs[] = {
 
 /* Error class */
 
-static JSValue iterator_to_array(JSContext *ctx, JSValueConst items)
-{
-    JSValue iter, next_method = JS_UNDEFINED;
-    JSValue v, r = JS_UNDEFINED;
-    int64_t k;
-    BOOL done;
-    
-    iter = JS_GetIterator(ctx, items, FALSE);
-    if (JS_IsException(iter))
-        goto exception;
-    next_method = JS_GetProperty(ctx, iter, JS_ATOM_next);
-    if (JS_IsException(next_method))
-        goto exception;
-    r = JS_NewArray(ctx);
-    if (JS_IsException(r))
-        goto exception;
-    for (k = 0;; k++) {
-        v = JS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
-        if (JS_IsException(v))
-            goto exception_close;
-        if (done)
-            break;
-        if (JS_DefinePropertyValueInt64(ctx, r, k, v,
-                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)
-            goto exception_close;
-    }
- done:
-    JS_FreeValue(ctx, next_method);
-    JS_FreeValue(ctx, iter);
-    return r;
- exception_close:
-    JS_IteratorClose(ctx, iter, TRUE);
- exception:
-    JS_FreeValue(ctx, r);
-    r = JS_EXCEPTION;
-    goto done;
-}
-
 static JSValue js_error_constructor(JSContext *ctx, JSValueConst new_target,
                                     int argc, JSValueConst *argv, int magic)
 {
     JSValue obj, msg, proto;
-    JSValueConst message;
+    JSValueConst proto1;
 
     if (JS_IsUndefined(new_target))
         new_target = JS_GetActiveFunction(ctx);
-    proto = JS_GetProperty(ctx, new_target, JS_ATOM_prototype);
+    if (magic < 0) {
+        proto1 = ctx->class_proto[JS_CLASS_ERROR];
+    } else {
+        proto1 = ctx->native_error_proto[magic];
+    }
+    proto = js_get_prototype_from_ctor(ctx, new_target, proto1);
     if (JS_IsException(proto))
         return proto;
-    if (!JS_IsObject(proto)) {
-        JSContext *realm;
-        JSValueConst proto1;
-        
-        JS_FreeValue(ctx, proto);
-        realm = JS_GetFunctionRealm(ctx, new_target);
-        if (!realm)
-            return JS_EXCEPTION;
-        if (magic < 0) {
-            proto1 = realm->class_proto[JS_CLASS_ERROR];
-        } else {
-            proto1 = realm->native_error_proto[magic];
-        }
-        proto = JS_DupValue(ctx, proto1);
-    }
     obj = JS_NewObjectProtoClass(ctx, proto, JS_CLASS_ERROR);
     JS_FreeValue(ctx, proto);
-    if (JS_IsException(obj))
-        return obj;
-    if (magic == JS_AGGREGATE_ERROR) {
-        message = argv[1];
-    } else {
-        message = argv[0];
-    }
-
-    if (!JS_IsUndefined(message)) {
-        msg = JS_ToString(ctx, message);
-        if (unlikely(JS_IsException(msg)))
-            goto exception;
+    if (!JS_IsException(obj) && !JS_IsUndefined(argv[0])) {
+        msg = JS_ToString(ctx, argv[0]);
+        if (unlikely(JS_IsException(msg))) {
+            JS_FreeValue(ctx, obj);
+            return JS_EXCEPTION;
+        }
         JS_DefinePropertyValue(ctx, obj, JS_ATOM_message, msg,
                                JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
     }
-
-    if (magic == JS_AGGREGATE_ERROR) {
-        JSValue error_list = iterator_to_array(ctx, argv[0]);
-        if (JS_IsException(error_list))
-            goto exception;
-        JS_DefinePropertyValue(ctx, obj, JS_ATOM_errors, error_list,
-                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-    }
-
-    /* skip the Error() function in the backtrace */
-    build_backtrace(ctx, obj, NULL, 0, JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL);
     return obj;
- exception:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
 }
 
 static JSValue js_error_toString(JSContext *ctx, JSValueConst this_val,
@@ -37919,8 +35305,6 @@ static JSValue js_error_toString(JSContext *ctx, JSValueConst this_val,
 {
     JSValue name, msg;
 
-    if (!JS_IsObject(this_val))
-        return JS_ThrowTypeErrorNotAnObject(ctx);
     name = JS_GetProperty(ctx, this_val, JS_ATOM_name);
     if (JS_IsUndefined(name))
         name = JS_AtomToString(ctx, JS_ATOM_Error);
@@ -37949,24 +35333,6 @@ static const JSCFunctionListEntry js_error_proto_funcs[] = {
     JS_PROP_STRING_DEF("message", "", JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE ),
 };
 
-/* AggregateError */
-
-/* used by C code. */
-static JSValue js_aggregate_error_constructor(JSContext *ctx,
-                                              JSValueConst errors)
-{
-    JSValue obj;
-    
-    obj = JS_NewObjectProtoClass(ctx,
-                                 ctx->native_error_proto[JS_AGGREGATE_ERROR],
-                                 JS_CLASS_ERROR);
-    if (JS_IsException(obj))
-        return obj;
-    JS_DefinePropertyValue(ctx, obj, JS_ATOM_errors, JS_DupValue(ctx, errors),
-                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-    return obj;
-}
-
 /* Array */
 
 static int JS_CopySubArray(JSContext *ctx,
@@ -38015,7 +35381,7 @@ static JSValue js_array_constructor(JSContext *ctx, JSValueConst new_target,
         return obj;
     if (argc == 1 && JS_IsNumber(argv[0])) {
         uint32_t len;
-        if (JS_ToArrayLengthFree(ctx, &len, JS_DupValue(ctx, argv[0]), TRUE))
+        if (JS_ToArrayLengthFree(ctx, &len, JS_DupValue(ctx, argv[0])))
             goto fail;
         if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewUint32(ctx, len)) < 0)
             goto fail;
@@ -38192,47 +35558,22 @@ static JSValue js_get_this(JSContext *ctx,
 static JSValue JS_ArraySpeciesCreate(JSContext *ctx, JSValueConst obj,
                                      JSValueConst len_val)
 {
-    JSValue ctor, ret, species;
+    JSValue ctor, ret;
     int res;
-    JSContext *realm;
-    
+
     res = JS_IsArray(ctx, obj);
     if (res < 0)
         return JS_EXCEPTION;
     if (!res)
         return js_array_constructor(ctx, JS_UNDEFINED, 1, &len_val);
-    ctor = JS_GetProperty(ctx, obj, JS_ATOM_constructor);
+    ctor = JS_SpeciesConstructor(ctx, obj, JS_UNDEFINED);
     if (JS_IsException(ctor))
-        return ctor;
-    if (JS_IsConstructor(ctx, ctor)) {
-        /* legacy web compatibility */
-        realm = JS_GetFunctionRealm(ctx, ctor);
-        if (!realm) {
-            JS_FreeValue(ctx, ctor);
-            return JS_EXCEPTION;
-        }
-        if (realm != ctx &&
-            js_same_value(ctx, ctor, realm->array_ctor)) {
-            JS_FreeValue(ctx, ctor);
-            ctor = JS_UNDEFINED;
-        }
-    }
-    if (JS_IsObject(ctor)) {
-        species = JS_GetProperty(ctx, ctor, JS_ATOM_Symbol_species);
-        JS_FreeValue(ctx, ctor);
-        if (JS_IsException(species))
-            return species;
-        ctor = species;
-        if (JS_IsNull(ctor))
-            ctor = JS_UNDEFINED;
-    }
-    if (JS_IsUndefined(ctor)) {
+        return JS_EXCEPTION;
+    if (JS_IsUndefined(ctor))
         return js_array_constructor(ctx, JS_UNDEFINED, 1, &len_val);
-    } else {
-        ret = JS_CallConstructor(ctx, ctor, 1, &len_val);
-        JS_FreeValue(ctx, ctor);
-        return ret;
-    }
+    ret = JS_CallConstructor(ctx, ctor, 1, &len_val);
+    JS_FreeValue(ctx, ctor);
+    return ret;
 }
 
 static const JSCFunctionListEntry js_array_funcs[] = {
@@ -38285,7 +35626,7 @@ static JSValue js_array_concat(JSContext *ctx, JSValueConst this_val,
         if (res) {
             if (js_get_length64(ctx, &len, e))
                 goto exception;
-            if (n + len > MAX_SAFE_INTEGER) {
+            if (n + len >= MAX_SAFE_INTEGER) {
                 JS_ThrowTypeError(ctx, "Array loo long");
                 goto exception;
             }
@@ -38400,16 +35741,9 @@ static JSValue js_array_every(JSContext *ctx, JSValueConst this_val,
     n = 0;
 
     for(k = 0; k < len; k++) {
-        if (special & special_TA) {
-            val = JS_GetPropertyInt64(ctx, obj, k);
-            if (JS_IsException(val))
-                goto exception;
-            present = TRUE;
-        } else {
-            present = JS_TryGetPropertyInt64(ctx, obj, k, &val);
-            if (present < 0)
-                goto exception;
-        }
+        present = JS_TryGetPropertyInt64(ctx, obj, k, &val);
+        if (present < 0)
+            goto exception;
         if (present) {
             index_val = JS_NewInt64(ctx, k);
             if (JS_IsException(index_val))
@@ -38527,32 +35861,18 @@ static JSValue js_array_reduce(JSContext *ctx, JSValueConst this_val,
             }
             k1 = (special & special_reduceRight) ? len - k - 1 : k;
             k++;
-            if (special & special_TA) {
-                acc = JS_GetPropertyInt64(ctx, obj, k1);
-                if (JS_IsException(acc))
-                    goto exception;
+            present = JS_TryGetPropertyInt64(ctx, obj, k1, &acc);
+            if (present < 0)
+                goto exception;
+            if (present)
                 break;
-            } else {
-                present = JS_TryGetPropertyInt64(ctx, obj, k1, &acc);
-                if (present < 0)
-                    goto exception;
-                if (present)
-                    break;
-            }
         }
     }
     for (; k < len; k++) {
         k1 = (special & special_reduceRight) ? len - k - 1 : k;
-        if (special & special_TA) {
-            val = JS_GetPropertyInt64(ctx, obj, k1);
-            if (JS_IsException(val))
-                goto exception;
-            present = TRUE;
-        } else {
-            present = JS_TryGetPropertyInt64(ctx, obj, k1, &val);
-            if (present < 0)
-                goto exception;
-        }
+        present = JS_TryGetPropertyInt64(ctx, obj, k1, &val);
+        if (present < 0)
+            goto exception;
         if (present) {
             index_val = JS_NewInt64(ctx, k1);
             if (JS_IsException(index_val))
@@ -38957,64 +36277,27 @@ static JSValue js_array_push(JSContext *ctx, JSValueConst this_val,
     int64_t len, from, newLen;
 
     obj = JS_ToObject(ctx, this_val);
-
-    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
-        JSObject *p = JS_VALUE_GET_OBJ(obj);
-        if (p->class_id != JS_CLASS_ARRAY ||
-            !p->fast_array || !p->extensible)
-            goto generic_case;
-        /* length must be writable */
-        if (unlikely(!(get_shape_prop(p->shape)->flags & JS_PROP_WRITABLE)))
-            goto generic_case;
-        /* check the length */
-        if (unlikely(JS_VALUE_GET_TAG(p->prop[0].u.value) != JS_TAG_INT))
-            goto generic_case;
-        len = JS_VALUE_GET_INT(p->prop[0].u.value);
-        /* we don't support holes */
-        if (unlikely(len != p->u.array.count))
-            goto generic_case;
-        newLen = len + argc;
-        if (unlikely(newLen > INT32_MAX))
-            goto generic_case;
-        if (newLen > p->u.array.u1.size) {
-            if (expand_fast_array(ctx, p, newLen))
-                goto exception;
-        }
-        if (unshift && argc > 0) {
-            memmove(p->u.array.u.values + argc, p->u.array.u.values,
-                    len * sizeof(p->u.array.u.values[0]));
-            from = 0;
-        } else {
-            from = len;
-        }
-        for(i = 0; i < argc; i++) {
-            p->u.array.u.values[from + i] = JS_DupValue(ctx, argv[i]);
-        }
-        p->u.array.count = newLen;
-        p->prop[0].u.value = JS_NewInt32(ctx, newLen);
-    } else {
-    generic_case:
-        if (js_get_length64(ctx, &len, obj))
-            goto exception;
-        newLen = len + argc;
-        if (newLen > MAX_SAFE_INTEGER) {
-            JS_ThrowTypeError(ctx, "Array loo long");
+    if (js_get_length64(ctx, &len, obj))
+        goto exception;
+    newLen = len + argc;
+    if (newLen > MAX_SAFE_INTEGER) {
+        JS_ThrowTypeError(ctx, "Array loo long");
+        goto exception;
+    }
+    from = len;
+    if (unshift && argc > 0) {
+        if (JS_CopySubArray(ctx, obj, argc, 0, len, -1))
             goto exception;
-        }
-        from = len;
-        if (unshift && argc > 0) {
-            if (JS_CopySubArray(ctx, obj, argc, 0, len, -1))
-                goto exception;
-            from = 0;
-        }
-        for(i = 0; i < argc; i++) {
-            if (JS_SetPropertyInt64(ctx, obj, from + i,
-                                    JS_DupValue(ctx, argv[i])) < 0)
-                goto exception;
-        }
-        if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)
+        from = 0;
+    }
+    for(i = 0; i < argc; i++) {
+        if (JS_SetPropertyInt64(ctx, obj, from + i,
+                                JS_DupValue(ctx, argv[i])) < 0)
             goto exception;
     }
+    if (JS_SetProperty(ctx, obj, JS_ATOM_length, JS_NewInt64(ctx, newLen)) < 0)
+        goto exception;
+
     JS_FreeValue(ctx, obj);
     return JS_NewInt64(ctx, newLen);
 
@@ -39244,11 +36527,6 @@ static int64_t JS_FlattenIntoArray(JSContext *ctx, JSValueConst target,
     int64_t sourceIndex, elementLen;
     int present, is_array;
 
-    if (js_check_stack_overflow(ctx->rt, 0)) {
-        JS_ThrowStackOverflow(ctx);
-        return -1;
-    }
-
     for (sourceIndex = 0; sourceIndex < sourceLen; sourceIndex++) {
         present = JS_TryGetPropertyInt64(ctx, source, sourceIndex, &element);
         if (present < 0)
@@ -39258,8 +36536,8 @@ static int64_t JS_FlattenIntoArray(JSContext *ctx, JSValueConst target,
         if (!JS_IsUndefined(mapperFunction)) {
             JSValueConst args[3] = { element, JS_NewInt64(ctx, sourceIndex), source };
             element = JS_Call(ctx, mapperFunction, thisArg, 3, args);
-            JS_FreeValue(ctx, (JSValue)args[0]);
-            JS_FreeValue(ctx, (JSValue)args[1]);
+            JS_FreeValue(ctx, args[0]);
+            JS_FreeValue(ctx, args[1]);
             if (JS_IsException(element))
                 return -1;
         }
@@ -39284,8 +36562,7 @@ static int64_t JS_FlattenIntoArray(JSContext *ctx, JSValueConst target,
             JS_ThrowTypeError(ctx, "Array too long");
             goto fail;
         }
-        if (JS_DefinePropertyValueInt64(ctx, target, targetIndex, element,
-                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+        if (JS_SetPropertyInt64(ctx, target, targetIndex, element) < 0)
             return -1;
         targetIndex++;
     }
@@ -39682,6 +36959,7 @@ static const JSCFunctionListEntry js_array_proto_funcs[] = {
     JS_CFUNC_DEF("copyWithin", 2, js_array_copyWithin ),
     JS_CFUNC_MAGIC_DEF("flatMap", 1, js_array_flatten, 1 ),
     JS_CFUNC_MAGIC_DEF("flat", 0, js_array_flatten, 0 ),
+    JS_CFUNC_MAGIC_DEF("flatten", 0, js_array_flatten, 0 ),
     JS_CFUNC_MAGIC_DEF("values", 0, js_create_array_iterator, JS_ITERATOR_KIND_VALUE ),
     JS_ALIAS_DEF("[Symbol.iterator]", "values" ),
     JS_CFUNC_MAGIC_DEF("keys", 0, js_create_array_iterator, JS_ITERATOR_KIND_KEY ),
@@ -39699,14 +36977,17 @@ static JSValue js_number_constructor(JSContext *ctx, JSValueConst new_target,
                                      int argc, JSValueConst *argv)
 {
     JSValue val, obj;
+#ifdef CONFIG_BIGNUM
     if (argc == 0) {
-        val = JS_NewInt32(ctx, 0);
+        if (is_bignum_mode(ctx))
+            val = __JS_NewFloat64(ctx, 0);
+        else
+            val = JS_NewInt32(ctx, 0);
     } else {
         val = JS_ToNumeric(ctx, argv[0]);
         if (JS_IsException(val))
             return val;
         switch(JS_VALUE_GET_TAG(val)) {
-#ifdef CONFIG_BIGNUM
         case JS_TAG_BIG_INT:
         case JS_TAG_BIG_FLOAT:
             {
@@ -39717,19 +36998,25 @@ static JSValue js_number_constructor(JSContext *ctx, JSValueConst new_target,
                 val = __JS_NewFloat64(ctx, d);
             }
             break;
-        case JS_TAG_BIG_DECIMAL:
-            val = JS_ToStringFree(ctx, val);
-            if (JS_IsException(val))
-                return val;
-            val = JS_ToNumberFree(ctx, val);
-            if (JS_IsException(val))
-                return val;
+        case JS_TAG_INT:
+            if (is_bignum_mode(ctx)) {
+                /* always return a number in bignum mode */
+                val = __JS_NewFloat64(ctx, JS_VALUE_GET_INT(val));
+            }
             break;
-#endif
         default:
             break;
         }
     }
+#else
+    if (argc == 0) {
+        val = JS_NewInt32(ctx, 0);
+    } else {
+        val = JS_ToNumber(ctx, argv[0]);
+        if (JS_IsException(val))
+            return val;
+    }
+#endif
     if (!JS_IsUndefined(new_target)) {
         obj = js_create_from_ctor(ctx, new_target, JS_CLASS_NUMBER);
         if (!JS_IsException(obj))
@@ -39760,6 +37047,7 @@ static JSValue js_number___toLength(JSContext *ctx, JSValueConst this_val,
 static JSValue js_number_isNaN(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
 {
+    /* XXX: should just check for float and big_float */
     if (!JS_IsNumber(argv[0]))
         return JS_FALSE;
     return js_global_isNaN(ctx, this_val, argc, argv);
@@ -39792,7 +37080,8 @@ static JSValue js_number_isSafeInteger(JSContext *ctx, JSValueConst this_val,
         return JS_FALSE;
     if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))
         return JS_EXCEPTION;
-    return JS_NewBool(ctx, is_safe_integer(d));
+    return JS_NewBool(ctx, isfinite(d) && floor(d) == d &&
+                      fabs(d) <= (double)MAX_SAFE_INTEGER);
 }
 
 static const JSCFunctionListEntry js_number_funcs[] = {
@@ -39836,24 +37125,11 @@ static JSValue js_number_valueOf(JSContext *ctx, JSValueConst this_val,
     return js_thisNumberValue(ctx, this_val);
 }
 
-static int js_get_radix(JSContext *ctx, JSValueConst val)
-{
-    int radix;
-    if (JS_ToInt32Sat(ctx, &radix, val))
-        return -1;
-    if (radix < 2 || radix > 36) {
-        JS_ThrowRangeError(ctx, "radix must be between 2 and 36");
-        return -1;
-    }
-    return radix;
-}
-
 static JSValue js_number_toString(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv, int magic)
 {
     JSValue val;
     int base;
-    double d;
 
     val = js_thisNumberValue(ctx, this_val);
     if (JS_IsException(val))
@@ -39861,18 +37137,198 @@ static JSValue js_number_toString(JSContext *ctx, JSValueConst this_val,
     if (magic || JS_IsUndefined(argv[0])) {
         base = 10;
     } else {
-        base = js_get_radix(ctx, argv[0]);
-        if (base < 0)
+        if (JS_ToInt32Sat(ctx, &base, argv[0]))
             goto fail;
+        if (base < 2 || base > 36) {
+            JS_ThrowRangeError(ctx, "radix must be between 2 and 36");
+            goto fail;
+        }
     }
-    if (JS_ToFloat64Free(ctx, &d, val))
-        return JS_EXCEPTION;
-    return js_dtoa(ctx, d, base, 0, JS_DTOA_VAR_FORMAT);
+#ifdef CONFIG_BIGNUM
+    {
+        JSValue ret = js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
+        JS_FreeValue(ctx, val);
+        return ret;
+    }
+#else
+    {
+        double d;
+        if (JS_ToFloat64Free(ctx, &d, val))
+            return JS_EXCEPTION;
+        return js_dtoa(ctx, d, base, 0, JS_DTOA_VAR_FORMAT);
+    }
+#endif
+ fail:
+    JS_FreeValue(ctx, val);
+    return JS_EXCEPTION;
+}
+
+#ifdef CONFIG_BIGNUM
+
+static JSValue js_thisBigFloatValue(JSContext *ctx, JSValueConst this_val);
+
+static int64_t js_number_get_prec_max(JSContext *ctx, int magic)
+{
+    if (magic)
+        return BF_PREC_MAX;
+    else
+        return 100;
+}
+
+static int get_rnd_mode(JSContext *ctx, JSValueConst val)
+{
+    int rnd_mode;
+    if (JS_ToInt32Sat(ctx, &rnd_mode, val))
+        return -1;
+    if (rnd_mode < BF_RNDN || rnd_mode > BF_RNDF) {
+        JS_ThrowRangeError(ctx, "invalid rounding mode");
+        return -1;
+    }
+    return rnd_mode;
+}
+
+static JSValue js_number_toFixed(JSContext *ctx, JSValueConst this_val,
+                                 int argc, JSValueConst *argv, int magic)
+{
+    JSValue val, ret;
+    int64_t f;
+    int res, rnd_mode;
+    bf_t a_s, *a, b;
+    BOOL is_float;
+
+    if (magic)
+        val = js_thisBigFloatValue(ctx, this_val);
+    else
+        val = js_thisNumberValue(ctx, this_val);
+    if (JS_IsException(val))
+        return val;
+    if (JS_ToInt64Sat(ctx, &f, argv[0]))
+        goto fail;
+    if (f < 0 || f > js_number_get_prec_max(ctx, magic)) {
+        JS_ThrowRangeError(ctx, "invalid number of digits");
+        goto fail;
+    }
+    rnd_mode = BF_RNDNA;
+    if (magic && argc > 1) {
+        rnd_mode = get_rnd_mode(ctx, argv[1]);
+        if (rnd_mode < 0)
+            goto fail;
+    }
+
+    a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
+    if (!a)
+        goto fail;
+    bf_init(ctx->bf_ctx, &b);
+    bf_set_float64(&b, 1e21);
+    res = bf_cmpu(a, &b);
+    bf_delete(&b);
+    if (a == &a_s)
+        bf_delete(a);
+    if (res >= 0) {
+        ret = JS_ToString(ctx, val);
+    } else {
+        ret = js_ftoa(ctx, val, 10, f, rnd_mode | BF_FTOA_FORMAT_FRAC);
+    }
+    JS_FreeValue(ctx, val);
+    return ret;
+ fail:
+    JS_FreeValue(ctx, val);
+    return JS_EXCEPTION;
+}
+
+static JSValue js_number_toExponential(JSContext *ctx, JSValueConst this_val,
+                                       int argc, JSValueConst *argv, int magic)
+{
+    JSValue val, ret;
+    int64_t f;
+    int rnd_mode;
+
+    if (magic)
+        val = js_thisBigFloatValue(ctx, this_val);
+    else
+        val = js_thisNumberValue(ctx, this_val);
+    if (JS_IsException(val))
+        return val;
+    if (JS_ToInt64Sat(ctx, &f, argv[0]))
+        goto fail;
+    if (!js_number_is_finite(ctx, val)) {
+        ret = JS_ToString(ctx, val);
+    } else if (JS_IsUndefined(argv[0])) {
+        ret = js_ftoa(ctx, val, 10, 0,
+                      BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);
+    } else {
+        if (f < 0 || f > js_number_get_prec_max(ctx, magic)) {
+            JS_ThrowRangeError(ctx, "invalid number of digits");
+            goto fail;
+        }
+        rnd_mode = BF_RNDNA;
+        if (magic && argc > 1) {
+            rnd_mode = get_rnd_mode(ctx, argv[1]);
+            if (rnd_mode < 0)
+                goto fail;
+        }
+        ret = js_ftoa(ctx, val, 10, f + 1,
+                      rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);
+    }
+    JS_FreeValue(ctx, val);
+    return ret;
  fail:
     JS_FreeValue(ctx, val);
     return JS_EXCEPTION;
 }
 
+static JSValue js_number_toPrecision(JSContext *ctx, JSValueConst this_val,
+                                     int argc, JSValueConst *argv, int magic)
+{
+    JSValue val, ret;
+    int64_t p;
+    int rnd_mode;
+
+    if (magic)
+        val = js_thisBigFloatValue(ctx, this_val);
+    else
+        val = js_thisNumberValue(ctx, this_val);
+    if (JS_IsException(val))
+        return val;
+    if (JS_IsUndefined(argv[0]))
+        goto to_string;
+    if (JS_ToInt64Sat(ctx, &p, argv[0]))
+        goto fail;
+    if (!js_number_is_finite(ctx, val)) {
+    to_string:
+        ret = JS_ToString(ctx, this_val);
+    } else {
+        if (p < 1 || p > js_number_get_prec_max(ctx, magic)) {
+            JS_ThrowRangeError(ctx, "invalid number of digits");
+            goto fail;
+        }
+        rnd_mode = BF_RNDNA;
+        if (magic && argc > 1) {
+            rnd_mode = get_rnd_mode(ctx, argv[1]);
+            if (rnd_mode < 0)
+                goto fail;
+        }
+        ret = js_ftoa(ctx, val, 10, p, rnd_mode | BF_FTOA_FORMAT_FIXED);
+    }
+    JS_FreeValue(ctx, val);
+    return ret;
+ fail:
+    JS_FreeValue(ctx, val);
+    return JS_EXCEPTION;
+
+}
+
+static const JSCFunctionListEntry js_number_proto_funcs[] = {
+    JS_CFUNC_MAGIC_DEF("toExponential", 1, js_number_toExponential, 0 ),
+    JS_CFUNC_MAGIC_DEF("toFixed", 1, js_number_toFixed, 0 ),
+    JS_CFUNC_MAGIC_DEF("toPrecision", 1, js_number_toPrecision, 0 ),
+    JS_CFUNC_MAGIC_DEF("toString", 1, js_number_toString, 0 ),
+    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_number_toString, 1 ),
+    JS_CFUNC_DEF("valueOf", 0, js_number_valueOf ),
+};
+
+#else /* !CONFIG_BIGNUM */
+
 static JSValue js_number_toFixed(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv)
 {
@@ -39959,11 +37415,14 @@ static const JSCFunctionListEntry js_number_proto_funcs[] = {
     JS_CFUNC_DEF("valueOf", 0, js_number_valueOf ),
 };
 
+#endif /* !CONFIG_BIGNUM */
+
+
 static JSValue js_parseInt(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
 {
-    const char *str, *p;
-    int radix, flags;
+    const char *str;
+    int radix;
     JSValue ret;
 
     str = JS_ToCString(ctx, argv[0]);
@@ -39976,10 +37435,15 @@ static JSValue js_parseInt(JSContext *ctx, JSValueConst this_val,
     if (radix != 0 && (radix < 2 || radix > 36)) {
         ret = JS_NAN;
     } else {
-        p = str;
-        p += skip_spaces(p);
-        flags = ATOD_INT_ONLY | ATOD_ACCEPT_PREFIX_AFTER_SIGN;
-        ret = js_atof(ctx, p, NULL, radix, flags);
+#ifdef CONFIG_BIGNUM
+        int flags;
+        flags = BF_ATOF_INT_ONLY | BF_ATOF_NAN_IF_EMPTY | BF_ATOF_FLOAT64;
+        if (is_bignum_mode(ctx))
+            flags |= BF_ATOF_INT_PREC_INF;
+        ret = js_atof(ctx, str, NULL, radix, flags);
+#else
+        ret = js_atod(ctx, str, NULL, radix, ATOD_INT_ONLY | ATOD_NAN_IF_EMPTY);
+#endif
     }
     JS_FreeCString(ctx, str);
     return ret;
@@ -39988,15 +37452,18 @@ static JSValue js_parseInt(JSContext *ctx, JSValueConst this_val,
 static JSValue js_parseFloat(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
 {
-    const char *str, *p;
+    const char *str;
     JSValue ret;
 
     str = JS_ToCString(ctx, argv[0]);
     if (!str)
         return JS_EXCEPTION;
-    p = str;
-    p += skip_spaces(p);
-    ret = js_atof(ctx, p, NULL, 10, 0);
+#ifdef CONFIG_BIGNUM
+    ret = js_atof(ctx, str, NULL, 10,
+                  BF_ATOF_JS_QUIRKS | BF_ATOF_NAN_IF_EMPTY | BF_ATOF_FLOAT64);
+#else
+    ret = js_atod(ctx, str, NULL, 10, ATOD_NAN_IF_EMPTY);
+#endif
     JS_FreeCString(ctx, str);
     return ret;
 }
@@ -40087,6 +37554,46 @@ static int js_string_get_own_property(JSContext *ctx,
     return FALSE;
 }
 
+static uint32_t js_string_obj_get_length(JSContext *ctx,
+                                         JSValueConst obj)
+{
+    JSObject *p;
+    JSString *p1;
+    uint32_t len = 0;
+
+    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */
+    p = JS_VALUE_GET_OBJ(obj);
+    if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {
+        p1 = JS_VALUE_GET_STRING(p->u.object_data);
+        len = p1->len;
+    }
+    return len;
+}
+
+static int js_string_get_own_property_names(JSContext *ctx,
+                                            JSPropertyEnum **ptab,
+                                            uint32_t *plen,
+                                            JSValueConst obj)
+{
+    JSPropertyEnum *tab;
+    uint32_t len, i;
+
+    len = js_string_obj_get_length(ctx, obj);
+    tab = NULL;
+    if (len > 0) {
+        /* do not allocate 0 bytes */
+        tab = js_malloc(ctx, sizeof(JSPropertyEnum) * len);
+        if (!tab)
+            return -1;
+        for(i = 0; i < len; i++) {
+            tab[i].atom = __JS_AtomFromUInt32(i);
+        }
+    }
+    *ptab = tab;
+    *plen = len;
+    return 0;
+}
+
 static int js_string_define_own_property(JSContext *ctx,
                                          JSValueConst this_obj,
                                          JSAtom prop, JSValueConst val,
@@ -40094,31 +37601,14 @@ static int js_string_define_own_property(JSContext *ctx,
                                          JSValueConst setter, int flags)
 {
     uint32_t idx;
-    JSObject *p;
-    JSString *p1, *p2;
-    
+
     if (__JS_AtomIsTaggedInt(prop)) {
         idx = __JS_AtomToUInt32(prop);
-        p = JS_VALUE_GET_OBJ(this_obj);
-        if (JS_VALUE_GET_TAG(p->u.object_data) != JS_TAG_STRING)
-            goto def;
-        p1 = JS_VALUE_GET_STRING(p->u.object_data);
-        if (idx >= p1->len)
+        if (idx >= js_string_obj_get_length(ctx, this_obj))
             goto def;
         if (!check_define_prop_flags(JS_PROP_ENUMERABLE, flags))
-            goto fail;
-        /* check that the same value is configured */
-        if (flags & JS_PROP_HAS_VALUE) {
-            if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)
-                goto fail;
-            p2 = JS_VALUE_GET_STRING(val);
-            if (p2->len != 1)
-                goto fail;
-            if (string_get(p1, idx) != string_get(p2, 0)) {
-            fail:
-                return JS_ThrowTypeErrorOrFalse(ctx, flags, "property is not configurable");
-            }
-        }
+            return JS_ThrowTypeErrorOrFalse(ctx, flags, "property is not configurable");
+        /* XXX: should check if same value is configured */
         return TRUE;
     } else {
     def:
@@ -40143,6 +37633,7 @@ static int js_string_delete_property(JSContext *ctx,
 
 static const JSClassExoticMethods js_string_exotic_methods = {
     .get_own_property = js_string_get_own_property,
+    .get_own_property_names = js_string_get_own_property_names,
     .define_own_property = js_string_define_own_property,
     .delete_property = js_string_delete_property,
 };
@@ -40467,14 +37958,12 @@ static int string_indexof(JSString *p1, JSString *p2, int from)
     return -1;
 }
 
-static int64_t string_advance_index(JSString *p, int64_t index, BOOL unicode)
+static int string_advance_index(JSString *p, int index, BOOL unicode)
 {
-    if (!unicode || index >= p->len || !p->is_wide_char) {
+    if (!unicode || (unsigned)index >= p->len || !p->is_wide_char) {
         index++;
     } else {
-        int index32 = (int)index;
-        string_getc(p, &index32);
-        index = index32;
+        string_getc(p, &index);
     }
     return index;
 }
@@ -40571,25 +38060,22 @@ static JSValue js_string_includes(JSContext *ctx, JSValueConst this_val,
     p1 = JS_VALUE_GET_STRING(v);
     len = p->len;
     v_len = p1->len;
-    pos = (magic == 2) ? len : 0;
+    pos = (magic & 2) ? len : 0;
     if (argc > 1 && !JS_IsUndefined(argv[1])) {
         if (JS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0))
             goto fail;
     }
     len -= v_len;
-    ret = 0;
-    if (magic == 0) {
-        start = pos;
-        stop = len;
-    } else {
-        if (magic == 1) {
-            if (pos > len)
-                goto done;
-        } else {
-            pos -= v_len;
-        }
+    start = pos;
+    stop = len;
+    if (magic & 1) {
+        stop = pos;
+    }
+    if (magic & 2) {
+        pos -= v_len;
         start = stop = pos;
     }
+    ret = 0;
     if (start >= 0 && start <= stop) {
         for (i = start;; i++) {
             if (!string_cmp(p, p1, i, 0, v_len)) {
@@ -40600,7 +38086,6 @@ static JSValue js_string_includes(JSContext *ctx, JSValueConst this_val,
                 break;
         }
     }
- done:
     JS_FreeValue(ctx, str);
     JS_FreeValue(ctx, v);
     return JS_NewBool(ctx, ret);
@@ -40611,35 +38096,6 @@ fail:
     return JS_EXCEPTION;
 }
 
-static int check_regexp_g_flag(JSContext *ctx, JSValueConst regexp)
-{
-    int ret;
-    JSValue flags;
-    
-    ret = js_is_regexp(ctx, regexp);
-    if (ret < 0)
-        return -1;
-    if (ret) {
-        flags = JS_GetProperty(ctx, regexp, JS_ATOM_flags);
-        if (JS_IsException(flags))
-            return -1;
-        if (JS_IsUndefined(flags) || JS_IsNull(flags)) {
-            JS_ThrowTypeError(ctx, "cannot convert to object");
-            return -1;
-        }
-        flags = JS_ToStringFree(ctx, flags);
-        if (JS_IsException(flags))
-            return -1;
-        ret = string_indexof_char(JS_VALUE_GET_STRING(flags), 'g', 0);
-        JS_FreeValue(ctx, flags);
-        if (ret < 0) {
-            JS_ThrowTypeError(ctx, "regexp must have the 'g' flag");
-            return -1;
-        }
-    }
-    return 0;
-}
-
 static JSValue js_string_match(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv, int atom)
 {
@@ -40657,9 +38113,31 @@ static JSValue js_string_match(JSContext *ctx, JSValueConst this_val,
         if (JS_IsException(matcher))
             return JS_EXCEPTION;
         if (atom == JS_ATOM_Symbol_matchAll) {
-            if (check_regexp_g_flag(ctx, regexp) < 0) {
-                JS_FreeValue(ctx, matcher);
-                return JS_EXCEPTION;
+            int ret;
+            JSValue flags;
+
+            ret = js_is_regexp(ctx, regexp);
+            if (ret < 0)
+                goto fail1;
+            if (ret) {
+                flags = JS_GetProperty(ctx, regexp, JS_ATOM_flags);
+                if (JS_IsException(flags))
+                    goto fail1;
+                if (JS_IsUndefined(flags) || JS_IsNull(flags)) {
+                    JS_ThrowTypeError(ctx, "cannot convert to object");
+                    goto fail1;
+                }
+                flags = JS_ToStringFree(ctx, flags);
+                if (JS_IsException(flags))
+                    goto fail1;
+                ret = string_indexof_char(JS_VALUE_GET_STRING(flags), 'g', 0);
+                JS_FreeValue(ctx, flags);
+                if (ret < 0) {
+                    JS_ThrowTypeError(ctx, "regexp must have the 'g' flag");
+                fail1:
+                    JS_FreeValue(ctx, matcher);
+                    return JS_EXCEPTION;
+                }
             }
         }
         if (!JS_IsUndefined(matcher) && !JS_IsNull(matcher)) {
@@ -40676,7 +38154,7 @@ static JSValue js_string_match(JSContext *ctx, JSValueConst this_val,
         str = JS_NewString(ctx, "g");
         if (JS_IsException(str))
             goto fail;
-        args[args_len++] = (JSValueConst)str;
+        args[args_len++] = str;
     }
     rx = JS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
     JS_FreeValue(ctx, str);
@@ -40746,17 +38224,15 @@ static JSValue js_string___GetSubstitution(JSContext *ctx, JSValueConst this_val
             string_buffer_concat(b, sp, position + matched_len, sp->len);
         } else if (c >= '0' && c <= '9') {
             k = c - '0';
-            if (j < len) {
-                c1 = string_get(rp, j);
-                if (c1 >= '0' && c1 <= '9') {
-                    /* This behavior is specified in ES6 and refined in ECMA 2019 */
-                    /* ECMA 2019 does not have the extra test, but
-                       Test262 S15.5.4.11_A3_T1..3 require this behavior */
-                    k1 = k * 10 + c1 - '0';
-                    if (k1 >= 1 && k1 < captures_len) {
-                        k = k1;
-                        j++;
-                    }
+            c1 = string_get(rp, j);
+            if (c1 >= '0' && c1 <= '9') {
+                /* This behavior is specified in ES6 and refined in ECMA 2019 */
+                /* ECMA 2019 does not have the extra test, but
+                   Test262 S15.5.4.11_A3_T1..3 require this behavior */
+                k1 = k * 10 + c1 - '0';
+                if (k1 >= 1 && k1 < captures_len) {
+                    k = k1;
+                    j++;
                 }
             }
             if (k >= 1 && k < captures_len) {
@@ -40799,8 +38275,7 @@ exception:
 }
 
 static JSValue js_string_replace(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv,
-                                 int is_replaceAll)
+                                 int argc, JSValueConst *argv)
 {
     // replace(rx, rep)
     JSValueConst O = this_val, searchValue = argv[0], replaceValue = argv[1];
@@ -40808,8 +38283,7 @@ static JSValue js_string_replace(JSContext *ctx, JSValueConst this_val,
     JSValue str, search_str, replaceValue_str, repl_str;
     JSString *sp, *searchp;
     StringBuffer b_s, *b = &b_s;
-    int pos, functionalReplace, endOfLastMatch;
-    BOOL is_first;
+    int pos, functionalReplace;
 
     if (JS_IsUndefined(O) || JS_IsNull(O))
         return JS_ThrowTypeError(ctx, "cannot convert to object");
@@ -40820,14 +38294,10 @@ static JSValue js_string_replace(JSContext *ctx, JSValueConst this_val,
 
     if (!JS_IsUndefined(searchValue) && !JS_IsNull(searchValue)) {
         JSValue replacer;
-        if (is_replaceAll) {
-            if (check_regexp_g_flag(ctx, searchValue) < 0)
-                return JS_EXCEPTION;
-        }
         replacer = JS_GetProperty(ctx, searchValue, JS_ATOM_Symbol_replace);
         if (JS_IsException(replacer))
             return JS_EXCEPTION;
-        if (!JS_IsUndefined(replacer) && !JS_IsNull(replacer)) {
+        if (!JS_IsUndefined(replacer)) {
             args[0] = O;
             args[1] = replaceValue;
             return JS_CallFree(ctx, replacer, searchValue, 2, args);
@@ -40850,54 +38320,34 @@ static JSValue js_string_replace(JSContext *ctx, JSValueConst this_val,
 
     sp = JS_VALUE_GET_STRING(str);
     searchp = JS_VALUE_GET_STRING(search_str);
-    endOfLastMatch = 0;
-    is_first = TRUE;
-    for(;;) {
-        if (unlikely(searchp->len == 0)) {
-            if (is_first)
-                pos = 0;
-            else if (endOfLastMatch >= sp->len)
-                pos = -1;
-            else
-                pos = endOfLastMatch + 1;
-        } else {
-            pos = string_indexof(sp, searchp, endOfLastMatch);
-        }
-        if (pos < 0) {
-            if (is_first) {
-                string_buffer_free(b);
-                JS_FreeValue(ctx, search_str);
-                JS_FreeValue(ctx, replaceValue_str);
-                return str;
-            } else {
-                break;
-            }
-        }
-        if (functionalReplace) {
-            args[0] = search_str;
-            args[1] = JS_NewInt32(ctx, pos);
-            args[2] = str;
-            repl_str = JS_ToStringFree(ctx, JS_Call(ctx, replaceValue, JS_UNDEFINED, 3, args));
-        } else {
-            args[0] = search_str;
-            args[1] = str;
-            args[2] = JS_NewInt32(ctx, pos);
-            args[3] = JS_UNDEFINED;
-            args[4] = JS_UNDEFINED;
-            args[5] = replaceValue_str;
-            repl_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);
-        }
-        if (JS_IsException(repl_str))
-            goto exception;
-        
-        string_buffer_concat(b, sp, endOfLastMatch, pos);
-        string_buffer_concat_value_free(b, repl_str);
-        endOfLastMatch = pos + searchp->len;
-        is_first = FALSE;
-        if (!is_replaceAll)
-            break;
+
+    pos = string_indexof(sp, searchp, 0);
+    if (pos < 0) {
+        string_buffer_free(b);
+        JS_FreeValue(ctx, search_str);
+        JS_FreeValue(ctx, replaceValue_str);
+        return str;
     }
-    string_buffer_concat(b, sp, endOfLastMatch, sp->len);
+    if (functionalReplace) {
+        args[0] = search_str;
+        args[1] = JS_NewInt32(ctx, pos);
+        args[2] = str;
+        repl_str = JS_ToStringFree(ctx, JS_Call(ctx, replaceValue, JS_UNDEFINED, 3, args));
+    } else {
+        args[0] = search_str;
+        args[1] = str;
+        args[2] = JS_NewInt32(ctx, pos);
+        args[3] = JS_UNDEFINED;
+        args[4] = JS_UNDEFINED;
+        args[5] = replaceValue_str;
+        repl_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);
+    }
+    if (JS_IsException(repl_str))
+        goto exception;
+
+    string_buffer_concat(b, sp, 0, pos);
+    string_buffer_concat_value_free(b, repl_str);
+    string_buffer_concat(b, sp, pos + searchp->len, sp->len);
     JS_FreeValue(ctx, search_str);
     JS_FreeValue(ctx, replaceValue_str);
     JS_FreeValue(ctx, str);
@@ -41108,6 +38558,10 @@ static JSValue js_string_pad(JSContext *ctx, JSValueConst this_val,
     len = p->len;
     if (len >= n)
         return str;
+    if (n > JS_STRING_LEN_MAX) {
+        JS_ThrowInternalError(ctx, "string too long");
+        goto fail2;
+    }
     if (argc > 1 && !JS_IsUndefined(argv[1])) {
         v = JS_ToString(ctx, argv[1]);
         if (JS_IsException(v))
@@ -41122,10 +38576,6 @@ static JSValue js_string_pad(JSContext *ctx, JSValueConst this_val,
             p1 = NULL;
         }
     }
-    if (n > JS_STRING_LEN_MAX) {
-        JS_ThrowInternalError(ctx, "string too long");
-        goto fail2;
-    }
     if (string_buffer_init(ctx, b, n))
         goto fail3;
     n -= len;
@@ -41642,8 +39092,7 @@ static const JSCFunctionListEntry js_string_proto_funcs[] = {
     JS_CFUNC_DEF("substr", 2, js_string_substr ),
     JS_CFUNC_DEF("slice", 2, js_string_slice ),
     JS_CFUNC_DEF("repeat", 1, js_string_repeat ),
-    JS_CFUNC_MAGIC_DEF("replace", 2, js_string_replace, 0 ),
-    JS_CFUNC_MAGIC_DEF("replaceAll", 2, js_string_replace, 1 ),
+    JS_CFUNC_DEF("replace", 2, js_string_replace ),
     JS_CFUNC_MAGIC_DEF("padEnd", 1, js_string_pad, 1 ),
     JS_CFUNC_MAGIC_DEF("padStart", 1, js_string_pad, 0 ),
     JS_CFUNC_MAGIC_DEF("trim", 0, js_string_trim, 3 ),
@@ -41725,6 +39174,351 @@ static double js_fmax(double a, double b)
     }
 }
 
+#ifdef CONFIG_BIGNUM
+
+enum {
+    MATH_OP_ABS,
+    MATH_OP_FLOOR,
+    MATH_OP_CEIL,
+    MATH_OP_ROUND,
+    MATH_OP_TRUNC,
+    MATH_OP_SQRT,
+    MATH_OP_FPROUND,
+    MATH_OP_ACOS,
+    MATH_OP_ASIN,
+    MATH_OP_ATAN,
+    MATH_OP_ATAN2,
+    MATH_OP_COS,
+    MATH_OP_EXP,
+    MATH_OP_LOG,
+    MATH_OP_POW,
+    MATH_OP_SIN,
+    MATH_OP_TAN,
+    MATH_OP_FMOD,
+    MATH_OP_REM,
+    MATH_OP_SIGN,
+
+    MATH_OP_ADD,
+    MATH_OP_SUB,
+    MATH_OP_MUL,
+    MATH_OP_DIV,
+};
+
+static JSValue js_math_fop(JSContext *ctx, JSValueConst this_val,
+                           int argc, JSValueConst *argv, int magic)
+{
+    bf_t a_s, *a, r_s, *r = &r_s;
+    BOOL is_float;
+    JSFloatEnv *fe;
+    int rnd_mode;
+    JSValue op1;
+
+    op1 = JS_ToNumber(ctx, argv[0]);
+    if (JS_IsException(op1))
+        return op1;
+    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+    fe = &ctx->fp_env;
+    if (argc > 1) {
+        fe = JS_GetOpaque2(ctx, argv[1], JS_CLASS_FLOAT_ENV);
+        if (!fe) {
+            if (a == &a_s)
+                bf_delete(a);
+            JS_FreeValue(ctx, op1);
+            return JS_EXCEPTION;
+        }
+    }
+
+    bf_init(ctx->bf_ctx, r);
+    switch (magic) {
+    case MATH_OP_ABS:
+        bf_set(r, a);
+        r->sign = 0;
+        break;
+    case MATH_OP_FLOOR:
+        rnd_mode = BF_RNDD;
+        goto rint;
+    case MATH_OP_CEIL:
+        rnd_mode = BF_RNDU;
+        goto rint;
+    case MATH_OP_ROUND:
+        rnd_mode = BF_RNDNU;
+        goto rint;
+    case MATH_OP_TRUNC:
+        rnd_mode = BF_RNDZ;
+    rint:
+        bf_set(r, a);
+        fe->status |= bf_rint(r, fe->prec,
+                              (fe->flags & ~BF_RND_MASK) | rnd_mode);
+        break;
+    case MATH_OP_SQRT:
+        fe->status |= bf_sqrt(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_FPROUND:
+        bf_set(r, a);
+        fe->status |= bf_round(r, fe->prec, fe->flags);
+        break;
+    case MATH_OP_ACOS:
+        fe->status |= bf_acos(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_ASIN:
+        fe->status |= bf_asin(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_ATAN:
+        fe->status |= bf_atan(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_COS:
+        fe->status |= bf_cos(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_EXP:
+        fe->status |= bf_exp(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_LOG:
+        fe->status |= bf_log(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_SIN:
+        fe->status |= bf_sin(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_TAN:
+        fe->status |= bf_tan(r, a, fe->prec, fe->flags);
+        break;
+    case MATH_OP_SIGN:
+        if (bf_is_nan(a) || bf_is_zero(a)) {
+            bf_set(r, a);
+        } else {
+            bf_set_si(r, 1 - 2 * a->sign);
+        }
+        break;
+    default:
+        abort();
+    }
+    if (a == &a_s)
+        bf_delete(a);
+    JS_FreeValue(ctx, op1);
+    return JS_NewBigFloat(ctx, r);
+}
+
+static JSValue js_math_fop2(JSContext *ctx, JSValueConst this_val,
+                            int argc, JSValueConst *argv, int magic)
+{
+    bf_t a_s, *a, b_s, *b, r_s, *r = &r_s;
+    BOOL is_float;
+    JSFloatEnv *fe;
+    JSValue op1, op2;
+
+    op1 = JS_ToNumber(ctx, argv[0]);
+    if (JS_IsException(op1))
+        return op1;
+    op2 = JS_ToNumber(ctx, argv[1]);
+    if (JS_IsException(op2)) {
+        JS_FreeValue(ctx, op1);
+        return op2;
+    }
+    a = JS_ToBigFloat(ctx, &is_float, &a_s, op1);
+    b = JS_ToBigFloat(ctx, &is_float, &b_s, op2);
+    fe = &ctx->fp_env;
+    if (argc > 2) {
+        fe = JS_GetOpaque2(ctx, argv[2], JS_CLASS_FLOAT_ENV);
+        if (!fe) {
+            if (a == &a_s)
+                bf_delete(a);
+            if (b == &b_s)
+                bf_delete(b);
+            JS_FreeValue(ctx, op1);
+            JS_FreeValue(ctx, op2);
+            return JS_EXCEPTION;
+        }
+    }
+
+    bf_init(ctx->bf_ctx, r);
+    switch (magic) {
+    case MATH_OP_ATAN2:
+        fe->status |= bf_atan2(r, a, b, fe->prec, fe->flags);
+        break;
+    case MATH_OP_POW:
+        fe->status |= bf_pow(r, a, b, fe->prec, fe->flags | BF_POW_JS_QUICKS);
+        break;
+    case MATH_OP_FMOD:
+        fe->status |= bf_fmod(r, a, b, fe->prec, fe->flags);
+        break;
+    case MATH_OP_REM:
+        fe->status |= bf_remainder(r, a, b, fe->prec, fe->flags);
+        break;
+    case MATH_OP_ADD:
+        fe->status |= bf_add(r, a, b, fe->prec, fe->flags);
+        break;
+    case MATH_OP_SUB:
+        fe->status |= bf_sub(r, a, b, fe->prec, fe->flags);
+        break;
+    case MATH_OP_MUL:
+        fe->status |= bf_mul(r, a, b, fe->prec, fe->flags);
+        break;
+    case MATH_OP_DIV:
+        fe->status |= bf_div(r, a, b, fe->prec, fe->flags);
+        break;
+    default:
+        abort();
+    }
+    if (a == &a_s)
+        bf_delete(a);
+    if (b == &b_s)
+        bf_delete(b);
+    JS_FreeValue(ctx, op1);
+    JS_FreeValue(ctx, op2);
+    return JS_NewBigFloat(ctx, r);
+}
+
+static JSValue js_math_min_max(JSContext *ctx, JSValueConst this_val,
+                               int argc, JSValueConst *argv, int magic)
+{
+    BOOL is_max = magic;
+    JSValue val, ret;
+    int i;
+    uint32_t tag;
+
+    if (unlikely(argc == 0)) {
+        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
+    }
+
+    tag = JS_VALUE_GET_TAG(argv[0]);
+    if (tag == JS_TAG_INT) {
+        int a1, r1 = JS_VALUE_GET_INT(argv[0]);
+        for(i = 1; i < argc; i++) {
+            tag = JS_VALUE_GET_TAG(argv[i]);
+            if (tag != JS_TAG_INT) {
+                ret = JS_NewInt32(ctx, r1);
+                goto generic_case;
+            }
+            a1 = JS_VALUE_GET_INT(argv[i]);
+            if (is_max)
+                r1 = max_int(r1, a1);
+            else
+                r1 = min_int(r1, a1);
+        }
+        ret = JS_NewInt32(ctx, r1);
+    } else {
+        ret = JS_ToNumber(ctx, argv[0]);
+        if (JS_IsException(ret))
+            return ret;
+        i = 1;
+    generic_case:
+        for(; i < argc; i++) {
+            val = JS_ToNumber(ctx, argv[i]);
+            if (JS_IsException(val)) {
+                JS_FreeValue(ctx, ret);
+                return val;
+            }
+            if (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(ret)) &&
+                JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(val))) {
+                double r, a;
+                r = JS_VALUE_GET_FLOAT64(ret);
+                a = JS_VALUE_GET_FLOAT64(val);
+                if (!isnan(r)) {
+                    if (isnan(a)) {
+                        r = a;
+                    } else {
+                        if (is_max)
+                            r = js_fmax(r, a);
+                        else
+                            r = js_fmin(r, a);
+                    }
+                    ret = __JS_NewFloat64(ctx, r);
+                }
+            } else {
+                bf_t a_s, *a, r_s, *r;
+                BOOL is_float;
+                int res;
+
+                r = JS_ToBigFloat(ctx, &is_float, &r_s, ret);
+                if (!bf_is_nan(r)) {
+                    a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
+                    res = bf_cmp_full(a, r);
+                    if (is_max)
+                        res = -res;
+                    if (bf_is_nan(a) || res < 0) {
+                        JS_FreeValue(ctx, ret);
+                        ret = JS_DupValue(ctx, val);
+                    }
+                    if (a == &a_s)
+                        bf_delete(a);
+                }
+                if (r == &r_s)
+                    bf_delete(r);
+            }
+        }
+    }
+    return ret;
+}
+
+static JSValue js_math_abs(JSContext *ctx, JSValueConst this_val,
+                           int argc, JSValueConst *argv)
+{
+    JSValue val;
+    uint32_t tag;
+
+    val = JS_ToNumeric(ctx, argv[0]);
+    tag = JS_VALUE_GET_NORM_TAG(val);
+    switch(tag) {
+    case JS_TAG_INT:
+        if (JS_VALUE_GET_INT(val) < 0)
+            val = JS_NewInt64(ctx, -(int64_t)JS_VALUE_GET_INT(val));
+        break;
+    case JS_TAG_FLOAT64:
+        val = __JS_NewFloat64(ctx, fabs(JS_VALUE_GET_FLOAT64(val)));
+        break;
+    case JS_TAG_BIG_FLOAT:
+    case JS_TAG_BIG_INT:
+        {
+            JSBigFloat *p = JS_VALUE_GET_PTR(val);
+            bf_t r_s, *r = &r_s;
+            bf_init(ctx->bf_ctx, r);
+            bf_set(r, &p->num);
+            r->sign = 0;
+            JS_FreeValue(ctx, val);
+            if (tag == JS_TAG_BIG_FLOAT)
+                val = JS_NewBigFloat(ctx, r);
+            else
+                val = JS_NewBigInt2(ctx, r, TRUE);
+        }
+        break;
+    default:
+        break;
+    }
+    return val;
+}
+
+#if 0
+/* XXX: should give exact rounding */
+/* XXX: correct NaN/Infinity handling */
+static JSValue js_math_hypot(JSContext *ctx, JSValueConst this_val,
+                             int argc, JSValueConst *argv)
+{
+    bf_t a_s, *a, r_s, *r = &r_s, r2_s, *r2 = &r2_s;
+    JSValue val;
+    int i;
+    BOOL is_float;
+
+    bf_init(ctx->bf_ctx, r);
+    bf_set_si(r, 0);
+    for(i = 0; i < argc; i++) {
+        val = JS_ToNumber(ctx, argv[i]);
+        if (JS_IsException(val)) {
+            bf_delete(r);
+            return val;
+        }
+        a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
+        bf_add(r, r, a, ctx->fp_env.prec, ctx->fp_env.flags);
+        if (a == &a_s)
+            bf_delete(a);
+    }
+    bf_init(ctx->bf_ctx, r2);
+    bf_sqrt(r2, r, ctx->fp_env.prec, ctx->fp_env.flags);
+    bf_delete(r);
+    return JS_NewBigFloat(ctx, r2);
+}
+#endif
+
+#else
+
 static JSValue js_math_min_max(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv, int magic)
 {
@@ -41734,7 +39528,11 @@ static JSValue js_math_min_max(JSContext *ctx, JSValueConst this_val,
     uint32_t tag;
 
     if (unlikely(argc == 0)) {
+#ifdef _MSC_VER
+        return __JS_NewFloat64(ctx, is_max ? -INFINITY : INFINITY);
+#else
         return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
+#endif
     }
 
     tag = JS_VALUE_GET_TAG(argv[0]);
@@ -41778,6 +39576,8 @@ static JSValue js_math_min_max(JSContext *ctx, JSValueConst this_val,
     }
 }
 
+#endif /* !CONFIG_BIGNUM */
+
 static double js_math_sign(double a)
 {
     if (isnan(a) || a == 0.0)
@@ -41819,23 +39619,24 @@ static double js_math_round(double a)
 static JSValue js_math_hypot(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
 {
-    double r, a;
+    double r, a, b;
     int i;
 
-    r = 0;
-    if (argc > 0) {
-        if (JS_ToFloat64(ctx, &r, argv[0]))
+    if (argc == 2) {
+        /* use the more precise built-in function when possible */
+        if (JS_ToFloat64(ctx, &a, argv[0]))
             return JS_EXCEPTION;
-        if (argc == 1) {
-            r = fabs(r);
-        } else {
-            /* use the built-in function to minimize precision loss */
-            for (i = 1; i < argc; i++) {
-                if (JS_ToFloat64(ctx, &a, argv[i]))
-                    return JS_EXCEPTION;
-                r = hypot(r, a);
-            }
+        if (JS_ToFloat64(ctx, &b, argv[1]))
+            return JS_EXCEPTION;
+        r = hypot(a, b);
+    } else {
+        r = 0;
+        for(i = 0; i < argc; i++) {
+            if (JS_ToFloat64(ctx, &a, argv[i]))
+                return JS_EXCEPTION;
+            r += a;
         }
+        r = sqrt(r);
     }
     return JS_NewFloat64(ctx, r);
 }
@@ -41906,12 +39707,19 @@ static JSValue js_math_random(JSContext *ctx, JSValueConst this_val,
     return __JS_NewFloat64(ctx, u.d - 1.0);
 }
 
+double js_math_floor(double value) { return floor(value); }
+double js_math_ceil(double value) { return ceil(value); }
+
 static const JSCFunctionListEntry js_math_funcs[] = {
     JS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0 ),
     JS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1 ),
+#ifdef CONFIG_BIGNUM
+    JS_CFUNC_DEF("abs", 1, js_math_abs ),
+#else
     JS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs ),
-    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor ),
-    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil ),
+#endif
+    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, js_math_floor ),
+    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, js_math_ceil ),
     JS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round ),
     JS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt ),
 
@@ -41986,7 +39794,7 @@ static JSValue js___date_clock(JSContext *ctx, JSValueConst this_val,
 }
 
 /* OS dependent. d = argv[0] is in ms from 1970. Return the difference
-   between UTC time and local time 'd' in minutes */
+   between local time and UTC time 'd' in minutes */
 static int getTimezoneOffset(int64_t time) {
 #if defined(_WIN32)
     /* XXX: TODO */
@@ -42036,20 +39844,6 @@ static JSValue js___date_getTimezoneOffset(JSContext *ctx, JSValueConst this_val
         return JS_NewInt32(ctx, getTimezoneOffset((int64_t)dd));
 }
 
-static JSValue js_get_prototype_from_ctor(JSContext *ctx, JSValueConst ctor,
-                                          JSValueConst def_proto)
-{
-    JSValue proto;
-    proto = JS_GetProperty(ctx, ctor, JS_ATOM_prototype);
-    if (JS_IsException(proto))
-        return proto;
-    if (!JS_IsObject(proto)) {
-        JS_FreeValue(ctx, proto);
-        proto = JS_DupValue(ctx, def_proto);
-    }
-    return proto;
-}
-
 /* create a new date object */
 static JSValue js___date_create(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
@@ -42419,14 +40213,13 @@ static JSValue js_regexp_get_flag(JSContext *ctx, JSValueConst this_val, int mas
     if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
         return JS_ThrowTypeErrorNotAnObject(ctx);
 
-    re = js_get_regexp(ctx, this_val, FALSE);
-    if (!re) {
-        if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))
-            return JS_UNDEFINED;
-        else
-            return JS_ThrowTypeErrorInvalidClass(ctx, JS_CLASS_REGEXP);
-    }
-    
+    if (js_same_value(ctx, this_val, ctx->class_proto[JS_CLASS_REGEXP]))
+        return JS_UNDEFINED;
+
+    re = js_get_regexp(ctx, this_val, TRUE);
+    if (!re)
+        return JS_EXCEPTION;
+
     flags = lre_get_flags(re->bytecode->u.str8);
     return JS_NewBool(ctx, (flags & mask) != 0);
 }
@@ -42503,7 +40296,7 @@ fail:
 BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size)
 {
     JSContext *ctx = opaque;
-    return js_check_stack_overflow(ctx->rt, alloca_size);
+    return js_check_stack_overflow(ctx, alloca_size);
 }
 
 void *lre_realloc(void *opaque, void *ptr, size_t size)
@@ -42585,11 +40378,14 @@ static JSValue js_regexp_exec(JSContext *ctx, JSValueConst this_val,
         if (JS_IsException(obj))
             goto fail;
         prop_flags = JS_PROP_C_W_E | JS_PROP_THROW;
-        group_name_ptr = lre_get_groupnames(re_bytecode);
-        if (group_name_ptr) {
+        group_name_ptr = NULL;
+        if (re_flags & LRE_FLAG_NAMED_GROUPS) {
+            uint32_t re_bytecode_len;
             groups = JS_NewObjectProto(ctx, JS_NULL);
             if (JS_IsException(groups))
                 goto fail;
+            re_bytecode_len = get_u32(re_bytecode + 3);
+            group_name_ptr = (char *)(re_bytecode + 7 + re_bytecode_len);
         }
 
         for(i = 0; i < capture_count; i++) {
@@ -42639,7 +40435,7 @@ fail1:
     return JS_EXCEPTION;
 }
 
-/* delete portions of a string that match a given regex */
+/* delete partions of a string that match a given regex */
 static JSValue JS_RegExpDelete(JSContext *ctx, JSValueConst this_val, JSValueConst arg)
 {
     JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
@@ -42838,7 +40634,9 @@ static JSValue js_regexp_Symbol_match(JSContext *ctx, JSValueConst this_val,
                                     JS_GetProperty(ctx, rx, JS_ATOM_lastIndex)) < 0)
                     goto exception;
                 p = JS_VALUE_GET_STRING(S);
-                nextIndex = string_advance_index(p, thisIndex, fullUnicode);
+                nextIndex = thisIndex + 1;
+                if (thisIndex < p->len)
+                    nextIndex = string_advance_index(p, thisIndex, fullUnicode);
                 if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt64(ctx, nextIndex)) < 0)
                     goto exception;
             }
@@ -42927,7 +40725,7 @@ static JSValue js_regexp_string_iterator_next(JSContext *ctx,
             sp = JS_VALUE_GET_STRING(S);
             nextIndex = string_advance_index(sp, thisIndex, it->unicode);
             if (JS_SetProperty(ctx, R, JS_ATOM_lastIndex,
-                               JS_NewInt64(ctx, nextIndex)) < 0)
+                               JS_NewInt32(ctx, nextIndex)) < 0)
                 goto exception;
         }
         JS_FreeValue(ctx, matchStr);
@@ -42980,7 +40778,7 @@ static JSValue js_regexp_Symbol_matchAll(JSContext *ctx, JSValueConst this_val,
                         JS_GetProperty(ctx, R, JS_ATOM_lastIndex)))
         goto exception;
     if (JS_SetProperty(ctx, matcher, JS_ATOM_lastIndex,
-                       JS_NewInt64(ctx, lastIndex)) < 0)
+                       JS_NewInt32(ctx, lastIndex)) < 0)
         goto exception;
     
     iter = JS_NewObjectClass(ctx, JS_CLASS_REGEXP_STRING_ITERATOR);
@@ -43168,7 +40966,7 @@ static JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,
             if (JS_ToLengthFree(ctx, &thisIndex, JS_GetProperty(ctx, rx, JS_ATOM_lastIndex)) < 0)
                 goto exception;
             nextIndex = string_advance_index(sp, thisIndex, fullUnicode);
-            if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt64(ctx, nextIndex)) < 0)
+            if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, JS_NewInt32(ctx, nextIndex)) < 0)
                 goto exception;
         }
     }
@@ -43194,8 +40992,7 @@ static JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,
         tab = JS_NewArray(ctx);
         if (JS_IsException(tab))
             goto exception;
-        if (JS_DefinePropertyValueInt64(ctx, tab, 0, JS_DupValue(ctx, matched),
-                                        JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+        if (JS_SetPropertyInt64(ctx, tab, 0, JS_DupValue(ctx, matched)) < 0)
             goto exception;
         for(n = 1; n < nCaptures; n++) {
             JSValue capN;
@@ -43207,8 +41004,7 @@ static JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,
                 if (JS_IsException(capN))
                     goto exception;
             }
-            if (JS_DefinePropertyValueInt64(ctx, tab, n, capN,
-                                            JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+            if (JS_SetPropertyInt64(ctx, tab, n, capN) < 0)
                 goto exception;
         }
         JS_FreeValue(ctx, namedCaptures);
@@ -43216,12 +41012,12 @@ static JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,
         if (JS_IsException(namedCaptures))
             goto exception;
         if (functionalReplace) {
-            if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_NewInt32(ctx, position), JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+            if (JS_SetPropertyInt64(ctx, tab, n++, JS_NewInt32(ctx, position)) < 0)
                 goto exception;
-            if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_DupValue(ctx, str), JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+            if (JS_SetPropertyInt64(ctx, tab, n++, JS_DupValue(ctx, str)) < 0)
                 goto exception;
             if (!JS_IsUndefined(namedCaptures)) {
-                if (JS_DefinePropertyValueInt64(ctx, tab, n++, JS_DupValue(ctx, namedCaptures), JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+                if (JS_SetPropertyInt64(ctx, tab, n++, JS_DupValue(ctx, namedCaptures)) < 0)
                     goto exception;
             }
             args[0] = JS_UNDEFINED;
@@ -43229,23 +41025,14 @@ static JSValue js_regexp_Symbol_replace(JSContext *ctx, JSValueConst this_val,
             JS_FreeValue(ctx, rep_str);
             rep_str = JS_ToStringFree(ctx, js_function_apply(ctx, rep, 2, args, 0));
         } else {
-            JSValue namedCaptures1;
-            if (!JS_IsUndefined(namedCaptures)) {
-                namedCaptures1 = JS_ToObject(ctx, namedCaptures);
-                if (JS_IsException(namedCaptures1))
-                    goto exception;
-            } else {
-                namedCaptures1 = JS_UNDEFINED;
-            }
             args[0] = matched;
             args[1] = str;
             args[2] = JS_NewInt32(ctx, position);
             args[3] = tab;
-            args[4] = namedCaptures1;
+            args[4] = namedCaptures;
             args[5] = rep_val;
             JS_FreeValue(ctx, rep_str);
             rep_str = js_string___GetSubstitution(ctx, JS_UNDEFINED, 6, args);
-            JS_FreeValue(ctx, namedCaptures1);
         }
         if (JS_IsException(rep_str))
             goto exception;
@@ -43308,10 +41095,8 @@ static JSValue js_regexp_Symbol_search(JSContext *ctx, JSValueConst this_val,
     if (js_same_value(ctx, currentLastIndex, previousLastIndex)) {
         JS_FreeValue(ctx, previousLastIndex);
     } else {
-        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, previousLastIndex) < 0) {
-            previousLastIndex = JS_UNDEFINED;
+        if (JS_SetProperty(ctx, rx, JS_ATOM_lastIndex, previousLastIndex) < 0)
             goto exception;
-        }
     }
     JS_FreeValue(ctx, str);
     JS_FreeValue(ctx, currentLastIndex);
@@ -43416,8 +41201,7 @@ static JSValue js_regexp_Symbol_split(JSContext *ctx, JSValueConst this_val,
                 sub = js_sub_string(ctx, strp, p, q);
                 if (JS_IsException(sub))
                     goto exception;
-                if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub,
-                                                JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+                if (JS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0)
                     goto exception;
                 if (lengthA == lim)
                     goto done;
@@ -43428,7 +41212,7 @@ static JSValue js_regexp_Symbol_split(JSContext *ctx, JSValueConst this_val,
                     sub = JS_ToStringFree(ctx, JS_GetPropertyInt64(ctx, z, i));
                     if (JS_IsException(sub))
                         goto exception;
-                    if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub, JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+                    if (JS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0)
                         goto exception;
                     if (lengthA == lim)
                         goto done;
@@ -43443,7 +41227,7 @@ add_tail:
     sub = js_sub_string(ctx, strp, p, size);
     if (JS_IsException(sub))
         goto exception;
-    if (JS_DefinePropertyValueInt64(ctx, A, lengthA++, sub, JS_PROP_C_W_E | JS_PROP_THROW) < 0)
+    if (JS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0)
         goto exception;
     goto done;
 exception:
@@ -43519,69 +41303,58 @@ void JS_AddIntrinsicRegExp(JSContext *ctx)
 
 /* JSON */
 
-static int json_parse_expect(JSParseState *s, int tok)
-{
-    if (s->token.val != tok) {
-        /* XXX: dump token correctly in all cases */
-        return js_parse_error(s, "expecting '%c'", tok);
-    }
-    return json_next_token(s);
-}
-
+/* XXX: this parser is less strict than the JSON standard because we
+   reuse the Javascript tokenizer. It could be improved by adding a
+   specific JSON parse flag. */
 static JSValue json_parse_value(JSParseState *s)
 {
     JSContext *ctx = s->ctx;
     JSValue val = JS_NULL;
+    BOOL is_neg;
     int ret;
 
     switch(s->token.val) {
     case '{':
         {
-            JSValue prop_val;
-            JSAtom prop_name;
-            
-            if (json_next_token(s))
+            JSValue prop_val, prop_str;
+
+            if (next_token(s))
                 goto fail;
             val = JS_NewObject(ctx);
             if (JS_IsException(val))
                 goto fail;
             if (s->token.val != '}') {
                 for(;;) {
-                    if (s->token.val == TOK_STRING) {
-                        prop_name = JS_ValueToAtom(ctx, s->token.u.str.str);
-                        if (prop_name == JS_ATOM_NULL)
-                            goto fail;
-                    } else if (s->ext_json && s->token.val == TOK_IDENT) {
-                        prop_name = JS_DupAtom(ctx, s->token.u.ident.atom);
-                    } else {
+                    if (s->token.val != TOK_STRING) {
                         js_parse_error(s, "expecting property name");
                         goto fail;
                     }
-                    if (json_next_token(s))
-                        goto fail1;
-                    if (json_parse_expect(s, ':'))
-                        goto fail1;
+                    prop_str = JS_DupValue(ctx, s->token.u.str.str);
+                    if (next_token(s)) {
+                        JS_FreeValue(ctx, prop_str);
+                        goto fail;
+                    }
+                    if (js_parse_expect(s, ':')) {
+                        JS_FreeValue(ctx, prop_str);
+                        goto fail;
+                    }
                     prop_val = json_parse_value(s);
                     if (JS_IsException(prop_val)) {
-                    fail1:
-                        JS_FreeAtom(ctx, prop_name);
+                        JS_FreeValue(ctx, prop_str);
                         goto fail;
                     }
-                    ret = JS_DefinePropertyValue(ctx, val, prop_name,
-                                                 prop_val, JS_PROP_C_W_E);
-                    JS_FreeAtom(ctx, prop_name);
+                    ret = JS_DefinePropertyValueValue(ctx, val, prop_str,
+                                                      prop_val, JS_PROP_C_W_E);
                     if (ret < 0)
                         goto fail;
 
                     if (s->token.val != ',')
                         break;
-                    if (json_next_token(s))
+                    if (next_token(s))
                         goto fail;
-                    if (s->ext_json && s->token.val == '}')
-                        break;
                 }
             }
-            if (json_parse_expect(s, '}'))
+            if (js_parse_expect(s, '}'))
                 goto fail;
         }
         break;
@@ -43590,7 +41363,7 @@ static JSValue json_parse_value(JSParseState *s)
             JSValue el;
             uint32_t idx;
 
-            if (json_next_token(s))
+            if (next_token(s))
                 goto fail;
             val = JS_NewArray(ctx);
             if (JS_IsException(val))
@@ -43606,41 +41379,86 @@ static JSValue json_parse_value(JSParseState *s)
                         goto fail;
                     if (s->token.val != ',')
                         break;
-                    if (json_next_token(s))
+                    if (next_token(s))
                         goto fail;
                     idx++;
-                    if (s->ext_json && s->token.val == ']')
-                        break;
                 }
             }
-            if (json_parse_expect(s, ']'))
+            if (js_parse_expect(s, ']'))
                 goto fail;
         }
         break;
     case TOK_STRING:
         val = JS_DupValue(ctx, s->token.u.str.str);
-        if (json_next_token(s))
+        if (next_token(s))
             goto fail;
         break;
     case TOK_NUMBER:
+        is_neg = 0;
+        goto number;
+    case '-':
+        if (next_token(s))
+            goto fail;
+        if (s->token.val != TOK_NUMBER) {
+            js_parse_error(s, "number expected");
+            goto fail;
+        }
+        is_neg = 1;
+    number:
+#ifdef CONFIG_BIGNUM
+        val = JS_DupValue(ctx, s->token.u.num.val);
+        if (is_neg) {
+            switch(JS_VALUE_GET_NORM_TAG(val)) {
+            case JS_TAG_BIG_INT:
+            case JS_TAG_BIG_FLOAT:
+                {
+                    JSBigFloat *p;
+                    p = JS_VALUE_GET_PTR(val);
+                    bf_neg(&p->num);
+                }
+                break;
+            case JS_TAG_FLOAT64:
+                {
+                    double d;
+                    d = JS_VALUE_GET_FLOAT64(val);
+                    val = __JS_NewFloat64(ctx, -d);
+                }
+                break;
+            default:
+            case JS_TAG_INT:
+                {
+                    int v;
+                    v = JS_VALUE_GET_INT(val);
+                    if (v == 0 && !is_bignum_mode(s->ctx))
+                        val = __JS_NewFloat64(ctx, -0.0);
+                    else
+                        val = JS_NewInt64(ctx, -(int64_t)v);
+                }
+                break;
+            }
+        }
+#else
         val = s->token.u.num.val;
-        if (json_next_token(s))
+        if (is_neg) {
+            double d;
+            JS_ToFloat64(ctx, &d, val);  /* no exception possible */
+            val = JS_NewFloat64(ctx, -d);
+        }
+#endif
+        if (next_token(s))
             goto fail;
         break;
-    case TOK_IDENT:
-        if (s->token.u.ident.atom == JS_ATOM_false ||
-            s->token.u.ident.atom == JS_ATOM_true) {
-            val = JS_NewBool(ctx, (s->token.u.ident.atom == JS_ATOM_true));
-        } else if (s->token.u.ident.atom == JS_ATOM_null) {
-            val = JS_NULL;
-        } else {
-            goto def_token;
-        }
-        if (json_next_token(s))
+    case TOK_FALSE:
+    case TOK_TRUE:
+        val = JS_NewBool(ctx, s->token.val - TOK_FALSE);
+        if (next_token(s))
+            goto fail;
+        break;
+    case TOK_NULL:
+        if (next_token(s))
             goto fail;
         break;
     default:
-    def_token:
         if (s->token.val == TOK_EOF) {
             js_parse_error(s, "unexpected end of input");
         } else {
@@ -43655,15 +41473,15 @@ static JSValue json_parse_value(JSParseState *s)
     return JS_EXCEPTION;
 }
 
-JSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,
-                      const char *filename, int flags)
+JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
+                     const char *filename)
 {
     JSParseState s1, *s = &s1;
-    JSValue val = JS_UNDEFINED;
+    JSValue val;
 
     js_parse_init(ctx, s, buf, buf_len, filename);
-    s->ext_json = ((flags & JS_PARSE_JSON_EXT) != 0);
-    if (json_next_token(s))
+
+    if (next_token(s))
         goto fail;
     val = json_parse_value(s);
     if (JS_IsException(val))
@@ -43674,17 +41492,10 @@ JSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,
     }
     return val;
  fail:
-    JS_FreeValue(ctx, val);
     free_token(s, &s->token);
     return JS_EXCEPTION;
 }
 
-JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
-                     const char *filename)
-{
-    return JS_ParseJSON2(ctx, buf, buf_len, filename, 0); 
-}
-
 static JSValue internalize_json_property(JSContext *ctx, JSValueConst holder,
                                          JSAtom name, JSValueConst reviver)
 {
@@ -43695,7 +41506,7 @@ static JSValue internalize_json_property(JSContext *ctx, JSValueConst holder,
     JSAtom prop;
     JSPropertyEnum *atoms = NULL;
 
-    if (js_check_stack_overflow(ctx->rt, 0)) {
+    if (js_check_stack_overflow(ctx, 0)) {
         return JS_ThrowStackOverflow(ctx);
     }
 
@@ -43803,6 +41614,10 @@ static JSValue JS_ToQuotedStringFree(JSContext *ctx, JSValue val) {
     return r;
 }
 
+#ifdef CONFIG_BIGNUM
+static inline BOOL JS_IsBigInt(JSContext *ctx, JSValueConst v);
+#endif
+
 static JSValue js_json_check(JSContext *ctx, JSONStringifyContext *jsc,
                              JSValueConst holder, JSValue val, JSValueConst key)
 {
@@ -44061,11 +41876,13 @@ exception:
     return -1;
 }
 
-JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
-                         JSValueConst replacer, JSValueConst space0)
+static JSValue js_json_stringify(JSContext *ctx, JSValueConst this_val,
+                                 int argc, JSValueConst *argv)
 {
+    // stringify(val, replacer, space)
     StringBuffer b_s;
     JSONStringifyContext jsc_s, *jsc = &jsc_s;
+    JSValueConst replacer = argv[1];
     JSValue val, v, space, ret, wrapper;
     int res;
     int64_t i, j, n;
@@ -44134,7 +41951,7 @@ JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
             }
         }
     }
-    space = JS_DupValue(ctx, space0);
+    space = JS_DupValue(ctx, argv[2]);
     if (JS_IsObject(space)) {
         JSObject *p = JS_VALUE_GET_OBJ(space);
         if (p->class_id == JS_CLASS_NUMBER) {
@@ -44165,9 +41982,9 @@ JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
     if (JS_IsException(wrapper))
         goto exception;
     if (JS_DefinePropertyValue(ctx, wrapper, JS_ATOM_empty_string,
-                               JS_DupValue(ctx, obj), JS_PROP_C_W_E) < 0)
+                               JS_DupValue(ctx, argv[0]), JS_PROP_C_W_E) < 0)
         goto exception;
-    val = JS_DupValue(ctx, obj);
+    val = JS_DupValue(ctx, argv[0]);
                            
     val = js_json_check(ctx, jsc, wrapper, val, jsc->empty);
     if (JS_IsException(val))
@@ -44195,13 +42012,6 @@ done:
     return ret;
 }
 
-static JSValue js_json_stringify(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    // stringify(val, replacer, space)
-    return JS_JSONStringify(ctx, argv[0], argv[1], argv[2]);
-}
-
 static const JSCFunctionListEntry js_json_funcs[] = {
     JS_CFUNC_DEF("parse", 2, js_json_parse ),
     JS_CFUNC_DEF("stringify", 3, js_json_stringify ),
@@ -44223,7 +42033,7 @@ void JS_AddIntrinsicJSON(JSContext *ctx)
 static JSValue js_reflect_apply(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
 {
-    return js_function_apply(ctx, argv[0], max_int(0, argc - 1), argv + 1, 2);
+    return js_function_apply(ctx, argv[0], max_int(0, argc - 1), argv + 1, 0);
 }
 
 static JSValue js_reflect_construct(JSContext *ctx, JSValueConst this_val,
@@ -44335,7 +42145,7 @@ static JSValue js_reflect_set(JSContext *ctx, JSValueConst this_val,
     atom = JS_ValueToAtom(ctx, prop);
     if (unlikely(atom == JS_ATOM_NULL))
         return JS_EXCEPTION;
-    ret = JS_SetPropertyGeneric(ctx, obj, atom,
+    ret = JS_SetPropertyGeneric(ctx, JS_VALUE_GET_OBJ(obj), atom,
                                 JS_DupValue(ctx, val), receiver, 0);
     JS_FreeAtom(ctx, atom);
     if (ret < 0)
@@ -44379,7 +42189,6 @@ static const JSCFunctionListEntry js_reflect_funcs[] = {
     JS_CFUNC_MAGIC_DEF("preventExtensions", 1, js_object_preventExtensions, 1 ),
     JS_CFUNC_DEF("set", 3, js_reflect_set ),
     JS_CFUNC_DEF("setPrototypeOf", 2, js_reflect_setPrototypeOf ),
-    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "Reflect", JS_PROP_CONFIGURABLE ),
 };
 
 static const JSCFunctionListEntry js_reflect_obj[] = {
@@ -44394,6 +42203,7 @@ static void js_proxy_finalizer(JSRuntime *rt, JSValue val)
     if (s) {
         JS_FreeValueRT(rt, s->target);
         JS_FreeValueRT(rt, s->handler);
+        JS_FreeValueRT(rt, s->proto);
         js_free_rt(rt, s);
     }
 }
@@ -44405,6 +42215,7 @@ static void js_proxy_mark(JSRuntime *rt, JSValueConst val,
     if (s) {
         JS_MarkValue(rt, s->target, mark_func);
         JS_MarkValue(rt, s->handler, mark_func);
+        JS_MarkValue(rt, s->proto, mark_func);
     }
 }
 
@@ -44420,7 +42231,7 @@ static JSProxyData *get_proxy_method(JSContext *ctx, JSValue *pmethod,
     JSValue method;
 
     /* safer to test recursion in all proxy methods */
-    if (js_check_stack_overflow(ctx->rt, 0)) {
+    if (js_check_stack_overflow(ctx, 0)) {
         JS_ThrowStackOverflow(ctx);
         return NULL;
     }
@@ -44439,12 +42250,17 @@ static JSProxyData *get_proxy_method(JSContext *ctx, JSValue *pmethod,
     return s;
 }
 
-static JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj)
+static JSValueConst js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj)
 {
     JSProxyData *s;
-    JSValue method, ret, proto1;
+    JSValue method, ret;
+    JSValueConst proto1;
     int res;
 
+    /* must check for timeout to avoid infinite loop in instanceof */
+    if (js_poll_interrupts(ctx))
+        return JS_EXCEPTION;
+
     s = get_proxy_method(ctx, &method, obj, JS_ATOM_getPrototypeOf);
     if (!s)
         return JS_EXCEPTION;
@@ -44470,13 +42286,13 @@ static JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj)
             return JS_EXCEPTION;
         }
         if (JS_VALUE_GET_OBJ(proto1) != JS_VALUE_GET_OBJ(ret)) {
-            JS_FreeValue(ctx, proto1);
         fail:
             JS_FreeValue(ctx, ret);
             return JS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
         }
-        JS_FreeValue(ctx, proto1);
     }
+    /* store the prototype in the proxy so that its refcount is at least 1 */
+    set_value(ctx, &s->proto, ret);
     return ret;
 }
 
@@ -44484,8 +42300,8 @@ static int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,
                                    JSValueConst proto_val, BOOL throw_flag)
 {
     JSProxyData *s;
-    JSValue method, ret, proto1;
-    JSValueConst args[2];
+    JSValue method, ret;
+    JSValueConst args[2], proto1;
     BOOL res;
     int res2;
 
@@ -44516,11 +42332,9 @@ static int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,
         if (JS_IsException(proto1))
             return -1;
         if (JS_VALUE_GET_OBJ(proto_val) != JS_VALUE_GET_OBJ(proto1)) {
-            JS_FreeValue(ctx, proto1);
             JS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
             return -1;
         }
-        JS_FreeValue(ctx, proto1);
     }
     return TRUE;
 }
@@ -44683,7 +42497,7 @@ static int js_proxy_set(JSContext *ctx, JSValueConst obj, JSAtom atom,
     if (!s)
         return -1;
     if (JS_IsUndefined(method)) {
-        return JS_SetPropertyGeneric(ctx, s->target, atom,
+        return JS_SetPropertyGeneric(ctx, JS_VALUE_GET_OBJ(s->target), atom,
                                      JS_DupValue(ctx, value), receiver,
                                      flags);
     }
@@ -45144,69 +42958,66 @@ static int js_proxy_get_own_property_names(JSContext *ctx,
     return -1;
 }
 
-static JSValue js_proxy_call_constructor(JSContext *ctx, JSValueConst func_obj,
-                                         JSValueConst new_target,
-                                         int argc, JSValueConst *argv)
+static JSValue js_proxy_call(JSContext *ctx, JSValueConst func_obj,
+                             JSValueConst this_obj,
+                             int argc, JSValueConst *argv)
 {
     JSProxyData *s;
     JSValue method, arg_array, ret;
     JSValueConst args[3];
 
-    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_construct);
+    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_apply);
     if (!s)
         return JS_EXCEPTION;
-    if (!JS_IsConstructor(ctx, s->target))
-        return JS_ThrowTypeError(ctx, "not a constructor");
+    if (!s->is_func) {
+        JS_FreeValue(ctx, method);
+        return JS_ThrowTypeError(ctx, "not a function");
+    }
     if (JS_IsUndefined(method))
-        return JS_CallConstructor2(ctx, s->target, new_target, argc, argv);
+        return JS_Call(ctx, s->target, this_obj, argc, argv);
     arg_array = js_create_array(ctx, argc, argv);
     if (JS_IsException(arg_array)) {
         ret = JS_EXCEPTION;
         goto fail;
     }
     args[0] = s->target;
-    args[1] = arg_array;
-    args[2] = new_target;
+    args[1] = this_obj;
+    args[2] = arg_array;
     ret = JS_Call(ctx, method, s->handler, 3, args);
-    if (!JS_IsException(ret) && JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {
-        JS_FreeValue(ctx, ret);
-        ret = JS_ThrowTypeErrorNotAnObject(ctx);
-    }
  fail:
     JS_FreeValue(ctx, method);
     JS_FreeValue(ctx, arg_array);
     return ret;
 }
 
-static JSValue js_proxy_call(JSContext *ctx, JSValueConst func_obj,
-                             JSValueConst this_obj,
-                             int argc, JSValueConst *argv, int flags)
+static JSValue js_proxy_call_constructor(JSContext *ctx, JSValueConst func_obj,
+                                         JSValueConst new_target,
+                                         int argc, JSValueConst *argv)
 {
     JSProxyData *s;
     JSValue method, arg_array, ret;
     JSValueConst args[3];
 
-    if (flags & JS_CALL_FLAG_CONSTRUCTOR)
-        return js_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);
-    
-    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_apply);
+    s = get_proxy_method(ctx, &method, func_obj, JS_ATOM_construct);
     if (!s)
         return JS_EXCEPTION;
-    if (!s->is_func) {
-        JS_FreeValue(ctx, method);
-        return JS_ThrowTypeError(ctx, "not a function");
-    }
+    if (!JS_IsConstructor(ctx, s->target))
+        return JS_ThrowTypeError(ctx, "not a constructor");
     if (JS_IsUndefined(method))
-        return JS_Call(ctx, s->target, this_obj, argc, argv);
+        return JS_CallConstructor2(ctx, s->target, new_target, argc, argv);
     arg_array = js_create_array(ctx, argc, argv);
     if (JS_IsException(arg_array)) {
         ret = JS_EXCEPTION;
         goto fail;
     }
     args[0] = s->target;
-    args[1] = this_obj;
-    args[2] = arg_array;
+    args[1] = arg_array;
+    args[2] = new_target;
     ret = JS_Call(ctx, method, s->handler, 3, args);
+    if (!JS_IsException(ret) && JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {
+        JS_FreeValue(ctx, ret);
+        ret = JS_ThrowTypeErrorNotAnObject(ctx);
+    }
  fail:
     JS_FreeValue(ctx, method);
     JS_FreeValue(ctx, arg_array);
@@ -45247,6 +43058,14 @@ static JSValue js_proxy_constructor(JSContext *ctx, JSValueConst this_val,
     if (JS_VALUE_GET_TAG(target) != JS_TAG_OBJECT ||
         JS_VALUE_GET_TAG(handler) != JS_TAG_OBJECT)
         return JS_ThrowTypeErrorNotAnObject(ctx);
+    s = JS_GetOpaque(target, JS_CLASS_PROXY);
+    if (s && s->is_revoked)
+        goto revoked_proxy;
+    s = JS_GetOpaque(handler, JS_CLASS_PROXY);
+    if (s && s->is_revoked) {
+    revoked_proxy:
+        return JS_ThrowTypeErrorRevokedProxy(ctx);
+    }
 
     obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_PROXY);
     if (JS_IsException(obj))
@@ -45258,6 +43077,7 @@ static JSValue js_proxy_constructor(JSContext *ctx, JSValueConst this_val,
     }
     s->target = JS_DupValue(ctx, target);
     s->handler = JS_DupValue(ctx, handler);
+    s->proto = JS_NULL;
     s->is_func = JS_IsFunction(ctx, target);
     s->is_revoked = FALSE;
     JS_SetOpaque(obj, s);
@@ -45704,7 +43524,7 @@ static JSMapRecord *map_add_record(JSContext *ctx, JSMapState *s,
     } else {
         JS_DupValue(ctx, key);
     }
-    mr->key = (JSValue)key;
+    mr->key = key;
     h = map_hash_key(ctx, key) & (s->hash_size - 1);
     list_add_tail(&mr->hash_link, &s->hash_table[h]);
     list_add_tail(&mr->link, &s->records);
@@ -45926,7 +43746,7 @@ static JSValue js_map_forEach(JSContext *ctx, JSValueConst this_val,
                 args[0] = args[1];
             else
                 args[0] = JS_DupValue(ctx, mr->value);
-            args[2] = (JSValue)this_val;
+            args[2] = this_val;
             ret = JS_Call(ctx, func, this_arg, 3, (JSValueConst *)args);
             JS_FreeValue(ctx, args[0]);
             if (!magic)
@@ -46327,14 +44147,6 @@ static JSValue promise_reaction_job(JSContext *ctx, int argc,
     return res2;
 }
 
-void JS_SetHostPromiseRejectionTracker(JSRuntime *rt,
-                                       JSHostPromiseRejectionTracker *cb,
-                                       void *opaque)
-{
-    rt->host_promise_rejection_tracker = cb;
-    rt->host_promise_rejection_tracker_opaque = opaque;
-}
-
 static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
                                       JSValueConst value, BOOL is_reject)
 {
@@ -46350,14 +44162,7 @@ static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
 #ifdef DUMP_PROMISE
     printf("fulfill_or_reject_promise: is_reject=%d\n", is_reject);
 #endif
-    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
-        JSRuntime *rt = ctx->rt;
-        if (rt->host_promise_rejection_tracker) {
-            rt->host_promise_rejection_tracker(ctx, promise, value, FALSE,
-                                               rt->host_promise_rejection_tracker_opaque);
-        }
-    }
-
+    /* Note: could call HostPromiseRejectTracker */
     list_for_each_safe(el, el1, &s->promise_reactions[is_reject]) {
         rd = list_entry(el, JSPromiseReactionData, link);
         args[0] = rd->resolving_funcs[0];
@@ -46481,8 +44286,7 @@ static void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,
 static JSValue js_promise_resolve_function_call(JSContext *ctx,
                                                 JSValueConst func_obj,
                                                 JSValueConst this_val,
-                                                int argc, JSValueConst *argv,
-                                                int flags)
+                                                int argc, JSValueConst *argv)
 {
     JSObject *p = JS_VALUE_GET_OBJ(func_obj);
     JSPromiseFunctionData *s;
@@ -46764,18 +44568,14 @@ static __exception int remainingElementsCount_add(JSContext *ctx,
     return (remainingElementsCount == 0);
 }
 
-#define PROMISE_MAGIC_all        0
-#define PROMISE_MAGIC_allSettled 1
-#define PROMISE_MAGIC_any        2
-
 static JSValue js_promise_all_resolve_element(JSContext *ctx,
                                               JSValueConst this_val,
                                               int argc, JSValueConst *argv,
                                               int magic,
                                               JSValue *func_data)
 {
-    int resolve_type = magic & 3;
-    int is_reject = magic & 4;
+    int is_allSettled = magic & 1;
+    int is_reject = magic & 2;
     BOOL alreadyCalled = JS_ToBool(ctx, func_data[0]);
     JSValueConst values = func_data[2];
     JSValueConst resolve = func_data[3];
@@ -46789,7 +44589,7 @@ static JSValue js_promise_all_resolve_element(JSContext *ctx,
         return JS_UNDEFINED;
     func_data[0] = JS_NewBool(ctx, TRUE);
 
-    if (resolve_type == PROMISE_MAGIC_allSettled) {
+    if (is_allSettled) {
         JSValue str;
         
         obj = JS_NewObject(ctx);
@@ -46821,16 +44621,7 @@ static JSValue js_promise_all_resolve_element(JSContext *ctx,
     if (is_zero < 0)
         return JS_EXCEPTION;
     if (is_zero) {
-        if (resolve_type == PROMISE_MAGIC_any) {
-            JSValue error;
-            error = js_aggregate_error_constructor(ctx, values);
-            if (JS_IsException(error))
-                return JS_EXCEPTION;
-            ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&error);
-            JS_FreeValue(ctx, error);
-        } else {
-            ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&values);
-        }
+        ret = JS_Call(ctx, resolve, JS_UNDEFINED, 1, (JSValueConst *)&values);
         if (JS_IsException(ret))
             return ret;
         JS_FreeValue(ctx, ret);
@@ -46842,23 +44633,19 @@ static JSValue js_promise_all_resolve_element(JSContext *ctx,
 static JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv, int magic)
 {
-    JSValue result_promise, resolving_funcs[2], item, next_promise, ret;
+    JSValue result_promise, resolving_funcs[2], iter, item, next_promise, ret;
     JSValue next_method = JS_UNDEFINED, values = JS_UNDEFINED;
     JSValue resolve_element_env = JS_UNDEFINED, resolve_element, reject_element;
-    JSValue promise_resolve = JS_UNDEFINED, iter = JS_UNDEFINED;
+    JSValue promise_resolve = JS_UNDEFINED;
     JSValueConst then_args[2], resolve_element_data[5];
-    BOOL done;
-    int index, is_zero, is_promise_any = (magic == PROMISE_MAGIC_any);
+    BOOL done, is_allSettled = magic;
+    int index, is_zero;
     
     if (!JS_IsObject(this_val))
         return JS_ThrowTypeErrorNotAnObject(ctx);
     result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
     if (JS_IsException(result_promise))
         return result_promise;
-    promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);
-    if (JS_IsException(promise_resolve) ||
-        check_function(ctx, promise_resolve))
-        goto fail_reject;
     iter = JS_GetIterator(ctx, argv[0], FALSE);
     if (JS_IsException(iter)) {
         JSValue error;
@@ -46886,6 +44673,11 @@ static JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,
                                          JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE | JS_PROP_WRITABLE) < 0)
             goto fail_reject;
         
+        promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);
+        if (JS_IsException(promise_resolve) ||
+            check_function(ctx, promise_resolve))
+            goto fail_reject1;
+        
         index = 0;
         for(;;) {
             /* XXX: conformance: should close the iterator if error on 'done'
@@ -46904,32 +44696,26 @@ static JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,
                 goto fail_reject;
             }
             resolve_element_data[0] = JS_NewBool(ctx, FALSE);
-            resolve_element_data[1] = (JSValueConst)JS_NewInt32(ctx, index);
+            resolve_element_data[1] = JS_NewInt32(ctx, index);
             resolve_element_data[2] = values;
-            resolve_element_data[3] = resolving_funcs[is_promise_any];
+            resolve_element_data[3] = resolving_funcs[0];
             resolve_element_data[4] = resolve_element_env;
             resolve_element =
                 JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,
-                                    magic, 5, resolve_element_data);
+                                    is_allSettled, 5, resolve_element_data);
             if (JS_IsException(resolve_element)) {
                 JS_FreeValue(ctx, next_promise);
                 goto fail_reject1;
             }
             
-            if (magic == PROMISE_MAGIC_allSettled) {
+            if (is_allSettled) {
                 reject_element =
                     JS_NewCFunctionData(ctx, js_promise_all_resolve_element, 1,
-                                        magic | 4, 5, resolve_element_data);
+                                        is_allSettled | 2, 5, resolve_element_data);
                 if (JS_IsException(reject_element)) {
                     JS_FreeValue(ctx, next_promise);
                     goto fail_reject1;
                 }
-            } else if (magic == PROMISE_MAGIC_any) {
-                if (JS_DefinePropertyValueUint32(ctx, values, index,
-                                                 JS_UNDEFINED, JS_PROP_C_W_E) < 0)
-                    goto fail_reject1;
-                reject_element = resolve_element;
-                resolve_element = JS_DupValue(ctx, resolving_funcs[0]);
             } else {
                 reject_element = JS_DupValue(ctx, resolving_funcs[1]);
             }
@@ -46955,15 +44741,7 @@ static JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,
         if (is_zero < 0)
             goto fail_reject;
         if (is_zero) {
-            if (magic == PROMISE_MAGIC_any) {
-                JSValue error;
-                error = js_aggregate_error_constructor(ctx, values);
-                if (JS_IsException(error))
-                    goto fail_reject;
-                JS_FreeValue(ctx, values);
-                values = error;
-            }
-            ret = JS_Call(ctx, resolving_funcs[is_promise_any], JS_UNDEFINED,
+            ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
                           1, (JSValueConst *)&values);
             if (check_exception_free(ctx, ret))
                 goto fail_reject;
@@ -46987,8 +44765,8 @@ static JSValue js_promise_all(JSContext *ctx, JSValueConst this_val,
 static JSValue js_promise_race(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
 {
-    JSValue result_promise, resolving_funcs[2], item, next_promise, ret;
-    JSValue next_method = JS_UNDEFINED, iter = JS_UNDEFINED;
+    JSValue result_promise, resolving_funcs[2], iter, item, next_promise, ret;
+    JSValue next_method = JS_UNDEFINED;
     JSValue promise_resolve = JS_UNDEFINED;
     BOOL done;
 
@@ -46997,10 +44775,6 @@ static JSValue js_promise_race(JSContext *ctx, JSValueConst this_val,
     result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
     if (JS_IsException(result_promise))
         return result_promise;
-    promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);
-    if (JS_IsException(promise_resolve) ||
-        check_function(ctx, promise_resolve))
-        goto fail_reject;
     iter = JS_GetIterator(ctx, argv[0], FALSE);
     if (JS_IsException(iter)) {
         JSValue error;
@@ -47017,6 +44791,11 @@ static JSValue js_promise_race(JSContext *ctx, JSValueConst this_val,
         if (JS_IsException(next_method))
             goto fail_reject;
 
+        promise_resolve = JS_GetProperty(ctx, this_val, JS_ATOM_resolve);
+        if (JS_IsException(promise_resolve) ||
+            check_function(ctx, promise_resolve))
+            goto fail_reject1;
+
         for(;;) {
             /* XXX: conformance: should close the iterator if error on 'done'
                access, but not on 'value' access */
@@ -47086,13 +44865,6 @@ static __exception int perform_promise_then(JSContext *ctx,
             list_add_tail(&rd_array[i]->link, &s->promise_reactions[i]);
     } else {
         JSValueConst args[5];
-        if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
-            JSRuntime *rt = ctx->rt;
-            if (rt->host_promise_rejection_tracker) {
-                rt->host_promise_rejection_tracker(ctx, promise, s->promise_result,
-                                                   TRUE, rt->host_promise_rejection_tracker_opaque);
-            }
-        }
         i = s->promise_state - JS_PROMISE_FULFILLED;
         rd = rd_array[i];
         args[0] = rd->resolving_funcs[0];
@@ -47166,20 +44938,31 @@ static JSValue js_promise_then_finally_func(JSContext *ctx, JSValueConst this_va
 {
     JSValueConst ctor = func_data[0];
     JSValueConst onFinally = func_data[1];
-    JSValue res, promise, ret, then_func;
+    JSValue res, promise, resolving_funcs[2], ret, then_func;
 
     res = JS_Call(ctx, onFinally, JS_UNDEFINED, 0, NULL);
     if (JS_IsException(res))
         return res;
-    promise = js_promise_resolve(ctx, ctor, 1, (JSValueConst *)&res, 0);
+    promise = js_new_promise_capability(ctx, resolving_funcs, ctor);
+    if (JS_IsException(promise)) {
+        JS_FreeValue(ctx, res);
+        return JS_EXCEPTION;
+    }
+    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
+                  1, (JSValueConst*)&res);
     JS_FreeValue(ctx, res);
-    if (JS_IsException(promise))
-        return promise;
+    JS_FreeValue(ctx, resolving_funcs[0]);
+    JS_FreeValue(ctx, resolving_funcs[1]);
+    if (JS_IsException(ret)) {
+        JS_FreeValue(ctx, promise);
+        return ret;
+    }
+    JS_FreeValue(ctx, ret);
     if (magic == 0) {
-        then_func = JS_NewCFunctionData(ctx, js_promise_finally_value_thunk, 0,
+        then_func = JS_NewCFunctionData(ctx, js_promise_finally_value_thunk, 1,
                                         0, 1, argv);
     } else {
-        then_func = JS_NewCFunctionData(ctx, js_promise_finally_thrower, 0,
+        then_func = JS_NewCFunctionData(ctx, js_promise_finally_thrower, 1,
                                         0, 1, argv);
     }
     if (JS_IsException(then_func)) {
@@ -47229,9 +45012,8 @@ static JSValue js_promise_finally(JSContext *ctx, JSValueConst this_val,
 static const JSCFunctionListEntry js_promise_funcs[] = {
     JS_CFUNC_MAGIC_DEF("resolve", 1, js_promise_resolve, 0 ),
     JS_CFUNC_MAGIC_DEF("reject", 1, js_promise_resolve, 1 ),
-    JS_CFUNC_MAGIC_DEF("all", 1, js_promise_all, PROMISE_MAGIC_all ),
-    JS_CFUNC_MAGIC_DEF("allSettled", 1, js_promise_all, PROMISE_MAGIC_allSettled ),
-    JS_CFUNC_MAGIC_DEF("any", 1, js_promise_all, PROMISE_MAGIC_any ),
+    JS_CFUNC_MAGIC_DEF("all", 1, js_promise_all, 0 ),
+    JS_CFUNC_MAGIC_DEF("allSettled", 1, js_promise_all, 1 ),
     JS_CFUNC_DEF("race", 1, js_promise_race ),
     //JS_CFUNC_DEF("__newPromiseCapability", 1, js_promise___newPromiseCapability ),
     JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
@@ -47263,7 +45045,7 @@ static JSValue js_async_from_sync_iterator_unwrap_func_create(JSContext *ctx,
 {
     JSValueConst func_data[1];
 
-    func_data[0] = (JSValueConst)JS_NewBool(ctx, done);
+    func_data[0] = JS_NewBool(ctx, done);
     return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_unwrap,
                                1, 0, 1, func_data);
 }
@@ -47366,8 +45148,7 @@ static JSValue js_async_from_sync_iterator_next(JSContext *ctx, JSValueConst thi
             goto done_resolve;
         }
     }
-    value = JS_IteratorNext2(ctx, s->sync_iter, method,
-                             argc >= 1 ? 1 : 0, argv, &done);
+    value = JS_IteratorNext2(ctx, s->sync_iter, method, 1, argv, &done);
     JS_FreeValue(ctx, method);
     if (JS_IsException(value))
         goto reject;
@@ -47568,7 +45349,7 @@ static int isURIReserved(int c) {
     return c < 0x100 && memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
 }
 
-static int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
+static int __js_printf_like(2, 3) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
 {
     va_list ap;
 
@@ -47774,7 +45555,7 @@ static JSValue js_global_escape(JSContext *ctx, JSValueConst this_val,
     JSString *p;
     int i, len, c;
 
-    str = JS_ToString(ctx, argv[0]);
+    str = JS_ToStringCheckObject(ctx, argv[0]);
     if (JS_IsException(str))
         return str;
 
@@ -47800,7 +45581,7 @@ static JSValue js_global_unescape(JSContext *ctx, JSValueConst this_val,
     JSString *p;
     int i, len, c, n;
 
-    str = JS_ToString(ctx, argv[0]);
+    str = JS_ToStringCheckObject(ctx, argv[0]);
     if (JS_IsException(str))
         return str;
 
@@ -47886,7 +45667,7 @@ static JSValue JS_SetThisTimeValue(JSContext *ctx, JSValueConst this_val, double
         JSObject *p = JS_VALUE_GET_OBJ(this_val);
         if (p->class_id == JS_CLASS_DATE) {
             JS_FreeValue(ctx, p->u.object_data);
-            p->u.object_data = JS_NewFloat64(ctx, v);
+            p->u.object_data = __JS_NewFloat64(ctx, v);
             return JS_DupValue(ctx, p->u.object_data);
         }
     }
@@ -47930,7 +45711,7 @@ static char const month_names[] = "JanFebMarAprMayJunJulAugSepOctNovDec";
 static char const day_names[] = "SunMonTueWedThuFriSat";
 
 static __exception int get_date_fields(JSContext *ctx, JSValueConst obj,
-                                       double fields[9], int is_local, int force)
+                                       int64_t fields[9], int is_local, int force)
 {
     double dval;
     int64_t d, days, wd, y, i, md, h, m, s, ms, tz = 0;
@@ -47989,18 +45770,12 @@ static double time_clip(double t) {
         return NAN;
 }
 
-/* The spec mandates the use of 'double' and it fixes the order
-   of the operations */
-static double set_date_fields(double fields[], int is_local) {
-    int64_t y;
-    double days, d, h, m1;
-    int i, m, md;
-    
-    m1 = fields[1];
-    m = fmod(m1, 12);
-    if (m < 0)
-        m += 12;
-    y = (int64_t)(fields[0] + floor(m1 / 12));
+static double set_date_fields(int64_t fields[], int is_local) {
+    int64_t days, y, m, md, h, d, i;
+
+    i = fields[1];
+    m = math_mod(i, 12);
+    y = fields[0] + (i - m) / 12;
     days = days_from_year(y);
 
     for(i = 0; i < m; i++) {
@@ -48010,8 +45785,7 @@ static double set_date_fields(double fields[], int is_local) {
         days += md;
     }
     days += fields[2] - 1;
-    h = fields[3] * 3600000 + fields[4] * 60000 + 
-        fields[5] * 1000 + fields[6];
+    h = ((fields[3] * 60 + fields[4]) * 60 + fields[5]) * 1000 + fields[6];
     d = days * 86400000 + h;
     if (is_local)
         d += getTimezoneOffset(d) * 60000;
@@ -48022,7 +45796,7 @@ static JSValue get_date_field(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv, int magic)
 {
     // get_date_field(obj, n, is_local)
-    double fields[9];
+    int64_t fields[9];
     int res, n, is_local;
 
     is_local = magic & 0x0F;
@@ -48036,14 +45810,14 @@ static JSValue get_date_field(JSContext *ctx, JSValueConst this_val,
     if (magic & 0x100) {    // getYear
         fields[0] -= 1900;
     }
-    return JS_NewFloat64(ctx, fields[n]);
+    return JS_NewInt64(ctx, fields[n]);
 }
 
 static JSValue set_date_field(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv, int magic)
 {
     // _field(obj, first_field, end_field, args, is_local)
-    double fields[9];
+    int64_t fields[9];
     int res, first_field, end_field, is_local, i, n;
     double d, a;
 
@@ -48085,7 +45859,7 @@ static JSValue get_date_string(JSContext *ctx, JSValueConst this_val,
 {
     // _string(obj, fmt, part)
     char buf[64];
-    double fields[9];
+    int64_t fields[9];
     int res, fmt, part, pos;
     int y, mon, d, h, m, s, ms, wd, tz;
 
@@ -48233,7 +46007,7 @@ static JSValue js_date_constructor(JSContext *ctx, JSValueConst new_target,
         }
         val = time_clip(val);
     } else {
-        double fields[] = { 0, 0, 1, 0, 0, 0, 0 };
+        int64_t fields[] = { 0, 0, 1, 0, 0, 0, 0 };
         if (n > 7)
             n = 7;
         for(i = 0; i < n; i++) {
@@ -48252,12 +46026,12 @@ has_val:
     JSValueConst args[3];
     args[0] = new_target;
     args[1] = ctx->class_proto[JS_CLASS_DATE];
-    args[2] = JS_NewFloat64(ctx, val);
+    args[2] = __JS_NewFloat64(ctx, val);
     rv = js___date_create(ctx, JS_UNDEFINED, 3, args);
 #else
     rv = js_create_from_ctor(ctx, new_target, JS_CLASS_DATE);
     if (!JS_IsException(rv))
-        JS_SetObjectData(ctx, rv, JS_NewFloat64(ctx, val));
+        JS_SetObjectData(ctx, rv, __JS_NewFloat64(ctx, val));
 #endif
     if (!JS_IsException(rv) && JS_IsUndefined(new_target)) {
         /* invoked as a function, return (new Date()).toString(); */
@@ -48273,7 +46047,7 @@ static JSValue js_Date_UTC(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
 {
     // UTC(y, mon, d, h, m, s, ms)
-    double fields[] = { 0, 0, 1, 0, 0, 0, 0 };
+    int64_t fields[] = { 0, 0, 1, 0, 0, 0, 0 };
     int i, n;
     double a;
 
@@ -48291,7 +46065,7 @@ static JSValue js_Date_UTC(JSContext *ctx, JSValueConst this_val,
         if (i == 0 && fields[0] >= 0 && fields[0] < 100)
             fields[0] += 1900;
     }
-    return JS_NewFloat64(ctx, set_date_fields(fields, 0));
+    return __JS_NewFloat64(ctx, set_date_fields(fields, 0));
 }
 
 static void string_skip_spaces(JSString *sp, int *pp) {
@@ -48304,22 +46078,24 @@ static void string_skip_non_spaces(JSString *sp, int *pp) {
         *pp += 1;
 }
 
-/* parse a numeric field with an optional sign if accept_sign is TRUE */
-static int string_get_digits(JSString *sp, int *pp, int64_t *pval) {
+/* parse a numeric field */
+static int string_get_field(JSString *sp, int *pp, int64_t *pval) {
     int64_t v = 0;
-    int c, p = *pp, p_start;
-    
+    int c, p = *pp;
+
+    /* skip non digits, should only skip spaces? */
+    while (p < sp->len) {
+        c = string_get(sp, p);
+        if (c >= '0' && c <= '9')
+            break;
+        p++;
+    }
     if (p >= sp->len)
         return -1;
-    p_start = p;
     while (p < sp->len) {
         c = string_get(sp, p);
-        if (!(c >= '0' && c <= '9')) {
-            if (p == p_start)
-                return -1;
-            else
-                break;
-        }
+        if (!(c >= '0' && c <= '9'))
+            break;
         v = v * 10 + c - '0';
         p++;
     }
@@ -48328,25 +46104,8 @@ static int string_get_digits(JSString *sp, int *pp, int64_t *pval) {
     return 0;
 }
 
-static int string_get_signed_digits(JSString *sp, int *pp, int64_t *pval) {
-    int res, sgn, p = *pp;
-    
-    if (p >= sp->len)
-        return -1;
-
-    sgn = string_get(sp, p);
-    if (sgn == '-' || sgn == '+')
-        p++;
- 
-    res = string_get_digits(sp, &p, pval);
-    if (res == 0 && sgn == '-')
-        *pval = -*pval;
-    *pp = p;
-    return res;
-}
-
 /* parse a fixed width numeric field */
-static int string_get_fixed_width_digits(JSString *sp, int *pp, int n, int64_t *pval) {
+static int string_get_digits(JSString *sp, int *pp, int n, int64_t *pval) {
     int64_t v = 0;
     int i, c, p = *pp;
 
@@ -48364,31 +46123,22 @@ static int string_get_fixed_width_digits(JSString *sp, int *pp, int n, int64_t *
     return 0;
 }
 
-static int string_get_milliseconds(JSString *sp, int *pp, int64_t *pval) {
-    /* parse milliseconds as a fractional part, round to nearest */
-    /* XXX: the spec does not indicate which rounding should be used */
-    int mul = 1000, ms = 0, p = *pp, c, p_start;
-    if (p >= sp->len)
+/* parse a signed numeric field */
+static int string_get_signed_field(JSString *sp, int *pp, int64_t *pval) {
+    int sgn, res;
+
+    if (*pp >= sp->len)
         return -1;
-    p_start = p;
-    while (p < sp->len) {
-        c = string_get(sp, p);
-        if (!(c >= '0' && c <= '9')) {
-            if (p == p_start)
-                return -1;
-            else
-                break;
-        }
-        if (mul == 1 && c >= '5')
-            ms += 1;
-        ms += (c - '0') * (mul /= 10);
-        p++;
-    }
-    *pval = ms;
-    *pp = p;
-    return 0;
-}
 
+    sgn = string_get(sp, *pp);
+    if (sgn == '-' || sgn == '+')
+        *pp += 1;
+
+    res = string_get_field(sp, pp, pval);
+    if (res == 0 && sgn == '-')
+        *pval = -*pval;
+    return res;
+}
 
 static int find_abbrev(JSString *sp, int p, const char *list, int count) {
     int n, i;
@@ -48425,13 +46175,11 @@ static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
     // parse(s)
     JSValue s, rv;
     int64_t fields[] = { 0, 1, 1, 0, 0, 0, 0 };
-    double fields1[7];
     int64_t tz, hh, mm;
     double d;
-    int p, i, c, sgn, l;
+    int p, i, c, sgn;
     JSString *sp;
-    BOOL is_local;
-    
+
     rv = JS_NAN;
 
     s = JS_ToString(ctx, argv[0]);
@@ -48443,74 +46191,40 @@ static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
     if (p < sp->len && (((c = string_get(sp, p)) >= '0' && c <= '9') || c == '+' || c == '-')) {
         /* ISO format */
         /* year field can be negative */
-        if (string_get_signed_digits(sp, &p, &fields[0]))
+        /* XXX: could be stricter */
+        if (string_get_signed_field(sp, &p, &fields[0]))
             goto done;
 
-        for (i = 1; i < 7; i++) {
-            if (p >= sp->len)
-                break;
-            switch(i) {
-            case 1:
-            case 2:
-                c = '-';
-                break;
-            case 3:
-                c = 'T';
+        for (i = 1; i < 6; i++) {
+            if (string_get_field(sp, &p, &fields[i]))
                 break;
-            case 4:
-            case 5:
-                c = ':';
-                break;
-            case 6:
-                c = '.';
-                break;
-            }
-            if (string_get(sp, p) != c)
-                break;
-            p++;
-            if (i == 6) {
-                if (string_get_milliseconds(sp, &p, &fields[i]))
-                    goto done;
-            } else {
-                if (string_get_digits(sp, &p, &fields[i]))
-                    goto done;
+        }
+        if (i == 6 && p < sp->len && string_get(sp, p) == '.') {
+            /* parse milliseconds as a fractional part, round to nearest */
+            /* XXX: the spec does not indicate which rounding should be used */
+            int mul = 1000, ms = 0;
+            while (++p < sp->len) {
+                int c = string_get(sp, p);
+                if (!(c >= '0' && c <= '9'))
+                    break;
+                if (mul == 1 && c >= '5')
+                    ms += 1;
+                ms += (c - '0') * (mul /= 10);
             }
+            fields[6] = ms;
         }
-        /* no time: UTC by default */
-        is_local = (i > 3);
         fields[1] -= 1;
 
-        /* parse the time zone offset if present: [+-]HH:mm or [+-]HHmm */
+        /* parse the time zone offset if present: [+-]HH:mm */
         tz = 0;
-        if (p < sp->len) {
-            sgn = string_get(sp, p);
-            if (sgn == '+' || sgn == '-') {
-                p++;
-                l = sp->len - p;
-                if (l != 4 && l != 5)
-                    goto done;
-                if (string_get_fixed_width_digits(sp, &p, 2, &hh))
-                    goto done;
-                if (l == 5) {
-                    if (string_get(sp, p) != ':')
-                        goto done;
-                    p++;
-                }
-                if (string_get_fixed_width_digits(sp, &p, 2, &mm))
-                    goto done;
-                tz = hh * 60 + mm;
-                if (sgn == '-')
-                    tz = -tz;
-                is_local = FALSE;
-            } else if (sgn == 'Z') {
-                p++;
-                is_local = FALSE;
-            } else {
+        if (p < sp->len && ((sgn = string_get(sp, p)) == '+' || sgn == '-')) {
+            if (string_get_field(sp, &p, &hh))
                 goto done;
-            }
-            /* error if extraneous characters */
-            if (p != sp->len)
+            if (string_get_field(sp, &p, &mm))
                 goto done;
+            tz = hh * 60 + mm;
+            if (sgn == '-')
+                tz = -tz;
         }
     } else {
         /* toString or toUTCString format */
@@ -48522,7 +46236,7 @@ static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
         c = string_get(sp, p);
         if (c >= '0' && c <= '9') {
             /* day of month first */
-            if (string_get_digits(sp, &p, &fields[2]))
+            if (string_get_field(sp, &p, &fields[2]))
                 goto done;
             if (string_get_month(sp, &p, &fields[1]))
                 goto done;
@@ -48530,40 +46244,29 @@ static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
             /* month first */
             if (string_get_month(sp, &p, &fields[1]))
                 goto done;
-            string_skip_spaces(sp, &p);
-            if (string_get_digits(sp, &p, &fields[2]))
+            if (string_get_field(sp, &p, &fields[2]))
                 goto done;
         }
-        /* year */
         string_skip_spaces(sp, &p);
-        if (string_get_signed_digits(sp, &p, &fields[0]))
+        if (string_get_signed_field(sp, &p, &fields[0]))
             goto done;
 
         /* hour, min, seconds */
-        string_skip_spaces(sp, &p);
         for(i = 0; i < 3; i++) {
-            if (i == 1 || i == 2) {
-                if (p >= sp->len)
-                    goto done;
-                if (string_get(sp, p) != ':')
-                    goto done;
-                p++;
-            }
-            if (string_get_digits(sp, &p, &fields[3 + i]))
+            if (string_get_field(sp, &p, &fields[3 + i]))
                 goto done;
         }
         // XXX: parse optional milliseconds?
 
         /* parse the time zone offset if present: [+-]HHmm */
-        is_local = FALSE;
         tz = 0;
         for (tz = 0; p < sp->len; p++) {
             sgn = string_get(sp, p);
             if (sgn == '+' || sgn == '-') {
                 p++;
-                if (string_get_fixed_width_digits(sp, &p, 2, &hh))
+                if (string_get_digits(sp, &p, 2, &hh))
                     goto done;
-                if (string_get_fixed_width_digits(sp, &p, 2, &mm))
+                if (string_get_digits(sp, &p, 2, &mm))
                     goto done;
                 tz = hh * 60 + mm;
                 if (sgn == '-')
@@ -48572,10 +46275,8 @@ static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
             }
         }
     }
-    for(i = 0; i < 7; i++)
-        fields1[i] = fields[i];
-    d = set_date_fields(fields1, is_local) - tz * 60000;
-    rv = JS_NewFloat64(ctx, d);
+    d = set_date_fields(fields, 0) - tz * 60000;
+    rv = __JS_NewFloat64(ctx, d);
 
 done:
     JS_FreeValue(ctx, s);
@@ -48645,7 +46346,7 @@ static JSValue js_date_getTime(JSContext *ctx, JSValueConst this_val,
 
     if (JS_ThisTimeValue(ctx, &v, this_val))
         return JS_EXCEPTION;
-    return JS_NewFloat64(ctx, v);
+    return __JS_NewFloat64(ctx, v);
 }
 
 static JSValue js_date_setTime(JSContext *ctx, JSValueConst this_val,
@@ -48674,7 +46375,7 @@ static JSValue js_date_setYear(JSContext *ctx, JSValueConst this_val,
         if (y >= 0 && y < 100)
             y += 1900;
     }
-    args[0] = JS_NewFloat64(ctx, y);
+    args[0] = __JS_NewFloat64(ctx, y);
     return set_date_field(ctx, this_val, 1, args, 0x011);
 }
 
@@ -48730,428 +46431,126 @@ static const JSCFunctionListEntry js_date_proto_funcs[] = {
     JS_ALIAS_DEF("toGMTString", "toUTCString" ),
     JS_CFUNC_MAGIC_DEF("toISOString", 0, get_date_string, 0x23 ),
     JS_CFUNC_MAGIC_DEF("toDateString", 0, get_date_string, 0x11 ),
-    JS_CFUNC_MAGIC_DEF("toTimeString", 0, get_date_string, 0x12 ),
-    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, get_date_string, 0x33 ),
-    JS_CFUNC_MAGIC_DEF("toLocaleDateString", 0, get_date_string, 0x31 ),
-    JS_CFUNC_MAGIC_DEF("toLocaleTimeString", 0, get_date_string, 0x32 ),
-    JS_CFUNC_DEF("getTimezoneOffset", 0, js_date_getTimezoneOffset ),
-    JS_CFUNC_DEF("getTime", 0, js_date_getTime ),
-    JS_CFUNC_MAGIC_DEF("getYear", 0, get_date_field, 0x101 ),
-    JS_CFUNC_MAGIC_DEF("getFullYear", 0, get_date_field, 0x01 ),
-    JS_CFUNC_MAGIC_DEF("getUTCFullYear", 0, get_date_field, 0x00 ),
-    JS_CFUNC_MAGIC_DEF("getMonth", 0, get_date_field, 0x11 ),
-    JS_CFUNC_MAGIC_DEF("getUTCMonth", 0, get_date_field, 0x10 ),
-    JS_CFUNC_MAGIC_DEF("getDate", 0, get_date_field, 0x21 ),
-    JS_CFUNC_MAGIC_DEF("getUTCDate", 0, get_date_field, 0x20 ),
-    JS_CFUNC_MAGIC_DEF("getHours", 0, get_date_field, 0x31 ),
-    JS_CFUNC_MAGIC_DEF("getUTCHours", 0, get_date_field, 0x30 ),
-    JS_CFUNC_MAGIC_DEF("getMinutes", 0, get_date_field, 0x41 ),
-    JS_CFUNC_MAGIC_DEF("getUTCMinutes", 0, get_date_field, 0x40 ),
-    JS_CFUNC_MAGIC_DEF("getSeconds", 0, get_date_field, 0x51 ),
-    JS_CFUNC_MAGIC_DEF("getUTCSeconds", 0, get_date_field, 0x50 ),
-    JS_CFUNC_MAGIC_DEF("getMilliseconds", 0, get_date_field, 0x61 ),
-    JS_CFUNC_MAGIC_DEF("getUTCMilliseconds", 0, get_date_field, 0x60 ),
-    JS_CFUNC_MAGIC_DEF("getDay", 0, get_date_field, 0x71 ),
-    JS_CFUNC_MAGIC_DEF("getUTCDay", 0, get_date_field, 0x70 ),
-    JS_CFUNC_DEF("setTime", 1, js_date_setTime ),
-    JS_CFUNC_MAGIC_DEF("setMilliseconds", 1, set_date_field, 0x671 ),
-    JS_CFUNC_MAGIC_DEF("setUTCMilliseconds", 1, set_date_field, 0x670 ),
-    JS_CFUNC_MAGIC_DEF("setSeconds", 2, set_date_field, 0x571 ),
-    JS_CFUNC_MAGIC_DEF("setUTCSeconds", 2, set_date_field, 0x570 ),
-    JS_CFUNC_MAGIC_DEF("setMinutes", 3, set_date_field, 0x471 ),
-    JS_CFUNC_MAGIC_DEF("setUTCMinutes", 3, set_date_field, 0x470 ),
-    JS_CFUNC_MAGIC_DEF("setHours", 4, set_date_field, 0x371 ),
-    JS_CFUNC_MAGIC_DEF("setUTCHours", 4, set_date_field, 0x370 ),
-    JS_CFUNC_MAGIC_DEF("setDate", 1, set_date_field, 0x231 ),
-    JS_CFUNC_MAGIC_DEF("setUTCDate", 1, set_date_field, 0x230 ),
-    JS_CFUNC_MAGIC_DEF("setMonth", 2, set_date_field, 0x131 ),
-    JS_CFUNC_MAGIC_DEF("setUTCMonth", 2, set_date_field, 0x130 ),
-    JS_CFUNC_DEF("setYear", 1, js_date_setYear ),
-    JS_CFUNC_MAGIC_DEF("setFullYear", 3, set_date_field, 0x031 ),
-    JS_CFUNC_MAGIC_DEF("setUTCFullYear", 3, set_date_field, 0x030 ),
-    JS_CFUNC_DEF("toJSON", 1, js_date_toJSON ),
-};
-
-void JS_AddIntrinsicDate(JSContext *ctx)
-{
-    JSValueConst obj;
-
-    /* Date */
-    ctx->class_proto[JS_CLASS_DATE] = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATE], js_date_proto_funcs,
-                               countof(js_date_proto_funcs));
-    obj = JS_NewGlobalCConstructor(ctx, "Date", js_date_constructor, 7,
-                                   ctx->class_proto[JS_CLASS_DATE]);
-    JS_SetPropertyFunctionList(ctx, obj, js_date_funcs, countof(js_date_funcs));
-}
-
-/* eval */
-
-void JS_AddIntrinsicEval(JSContext *ctx)
-{
-    ctx->eval_internal = __JS_EvalInternal;
-}
-
-#ifdef CONFIG_BIGNUM
-
-/* Operators */
-
-static void js_operator_set_finalizer(JSRuntime *rt, JSValue val)
-{
-    JSOperatorSetData *opset = JS_GetOpaque(val, JS_CLASS_OPERATOR_SET);
-    int i, j;
-    JSBinaryOperatorDefEntry *ent;
-    
-    if (opset) {
-        for(i = 0; i < JS_OVOP_COUNT; i++) {
-            if (opset->self_ops[i])
-                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, opset->self_ops[i]));
-        }
-        for(j = 0; j < opset->left.count; j++) {
-            ent = &opset->left.tab[j];
-            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {
-                if (ent->ops[i])
-                    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]));
-            }
-        }
-        js_free_rt(rt, opset->left.tab);
-        for(j = 0; j < opset->right.count; j++) {
-            ent = &opset->right.tab[j];
-            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {
-                if (ent->ops[i])
-                    JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]));
-            }
-        }
-        js_free_rt(rt, opset->right.tab);
-        js_free_rt(rt, opset);
-    }
-}
-
-static void js_operator_set_mark(JSRuntime *rt, JSValueConst val,
-                                 JS_MarkFunc *mark_func)
-{
-    JSOperatorSetData *opset = JS_GetOpaque(val, JS_CLASS_OPERATOR_SET);
-    int i, j;
-    JSBinaryOperatorDefEntry *ent;
-    
-    if (opset) {
-        for(i = 0; i < JS_OVOP_COUNT; i++) {
-            if (opset->self_ops[i])
-                JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, opset->self_ops[i]),
-                             mark_func);
-        }
-        for(j = 0; j < opset->left.count; j++) {
-            ent = &opset->left.tab[j];
-            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {
-                if (ent->ops[i])
-                    JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]),
-                                 mark_func);
-            }
-        }
-        for(j = 0; j < opset->right.count; j++) {
-            ent = &opset->right.tab[j];
-            for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {
-                if (ent->ops[i])
-                    JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, ent->ops[i]),
-                                 mark_func);
-            }
-        }
-    }
-}
-
-
-/* create an OperatorSet object */
-static JSValue js_operators_create_internal(JSContext *ctx,
-                                            int argc, JSValueConst *argv,
-                                            BOOL is_primitive)
-{
-    JSValue opset_obj, prop, obj;
-    JSOperatorSetData *opset, *opset1;
-    JSBinaryOperatorDef *def;
-    JSValueConst arg;
-    int i, j;
-    JSBinaryOperatorDefEntry *new_tab;
-    JSBinaryOperatorDefEntry *ent;
-    uint32_t op_count;
-
-    if (ctx->rt->operator_count == UINT32_MAX) {
-        return JS_ThrowTypeError(ctx, "too many operators");
-    }
-    opset_obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_OPERATOR_SET);
-    if (JS_IsException(opset_obj))
-        goto fail;
-    opset = js_mallocz(ctx, sizeof(*opset));
-    if (!opset)
-        goto fail;
-    JS_SetOpaque(opset_obj, opset);
-    if (argc >= 1) {
-        arg = argv[0];
-        /* self operators */
-        for(i = 0; i < JS_OVOP_COUNT; i++) {
-            prop = JS_GetPropertyStr(ctx, arg, js_overloadable_operator_names[i]);
-            if (JS_IsException(prop))
-                goto fail;
-            if (!JS_IsUndefined(prop)) {
-                if (check_function(ctx, prop)) {
-                    JS_FreeValue(ctx, prop);
-                    goto fail;
-                }
-                opset->self_ops[i] = JS_VALUE_GET_OBJ(prop);
-            }
-        }
-    }
-    /* left & right operators */
-    for(j = 1; j < argc; j++) {
-        arg = argv[j];
-        prop = JS_GetPropertyStr(ctx, arg, "left");
-        if (JS_IsException(prop))
-            goto fail;
-        def = &opset->right;
-        if (JS_IsUndefined(prop)) {
-            prop = JS_GetPropertyStr(ctx, arg, "right");
-            if (JS_IsException(prop))
-                goto fail;
-            if (JS_IsUndefined(prop)) {
-                JS_ThrowTypeError(ctx, "left or right property must be present");
-                goto fail;
-            }
-            def = &opset->left;
-        }
-        /* get the operator set */
-        obj = JS_GetProperty(ctx, prop, JS_ATOM_prototype);
-        JS_FreeValue(ctx, prop);
-        if (JS_IsException(obj))
-            goto fail;
-        prop = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_operatorSet);
-        JS_FreeValue(ctx, obj);
-        if (JS_IsException(prop))
-            goto fail;
-        opset1 = JS_GetOpaque2(ctx, prop, JS_CLASS_OPERATOR_SET);
-        if (!opset1) {
-            JS_FreeValue(ctx, prop);
-            goto fail;
-        }
-        op_count = opset1->operator_counter;
-        JS_FreeValue(ctx, prop);
-        
-        /* we assume there are few entries */
-        new_tab = js_realloc(ctx, def->tab,
-                             (def->count + 1) * sizeof(def->tab[0]));
-        if (!new_tab)
-            goto fail;
-        def->tab = new_tab;
-        def->count++;
-        ent = def->tab + def->count - 1;
-        memset(ent, 0, sizeof(def->tab[0]));
-        ent->operator_index = op_count;
-        
-        for(i = 0; i < JS_OVOP_BINARY_COUNT; i++) {
-            prop = JS_GetPropertyStr(ctx, arg,
-                                     js_overloadable_operator_names[i]);
-            if (JS_IsException(prop))
-                goto fail;
-            if (!JS_IsUndefined(prop)) {
-                if (check_function(ctx, prop)) {
-                    JS_FreeValue(ctx, prop);
-                    goto fail;
-                }
-                ent->ops[i] = JS_VALUE_GET_OBJ(prop);
-            }
-        }
-    }
-    opset->is_primitive = is_primitive;
-    opset->operator_counter = ctx->rt->operator_count++;
-    return opset_obj;
- fail:
-    JS_FreeValue(ctx, opset_obj);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_operators_create(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv)
-{
-    return js_operators_create_internal(ctx, argc, argv, FALSE);
-}
-
-static JSValue js_operators_updateBigIntOperators(JSContext *ctx, JSValueConst this_val,
-                                                  int argc, JSValueConst *argv)
-{
-    JSValue opset_obj, prop;
-    JSOperatorSetData *opset;
-    const JSOverloadableOperatorEnum ops[2] = { JS_OVOP_DIV, JS_OVOP_POW };
-    JSOverloadableOperatorEnum op;
-    int i;
-    
-    opset_obj = JS_GetProperty(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
-                               JS_ATOM_Symbol_operatorSet);
-    if (JS_IsException(opset_obj))
-        goto fail;
-    opset = JS_GetOpaque2(ctx, opset_obj, JS_CLASS_OPERATOR_SET);
-    if (!opset)
-        goto fail;
-    for(i = 0; i < countof(ops); i++) {
-        op = ops[i];
-        prop = JS_GetPropertyStr(ctx, argv[0],
-                                 js_overloadable_operator_names[op]);
-        if (JS_IsException(prop))
-            goto fail;
-        if (!JS_IsUndefined(prop)) {
-            if (!JS_IsNull(prop) && check_function(ctx, prop)) {
-                JS_FreeValue(ctx, prop);
-                goto fail;
-            }
-            if (opset->self_ops[op])
-                JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, opset->self_ops[op]));
-            if (JS_IsNull(prop)) {
-                opset->self_ops[op] = NULL;
-            } else {
-                opset->self_ops[op] = JS_VALUE_GET_PTR(prop);
-            }
-        }
-    }
-    JS_FreeValue(ctx, opset_obj);
-    return JS_UNDEFINED;
- fail:
-    JS_FreeValue(ctx, opset_obj);
-    return JS_EXCEPTION;
-}
-
-static int js_operators_set_default(JSContext *ctx, JSValueConst obj)
-{
-    JSValue opset_obj;
-
-    if (!JS_IsObject(obj)) /* in case the prototype is not defined */
-        return 0;
-    opset_obj = js_operators_create_internal(ctx, 0, NULL, TRUE);
-    if (JS_IsException(opset_obj))
-        return -1;
-    /* cannot be modified by the user */
-    JS_DefinePropertyValue(ctx, obj, JS_ATOM_Symbol_operatorSet,
-                           opset_obj, 0);
-    return 0;
-}
-
-static JSValue js_dummy_operators_ctor(JSContext *ctx, JSValueConst new_target,
-                                       int argc, JSValueConst *argv)
-{
-    return js_create_from_ctor(ctx, new_target, JS_CLASS_OBJECT);
-}
+    JS_CFUNC_MAGIC_DEF("toTimeString", 0, get_date_string, 0x12 ),
+    JS_CFUNC_MAGIC_DEF("toLocaleString", 0, get_date_string, 0x33 ),
+    JS_CFUNC_MAGIC_DEF("toLocaleDateString", 0, get_date_string, 0x31 ),
+    JS_CFUNC_MAGIC_DEF("toLocaleTimeString", 0, get_date_string, 0x32 ),
+    JS_CFUNC_DEF("getTimezoneOffset", 0, js_date_getTimezoneOffset ),
+    JS_CFUNC_DEF("getTime", 0, js_date_getTime ),
+    JS_CFUNC_MAGIC_DEF("getYear", 0, get_date_field, 0x101 ),
+    JS_CFUNC_MAGIC_DEF("getFullYear", 0, get_date_field, 0x01 ),
+    JS_CFUNC_MAGIC_DEF("getUTCFullYear", 0, get_date_field, 0x00 ),
+    JS_CFUNC_MAGIC_DEF("getMonth", 0, get_date_field, 0x11 ),
+    JS_CFUNC_MAGIC_DEF("getUTCMonth", 0, get_date_field, 0x10 ),
+    JS_CFUNC_MAGIC_DEF("getDate", 0, get_date_field, 0x21 ),
+    JS_CFUNC_MAGIC_DEF("getUTCDate", 0, get_date_field, 0x20 ),
+    JS_CFUNC_MAGIC_DEF("getHours", 0, get_date_field, 0x31 ),
+    JS_CFUNC_MAGIC_DEF("getUTCHours", 0, get_date_field, 0x30 ),
+    JS_CFUNC_MAGIC_DEF("getMinutes", 0, get_date_field, 0x41 ),
+    JS_CFUNC_MAGIC_DEF("getUTCMinutes", 0, get_date_field, 0x40 ),
+    JS_CFUNC_MAGIC_DEF("getSeconds", 0, get_date_field, 0x51 ),
+    JS_CFUNC_MAGIC_DEF("getUTCSeconds", 0, get_date_field, 0x50 ),
+    JS_CFUNC_MAGIC_DEF("getMilliseconds", 0, get_date_field, 0x61 ),
+    JS_CFUNC_MAGIC_DEF("getUTCMilliseconds", 0, get_date_field, 0x60 ),
+    JS_CFUNC_MAGIC_DEF("getDay", 0, get_date_field, 0x71 ),
+    JS_CFUNC_MAGIC_DEF("getUTCDay", 0, get_date_field, 0x70 ),
+    JS_CFUNC_DEF("setTime", 1, js_date_setTime ),
+    JS_CFUNC_MAGIC_DEF("setMilliseconds", 1, set_date_field, 0x671 ),
+    JS_CFUNC_MAGIC_DEF("setUTCMilliseconds", 1, set_date_field, 0x670 ),
+    JS_CFUNC_MAGIC_DEF("setSeconds", 2, set_date_field, 0x571 ),
+    JS_CFUNC_MAGIC_DEF("setUTCSeconds", 2, set_date_field, 0x570 ),
+    JS_CFUNC_MAGIC_DEF("setMinutes", 3, set_date_field, 0x471 ),
+    JS_CFUNC_MAGIC_DEF("setUTCMinutes", 3, set_date_field, 0x470 ),
+    JS_CFUNC_MAGIC_DEF("setHours", 4, set_date_field, 0x371 ),
+    JS_CFUNC_MAGIC_DEF("setUTCHours", 4, set_date_field, 0x370 ),
+    JS_CFUNC_MAGIC_DEF("setDate", 1, set_date_field, 0x231 ),
+    JS_CFUNC_MAGIC_DEF("setUTCDate", 1, set_date_field, 0x230 ),
+    JS_CFUNC_MAGIC_DEF("setMonth", 2, set_date_field, 0x131 ),
+    JS_CFUNC_MAGIC_DEF("setUTCMonth", 2, set_date_field, 0x130 ),
+    JS_CFUNC_DEF("setYear", 1, js_date_setYear ),
+    JS_CFUNC_MAGIC_DEF("setFullYear", 3, set_date_field, 0x031 ),
+    JS_CFUNC_MAGIC_DEF("setUTCFullYear", 3, set_date_field, 0x030 ),
+    JS_CFUNC_DEF("toJSON", 1, js_date_toJSON ),
+};
 
-static JSValue js_global_operators(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
+void JS_AddIntrinsicDate(JSContext *ctx)
 {
-    JSValue func_obj, proto, opset_obj;
+    JSValueConst obj;
 
-    func_obj = JS_UNDEFINED;
-    proto = JS_NewObject(ctx);
-    if (JS_IsException(proto))
-        return JS_EXCEPTION;
-    opset_obj = js_operators_create_internal(ctx, argc, argv, FALSE);
-    if (JS_IsException(opset_obj))
-        goto fail;
-    JS_DefinePropertyValue(ctx, proto, JS_ATOM_Symbol_operatorSet,
-                           opset_obj, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-    func_obj = JS_NewCFunction2(ctx, js_dummy_operators_ctor, "Operators",
-                                0, JS_CFUNC_constructor, 0);
-    if (JS_IsException(func_obj))
-        goto fail;
-    JS_SetConstructor2(ctx, func_obj, proto,
-                       0, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-    JS_FreeValue(ctx, proto);
-    return func_obj;
- fail:
-    JS_FreeValue(ctx, proto);
-    JS_FreeValue(ctx, func_obj);
-    return JS_EXCEPTION;
+    /* Date */
+    ctx->class_proto[JS_CLASS_DATE] = JS_NewObject(ctx);
+    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_DATE], js_date_proto_funcs,
+                               countof(js_date_proto_funcs));
+    obj = JS_NewGlobalCConstructor(ctx, "Date", js_date_constructor, 7,
+                                   ctx->class_proto[JS_CLASS_DATE]);
+    JS_SetPropertyFunctionList(ctx, obj, js_date_funcs, countof(js_date_funcs));
 }
 
-static const JSCFunctionListEntry js_operators_funcs[] = {
-    JS_CFUNC_DEF("create", 1, js_operators_create ),
-    JS_CFUNC_DEF("updateBigIntOperators", 2, js_operators_updateBigIntOperators ),
-};
+/* eval */
 
-/* must be called after all overloadable base types are initialized */
-void JS_AddIntrinsicOperators(JSContext *ctx)
+void JS_AddIntrinsicEval(JSContext *ctx)
 {
-    JSValue obj;
-
-    ctx->allow_operator_overloading = TRUE;
-    obj = JS_NewCFunction(ctx, js_global_operators, "Operators", 1);
-    JS_SetPropertyFunctionList(ctx, obj,
-                               js_operators_funcs,
-                               countof(js_operators_funcs));
-    JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_Operators,
-                           obj,
-                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-    /* add default operatorSets */
-    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BOOLEAN]);
-    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_NUMBER]);
-    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_STRING]);
-    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_INT]);
-    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT]);
-    js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_DECIMAL]);
+    ctx->eval_internal = __JS_EvalInternal;
 }
 
-/* BigInt */
+#ifdef CONFIG_BIGNUM
 
 static JSValue JS_ToBigIntCtorFree(JSContext *ctx, JSValue val)
 {
     uint32_t tag;
+    BOOL is_legacy;
+    int ret;
 
+    is_legacy = is_bignum_mode(ctx) ^ 1;
  redo:
     tag = JS_VALUE_GET_NORM_TAG(val);
     switch(tag) {
     case JS_TAG_INT:
     case JS_TAG_BOOL:
-        val = JS_NewBigInt64(ctx, JS_VALUE_GET_INT(val));
+        if (is_legacy) {
+            bf_t r_s, *r = &r_s;
+            bf_init(ctx->bf_ctx, r);
+            bf_set_si(r, JS_VALUE_GET_INT(val));
+            val = JS_NewBigInt2(ctx, r, TRUE);
+        } else {
+            val = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));
+        }
         break;
     case JS_TAG_BIG_INT:
         break;
     case JS_TAG_FLOAT64:
     case JS_TAG_BIG_FLOAT:
         {
-            bf_t *a, a_s;
-            
-            a = JS_ToBigFloat(ctx, &a_s, val);
+            bf_t *a, a_s, r_s, *r = &r_s;
+            BOOL is_float;
+            a = JS_ToBigFloat(ctx, &is_float, &a_s, val);
+            bf_init(ctx->bf_ctx, r);
             if (!bf_is_finite(a)) {
                 JS_FreeValue(ctx, val);
                 val = JS_ThrowRangeError(ctx, "cannot convert NaN or Infinity to bigint");
             } else {
-                JSValue val1 = JS_NewBigInt(ctx);
-                bf_t *r;
-                int ret;
-                if (JS_IsException(val1)) {
-                    JS_FreeValue(ctx, val);
-                    return JS_EXCEPTION;
-                }
-                r = JS_GetBigInt(val1);
-                ret = bf_set(r, a);
-                ret |= bf_rint(r, BF_RNDZ);
+                bf_set(r, a);
+                ret = bf_rint(r, BF_PREC_INF, BF_RNDZ);
                 JS_FreeValue(ctx, val);
-                if (ret & BF_ST_MEM_ERROR) {
-                    JS_FreeValue(ctx, val1);
-                    val = JS_ThrowOutOfMemory(ctx);
-                } else if (ret & BF_ST_INEXACT) {
-                    JS_FreeValue(ctx, val1);
+                if (is_legacy && (ret & BF_ST_INEXACT)) {
+                    bf_delete(r);
                     val = JS_ThrowRangeError(ctx, "cannot convert to bigint: not an integer");
                 } else {
-                    val = JS_CompactBigInt(ctx, val1);
+                    val = JS_NewBigInt2(ctx, r, is_legacy);
                 }
             }
             if (a == &a_s)
                 bf_delete(a);
         }
         break;
-    case JS_TAG_BIG_DECIMAL:
-        val = JS_ToStringFree(ctx, val);
-         if (JS_IsException(val))
-            break;
-        goto redo;
     case JS_TAG_STRING:
         val = JS_StringToBigIntErr(ctx, val);
-        break;
+        if (JS_IsException(val))
+            break;
+        goto redo;
     case JS_TAG_OBJECT:
-        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
+        val = JS_ToPrimitiveFree(ctx, val,
+                                 is_legacy ? HINT_NUMBER : HINT_INTEGER);
         if (JS_IsException(val))
             break;
         goto redo;
@@ -49165,14 +46564,23 @@ static JSValue JS_ToBigIntCtorFree(JSContext *ctx, JSValue val)
 }
 
 static JSValue js_bigint_constructor(JSContext *ctx,
-                                     JSValueConst new_target,
+                                     JSValueConst this_val,
                                      int argc, JSValueConst *argv)
 {
-    if (!JS_IsUndefined(new_target))
-        return JS_ThrowTypeError(ctx, "not a constructor");
     return JS_ToBigIntCtorFree(ctx, JS_DupValue(ctx, argv[0]));
 }
 
+static inline BOOL JS_IsBigInt(JSContext *ctx, JSValueConst v)
+{
+    int tag = JS_VALUE_GET_TAG(v);
+    if (tag == JS_TAG_BIG_INT)
+        return TRUE;
+    if (is_bignum_mode(ctx))
+        return tag == JS_TAG_INT;
+    else
+        return FALSE;
+}
+
 static JSValue js_thisBigIntValue(JSContext *ctx, JSValueConst this_val)
 {
     if (JS_IsBigInt(ctx, this_val))
@@ -49181,6 +46589,8 @@ static JSValue js_thisBigIntValue(JSContext *ctx, JSValueConst this_val)
     if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
         JSObject *p = JS_VALUE_GET_OBJ(this_val);
         if (p->class_id == JS_CLASS_BIG_INT) {
+            /* XXX: may relax the check in case the object comes from
+               bignum mode */
             if (JS_IsBigInt(ctx, p->u.object_data))
                 return JS_DupValue(ctx, p->u.object_data);
         }
@@ -49201,11 +46611,14 @@ static JSValue js_bigint_toString(JSContext *ctx, JSValueConst this_val,
     if (argc == 0 || JS_IsUndefined(argv[0])) {
         base = 10;
     } else {
-        base = js_get_radix(ctx, argv[0]);
-        if (base < 0)
+        if (JS_ToInt32Sat(ctx, &base, argv[0]))
             goto fail;
+        if (base < 2 || base > 36) {
+            JS_ThrowRangeError(ctx, "radix must be between 2 and 36");
+            goto fail;
+        }
     }
-    ret = js_bigint_to_string1(ctx, val, base);
+    ret = js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
     JS_FreeValue(ctx, val);
     return ret;
  fail:
@@ -49219,103 +46632,79 @@ static JSValue js_bigint_valueOf(JSContext *ctx, JSValueConst this_val,
     return js_thisBigIntValue(ctx, this_val);
 }
 
-static JSValue js_bigint_div(JSContext *ctx,
+static JSValue js_integer_div(JSContext *ctx,
                               JSValueConst this_val,
                               int argc, JSValueConst *argv, int magic)
 {
-    bf_t a_s, b_s, *a, *b, *r, *q;
+    bf_t a_s, b_s, *a, *b, r_s, *r = &r_s, q_s, *q = &q_s;
     int status;
-    JSValue q_val, r_val;
-    
-    q_val = JS_NewBigInt(ctx);
-    if (JS_IsException(q_val))
-        return JS_EXCEPTION;
-    r_val = JS_NewBigInt(ctx);
-    if (JS_IsException(r_val))
-        goto fail;
+
     b = NULL;
     a = JS_ToBigInt(ctx, &a_s, argv[0]);
     if (!a)
-        goto fail;
+        return JS_EXCEPTION;
     b = JS_ToBigInt(ctx, &b_s, argv[1]);
     if (!b) {
         JS_FreeBigInt(ctx, a, &a_s);
-        goto fail;
+        return JS_EXCEPTION;
     }
-    q = JS_GetBigInt(q_val);
-    r = JS_GetBigInt(r_val);
+    bf_init(ctx->bf_ctx, q);
+    bf_init(ctx->bf_ctx, r);
     status = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ, magic & 0xf);
     JS_FreeBigInt(ctx, a, &a_s);
     JS_FreeBigInt(ctx, b, &b_s);
     if (unlikely(status)) {
+        bf_delete(q);
+        bf_delete(r);
         throw_bf_exception(ctx, status);
-        goto fail;
+        return JS_EXCEPTION;
     }
-    q_val = JS_CompactBigInt(ctx, q_val);
     if (magic & 0x10) {
         JSValue ret;
+        /* XXX: handle exceptions */
         ret = JS_NewArray(ctx);
-        if (JS_IsException(ret))
-            goto fail;
-        JS_SetPropertyUint32(ctx, ret, 0, q_val);
-        JS_SetPropertyUint32(ctx, ret, 1, JS_CompactBigInt(ctx, r_val));
+        JS_SetPropertyUint32(ctx, ret, 0, JS_NewBigInt(ctx, q));
+        JS_SetPropertyUint32(ctx, ret, 1, JS_NewBigInt(ctx, r));
         return ret;
     } else {
-        JS_FreeValue(ctx, r_val);
-        return q_val;
+        bf_delete(r);
+        return JS_NewBigInt(ctx, q);
     }
- fail:
-    JS_FreeValue(ctx, q_val);
-    JS_FreeValue(ctx, r_val);
-    return JS_EXCEPTION;
 }
 
-static JSValue js_bigint_sqrt(JSContext *ctx,
+static JSValue js_integer_sqrt(JSContext *ctx,
                                JSValueConst this_val,
                                int argc, JSValueConst *argv, int magic)
 {
-    bf_t a_s, *a, *r, *rem;
+    bf_t a_s, *a, r_s, *r = &r_s, rem_s, *rem = &rem_s;
     int status;
-    JSValue r_val, rem_val;
-    
-    r_val = JS_NewBigInt(ctx);
-    if (JS_IsException(r_val))
-        return JS_EXCEPTION;
-    rem_val = JS_NewBigInt(ctx);
-    if (JS_IsException(rem_val))
-        return JS_EXCEPTION;
-    r = JS_GetBigInt(r_val);
-    rem = JS_GetBigInt(rem_val);
 
     a = JS_ToBigInt(ctx, &a_s, argv[0]);
     if (!a)
-        goto fail;
+        return JS_EXCEPTION;
+    bf_init(ctx->bf_ctx, r);
+    bf_init(ctx->bf_ctx, rem);
     status = bf_sqrtrem(r, rem, a);
     JS_FreeBigInt(ctx, a, &a_s);
     if (unlikely(status & ~BF_ST_INEXACT)) {
-        throw_bf_exception(ctx, status);
-        goto fail;
+        bf_delete(r);
+        bf_delete(rem);
+        return throw_bf_exception(ctx, status);
     }
-    r_val = JS_CompactBigInt(ctx, r_val);
     if (magic) {
         JSValue ret;
+        /* XXX: handle exceptions */
         ret = JS_NewArray(ctx);
-        if (JS_IsException(ret))
-            goto fail;
-        JS_SetPropertyUint32(ctx, ret, 0, r_val);
-        JS_SetPropertyUint32(ctx, ret, 1, JS_CompactBigInt(ctx, rem_val));
+        JS_SetPropertyUint32(ctx, ret, 0, JS_NewBigInt(ctx, r));
+        JS_SetPropertyUint32(ctx, ret, 1, JS_NewBigInt(ctx, rem));
         return ret;
     } else {
-        JS_FreeValue(ctx, rem_val);
-        return r_val;
+        bf_delete(rem);
+        return JS_NewBigInt(ctx, r);
     }
- fail:
-    JS_FreeValue(ctx, r_val);
-    JS_FreeValue(ctx, rem_val);
-    return JS_EXCEPTION;
 }
 
-static JSValue js_bigint_op1(JSContext *ctx,
+static JSValue js_integer_op1(JSContext *ctx,
                               JSValueConst this_val,
                               int argc, JSValueConst *argv,
                               int magic)
@@ -49345,30 +46734,24 @@ static JSValue js_bigint_op1(JSContext *ctx,
         abort();
     }
     JS_FreeBigInt(ctx, a, &a_s);
-    return JS_NewBigInt64(ctx, res);
+    return JS_NewInt64(ctx, res);
 }
 
-static JSValue js_bigint_asUintN(JSContext *ctx,
+static JSValue js_integer_asUintN(JSContext *ctx,
                                   JSValueConst this_val,
                                   int argc, JSValueConst *argv, int asIntN)
 {
     uint64_t bits;
-    bf_t a_s, *a = &a_s, *r, mask_s, *mask = &mask_s;
-    JSValue res;
-    
+    bf_t a_s, *a = &a_s, r_s, *r = &r_s, mask_s, *mask = &mask_s;
+    BOOL is_legacy;
+
     if (JS_ToIndex(ctx, &bits, argv[0]))
         return JS_EXCEPTION;
-    res = JS_NewBigInt(ctx);
-    if (JS_IsException(res))
-        return JS_EXCEPTION;
-    r = JS_GetBigInt(res);
     a = JS_ToBigInt(ctx, &a_s, argv[1]);
-    if (!a) {
-        JS_FreeValue(ctx, res);
+    if (!a)
         return JS_EXCEPTION;
-    }
     /* XXX: optimize */
-    r = JS_GetBigInt(res);
+    bf_init(ctx->bf_ctx, r);
     bf_init(ctx->bf_ctx, mask);
     bf_set_ui(mask, 1);
     bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);
@@ -49385,25 +46768,25 @@ static JSValue js_bigint_asUintN(JSContext *ctx,
     }
     bf_delete(mask);
     JS_FreeBigInt(ctx, a, &a_s);
-    return JS_CompactBigInt(ctx, res);
-}
-
-static const JSCFunctionListEntry js_bigint_funcs[] = {
-    JS_CFUNC_MAGIC_DEF("asUintN", 2, js_bigint_asUintN, 0 ),
-    JS_CFUNC_MAGIC_DEF("asIntN", 2, js_bigint_asUintN, 1 ),
-    /* QuickJS extensions */
-    JS_CFUNC_MAGIC_DEF("tdiv", 2, js_bigint_div, BF_RNDZ ),
-    JS_CFUNC_MAGIC_DEF("fdiv", 2, js_bigint_div, BF_RNDD ),
-    JS_CFUNC_MAGIC_DEF("cdiv", 2, js_bigint_div, BF_RNDU ),
-    JS_CFUNC_MAGIC_DEF("ediv", 2, js_bigint_div, BF_DIVREM_EUCLIDIAN ),
-    JS_CFUNC_MAGIC_DEF("tdivrem", 2, js_bigint_div, BF_RNDZ | 0x10 ),
-    JS_CFUNC_MAGIC_DEF("fdivrem", 2, js_bigint_div, BF_RNDD | 0x10 ),
-    JS_CFUNC_MAGIC_DEF("cdivrem", 2, js_bigint_div, BF_RNDU | 0x10 ),
-    JS_CFUNC_MAGIC_DEF("edivrem", 2, js_bigint_div, BF_DIVREM_EUCLIDIAN | 0x10 ),
-    JS_CFUNC_MAGIC_DEF("sqrt", 1, js_bigint_sqrt, 0 ),
-    JS_CFUNC_MAGIC_DEF("sqrtrem", 1, js_bigint_sqrt, 1 ),
-    JS_CFUNC_MAGIC_DEF("floorLog2", 1, js_bigint_op1, 0 ),
-    JS_CFUNC_MAGIC_DEF("ctz", 1, js_bigint_op1, 1 ),
+    is_legacy = is_bignum_mode(ctx) ^ 1;
+    return JS_NewBigInt2(ctx, r, is_legacy);
+}
+
+static const JSCFunctionListEntry js_integer_funcs[] = {
+    JS_CFUNC_MAGIC_DEF("tdiv", 2, js_integer_div, BF_RNDZ ),
+    JS_CFUNC_MAGIC_DEF("fdiv", 2, js_integer_div, BF_RNDD ),
+    JS_CFUNC_MAGIC_DEF("cdiv", 2, js_integer_div, BF_RNDU ),
+    JS_CFUNC_MAGIC_DEF("ediv", 2, js_integer_div, BF_DIVREM_EUCLIDIAN ),
+    JS_CFUNC_MAGIC_DEF("tdivrem", 2, js_integer_div, BF_RNDZ | 0x10 ),
+    JS_CFUNC_MAGIC_DEF("fdivrem", 2, js_integer_div, BF_RNDD | 0x10 ),
+    JS_CFUNC_MAGIC_DEF("cdivrem", 2, js_integer_div, BF_RNDU | 0x10 ),
+    JS_CFUNC_MAGIC_DEF("edivrem", 2, js_integer_div, BF_DIVREM_EUCLIDIAN | 0x10 ),
+    JS_CFUNC_MAGIC_DEF("sqrt", 1, js_integer_sqrt, 0 ),
+    JS_CFUNC_MAGIC_DEF("sqrtrem", 1, js_integer_sqrt, 1 ),
+    JS_CFUNC_MAGIC_DEF("floorLog2", 1, js_integer_op1, 0 ),
+    JS_CFUNC_MAGIC_DEF("ctz", 1, js_integer_op1, 1 ),
+    JS_CFUNC_MAGIC_DEF("asUintN", 2, js_integer_asUintN, 0 ),
+    JS_CFUNC_MAGIC_DEF("asIntN", 2, js_integer_asUintN, 1 ),
 };
 
 static const JSCFunctionListEntry js_bigint_proto_funcs[] = {
@@ -49412,29 +46795,6 @@ static const JSCFunctionListEntry js_bigint_proto_funcs[] = {
     JS_PROP_STRING_DEF("[Symbol.toStringTag]", "BigInt", JS_PROP_CONFIGURABLE ),
 };
 
-void JS_AddIntrinsicBigInt(JSContext *ctx)
-{
-    JSRuntime *rt = ctx->rt;
-    JSValueConst obj1;
-
-    rt->bigint_ops.to_string = js_bigint_to_string;
-    rt->bigint_ops.from_string = js_string_to_bigint;
-    rt->bigint_ops.unary_arith = js_unary_arith_bigint;
-    rt->bigint_ops.binary_arith = js_binary_arith_bigint;
-    rt->bigint_ops.compare = js_compare_bigfloat;
-    
-    ctx->class_proto[JS_CLASS_BIG_INT] = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
-                               js_bigint_proto_funcs,
-                               countof(js_bigint_proto_funcs));
-    obj1 = JS_NewGlobalCConstructor(ctx, "BigInt", js_bigint_constructor, 1,
-                                    ctx->class_proto[JS_CLASS_BIG_INT]);
-    JS_SetPropertyFunctionList(ctx, obj1, js_bigint_funcs,
-                               countof(js_bigint_funcs));
-}
-
-/* BigFloat */
-
 static JSValue js_thisBigFloatValue(JSContext *ctx, JSValueConst this_val)
 {
     if (JS_IsBigFloat(this_val))
@@ -49463,9 +46823,12 @@ static JSValue js_bigfloat_toString(JSContext *ctx, JSValueConst this_val,
     if (argc == 0 || JS_IsUndefined(argv[0])) {
         base = 10;
     } else {
-        base = js_get_radix(ctx, argv[0]);
-        if (base < 0)
+        if (JS_ToInt32Sat(ctx, &base, argv[0]))
             goto fail;
+        if (base < 2 || base > 36) {
+            JS_ThrowRangeError(ctx, "radix must be between 2 and 36");
+            goto fail;
+        }
     }
     ret = js_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
     JS_FreeValue(ctx, val);
@@ -49481,184 +46844,24 @@ static JSValue js_bigfloat_valueOf(JSContext *ctx, JSValueConst this_val,
     return js_thisBigFloatValue(ctx, this_val);
 }
 
-static int bigfloat_get_rnd_mode(JSContext *ctx, JSValueConst val)
-{
-    int rnd_mode;
-    if (JS_ToInt32Sat(ctx, &rnd_mode, val))
-        return -1;
-    if (rnd_mode < BF_RNDN || rnd_mode > BF_RNDF) {
-        JS_ThrowRangeError(ctx, "invalid rounding mode");
-        return -1;
-    }
-    return rnd_mode;
-}
-
-static JSValue js_bigfloat_toFixed(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSValue val, ret;
-    int64_t f;
-    int rnd_mode, radix;
-
-    val = js_thisBigFloatValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    if (JS_ToInt64Sat(ctx, &f, argv[0]))
-        goto fail;
-    if (f < 0 || f > BF_PREC_MAX) {
-        JS_ThrowRangeError(ctx, "invalid number of digits");
-        goto fail;
-    }
-    rnd_mode = BF_RNDNA;
-    radix = 10;
-    /* XXX: swap parameter order for rounding mode and radix */
-    if (argc > 1) {
-        rnd_mode = bigfloat_get_rnd_mode(ctx, argv[1]);
-        if (rnd_mode < 0)
-            goto fail;
-    }
-    if (argc > 2) {
-        radix = js_get_radix(ctx, argv[2]);
-        if (radix < 0)
-            goto fail;
-    }
-    ret = js_ftoa(ctx, val, radix, f, rnd_mode | BF_FTOA_FORMAT_FRAC);
-    JS_FreeValue(ctx, val);
-    return ret;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
-}
-
-static BOOL js_bigfloat_is_finite(JSContext *ctx, JSValueConst val)
-{
-    BOOL res;
-    uint32_t tag;
-
-    tag = JS_VALUE_GET_NORM_TAG(val);
-    switch(tag) {
-    case JS_TAG_BIG_FLOAT:
-        {
-            JSBigFloat *p = JS_VALUE_GET_PTR(val);
-            res = bf_is_finite(&p->num);
-        }
-        break;
-    default:
-        res = FALSE;
-        break;
-    }
-    return res;
-}
-
-static JSValue js_bigfloat_toExponential(JSContext *ctx, JSValueConst this_val,
-                                       int argc, JSValueConst *argv)
-{
-    JSValue val, ret;
-    int64_t f;
-    int rnd_mode, radix;
-
-    val = js_thisBigFloatValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    if (JS_ToInt64Sat(ctx, &f, argv[0]))
-        goto fail;
-    if (!js_bigfloat_is_finite(ctx, val)) {
-        ret = JS_ToString(ctx, val);
-    } else if (JS_IsUndefined(argv[0])) {
-        ret = js_ftoa(ctx, val, 10, 0,
-                      BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);
-    } else {
-        if (f < 0 || f > BF_PREC_MAX) {
-            JS_ThrowRangeError(ctx, "invalid number of digits");
-            goto fail;
-        }
-        rnd_mode = BF_RNDNA;
-        radix = 10;
-        if (argc > 1) {
-            rnd_mode = bigfloat_get_rnd_mode(ctx, argv[1]);
-            if (rnd_mode < 0)
-                goto fail;
-        }
-        if (argc > 2) {
-            radix = js_get_radix(ctx, argv[2]);
-            if (radix < 0)
-                goto fail;
-        }
-        ret = js_ftoa(ctx, val, radix, f + 1,
-                      rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);
-    }
-    JS_FreeValue(ctx, val);
-    return ret;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_bigfloat_toPrecision(JSContext *ctx, JSValueConst this_val,
-                                     int argc, JSValueConst *argv)
-{
-    JSValue val, ret;
-    int64_t p;
-    int rnd_mode, radix;
-
-    val = js_thisBigFloatValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    if (JS_IsUndefined(argv[0]))
-        goto to_string;
-    if (JS_ToInt64Sat(ctx, &p, argv[0]))
-        goto fail;
-    if (!js_bigfloat_is_finite(ctx, val)) {
-    to_string:
-        ret = JS_ToString(ctx, this_val);
-    } else {
-        if (p < 1 || p > BF_PREC_MAX) {
-            JS_ThrowRangeError(ctx, "invalid number of digits");
-            goto fail;
-        }
-        rnd_mode = BF_RNDNA;
-        radix = 10;
-        if (argc > 1) {
-            rnd_mode = bigfloat_get_rnd_mode(ctx, argv[1]);
-            if (rnd_mode < 0)
-                goto fail;
-        }
-        if (argc > 2) {
-            radix = js_get_radix(ctx, argv[2]);
-            if (radix < 0)
-                goto fail;
-        }
-        ret = js_ftoa(ctx, val, radix, p, rnd_mode | BF_FTOA_FORMAT_FIXED);
-    }
-    JS_FreeValue(ctx, val);
-    return ret;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
-}
-
 static const JSCFunctionListEntry js_bigfloat_proto_funcs[] = {
     JS_CFUNC_DEF("toString", 0, js_bigfloat_toString ),
     JS_CFUNC_DEF("valueOf", 0, js_bigfloat_valueOf ),
-    JS_CFUNC_DEF("toPrecision", 1, js_bigfloat_toPrecision ),
-    JS_CFUNC_DEF("toFixed", 1, js_bigfloat_toFixed ),
-    JS_CFUNC_DEF("toExponential", 1, js_bigfloat_toExponential ),
+    JS_CFUNC_MAGIC_DEF("toPrecision", 1, js_number_toPrecision, 1 ),
+    JS_CFUNC_MAGIC_DEF("toFixed", 1, js_number_toFixed, 1 ),
+    JS_CFUNC_MAGIC_DEF("toExponential", 1, js_number_toExponential, 1 ),
 };
 
 static JSValue js_bigfloat_constructor(JSContext *ctx,
-                                       JSValueConst new_target,
+                                       JSValueConst this_val,
                                        int argc, JSValueConst *argv)
 {
     JSValue val;
-    if (!JS_IsUndefined(new_target))
-        return JS_ThrowTypeError(ctx, "not a constructor");
     if (argc == 0) {
-        bf_t *r;
-        val = JS_NewBigFloat(ctx);
-        if (JS_IsException(val))
-            return val;
-        r = JS_GetBigFloat(val);
+        bf_t r_s, *r = &r_s;
+        bf_init(ctx->bf_ctx, r);
         bf_set_zero(r, 0);
+        val = JS_NewBigFloat(ctx, r);
     } else {
         val = JS_DupValue(ctx, argv[0]);
     redo:
@@ -49667,26 +46870,18 @@ static JSValue js_bigfloat_constructor(JSContext *ctx,
             break;
         case JS_TAG_FLOAT64:
             {
-                bf_t *r;
-                double d = JS_VALUE_GET_FLOAT64(val);
-                val = JS_NewBigFloat(ctx);
-                if (JS_IsException(val))
-                    break;
-                r = JS_GetBigFloat(val);
-                if (bf_set_float64(r, d))
-                    goto fail;
+                bf_t r_s, *r = &r_s;
+                bf_init(ctx->bf_ctx, r);
+                bf_set_float64(r, JS_VALUE_GET_FLOAT64(val));
+                val = JS_NewBigFloat(ctx, r);
             }
             break;
         case JS_TAG_INT:
             {
-                bf_t *r;
-                int32_t v = JS_VALUE_GET_INT(val);
-                val = JS_NewBigFloat(ctx);
-                if (JS_IsException(val))
-                    break;
-                r = JS_GetBigFloat(val);
-                if (bf_set_si(r, v))
-                    goto fail;
+                bf_t r_s, *r = &r_s;
+                bf_init(ctx->bf_ctx, r);
+                bf_set_si(r, JS_VALUE_GET_INT(val));
+                val = JS_NewBigFloat(ctx, r);
             }
             break;
         case JS_TAG_BIG_INT:
@@ -49696,42 +46891,20 @@ static JSValue js_bigfloat_constructor(JSContext *ctx,
                 val = JS_MKPTR(JS_TAG_BIG_FLOAT, p);
             }
             break;
-        case JS_TAG_BIG_DECIMAL:
-            val = JS_ToStringFree(ctx, val);
-            if (JS_IsException(val))
-                break;
-            goto redo;
         case JS_TAG_STRING:
             {
                 const char *str, *p;
-                size_t len;
                 int err;
 
-                str = JS_ToCStringLen(ctx, &len, val);
+                str = JS_ToCString(ctx, val);
                 JS_FreeValue(ctx, val);
                 if (!str)
                     return JS_EXCEPTION;
-                p = str;
+                val = js_atof(ctx, str, &p, 0, BF_ATOF_BIN_OCT |
+                              BF_ATOF_NO_PREFIX_AFTER_SIGN |
+                              BF_ATOF_JS_QUIRKS);
                 p += skip_spaces(p);
-                if ((p - str) == len) {
-                    bf_t *r;
-                    val = JS_NewBigFloat(ctx);
-                    if (JS_IsException(val))
-                        break;
-                    r = JS_GetBigFloat(val);
-                    bf_set_zero(r, 0);
-                    err = 0;
-                } else {
-                    val = js_atof(ctx, p, &p, 0, ATOD_ACCEPT_BIN_OCT |
-                                  ATOD_TYPE_BIG_FLOAT |
-                                  ATOD_ACCEPT_PREFIX_AFTER_SIGN);
-                    if (JS_IsException(val)) {
-                        JS_FreeCString(ctx, str);
-                        return JS_EXCEPTION;
-                    }
-                    p += skip_spaces(p);
-                    err = ((p - str) != len);
-                }
+                err = (*p != '\0');
                 JS_FreeCString(ctx, str);
                 if (err) {
                     JS_FreeValue(ctx, val);
@@ -49752,20 +46925,13 @@ static JSValue js_bigfloat_constructor(JSContext *ctx,
         }
     }
     return val;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
 }
 
-static JSValue js_bigfloat_get_const(JSContext *ctx,
-                                     JSValueConst this_val, int magic)
+static JSValue js_float_get_const(JSContext *ctx,
+                                  JSValueConst this_val, int magic)
 {
-    bf_t *r;
-    JSValue val;
-    val = JS_NewBigFloat(ctx);
-    if (JS_IsException(val))
-        return val;
-    r = JS_GetBigFloat(val);
+    bf_t r_s, *r = &r_s;
+    bf_init(ctx->bf_ctx, r);
     switch(magic) {
     case 0: /* PI */
         bf_const_pi(r, ctx->fp_env.prec, ctx->fp_env.flags);
@@ -49801,13 +46967,13 @@ static JSValue js_bigfloat_get_const(JSContext *ctx,
     default:
         abort();
     }
-    return val;
+    return JS_NewBigFloat(ctx, r);
 }
 
-static JSValue js_bigfloat_parseFloat(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv)
+static JSValue js_float_parseFloat(JSContext *ctx, JSValueConst this_val,
+                                   int argc, JSValueConst *argv)
 {
-    bf_t *a;
+    bf_t a_s, *a = &a_s;
     const char *str;
     JSValue ret;
     int radix;
@@ -49831,268 +46997,44 @@ static JSValue js_bigfloat_parseFloat(JSContext *ctx, JSValueConst this_val,
         if (!fe)
             goto fail;
     }
-    ret = JS_NewBigFloat(ctx);
-    if (JS_IsException(ret))
-        goto done;
-    a = JS_GetBigFloat(ret);
-    /* XXX: use js_atof() */
-    bf_atof(a, str, NULL, radix, fe->prec, fe->flags);
- done:
+    bf_init(ctx->bf_ctx, a);
+    bf_atof(a, str, NULL, radix, fe->prec, BF_ATOF_JS_QUIRKS | fe->flags);
+    ret = JS_NewBigFloat(ctx, a);
     JS_FreeCString(ctx, str);
     return ret;
 }
 
-static JSValue js_bigfloat_isFinite(JSContext *ctx, JSValueConst this_val,
-                                    int argc, JSValueConst *argv)
-{
-    JSValueConst val = argv[0];
-    JSBigFloat *p;
-    
-    if (JS_VALUE_GET_NORM_TAG(val) != JS_TAG_BIG_FLOAT)
-        return JS_FALSE;
-    p = JS_VALUE_GET_PTR(val);
-    return JS_NewBool(ctx, bf_is_finite(&p->num));
-}
-
-static JSValue js_bigfloat_isNaN(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSValueConst val = argv[0];
-    JSBigFloat *p;
-    
-    if (JS_VALUE_GET_NORM_TAG(val) != JS_TAG_BIG_FLOAT)
-        return JS_FALSE;
-    p = JS_VALUE_GET_PTR(val);
-    return JS_NewBool(ctx, bf_is_nan(&p->num));
-}
-
-enum {
-    MATH_OP_ABS,
-    MATH_OP_FLOOR,
-    MATH_OP_CEIL,
-    MATH_OP_ROUND,
-    MATH_OP_TRUNC,
-    MATH_OP_SQRT,
-    MATH_OP_FPROUND,
-    MATH_OP_ACOS,
-    MATH_OP_ASIN,
-    MATH_OP_ATAN,
-    MATH_OP_ATAN2,
-    MATH_OP_COS,
-    MATH_OP_EXP,
-    MATH_OP_LOG,
-    MATH_OP_POW,
-    MATH_OP_SIN,
-    MATH_OP_TAN,
-    MATH_OP_FMOD,
-    MATH_OP_REM,
-    MATH_OP_SIGN,
-
-    MATH_OP_ADD,
-    MATH_OP_SUB,
-    MATH_OP_MUL,
-    MATH_OP_DIV,
-};
-
-static JSValue js_bigfloat_fop(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv, int magic)
-{
-    bf_t a_s, *a, *r;
-    JSFloatEnv *fe;
-    int rnd_mode;
-    JSValue op1, res;
-
-    op1 = JS_ToNumeric(ctx, argv[0]);
-    if (JS_IsException(op1))
-        return op1;
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    fe = &ctx->fp_env;
-    if (argc > 1) {
-        fe = JS_GetOpaque2(ctx, argv[1], JS_CLASS_FLOAT_ENV);
-        if (!fe)
-            goto fail;
-    }
-    res = JS_NewBigFloat(ctx);
-    if (JS_IsException(res)) {
-    fail:
-        if (a == &a_s)
-            bf_delete(a);
-        JS_FreeValue(ctx, op1);
-        return JS_EXCEPTION;
-    }
-    r = JS_GetBigFloat(res);
-    switch (magic) {
-    case MATH_OP_ABS:
-        bf_set(r, a);
-        r->sign = 0;
-        break;
-    case MATH_OP_FLOOR:
-        rnd_mode = BF_RNDD;
-        goto rint;
-    case MATH_OP_CEIL:
-        rnd_mode = BF_RNDU;
-        goto rint;
-    case MATH_OP_ROUND:
-        rnd_mode = BF_RNDNA;
-        goto rint;
-    case MATH_OP_TRUNC:
-        rnd_mode = BF_RNDZ;
-    rint:
-        bf_set(r, a);
-        fe->status |= bf_rint(r, rnd_mode);
-        break;
-    case MATH_OP_SQRT:
-        fe->status |= bf_sqrt(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_FPROUND:
-        bf_set(r, a);
-        fe->status |= bf_round(r, fe->prec, fe->flags);
-        break;
-    case MATH_OP_ACOS:
-        fe->status |= bf_acos(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_ASIN:
-        fe->status |= bf_asin(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_ATAN:
-        fe->status |= bf_atan(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_COS:
-        fe->status |= bf_cos(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_EXP:
-        fe->status |= bf_exp(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_LOG:
-        fe->status |= bf_log(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_SIN:
-        fe->status |= bf_sin(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_TAN:
-        fe->status |= bf_tan(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_SIGN:
-        if (bf_is_nan(a) || bf_is_zero(a)) {
-            bf_set(r, a);
-        } else {
-            bf_set_si(r, 1 - 2 * a->sign);
-        }
-        break;
-    default:
-        abort();
-    }
-    if (a == &a_s)
-        bf_delete(a);
-    JS_FreeValue(ctx, op1);
-    return res;
-}
-
-static JSValue js_bigfloat_fop2(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv, int magic)
-{
-    bf_t a_s, *a, b_s, *b, r_s, *r = &r_s;
-    JSFloatEnv *fe;
-    JSValue op1, op2, res;
-
-    op1 = JS_ToNumeric(ctx, argv[0]);
-    if (JS_IsException(op1))
-        return op1;
-    op2 = JS_ToNumeric(ctx, argv[1]);
-    if (JS_IsException(op2)) {
-        JS_FreeValue(ctx, op1);
-        return op2;
-    }
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    b = JS_ToBigFloat(ctx, &b_s, op2);
-    fe = &ctx->fp_env;
-    if (argc > 2) {
-        fe = JS_GetOpaque2(ctx, argv[2], JS_CLASS_FLOAT_ENV);
-        if (!fe)
-            goto fail;
-    }
-    res = JS_NewBigFloat(ctx);
-    if (JS_IsException(res)) {
-    fail:
-        if (a == &a_s)
-            bf_delete(a);
-        if (b == &b_s)
-            bf_delete(b);
-        JS_FreeValue(ctx, op1);
-        JS_FreeValue(ctx, op2);
-        return JS_EXCEPTION;
-    }
-    r = JS_GetBigFloat(res);
-    switch (magic) {
-    case MATH_OP_ATAN2:
-        fe->status |= bf_atan2(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_POW:
-        fe->status |= bf_pow(r, a, b, fe->prec, fe->flags | BF_POW_JS_QUIRKS);
-        break;
-    case MATH_OP_FMOD:
-        fe->status |= bf_rem(r, a, b, fe->prec, fe->flags, BF_RNDZ);
-        break;
-    case MATH_OP_REM:
-        fe->status |= bf_rem(r, a, b, fe->prec, fe->flags, BF_RNDN);
-        break;
-    case MATH_OP_ADD:
-        fe->status |= bf_add(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_SUB:
-        fe->status |= bf_sub(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_MUL:
-        fe->status |= bf_mul(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_DIV:
-        fe->status |= bf_div(r, a, b, fe->prec, fe->flags);
-        break;
-    default:
-        abort();
-    }
-    if (a == &a_s)
-        bf_delete(a);
-    if (b == &b_s)
-        bf_delete(b);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    return res;
-}
-
 static const JSCFunctionListEntry js_bigfloat_funcs[] = {
-    JS_CGETSET_MAGIC_DEF("PI", js_bigfloat_get_const, NULL, 0 ),
-    JS_CGETSET_MAGIC_DEF("LN2", js_bigfloat_get_const, NULL, 1 ),
-    JS_CGETSET_MAGIC_DEF("MIN_VALUE", js_bigfloat_get_const, NULL, 2 ),
-    JS_CGETSET_MAGIC_DEF("MAX_VALUE", js_bigfloat_get_const, NULL, 3 ),
-    JS_CGETSET_MAGIC_DEF("EPSILON", js_bigfloat_get_const, NULL, 4 ),
-    JS_CFUNC_DEF("parseFloat", 1, js_bigfloat_parseFloat ),
-    JS_CFUNC_DEF("isFinite", 1, js_bigfloat_isFinite ),
-    JS_CFUNC_DEF("isNaN", 1, js_bigfloat_isNaN ),
-    JS_CFUNC_MAGIC_DEF("abs", 1, js_bigfloat_fop, MATH_OP_ABS ),
-    JS_CFUNC_MAGIC_DEF("fpRound", 1, js_bigfloat_fop, MATH_OP_FPROUND ),
-    JS_CFUNC_MAGIC_DEF("floor", 1, js_bigfloat_fop, MATH_OP_FLOOR ),
-    JS_CFUNC_MAGIC_DEF("ceil", 1, js_bigfloat_fop, MATH_OP_CEIL ),
-    JS_CFUNC_MAGIC_DEF("round", 1, js_bigfloat_fop, MATH_OP_ROUND ),
-    JS_CFUNC_MAGIC_DEF("trunc", 1, js_bigfloat_fop, MATH_OP_TRUNC ),
-    JS_CFUNC_MAGIC_DEF("sqrt", 1, js_bigfloat_fop, MATH_OP_SQRT ),
-    JS_CFUNC_MAGIC_DEF("acos", 1, js_bigfloat_fop, MATH_OP_ACOS ),
-    JS_CFUNC_MAGIC_DEF("asin", 1, js_bigfloat_fop, MATH_OP_ASIN ),
-    JS_CFUNC_MAGIC_DEF("atan", 1, js_bigfloat_fop, MATH_OP_ATAN ),
-    JS_CFUNC_MAGIC_DEF("atan2", 2, js_bigfloat_fop2, MATH_OP_ATAN2 ),
-    JS_CFUNC_MAGIC_DEF("cos", 1, js_bigfloat_fop, MATH_OP_COS ),
-    JS_CFUNC_MAGIC_DEF("exp", 1, js_bigfloat_fop, MATH_OP_EXP ),
-    JS_CFUNC_MAGIC_DEF("log", 1, js_bigfloat_fop, MATH_OP_LOG ),
-    JS_CFUNC_MAGIC_DEF("pow", 2, js_bigfloat_fop2, MATH_OP_POW ),
-    JS_CFUNC_MAGIC_DEF("sin", 1, js_bigfloat_fop, MATH_OP_SIN ),
-    JS_CFUNC_MAGIC_DEF("tan", 1, js_bigfloat_fop, MATH_OP_TAN ),
-    JS_CFUNC_MAGIC_DEF("sign", 1, js_bigfloat_fop, MATH_OP_SIGN ),
-    JS_CFUNC_MAGIC_DEF("add", 2, js_bigfloat_fop2, MATH_OP_ADD ),
-    JS_CFUNC_MAGIC_DEF("sub", 2, js_bigfloat_fop2, MATH_OP_SUB ),
-    JS_CFUNC_MAGIC_DEF("mul", 2, js_bigfloat_fop2, MATH_OP_MUL ),
-    JS_CFUNC_MAGIC_DEF("div", 2, js_bigfloat_fop2, MATH_OP_DIV ),
-    JS_CFUNC_MAGIC_DEF("fmod", 2, js_bigfloat_fop2, MATH_OP_FMOD ),
-    JS_CFUNC_MAGIC_DEF("remainder", 2, js_bigfloat_fop2, MATH_OP_REM ),
+    JS_CGETSET_MAGIC_DEF("PI", js_float_get_const, NULL, 0 ),
+    JS_CGETSET_MAGIC_DEF("LN2", js_float_get_const, NULL, 1 ),
+    JS_CGETSET_MAGIC_DEF("MIN_VALUE", js_float_get_const, NULL, 2 ),
+    JS_CGETSET_MAGIC_DEF("MAX_VALUE", js_float_get_const, NULL, 3 ),
+    JS_CGETSET_MAGIC_DEF("EPSILON", js_float_get_const, NULL, 4 ),
+    JS_CFUNC_DEF("parseFloat", 1, js_float_parseFloat ),
+    JS_CFUNC_MAGIC_DEF("abs", 1, js_math_fop, MATH_OP_ABS ),
+    JS_CFUNC_MAGIC_DEF("fpRound", 1, js_math_fop, MATH_OP_FPROUND ),
+    JS_CFUNC_MAGIC_DEF("floor", 1, js_math_fop, MATH_OP_FLOOR ),
+    JS_CFUNC_MAGIC_DEF("ceil", 1, js_math_fop, MATH_OP_CEIL ),
+    JS_CFUNC_MAGIC_DEF("round", 1, js_math_fop, MATH_OP_ROUND ),
+    JS_CFUNC_MAGIC_DEF("trunc", 1, js_math_fop, MATH_OP_TRUNC ),
+    JS_CFUNC_MAGIC_DEF("sqrt", 1, js_math_fop, MATH_OP_SQRT ),
+    JS_CFUNC_MAGIC_DEF("acos", 1, js_math_fop, MATH_OP_ACOS ),
+    JS_CFUNC_MAGIC_DEF("asin", 1, js_math_fop, MATH_OP_ASIN ),
+    JS_CFUNC_MAGIC_DEF("atan", 1, js_math_fop, MATH_OP_ATAN ),
+    JS_CFUNC_MAGIC_DEF("atan2", 2, js_math_fop2, MATH_OP_ATAN2 ),
+    JS_CFUNC_MAGIC_DEF("cos", 1, js_math_fop, MATH_OP_COS ),
+    JS_CFUNC_MAGIC_DEF("exp", 1, js_math_fop, MATH_OP_EXP ),
+    JS_CFUNC_MAGIC_DEF("log", 1, js_math_fop, MATH_OP_LOG ),
+    JS_CFUNC_MAGIC_DEF("pow", 2, js_math_fop2, MATH_OP_POW ),
+    JS_CFUNC_MAGIC_DEF("sin", 1, js_math_fop, MATH_OP_SIN ),
+    JS_CFUNC_MAGIC_DEF("tan", 1, js_math_fop, MATH_OP_TAN ),
+    JS_CFUNC_MAGIC_DEF("sign", 1, js_math_fop, MATH_OP_SIGN ),
+    JS_CFUNC_MAGIC_DEF("add", 2, js_math_fop2, MATH_OP_ADD ),
+    JS_CFUNC_MAGIC_DEF("sub", 2, js_math_fop2, MATH_OP_SUB ),
+    JS_CFUNC_MAGIC_DEF("mul", 2, js_math_fop2, MATH_OP_MUL ),
+    JS_CFUNC_MAGIC_DEF("div", 2, js_math_fop2, MATH_OP_DIV ),
+    JS_CFUNC_MAGIC_DEF("fmod", 2, js_math_fop2, MATH_OP_FMOD ),
+    JS_CFUNC_MAGIC_DEF("remainder", 2, js_math_fop2, MATH_OP_REM ),
 };
 
 /* FloatEnv */
@@ -50152,6 +47094,9 @@ static JSValue js_float_env_get_expBits(JSContext *ctx, JSValueConst this_val)
     return JS_NewInt32(ctx, bf_get_exp_bits(ctx->fp_env.flags));
 }
 
+/* temporary fix for string conversion overflows */
+#define BF_EXP_BITS_MAX1 (BF_EXP_BITS_MAX - 1)
+
 static JSValue js_float_env_setPrec(JSContext *ctx,
                                     JSValueConst this_val,
                                     int argc, JSValueConst *argv)
@@ -50167,16 +47112,18 @@ static JSValue js_float_env_setPrec(JSContext *ctx,
         return JS_EXCEPTION;
     if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
         return JS_ThrowRangeError(ctx, "invalid precision");
-    exp_bits = BF_EXP_BITS_MAX;
+    exp_bits = BF_EXP_BITS_MAX1;
 
     if (argc > 2 && !JS_IsUndefined(argv[2])) {
         if (JS_ToInt32Sat(ctx, &exp_bits, argv[2]))
             return JS_EXCEPTION;
-        if (exp_bits < BF_EXP_BITS_MIN || exp_bits > BF_EXP_BITS_MAX)
+        if (exp_bits < BF_EXP_BITS_MIN || exp_bits > BF_EXP_BITS_MAX1)
             return JS_ThrowRangeError(ctx, "invalid number of exponent bits");
     }
 
-    flags = BF_RNDN | BF_FLAG_SUBNORMAL | bf_set_exp_bits(exp_bits);
+    flags = BF_RNDN | bf_set_exp_bits(exp_bits);
+    if (exp_bits != BF_EXP_BITS_MAX1)
+        flags |= BF_FLAG_SUBNORMAL;
 
     saved_prec = ctx->fp_env.prec;
     saved_flags = ctx->fp_env.flags;
@@ -50216,7 +47163,7 @@ static JSValue js_float_env_proto_get_status(JSContext *ctx, JSValueConst this_v
     }
 }
 
-static JSValue js_float_env_proto_set_status(JSContext *ctx, JSValueConst this_val, JSValueConst val, int magic)
+static JSValue js_float_env_proto_set_status(JSContext *ctx, JSValueConst this_val, JSValue val, int magic)
 {
     JSFloatEnv *fe;
     int b;
@@ -50236,20 +47183,24 @@ static JSValue js_float_env_proto_set_status(JSContext *ctx, JSValueConst this_v
     case FE_EXP:
         if (JS_ToInt32Sat(ctx, &b, val))
             return JS_EXCEPTION;
-        if (b < BF_EXP_BITS_MIN || b > BF_EXP_BITS_MAX)
+        if (b < BF_EXP_BITS_MIN || b > BF_EXP_BITS_MAX1)
             return JS_ThrowRangeError(ctx, "invalid number of exponent bits");
+        if (b == BF_EXP_BITS_MAX1)
+            fe->flags &= ~BF_FLAG_SUBNORMAL;
         fe->flags = (fe->flags & ~(BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT)) |
             bf_set_exp_bits(b);
         break;
     case FE_RNDMODE:
-        b = bigfloat_get_rnd_mode(ctx, val);
+        b = get_rnd_mode(ctx, val);
         if (b < 0)
             return JS_EXCEPTION;
         fe->flags = (fe->flags & ~BF_RND_MASK) | b;
         break;
     case FE_SUBNORMAL:
         b = JS_ToBool(ctx, val);
-        fe->flags = (fe->flags & ~BF_FLAG_SUBNORMAL) | (b ? BF_FLAG_SUBNORMAL: 0);
+        if (bf_get_exp_bits(fe->flags) != BF_EXP_BITS_MAX1) {
+            fe->flags = (fe->flags & ~BF_FLAG_SUBNORMAL) | (b ? BF_FLAG_SUBNORMAL: 0);
+        }
         break;
     default:
         b = JS_ToBool(ctx, val);
@@ -50279,12 +47230,12 @@ static const JSCFunctionListEntry js_float_env_funcs[] = {
     JS_PROP_INT32_DEF("RNDU", BF_RNDU, 0 ),
     JS_PROP_INT32_DEF("RNDD", BF_RNDD, 0 ),
     JS_PROP_INT32_DEF("RNDNA", BF_RNDNA, 0 ),
-    JS_PROP_INT32_DEF("RNDA", BF_RNDA, 0 ),
+    JS_PROP_INT32_DEF("RNDNU", BF_RNDNU, 0 ),
     JS_PROP_INT32_DEF("RNDF", BF_RNDF, 0 ),
     JS_PROP_INT32_DEF("precMin", BF_PREC_MIN, 0 ),
     JS_PROP_INT64_DEF("precMax", BF_PREC_MAX, 0 ),
     JS_PROP_INT32_DEF("expBitsMin", BF_EXP_BITS_MIN, 0 ),
-    JS_PROP_INT32_DEF("expBitsMax", BF_EXP_BITS_MAX, 0 ),
+    JS_PROP_INT32_DEF("expBitsMax", BF_EXP_BITS_MAX1, 0 ),
 };
 
 static const JSCFunctionListEntry js_float_env_proto_funcs[] = {
@@ -50309,529 +47260,12 @@ static const JSCFunctionListEntry js_float_env_proto_funcs[] = {
     JS_CFUNC_DEF("clearStatus", 0, js_float_env_clearStatus ),
 };
 
-void JS_AddIntrinsicBigFloat(JSContext *ctx)
-{
-    JSRuntime *rt = ctx->rt;
-    JSValueConst obj1;
-    
-    rt->bigfloat_ops.to_string = js_bigfloat_to_string;
-    rt->bigfloat_ops.from_string = js_string_to_bigfloat;
-    rt->bigfloat_ops.unary_arith = js_unary_arith_bigfloat;
-    rt->bigfloat_ops.binary_arith = js_binary_arith_bigfloat;
-    rt->bigfloat_ops.compare = js_compare_bigfloat;
-    rt->bigfloat_ops.mul_pow10_to_float64 = js_mul_pow10_to_float64;
-    rt->bigfloat_ops.mul_pow10 = js_mul_pow10;
-    
-    ctx->class_proto[JS_CLASS_BIG_FLOAT] = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT],
-                               js_bigfloat_proto_funcs,
-                               countof(js_bigfloat_proto_funcs));
-    obj1 = JS_NewGlobalCConstructor(ctx, "BigFloat", js_bigfloat_constructor, 1,
-                                    ctx->class_proto[JS_CLASS_BIG_FLOAT]);
-    JS_SetPropertyFunctionList(ctx, obj1, js_bigfloat_funcs,
-                               countof(js_bigfloat_funcs));
-
-    ctx->class_proto[JS_CLASS_FLOAT_ENV] = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_FLOAT_ENV],
-                               js_float_env_proto_funcs,
-                               countof(js_float_env_proto_funcs));
-    obj1 = JS_NewGlobalCConstructorOnly(ctx, "BigFloatEnv",
-                                        js_float_env_constructor, 1,
-                                        ctx->class_proto[JS_CLASS_FLOAT_ENV]);
-    JS_SetPropertyFunctionList(ctx, obj1, js_float_env_funcs,
-                               countof(js_float_env_funcs));
-}
-
-/* BigDecimal */
-
-static JSValue JS_ToBigDecimalFree(JSContext *ctx, JSValue val,
-                                   BOOL allow_null_or_undefined)
-{
- redo:
-    switch(JS_VALUE_GET_NORM_TAG(val)) {
-    case JS_TAG_BIG_DECIMAL:
-        break;
-    case JS_TAG_NULL:
-        if (!allow_null_or_undefined)
-            goto fail;
-        /* fall thru */
-    case JS_TAG_BOOL:
-    case JS_TAG_INT:
-        {
-            bfdec_t *r;
-            int32_t v = JS_VALUE_GET_INT(val);
-
-            val = JS_NewBigDecimal(ctx);
-            if (JS_IsException(val))
-                break;
-            r = JS_GetBigDecimal(val);
-            if (bfdec_set_si(r, v)) {
-                JS_FreeValue(ctx, val);
-                val = JS_EXCEPTION;
-                break;
-            }
-        }
-        break;
-    case JS_TAG_FLOAT64:
-    case JS_TAG_BIG_INT:
-    case JS_TAG_BIG_FLOAT:
-        val = JS_ToStringFree(ctx, val);
-        if (JS_IsException(val))
-            break;
-        goto redo;
-    case JS_TAG_STRING:
-        {
-            const char *str, *p;
-            size_t len;
-            int err;
-
-            str = JS_ToCStringLen(ctx, &len, val);
-            JS_FreeValue(ctx, val);
-            if (!str)
-                return JS_EXCEPTION;
-            p = str;
-            p += skip_spaces(p);
-            if ((p - str) == len) {
-                bfdec_t *r;
-                val = JS_NewBigDecimal(ctx);
-                if (JS_IsException(val))
-                    break;
-                r = JS_GetBigDecimal(val);
-                bfdec_set_zero(r, 0);
-                err = 0;
-            } else {
-                val = js_atof(ctx, p, &p, 0, ATOD_TYPE_BIG_DECIMAL);
-                if (JS_IsException(val)) {
-                    JS_FreeCString(ctx, str);
-                    return JS_EXCEPTION;
-                }
-                p += skip_spaces(p);
-                err = ((p - str) != len);
-            }
-            JS_FreeCString(ctx, str);
-            if (err) {
-                JS_FreeValue(ctx, val);
-                return JS_ThrowSyntaxError(ctx, "invalid bigdecimal literal");
-            }
-        }
-        break;
-    case JS_TAG_OBJECT:
-        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
-        if (JS_IsException(val))
-            break;
-        goto redo;
-    case JS_TAG_UNDEFINED:
-        {
-            bfdec_t *r;
-            if (!allow_null_or_undefined)
-                goto fail;
-            val = JS_NewBigDecimal(ctx);
-            if (JS_IsException(val))
-                break;
-            r = JS_GetBigDecimal(val);
-            bfdec_set_nan(r);
-        }
-        break;
-    default:
-    fail:
-        JS_FreeValue(ctx, val);
-        return JS_ThrowTypeError(ctx, "cannot convert to bigdecimal");
-    }
-    return val;
-}
-
-static JSValue js_bigdecimal_constructor(JSContext *ctx,
-                                         JSValueConst new_target,
-                                         int argc, JSValueConst *argv)
-{
-    JSValue val;
-    if (!JS_IsUndefined(new_target))
-        return JS_ThrowTypeError(ctx, "not a constructor");
-    if (argc == 0) {
-        bfdec_t *r;
-        val = JS_NewBigDecimal(ctx);
-        if (JS_IsException(val))
-            return val;
-        r = JS_GetBigDecimal(val);
-        bfdec_set_zero(r, 0);
-    } else {
-        val = JS_ToBigDecimalFree(ctx, JS_DupValue(ctx, argv[0]), FALSE);
-    }
-    return val;
-}
-
-static JSValue js_thisBigDecimalValue(JSContext *ctx, JSValueConst this_val)
-{
-    if (JS_IsBigDecimal(this_val))
-        return JS_DupValue(ctx, this_val);
-
-    if (JS_VALUE_GET_TAG(this_val) == JS_TAG_OBJECT) {
-        JSObject *p = JS_VALUE_GET_OBJ(this_val);
-        if (p->class_id == JS_CLASS_BIG_DECIMAL) {
-            if (JS_IsBigDecimal(p->u.object_data))
-                return JS_DupValue(ctx, p->u.object_data);
-        }
-    }
-    return JS_ThrowTypeError(ctx, "not a bigdecimal");
-}
-
-static JSValue js_bigdecimal_toString(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv)
-{
-    JSValue val;
-
-    val = js_thisBigDecimalValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    return JS_ToStringFree(ctx, val);
-}
-
-static JSValue js_bigdecimal_valueOf(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    return js_thisBigDecimalValue(ctx, this_val);
-}
-
-static int js_bigdecimal_get_rnd_mode(JSContext *ctx, JSValueConst obj)
-{
-    const char *str;
-    size_t size;
-    int rnd_mode;
-    
-    str = JS_ToCStringLen(ctx, &size, obj);
-    if (!str)
-        return -1;
-    if (strlen(str) != size)
-        goto invalid_rounding_mode;
-    if (!strcmp(str, "floor")) {
-        rnd_mode = BF_RNDD;
-    } else if (!strcmp(str, "ceiling")) {
-        rnd_mode = BF_RNDU;
-    } else if (!strcmp(str, "down")) {
-        rnd_mode = BF_RNDZ;
-    } else if (!strcmp(str, "up")) {
-        rnd_mode = BF_RNDA;
-    } else if (!strcmp(str, "half-even")) {
-        rnd_mode = BF_RNDN;
-    } else if (!strcmp(str, "half-up")) {
-        rnd_mode = BF_RNDNA;
-    } else {
-    invalid_rounding_mode:
-        JS_FreeCString(ctx, str);
-        JS_ThrowTypeError(ctx, "invalid rounding mode");
-        return -1;
-    }
-    JS_FreeCString(ctx, str);
-    return rnd_mode;
-}
-
-typedef struct {
-    int64_t prec;
-    bf_flags_t flags;
-} BigDecimalEnv;
-
-static int js_bigdecimal_get_env(JSContext *ctx, BigDecimalEnv *fe,
-                                 JSValueConst obj)
-{
-    JSValue prop;
-    int64_t val;
-    BOOL has_prec;
-    int rnd_mode;
-    
-    if (!JS_IsObject(obj)) {
-        JS_ThrowTypeErrorNotAnObject(ctx);
-        return -1;
-    }
-    prop = JS_GetProperty(ctx, obj, JS_ATOM_roundingMode);
-    if (JS_IsException(prop))
-        return -1;
-    rnd_mode = js_bigdecimal_get_rnd_mode(ctx, prop);
-    JS_FreeValue(ctx, prop);
-    if (rnd_mode < 0)
-        return -1;
-    fe->flags = rnd_mode;
-    
-    prop = JS_GetProperty(ctx, obj, JS_ATOM_maximumSignificantDigits);
-    if (JS_IsException(prop))
-        return -1;
-    has_prec = FALSE;
-    if (!JS_IsUndefined(prop)) {
-        if (JS_ToInt64SatFree(ctx, &val, prop))
-            return -1;
-        if (val < 1 || val > BF_PREC_MAX)
-            goto invalid_precision;
-        fe->prec = val;
-        has_prec = TRUE;
-    }
-
-    prop = JS_GetProperty(ctx, obj, JS_ATOM_maximumFractionDigits);
-    if (JS_IsException(prop))
-        return -1;
-    if (!JS_IsUndefined(prop)) {
-        if (has_prec) {
-            JS_FreeValue(ctx, prop);
-            JS_ThrowTypeError(ctx, "cannot provide both maximumSignificantDigits and maximumFractionDigits");
-            return -1;
-        }
-        if (JS_ToInt64SatFree(ctx, &val, prop))
-            return -1;
-        if (val < 0 || val > BF_PREC_MAX) {
-        invalid_precision:
-            JS_ThrowTypeError(ctx, "invalid precision");
-            return -1;
-        }
-        fe->prec = val;
-        fe->flags |= BF_FLAG_RADPNT_PREC;
-        has_prec = TRUE;
-    }
-    if (!has_prec) {
-        JS_ThrowTypeError(ctx, "precision must be present");
-        return -1;
-    }
-    return 0;
-}
-
-
-static JSValue js_bigdecimal_fop(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv, int magic)
-{
-    bfdec_t *a, *b, r_s, *r = &r_s;
-    JSValue op1, op2, res;
-    BigDecimalEnv fe_s, *fe = &fe_s;
-    int op_count, ret;
-
-    if (magic == MATH_OP_SQRT ||
-        magic == MATH_OP_ROUND)
-        op_count = 1;
-    else
-        op_count = 2;
-    
-    op1 = JS_ToNumeric(ctx, argv[0]);
-    if (JS_IsException(op1))
-        return op1;
-    a = JS_ToBigDecimal(ctx, op1);
-    if (!a) {
-        JS_FreeValue(ctx, op1);
-        return JS_EXCEPTION;
-    }
-    if (op_count >= 2) {
-        op2 = JS_ToNumeric(ctx, argv[1]);
-        if (JS_IsException(op2)) {
-            JS_FreeValue(ctx, op1);
-            return op2;
-        }
-        b = JS_ToBigDecimal(ctx, op2);
-        if (!b)
-            goto fail;
-    } else {
-        op2 = JS_UNDEFINED;
-        b = NULL;
-    }
-    fe->flags = BF_RNDZ;
-    fe->prec = BF_PREC_INF;
-    if (op_count < argc) {
-        if (js_bigdecimal_get_env(ctx, fe, argv[op_count]))
-            goto fail;
-    }
-
-    res = JS_NewBigDecimal(ctx);
-    if (JS_IsException(res)) {
-    fail:
-        JS_FreeValue(ctx, op1);
-        JS_FreeValue(ctx, op2);
-        return JS_EXCEPTION;
-    }
-    r = JS_GetBigDecimal(res);
-    switch (magic) {
-    case MATH_OP_ADD:
-        ret = bfdec_add(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_SUB:
-        ret = bfdec_sub(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_MUL:
-        ret = bfdec_mul(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_DIV:
-        ret = bfdec_div(r, a, b, fe->prec, fe->flags);
-        break;
-    case MATH_OP_FMOD:
-        ret = bfdec_rem(r, a, b, fe->prec, fe->flags, BF_RNDZ);
-        break;
-    case MATH_OP_SQRT:
-        ret = bfdec_sqrt(r, a, fe->prec, fe->flags);
-        break;
-    case MATH_OP_ROUND:
-        ret = bfdec_set(r, a);
-        if (!(ret & BF_ST_MEM_ERROR))
-            ret = bfdec_round(r, fe->prec, fe->flags);
-        break;
-    default:
-        abort();
-    }
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    ret &= BF_ST_MEM_ERROR | BF_ST_DIVIDE_ZERO | BF_ST_INVALID_OP |
-        BF_ST_OVERFLOW;
-    if (ret != 0) {
-        JS_FreeValue(ctx, res);
-        return throw_bf_exception(ctx, ret);
-    } else {
-        return res;
-    }
-}
-
-static JSValue js_bigdecimal_toFixed(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSValue val, ret;
-    int64_t f;
-    int rnd_mode;
-
-    val = js_thisBigDecimalValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    if (JS_ToInt64Sat(ctx, &f, argv[0]))
-        goto fail;
-    if (f < 0 || f > BF_PREC_MAX) {
-        JS_ThrowRangeError(ctx, "invalid number of digits");
-        goto fail;
-    }
-    rnd_mode = BF_RNDNA;
-    if (argc > 1) {
-        rnd_mode = js_bigdecimal_get_rnd_mode(ctx, argv[1]);
-        if (rnd_mode < 0)
-            goto fail;
-    }
-    ret = js_bigdecimal_to_string1(ctx, val, f, rnd_mode | BF_FTOA_FORMAT_FRAC);
-    JS_FreeValue(ctx, val);
-    return ret;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_bigdecimal_toExponential(JSContext *ctx, JSValueConst this_val,
-                                       int argc, JSValueConst *argv)
-{
-    JSValue val, ret;
-    int64_t f;
-    int rnd_mode;
-
-    val = js_thisBigDecimalValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    if (JS_ToInt64Sat(ctx, &f, argv[0]))
-        goto fail;
-    if (JS_IsUndefined(argv[0])) {
-        ret = js_bigdecimal_to_string1(ctx, val, 0,
-                  BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);
-    } else {
-        if (f < 0 || f > BF_PREC_MAX) {
-            JS_ThrowRangeError(ctx, "invalid number of digits");
-            goto fail;
-        }
-        rnd_mode = BF_RNDNA;
-        if (argc > 1) {
-            rnd_mode = js_bigdecimal_get_rnd_mode(ctx, argv[1]);
-            if (rnd_mode < 0)
-                goto fail;
-        }
-        ret = js_bigdecimal_to_string1(ctx, val, f + 1,
-                      rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);
-    }
-    JS_FreeValue(ctx, val);
-    return ret;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_bigdecimal_toPrecision(JSContext *ctx, JSValueConst this_val,
-                                     int argc, JSValueConst *argv)
-{
-    JSValue val, ret;
-    int64_t p;
-    int rnd_mode;
-
-    val = js_thisBigDecimalValue(ctx, this_val);
-    if (JS_IsException(val))
-        return val;
-    if (JS_IsUndefined(argv[0])) {
-        return JS_ToStringFree(ctx, val);
-    }
-    if (JS_ToInt64Sat(ctx, &p, argv[0]))
-        goto fail;
-    if (p < 1 || p > BF_PREC_MAX) {
-        JS_ThrowRangeError(ctx, "invalid number of digits");
-        goto fail;
-    }
-    rnd_mode = BF_RNDNA;
-    if (argc > 1) {
-        rnd_mode = js_bigdecimal_get_rnd_mode(ctx, argv[1]);
-        if (rnd_mode < 0)
-            goto fail;
-    }
-    ret = js_bigdecimal_to_string1(ctx, val, p,
-                                   rnd_mode | BF_FTOA_FORMAT_FIXED);
-    JS_FreeValue(ctx, val);
-    return ret;
- fail:
-    JS_FreeValue(ctx, val);
-    return JS_EXCEPTION;
-}
-
-static const JSCFunctionListEntry js_bigdecimal_proto_funcs[] = {
-    JS_CFUNC_DEF("toString", 0, js_bigdecimal_toString ),
-    JS_CFUNC_DEF("valueOf", 0, js_bigdecimal_valueOf ),
-    JS_CFUNC_DEF("toPrecision", 1, js_bigdecimal_toPrecision ),
-    JS_CFUNC_DEF("toFixed", 1, js_bigdecimal_toFixed ),
-    JS_CFUNC_DEF("toExponential", 1, js_bigdecimal_toExponential ),
-};
-
-static const JSCFunctionListEntry js_bigdecimal_funcs[] = {
-    JS_CFUNC_MAGIC_DEF("add", 2, js_bigdecimal_fop, MATH_OP_ADD ),
-    JS_CFUNC_MAGIC_DEF("sub", 2, js_bigdecimal_fop, MATH_OP_SUB ),
-    JS_CFUNC_MAGIC_DEF("mul", 2, js_bigdecimal_fop, MATH_OP_MUL ),
-    JS_CFUNC_MAGIC_DEF("div", 2, js_bigdecimal_fop, MATH_OP_DIV ),
-    JS_CFUNC_MAGIC_DEF("mod", 2, js_bigdecimal_fop, MATH_OP_FMOD ),
-    JS_CFUNC_MAGIC_DEF("round", 1, js_bigdecimal_fop, MATH_OP_ROUND ),
-    JS_CFUNC_MAGIC_DEF("sqrt", 1, js_bigdecimal_fop, MATH_OP_SQRT ),
-};
-
-void JS_AddIntrinsicBigDecimal(JSContext *ctx)
-{
-    JSRuntime *rt = ctx->rt;
-    JSValueConst obj1;
-
-    rt->bigdecimal_ops.to_string = js_bigdecimal_to_string;
-    rt->bigdecimal_ops.from_string = js_string_to_bigdecimal;
-    rt->bigdecimal_ops.unary_arith = js_unary_arith_bigdecimal;
-    rt->bigdecimal_ops.binary_arith = js_binary_arith_bigdecimal;
-    rt->bigdecimal_ops.compare = js_compare_bigdecimal;
-
-    ctx->class_proto[JS_CLASS_BIG_DECIMAL] = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_DECIMAL],
-                               js_bigdecimal_proto_funcs,
-                               countof(js_bigdecimal_proto_funcs));
-    obj1 = JS_NewGlobalCConstructor(ctx, "BigDecimal",
-                                    js_bigdecimal_constructor, 1,
-                                    ctx->class_proto[JS_CLASS_BIG_DECIMAL]);
-    JS_SetPropertyFunctionList(ctx, obj1, js_bigdecimal_funcs,
-                               countof(js_bigdecimal_funcs));
-}
-
-void JS_EnableBignumExt(JSContext *ctx, BOOL enable)
-{
-    ctx->bignum_ext = enable;
-}
-
 #endif /* CONFIG_BIGNUM */
 
 static const char * const native_error_name[JS_NATIVE_ERROR_COUNT] = {
     "EvalError", "RangeError", "ReferenceError",
     "SyntaxError", "TypeError", "URIError",
-    "InternalError", "AggregateError",
+    "InternalError",
 };
 
 /* Minimum amount of objects to be able to compile code and display
@@ -50899,16 +47333,16 @@ void JS_AddIntrinsicBaseObjects(JSContext *ctx)
     ctx->throw_type_error = JS_NewCFunction(ctx, js_throw_type_error, NULL, 0);
 
     /* add caller and arguments properties to throw a TypeError */
-    obj1 = JS_NewCFunction(ctx, js_function_proto_caller, NULL, 0);
+    obj1 = JS_NewCFunction(ctx, js_function_proto_caller, "get caller", 0);
     JS_DefineProperty(ctx, ctx->function_proto, JS_ATOM_caller, JS_UNDEFINED,
                       obj1, ctx->throw_type_error,
                       JS_PROP_HAS_GET | JS_PROP_HAS_SET |
                       JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE);
+    JS_FreeValue(ctx, obj1);
     JS_DefineProperty(ctx, ctx->function_proto, JS_ATOM_arguments, JS_UNDEFINED,
-                      obj1, ctx->throw_type_error,
+                      ctx->throw_type_error, ctx->throw_type_error,
                       JS_PROP_HAS_GET | JS_PROP_HAS_SET |
                       JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE);
-    JS_FreeValue(ctx, obj1);
     JS_FreeValue(ctx, js_object_seal(ctx, JS_UNDEFINED, 1, (JSValueConst *)&ctx->throw_type_error, 1));
 
     ctx->global_obj = JS_NewObject(ctx);
@@ -50936,12 +47370,9 @@ void JS_AddIntrinsicBaseObjects(JSContext *ctx)
                               "Error", ctx->class_proto[JS_CLASS_ERROR]);
 
     for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
-        JSValue func_obj;
-        int n_args;
-        n_args = 1 + (i == JS_AGGREGATE_ERROR);
-        func_obj = JS_NewCFunction3(ctx, (JSCFunction *)js_error_constructor,
-                                    native_error_name[i], n_args,
-                                    JS_CFUNC_constructor_or_func_magic, i, obj1);
+        JSValue func_obj = JS_NewCFunction3(ctx, (JSCFunction *)js_error_constructor,
+                                            native_error_name[i], 1,
+                                            JS_CFUNC_constructor_or_func_magic, i, obj1);
         JS_NewGlobalCConstructor2(ctx, func_obj, native_error_name[i],
                                   ctx->native_error_proto[i]);
     }
@@ -50959,7 +47390,6 @@ void JS_AddIntrinsicBaseObjects(JSContext *ctx)
 
     obj = JS_NewGlobalCConstructor(ctx, "Array", js_array_constructor, 1,
                                    ctx->class_proto[JS_CLASS_ARRAY]);
-    ctx->array_ctor = JS_DupValue(ctx, obj);
     JS_SetPropertyFunctionList(ctx, obj, js_array_funcs,
                                countof(js_array_funcs));
 
@@ -50987,12 +47417,6 @@ void JS_AddIntrinsicBaseObjects(JSContext *ctx)
                                js_array_iterator_proto_funcs,
                                countof(js_array_iterator_proto_funcs));
 
-    /* parseFloat and parseInteger must be defined before Number
-       because of the Number.parseFloat and Number.parseInteger
-       aliases */
-    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_global_funcs,
-                               countof(js_global_funcs));
-
     /* Number */
     ctx->class_proto[JS_CLASS_NUMBER] = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],
                                                                JS_CLASS_NUMBER);
@@ -51076,12 +47500,46 @@ void JS_AddIntrinsicBaseObjects(JSContext *ctx)
                        0, JS_PROP_CONFIGURABLE);
     JS_FreeValue(ctx, obj1);
 
+#ifdef CONFIG_BIGNUM
+    ctx->class_proto[JS_CLASS_BIG_INT] = JS_NewObject(ctx);
+    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
+                               js_bigint_proto_funcs,
+                               countof(js_bigint_proto_funcs));
+    obj1 = JS_NewCFunction(ctx, js_bigint_constructor, "BigInt", 1);
+    JS_NewGlobalCConstructor2(ctx, obj1, "BigInt",
+                              ctx->class_proto[JS_CLASS_BIG_INT]);
+    JS_SetPropertyFunctionList(ctx, obj1, js_integer_funcs,
+                               countof(js_integer_funcs));
+
+    ctx->class_proto[JS_CLASS_BIG_FLOAT] = JS_NewObject(ctx);
+    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT],
+                               js_bigfloat_proto_funcs,
+                               countof(js_bigfloat_proto_funcs));
+    obj1 = JS_NewCFunction(ctx, js_bigfloat_constructor, "BigFloat", 1);
+    JS_NewGlobalCConstructor2(ctx, obj1, "BigFloat",
+                              ctx->class_proto[JS_CLASS_BIG_FLOAT]);
+    JS_SetPropertyFunctionList(ctx, obj1, js_bigfloat_funcs,
+                               countof(js_bigfloat_funcs));
+
+    ctx->class_proto[JS_CLASS_FLOAT_ENV] = JS_NewObject(ctx);
+    JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_FLOAT_ENV],
+                               js_float_env_proto_funcs,
+                               countof(js_float_env_proto_funcs));
+    obj1 = JS_NewGlobalCConstructorOnly(ctx, "BigFloatEnv",
+                                        js_float_env_constructor, 1,
+                                        ctx->class_proto[JS_CLASS_FLOAT_ENV]);
+    JS_SetPropertyFunctionList(ctx, obj1, js_float_env_funcs,
+                               countof(js_float_env_funcs));
+#endif
     /* global properties */
     ctx->eval_obj = JS_NewCFunction(ctx, js_global_eval, "eval", 1);
     JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_eval,
                            JS_DupValue(ctx, ctx->eval_obj),
                            JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
 
+    JS_SetPropertyFunctionList(ctx, ctx->global_obj, js_global_funcs,
+                               countof(js_global_funcs));
+
     JS_DefinePropertyValue(ctx, ctx->global_obj, JS_ATOM_globalThis,
                            JS_DupValue(ctx, ctx->global_obj),
                            JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
@@ -51104,7 +47562,6 @@ static JSValue js_array_buffer_constructor3(JSContext *ctx,
                                             JSFreeArrayBufferDataFunc *free_func,
                                             void *opaque, BOOL alloc_flag)
 {
-    JSRuntime *rt = ctx->rt;
     JSValue obj;
     JSArrayBuffer *abuf = NULL;
 
@@ -51121,24 +47578,11 @@ static JSValue js_array_buffer_constructor3(JSContext *ctx,
         goto fail;
     abuf->byte_length = len;
     if (alloc_flag) {
-        if (class_id == JS_CLASS_SHARED_ARRAY_BUFFER &&
-            rt->sab_funcs.sab_alloc) {
-            abuf->data = rt->sab_funcs.sab_alloc(rt->sab_funcs.sab_opaque,
-                                                 max_int(len, 1));
-            if (!abuf->data)
-                goto fail;
-            memset(abuf->data, 0, len);
-        } else {
-            /* the allocation must be done after the object creation */
-            abuf->data = js_mallocz(ctx, max_int(len, 1));
-            if (!abuf->data)
-                goto fail;
-        }
+        /* the allocation must be done after the object creation */
+        abuf->data = js_mallocz(ctx, max_int(len, 1));
+        if (!abuf->data)
+            goto fail;
     } else {
-        if (class_id == JS_CLASS_SHARED_ARRAY_BUFFER &&
-            rt->sab_funcs.sab_dup) {
-            rt->sab_funcs.sab_dup(rt->sab_funcs.sab_opaque, buf);
-        }
         abuf->data = buf;
     }
     init_list_head(&abuf->array_list);
@@ -51224,16 +47668,14 @@ static void js_array_buffer_finalizer(JSRuntime *rt, JSValue val)
     JSObject *p = JS_VALUE_GET_OBJ(val);
     JSArrayBuffer *abuf = p->u.array_buffer;
     if (abuf) {
-        /* The ArrayBuffer finalizer may be called before the typed
-           array finalizers using it, so abuf->array_list is not
-           necessarily empty. */
-        // assert(list_empty(&abuf->array_list));
-        if (abuf->shared && rt->sab_funcs.sab_free) {
-            rt->sab_funcs.sab_free(rt->sab_funcs.sab_opaque, abuf->data);
-        } else {
-            if (abuf->free_func)
-                abuf->free_func(rt, abuf->opaque, abuf->data);
-        }
+        /* During the GC sweep phase the ArrayBuffer finalizer may be
+           called before the typed array finalizers using it, so
+           abuf->array_list is not necessarily empty. */
+        if (!JS_IsInGCSweep(rt)) {
+            assert(list_empty(&abuf->array_list));
+        }
+        if (abuf->free_func)
+            abuf->free_func(rt, abuf->opaque, abuf->data);
         js_free_rt(rt, abuf);
     }
 }
@@ -51272,7 +47714,8 @@ static JSValue js_array_buffer_get_byteLength(JSContext *ctx,
     JSArrayBuffer *abuf = JS_GetOpaque2(ctx, this_val, class_id);
     if (!abuf)
         return JS_EXCEPTION;
-    /* return 0 if detached */
+    if (abuf->detached)
+        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
     return JS_NewUint32(ctx, abuf->byte_length);
 }
 
@@ -51708,6 +48151,11 @@ static JSValue js_typed_array___getLength(JSContext *ctx,
 }
 #endif
 
+static JSValue js_typed_array_constructor(JSContext *ctx,
+                                          JSValueConst this_val,
+                                          int argc, JSValueConst *argv,
+                                          int classid);
+
 static JSValue js_typed_array_create(JSContext *ctx, JSValueConst ctor,
                                      int argc, JSValueConst *argv)
 {
@@ -51911,8 +48359,6 @@ static JSValue js_typed_array_copyWithin(JSContext *ctx, JSValueConst this_val,
     count = min_int(final - from, len - to);
     if (count > 0) {
         p = JS_VALUE_GET_OBJ(this_val);
-        if (typed_array_is_detached(ctx, p))
-            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
         shift = typed_array_size_log2(p->class_id);
         memmove(p->u.array.u.uint8_ptr + (to << shift),
                 p->u.array.u.uint8_ptr + (from << shift),
@@ -51980,9 +48426,6 @@ static JSValue js_typed_array_fill(JSContext *ctx, JSValueConst this_val,
             return JS_EXCEPTION;
     }
 
-    if (typed_array_is_detached(ctx, p))
-        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
-    
     shift = typed_array_size_log2(p->class_id);
     switch(shift) {
     case 0:
@@ -52071,7 +48514,7 @@ static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
                                       int argc, JSValueConst *argv, int special)
 {
     JSObject *p;
-    int len, tag, is_int, is_bigint, k, stop, inc, res = -1;
+    int len, tag, is_int, is_big, k, stop, inc, res = -1;
     int64_t v64;
     double d;
     float f;
@@ -52114,17 +48557,7 @@ static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
         inc = 1;
     }
 
-    p = JS_VALUE_GET_OBJ(this_val);
-    /* if the array was detached, no need to go further (but no
-       exception is raised) */
-    if (typed_array_is_detached(ctx, p)) {
-        /* "includes" scans all the properties, so "undefined" can match */
-        if (special == special_includes && JS_IsUndefined(argv[0]) && len > 0)
-            res = 0;
-        goto done;
-    }
-    
-    is_bigint = 0;
+    is_big = 0;
     is_int = 0; /* avoid warning */
     v64 = 0; /* avoid warning */
     tag = JS_VALUE_GET_NORM_TAG(argv[0]);
@@ -52139,26 +48572,17 @@ static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
         is_int = (v64 == d);
     } else
 #ifdef CONFIG_BIGNUM
-    if (tag == JS_TAG_BIG_INT) {
-        JSBigFloat *p1 = JS_VALUE_GET_PTR(argv[0]);
-        
-        if (p->class_id == JS_CLASS_BIG_INT64_ARRAY) {
-            if (bf_get_int64(&v64, &p1->num, 0) != 0)
-                goto done;
-        } else if (p->class_id == JS_CLASS_BIG_UINT64_ARRAY) {
-            if (bf_get_uint64((uint64_t *)&v64, &p1->num) != 0)
-                goto done;
-        } else {
-            goto done;
-        }
-        d = 0;
-        is_bigint = 1;
+    if (tag == JS_TAG_BIG_INT || tag == JS_TAG_BIG_FLOAT) {
+        /* will a generic loop for bigint and bigfloat */
+        /* XXX: should use the generic loop in math_mode? */
+        is_big = 1;
     } else
 #endif
     {
         goto done;
     }
 
+    p = JS_VALUE_GET_OBJ(this_val);
     switch (p->class_id) {
     case JS_CLASS_INT8_ARRAY:
         if (is_int && (int8_t)v64 == v64)
@@ -52225,7 +48649,7 @@ static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
         }
         break;
     case JS_CLASS_FLOAT32_ARRAY:
-        if (is_bigint)
+        if (is_big)
             break;
         if (isnan(d)) {
             const float *pv = p->u.array.u.float_ptr;
@@ -52249,7 +48673,7 @@ static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
         }
         break;
     case JS_CLASS_FLOAT64_ARRAY:
-        if (is_bigint)
+        if (is_big)
             break;
         if (isnan(d)) {
             const double *pv = p->u.array.u.double_ptr;
@@ -52274,22 +48698,20 @@ static JSValue js_typed_array_indexOf(JSContext *ctx, JSValueConst this_val,
         break;
 #ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT64_ARRAY:
-        if (is_bigint || (is_math_mode(ctx) && is_int &&
-                          v64 >= -MAX_SAFE_INTEGER &&
-                          v64 <= MAX_SAFE_INTEGER)) {
-            goto scan64;
-        }
-        break;
     case JS_CLASS_BIG_UINT64_ARRAY:
-        if (is_bigint || (is_math_mode(ctx) && is_int &&
-                          v64 >= 0 && v64 <= MAX_SAFE_INTEGER)) {
-            const uint64_t *pv;
-            uint64_t v;
-        scan64:
-            pv = p->u.array.u.uint64_ptr;
-            v = v64;
+        if (is_big || is_strict_mode(ctx)) {
+            /* generic loop for bignums, argv[0] is a bignum != NaN */
+            /* XXX: optimize with explicit values */
             for (; k != stop; k += inc) {
-                if (pv[k] == v) {
+                JSValue v = JS_GetPropertyUint32(ctx, this_val, k);
+                int ret;
+                if (JS_IsException(v))
+                    goto exception;
+                ret = js_same_value_zero(ctx, v, argv[0]);
+                JS_FreeValue(ctx, v);
+                if (ret) {
+                    if (ret < 0)
+                        goto exception;
                     res = k;
                     break;
                 }
@@ -52347,16 +48769,13 @@ static JSValue js_typed_array_join(JSContext *ctx, JSValueConst this_val,
             }
         }
         el = JS_GetPropertyUint32(ctx, this_val, i);
-        /* Can return undefined for example if the typed array is detached */
-        if (!JS_IsNull(el) && !JS_IsUndefined(el)) {
-            if (JS_IsException(el))
-                goto fail;
-            if (toLocaleString) {
-                el = JS_ToLocaleStringFree(ctx, el);
-            }
-            if (string_buffer_concat_value_free(b, el))
-                goto fail;
+        if (JS_IsException(el))
+            goto fail;
+        if (toLocaleString) {
+            el = JS_ToLocaleStringFree(ctx, el);
         }
+        if (string_buffer_concat_value_free(b, el))
+            goto fail;
     }
     JS_FreeValue(ctx, sep);
     return string_buffer_end(b);
@@ -52692,8 +49111,8 @@ static int js_TA_cmp_generic(const void *a, const void *b, void *opaque) {
             psc->exception = 1;
         }
     done:
-        JS_FreeValue(ctx, (JSValue)argv[0]);
-        JS_FreeValue(ctx, (JSValue)argv[1]);
+        JS_FreeValue(ctx, argv[0]);
+        JS_FreeValue(ctx, argv[1]);
     }
     return cmp;
 }
@@ -53470,10 +49889,9 @@ typedef enum AtomicsOpEnum {
 } AtomicsOpEnum;
 
 static void *js_atomics_get_ptr(JSContext *ctx,
-                                JSArrayBuffer **pabuf,
                                 int *psize_log2, JSClassID *pclass_id,
                                 JSValueConst obj, JSValueConst idx_val,
-                                int is_waitable)
+                                BOOL is_waitable)
 {
     JSObject *p;
     JSTypedArray *ta;
@@ -53508,27 +49926,18 @@ static void *js_atomics_get_ptr(JSContext *ctx,
     ta = p->u.typed_array;
     abuf = ta->buffer->u.array_buffer;
     if (!abuf->shared) {
-        if (is_waitable == 2) {
-            JS_ThrowTypeError(ctx, "not a SharedArrayBuffer TypedArray");
-            return NULL;
-        }
-        if (abuf->detached) {
-            JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
-            return NULL;
-        }
+        JS_ThrowTypeError(ctx, "not a SharedArrayBuffer TypedArray");
+        return NULL;
     }
     if (JS_ToIndex(ctx, &idx, idx_val)) {
         return NULL;
     }
-    /* if the array buffer is detached, p->u.array.count = 0 */
     if (idx >= p->u.array.count) {
         JS_ThrowRangeError(ctx, "out-of-bound access");
         return NULL;
     }
     size_log2 = typed_array_size_log2(p->class_id);
     ptr = p->u.array.u.uint8_ptr + ((uintptr_t)idx << size_log2);
-    if (pabuf)
-        *pabuf = abuf;
     if (psize_log2)
         *psize_log2 = size_log2;
     if (pclass_id)
@@ -53549,18 +49958,17 @@ static JSValue js_atomics_op(JSContext *ctx,
     void *ptr;
     JSValue ret;
     JSClassID class_id;
-    JSArrayBuffer *abuf;
 
-    ptr = js_atomics_get_ptr(ctx, &abuf, &size_log2, &class_id,
-                             argv[0], argv[1], 0);
+    ptr = js_atomics_get_ptr(ctx, &size_log2, &class_id,
+                             argv[0], argv[1], FALSE);
     if (!ptr)
         return JS_EXCEPTION;
     rep_val = 0;
     if (op == ATOMICS_OP_LOAD) {
         v = 0;
-    } else {
+    } else
 #ifdef CONFIG_BIGNUM
-        if (size_log2 == 3) {
+   if (size_log2 == 3) {
             int64_t v64;
             if (JS_ToBigInt64(ctx, &v64, argv[2]))
                 return JS_EXCEPTION;
@@ -53570,23 +49978,19 @@ static JSValue js_atomics_op(JSContext *ctx,
                     return JS_EXCEPTION;
                 rep_val = v64;
             }
-        } else
+   } else
 #endif
-        {
-                uint32_t v32;
-                if (JS_ToUint32(ctx, &v32, argv[2]))
-                    return JS_EXCEPTION;
-                v = v32;
-                if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
-                    if (JS_ToUint32(ctx, &v32, argv[3]))
-                        return JS_EXCEPTION;
-                    rep_val = v32;
-                }
-        }
-        if (abuf->detached)
-            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
+   {
+       uint32_t v32;
+       if (JS_ToUint32(ctx, &v32, argv[2]))
+           return JS_EXCEPTION;
+       v = v32;
+       if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
+           if (JS_ToUint32(ctx, &v32, argv[3]))
+               return JS_EXCEPTION;
+           rep_val = v32;
+       }
    }
-
    switch(op | (size_log2 << 3)) {
             
 #ifdef CONFIG_BIGNUM
@@ -53713,10 +50117,8 @@ static JSValue js_atomics_store(JSContext *ctx,
     int size_log2;
     void *ptr;
     JSValue ret;
-    JSArrayBuffer *abuf;
 
-    ptr = js_atomics_get_ptr(ctx, &abuf, &size_log2, NULL,
-                             argv[0], argv[1], 0);
+    ptr = js_atomics_get_ptr(ctx, &size_log2, NULL, argv[0], argv[1], FALSE);
     if (!ptr)
         return JS_EXCEPTION;
 #ifdef CONFIG_BIGNUM
@@ -53729,8 +50131,6 @@ static JSValue js_atomics_store(JSContext *ctx,
             JS_FreeValue(ctx, ret);
             return JS_EXCEPTION;
         }
-        if (abuf->detached)
-            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
         atomic_store((_Atomic(uint64_t) *)ptr, v64);
     } else
 #endif
@@ -53744,8 +50144,6 @@ static JSValue js_atomics_store(JSContext *ctx,
             JS_FreeValue(ctx, ret);
             return JS_EXCEPTION;
         }
-        if (abuf->detached)
-            return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
         switch(size_log2) {
         case 0:
             atomic_store((_Atomic(uint8_t) *)ptr, v);
@@ -53802,8 +50200,7 @@ static JSValue js_atomics_wait(JSContext *ctx,
     int ret, size_log2, res;
     double d;
 
-    ptr = js_atomics_get_ptr(ctx, NULL, &size_log2, NULL,
-                             argv[0], argv[1], 2);
+    ptr = js_atomics_get_ptr(ctx, &size_log2, NULL, argv[0], argv[1], TRUE);
     if (!ptr)
         return JS_EXCEPTION;
 #ifdef CONFIG_BIGNUM
@@ -53882,9 +50279,8 @@ static JSValue js_atomics_notify(JSContext *ctx,
     int32_t count, n;
     void *ptr;
     JSAtomicsWaiter *waiter;
-    JSArrayBuffer *abuf;
 
-    ptr = js_atomics_get_ptr(ctx, &abuf, NULL, NULL, argv[0], argv[1], 1);
+    ptr = js_atomics_get_ptr(ctx, NULL, NULL, argv[0], argv[1], TRUE);
     if (!ptr)
         return JS_EXCEPTION;
 
@@ -53894,11 +50290,9 @@ static JSValue js_atomics_notify(JSContext *ctx,
         if (JS_ToInt32Clamp(ctx, &count, argv[2], 0, INT32_MAX, 0))
             return JS_EXCEPTION;
     }
-    if (abuf->detached)
-        return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
 
     n = 0;
-    if (abuf->shared && count > 0) {
+    if (count > 0) {
         pthread_mutex_lock(&js_atomics_mutex);
         init_list_head(&waiter_list);
         list_for_each_safe(el, el1, &js_atomics_waiter_list) {
diff --git a/quickjs.h b/quickjs.h
index d4a5cd3..fcd135d 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -40,7 +40,11 @@ extern "C" {
 #else
 #define js_likely(x)     (x)
 #define js_unlikely(x)   (x)
+#ifdef _MSC_VER
+#define js_force_inline  __forceinline
+#else
 #define js_force_inline  inline
+#endif
 #define __js_printf_like(a, b)
 #endif
 
@@ -53,7 +57,7 @@ typedef struct JSClass JSClass;
 typedef uint32_t JSClassID;
 typedef uint32_t JSAtom;
 
-#if INTPTR_MAX >= INT64_MAX
+#if defined(__x86_64__) || defined(__aarch64__)
 #define JS_PTR64
 #define JS_PTR64_DEF(a) a
 #else
@@ -64,14 +68,24 @@ typedef uint32_t JSAtom;
 #define JS_NAN_BOXING
 #endif
 
+#ifndef CONFIG_VERSION
+#define CONFIG_VERSION "2019-10-27"
+#endif
+
+#ifdef _MSC_VER
+typedef size_t ssize_t;
+#endif
+
 enum {
     /* all tags with a reference count are negative */
-    JS_TAG_FIRST       = -11, /* first negative tag */
-    JS_TAG_BIG_DECIMAL = -11,
+    JS_TAG_FIRST       = -10, /* first negative tag */
     JS_TAG_BIG_INT     = -10,
     JS_TAG_BIG_FLOAT   = -9,
     JS_TAG_SYMBOL      = -8,
     JS_TAG_STRING      = -7,
+    JS_TAG_SHAPE       = -6, /* used internally during GC */
+    JS_TAG_ASYNC_FUNCTION = -5, /* used internally during GC */
+    JS_TAG_VAR_REF     = -4, /* used internally during GC */
     JS_TAG_MODULE      = -3, /* used internally */
     JS_TAG_FUNCTION_BYTECODE = -2, /* used internally */
     JS_TAG_OBJECT      = -1,
@@ -122,11 +136,6 @@ static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
     return JS_MKVAL(JS_TAG_FLOAT64, (int)d);
 }
 
-static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
-{
-    return 0;
-}
-    
 #elif defined(JS_NAN_BOXING)
 
 typedef uint64_t JSValue;
@@ -185,13 +194,6 @@ static inline int JS_VALUE_GET_NORM_TAG(JSValue v)
         return tag;
 }
 
-static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
-{
-    uint32_t tag;
-    tag = JS_VALUE_GET_TAG(v);
-    return tag == (JS_NAN >> 32);
-}
-    
 #else /* !JS_NAN_BOXING */
 
 typedef union JSValueUnion {
@@ -230,18 +232,6 @@ static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
     return v;
 }
 
-static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
-{
-    union {
-        double d;
-        uint64_t u64;
-    } u;
-    if (v.tag != JS_TAG_FLOAT64)
-        return 0;
-    u.d = v.u.float64;
-    return (u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000;
-}
-
 #endif /* !JS_NAN_BOXING */
 
 #define JS_VALUE_IS_BOTH_INT(v1, v2) ((JS_VALUE_GET_TAG(v1) | JS_VALUE_GET_TAG(v2)) == 0)
@@ -305,8 +295,6 @@ static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
    JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed
    with JS_EvalFunction(). */
 #define JS_EVAL_FLAG_COMPILE_ONLY (1 << 5)
-/* don't include the stack frames before this eval in the Error() backtraces */
-#define JS_EVAL_FLAG_BACKTRACE_BARRIER (1 << 6)
 
 typedef JSValue JSCFunction(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
 typedef JSValue JSCFunctionMagic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);
@@ -326,33 +314,25 @@ typedef struct JSMallocFunctions {
     size_t (*js_malloc_usable_size)(const void *ptr);
 } JSMallocFunctions;
 
-typedef struct JSGCObjectHeader JSGCObjectHeader;
-
 JSRuntime *JS_NewRuntime(void);
 /* info lifetime must exceed that of rt */
 void JS_SetRuntimeInfo(JSRuntime *rt, const char *info);
 void JS_SetMemoryLimit(JSRuntime *rt, size_t limit);
 void JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold);
-/* use 0 to disable maximum stack size check */
-void JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size);
-/* should be called when changing thread to update the stack top value
-   used to check stack overflow. */
-void JS_UpdateStackTop(JSRuntime *rt);
 JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque);
 void JS_FreeRuntime(JSRuntime *rt);
-void *JS_GetRuntimeOpaque(JSRuntime *rt);
-void JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque);
-typedef void JS_MarkFunc(JSRuntime *rt, JSGCObjectHeader *gp);
+typedef void JS_MarkFunc(JSRuntime *rt, JSValueConst val);
 void JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
 void JS_RunGC(JSRuntime *rt);
 JS_BOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj);
+JS_BOOL JS_IsInGCSweep(JSRuntime *rt);
 
 JSContext *JS_NewContext(JSRuntime *rt);
 void JS_FreeContext(JSContext *s);
-JSContext *JS_DupContext(JSContext *ctx);
 void *JS_GetContextOpaque(JSContext *ctx);
 void JS_SetContextOpaque(JSContext *ctx, void *opaque);
 JSRuntime *JS_GetRuntime(JSContext *ctx);
+void JS_SetMaxStackSize(JSContext *ctx, size_t stack_size);
 void JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj);
 JSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id);
 
@@ -370,14 +350,6 @@ void JS_AddIntrinsicProxy(JSContext *ctx);
 void JS_AddIntrinsicMapSet(JSContext *ctx);
 void JS_AddIntrinsicTypedArrays(JSContext *ctx);
 void JS_AddIntrinsicPromise(JSContext *ctx);
-void JS_AddIntrinsicBigInt(JSContext *ctx);
-void JS_AddIntrinsicBigFloat(JSContext *ctx);
-void JS_AddIntrinsicBigDecimal(JSContext *ctx);
-/* enable operator overloading */
-void JS_AddIntrinsicOperators(JSContext *ctx);
-/* enable "use math" */
-void JS_EnableBignumExt(JSContext *ctx, JS_BOOL enable);
-
 JSValue js_string_codePointRange(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv);
 
@@ -416,8 +388,6 @@ void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s);
 void JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt);
 
 /* atom support */
-#define JS_ATOM_NULL 0
-
 JSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len);
 JSAtom JS_NewAtom(JSContext *ctx, const char *str);
 JSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n);
@@ -476,20 +446,13 @@ typedef struct JSClassExoticMethods {
 typedef void JSClassFinalizer(JSRuntime *rt, JSValue val);
 typedef void JSClassGCMark(JSRuntime *rt, JSValueConst val,
                            JS_MarkFunc *mark_func);
-#define JS_CALL_FLAG_CONSTRUCTOR (1 << 0)
 typedef JSValue JSClassCall(JSContext *ctx, JSValueConst func_obj,
-                            JSValueConst this_val, int argc, JSValueConst *argv,
-                            int flags);
+                            JSValueConst this_val, int argc, JSValueConst *argv);
 
 typedef struct JSClassDef {
     const char *class_name;
     JSClassFinalizer *finalizer;
     JSClassGCMark *gc_mark;
-    /* if call != NULL, the object is a function. If (flags &
-       JS_CALL_FLAG_CONSTRUCTOR) != 0, the function is called as a
-       constructor. In this case, 'this_val' is new.target. A
-       constructor call only happens if the object constructor bit is
-       set (see JS_SetConstructorBit()). */
     JSClassCall *call;
     /* XXX: suppress this indirection ? It is here only to save memory
        because only a few classes need these methods */
@@ -504,7 +467,7 @@ int JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);
 
 static js_force_inline JSValue JS_NewBool(JSContext *ctx, JS_BOOL val)
 {
-    return JS_MKVAL(JS_TAG_BOOL, (val != 0));
+    return JS_MKVAL(JS_TAG_BOOL, val);
 }
 
 static js_force_inline JSValue JS_NewInt32(JSContext *ctx, int32_t val)
@@ -517,28 +480,7 @@ static js_force_inline JSValue JS_NewCatchOffset(JSContext *ctx, int32_t val)
     return JS_MKVAL(JS_TAG_CATCH_OFFSET, val);
 }
 
-static js_force_inline JSValue JS_NewInt64(JSContext *ctx, int64_t val)
-{
-    JSValue v;
-    if (val == (int32_t)val) {
-        v = JS_NewInt32(ctx, val);
-    } else {
-        v = __JS_NewFloat64(ctx, val);
-    }
-    return v;
-}
-
-static js_force_inline JSValue JS_NewUint32(JSContext *ctx, uint32_t val)
-{
-    JSValue v;
-    if (val <= 0x7fffffff) {
-        v = JS_NewInt32(ctx, val);
-    } else {
-        v = __JS_NewFloat64(ctx, val);
-    }
-    return v;
-}
-
+JSValue JS_NewInt64(JSContext *ctx, int64_t v);
 JSValue JS_NewBigInt64(JSContext *ctx, int64_t v);
 JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v);
 
@@ -563,16 +505,12 @@ static js_force_inline JSValue JS_NewFloat64(JSContext *ctx, double d)
     return v;
 }
 
-static inline JS_BOOL JS_IsNumber(JSValueConst v)
-{
-    int tag = JS_VALUE_GET_TAG(v);
-    return tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag);
-}
+JS_BOOL JS_IsNumber(JSValueConst v);
 
-static inline JS_BOOL JS_IsBigInt(JSContext *ctx, JSValueConst v)
+static inline JS_BOOL JS_IsInteger(JSValueConst v)
 {
     int tag = JS_VALUE_GET_TAG(v);
-    return tag == JS_TAG_BIG_INT;
+    return tag == JS_TAG_INT || tag == JS_TAG_BIG_INT;
 }
 
 static inline JS_BOOL JS_IsBigFloat(JSValueConst v)
@@ -581,12 +519,6 @@ static inline JS_BOOL JS_IsBigFloat(JSValueConst v)
     return tag == JS_TAG_BIG_FLOAT;
 }
 
-static inline JS_BOOL JS_IsBigDecimal(JSValueConst v)
-{
-    int tag = JS_VALUE_GET_TAG(v);
-    return tag == JS_TAG_BIG_DECIMAL;
-}
-
 static inline JS_BOOL JS_IsBool(JSValueConst v)
 {
     return JS_VALUE_GET_TAG(v) == JS_TAG_BOOL;
@@ -630,6 +562,7 @@ static inline JS_BOOL JS_IsObject(JSValueConst v)
 JSValue JS_Throw(JSContext *ctx, JSValue obj);
 JSValue JS_GetException(JSContext *ctx);
 JS_BOOL JS_IsError(JSContext *ctx, JSValueConst val);
+void JS_EnableIsErrorProperty(JSContext *ctx, JS_BOOL enable);
 void JS_ResetUncatchableError(JSContext *ctx);
 JSValue JS_NewError(JSContext *ctx);
 JSValue __js_printf_like(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...);
@@ -666,7 +599,7 @@ static inline JSValue JS_DupValue(JSContext *ctx, JSValueConst v)
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
@@ -675,22 +608,19 @@ static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 int JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */
 int JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val);
-static inline int JS_ToUint32(JSContext *ctx, uint32_t *pres, JSValueConst val)
+static int inline JS_ToUint32(JSContext *ctx, uint32_t *pres, JSValueConst val)
 {
     return JS_ToInt32(ctx, (int32_t*)pres, val);
 }
 int JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val);
 int JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val);
 int JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val);
-/* return an exception if 'val' is a Number */
 int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val);
-/* same as JS_ToInt64() but allow BigInt */
-int JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val);
 
 JSValue JS_NewStringLen(JSContext *ctx, const char *str1, size_t len1);
 JSValue JS_NewString(JSContext *ctx, const char *str);
@@ -715,7 +645,6 @@ JSValue JS_NewObject(JSContext *ctx);
 
 JS_BOOL JS_IsFunction(JSContext* ctx, JSValueConst val);
 JS_BOOL JS_IsConstructor(JSContext* ctx, JSValueConst val);
-JS_BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, JS_BOOL val);
 
 JSValue JS_NewArray(JSContext *ctx);
 int JS_IsArray(JSContext *ctx, JSValueConst val);
@@ -752,7 +681,7 @@ int JS_IsExtensible(JSContext *ctx, JSValueConst obj);
 int JS_PreventExtensions(JSContext *ctx, JSValueConst obj);
 int JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags);
 int JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val);
-JSValue JS_GetPrototype(JSContext *ctx, JSValueConst val);
+JSValueConst JS_GetPrototype(JSContext *ctx, JSValueConst val);
 
 #define JS_GPN_STRING_MASK  (1 << 0)
 #define JS_GPN_SYMBOL_MASK  (1 << 1)
@@ -767,6 +696,9 @@ int JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,
 int JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,
                       JSValueConst obj, JSAtom prop);
 
+/* 'buf' must be zero terminated i.e. buf[buf_len] = '\0'. */
+JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
+                     const char *filename);
 JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
                 int argc, JSValueConst *argv);
 JSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,
@@ -780,10 +712,7 @@ JS_BOOL JS_DetectModule(const char *input, size_t input_len);
 /* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
 JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
                 const char *filename, int eval_flags);
-/* same as JS_Eval() but with an explicit 'this_obj' parameter */
-JSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,
-                    const char *input, size_t input_len,
-                    const char *filename, int eval_flags);
+JSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj);
 JSValue JS_GetGlobalObject(JSContext *ctx);
 int JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj);
 int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
@@ -802,15 +731,6 @@ void JS_SetOpaque(JSValue obj, void *opaque);
 void *JS_GetOpaque(JSValueConst obj, JSClassID class_id);
 void *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id);
 
-/* 'buf' must be zero terminated i.e. buf[buf_len] = '\0'. */
-JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
-                     const char *filename);
-#define JS_PARSE_JSON_EXT (1 << 0) /* allow extended JSON */
-JSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,
-                      const char *filename, int flags);
-JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
-                         JSValueConst replacer, JSValueConst space0);
-
 typedef void JSFreeArrayBufferDataFunc(JSRuntime *rt, void *opaque, void *ptr);
 JSValue JS_NewArrayBuffer(JSContext *ctx, uint8_t *buf, size_t len,
                           JSFreeArrayBufferDataFunc *free_func, void *opaque,
@@ -822,30 +742,14 @@ JSValue JS_GetTypedArrayBuffer(JSContext *ctx, JSValueConst obj,
                                size_t *pbyte_offset,
                                size_t *pbyte_length,
                                size_t *pbytes_per_element);
-typedef struct {
-    void *(*sab_alloc)(void *opaque, size_t size);
-    void (*sab_free)(void *opaque, void *ptr);
-    void (*sab_dup)(void *opaque, void *ptr);
-    void *sab_opaque;
-} JSSharedArrayBufferFunctions;
-void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
-                                      const JSSharedArrayBufferFunctions *sf);
 
 JSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs);
 
-/* is_handled = TRUE means that the rejection is handled */
-typedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,
-                                           JSValueConst reason,
-                                           JS_BOOL is_handled, void *opaque);
-void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
-
 /* return != 0 if the JS code needs to be interrupted */
 typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
 void JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque);
 /* if can_block is TRUE, Atomics.wait() can be used */
 void JS_SetCanBlock(JSRuntime *rt, JS_BOOL can_block);
-/* set the [IsHTMLDDA] internal slot */
-void JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj);
 
 typedef struct JSModuleDef JSModuleDef;
 
@@ -875,36 +779,18 @@ JS_BOOL JS_IsJobPending(JSRuntime *rt);
 int JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx);
 
 /* Object Writer/Reader (currently only used to handle precompiled code) */
-#define JS_WRITE_OBJ_BYTECODE  (1 << 0) /* allow function/module */
-#define JS_WRITE_OBJ_BSWAP     (1 << 1) /* byte swapped output */
-#define JS_WRITE_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */
-#define JS_WRITE_OBJ_REFERENCE (1 << 3) /* allow object references to
-                                           encode arbitrary object
-                                           graph */
+#define JS_WRITE_OBJ_BYTECODE (1 << 0) /* allow function/module */
+#define JS_WRITE_OBJ_BSWAP    (1 << 1) /* byte swapped output */
 uint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,
                         int flags);
-uint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,
-                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len);
-
 #define JS_READ_OBJ_BYTECODE  (1 << 0) /* allow function/module */
 #define JS_READ_OBJ_ROM_DATA  (1 << 1) /* avoid duplicating 'buf' data */
-#define JS_READ_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */
-#define JS_READ_OBJ_REFERENCE (1 << 3) /* allow object references */
 JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                       int flags);
-/* instantiate and evaluate a bytecode function. Only used when
-   reading a script or module with JS_ReadObject() */
-JSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj);
 /* load the dependencies of the module 'obj'. Useful when JS_ReadObject()
    returns a module. */
 int JS_ResolveModule(JSContext *ctx, JSValueConst obj);
 
-/* only exported for os.Worker() */
-JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
-/* only exported for os.Worker() */
-JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
-                          const char *filename);
-
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
     JS_CFUNC_generic,
@@ -999,25 +885,24 @@ typedef struct JSCFunctionListEntry {
 #define JS_DEF_PROP_INT32     4
 #define JS_DEF_PROP_INT64     5
 #define JS_DEF_PROP_DOUBLE    6
-#define JS_DEF_PROP_UNDEFINED 7
+#define JS_DEF_PROP_UNDEFINED  7
 #define JS_DEF_OBJECT         8
 #define JS_DEF_ALIAS          9
 
-/* Note: c++ does not like nested designators */
-#define JS_CFUNC_DEF(name, length, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_generic, { .generic = func1 } } } }
-#define JS_CFUNC_MAGIC_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_generic_magic, { .generic_magic = func1 } } } }
-#define JS_CFUNC_SPECIAL_DEF(name, length, cproto, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_ ## cproto, { .cproto = func1 } } } }
-#define JS_ITERATOR_NEXT_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_iterator_next, { .iterator_next = func1 } } } }
-#define JS_CGETSET_DEF(name, fgetter, fsetter) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET, 0, .u = { .getset = { .get = { .getter = fgetter }, .set = { .setter = fsetter } } } }
-#define JS_CGETSET_MAGIC_DEF(name, fgetter, fsetter, magic) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET_MAGIC, magic, .u = { .getset = { .get = { .getter_magic = fgetter }, .set = { .setter_magic = fsetter } } } }
-#define JS_PROP_STRING_DEF(name, cstr, prop_flags) { name, prop_flags, JS_DEF_PROP_STRING, 0, .u = { .str = cstr } }
-#define JS_PROP_INT32_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT32, 0, .u = { .i32 = val } }
-#define JS_PROP_INT64_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT64, 0, .u = { .i64 = val } }
-#define JS_PROP_DOUBLE_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_DOUBLE, 0, .u = { .f64 = val } }
-#define JS_PROP_UNDEFINED_DEF(name, prop_flags) { name, prop_flags, JS_DEF_PROP_UNDEFINED, 0, .u = { .i32 = 0 } }
-#define JS_OBJECT_DEF(name, tab, len, prop_flags) { name, prop_flags, JS_DEF_OBJECT, 0, .u = { .prop_list = { tab, len } } }
-#define JS_ALIAS_DEF(name, from) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, -1 } } }
-#define JS_ALIAS_BASE_DEF(name, from, base) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, base } } }
+#define JS_CFUNC_DEF(name, length, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u.func = { length, JS_CFUNC_generic, { .generic = func1 } } }
+#define JS_CFUNC_MAGIC_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u.func = { length, JS_CFUNC_generic_magic, { .generic_magic = func1 } } }
+#define JS_CFUNC_SPECIAL_DEF(name, length, cproto, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u.func = { length, JS_CFUNC_ ## cproto, { .cproto = func1 } } }
+#define JS_ITERATOR_NEXT_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u.func = { length, JS_CFUNC_iterator_next, { .iterator_next = func1 } } }
+#define JS_CGETSET_DEF(name, fgetter, fsetter) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET, 0, .u.getset.get.getter = fgetter, .u.getset.set.setter = fsetter }
+#define JS_CGETSET_MAGIC_DEF(name, fgetter, fsetter, magic) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET_MAGIC, magic, .u.getset.get.getter_magic = fgetter, .u.getset.set.setter_magic = fsetter }
+#define JS_PROP_STRING_DEF(name, cstr, prop_flags) { name, prop_flags, JS_DEF_PROP_STRING, 0, .u.str = cstr }
+#define JS_PROP_INT32_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT32, 0, .u.i32 = val }
+#define JS_PROP_INT64_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT64, 0, .u.i64 = val }
+#define JS_PROP_DOUBLE_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_DOUBLE, 0, .u.f64 = val }
+#define JS_PROP_UNDEFINED_DEF(name, prop_flags) { name, prop_flags, JS_DEF_PROP_UNDEFINED, 0, .u.i32 = 0 }
+#define JS_OBJECT_DEF(name, tab, len, prop_flags) { name, prop_flags, JS_DEF_OBJECT, 0, .u.prop_list = { tab, len } }
+#define JS_ALIAS_DEF(name, from) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u.alias = { from, -1 } }
+#define JS_ALIAS_BASE_DEF(name, from, base) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u.alias = { from, base } }
 
 void JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,
                                 const JSCFunctionListEntry *tab,
@@ -1047,3 +932,4 @@ int JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,
 #endif
 
 #endif /* QUICKJS_H */
+
-- 
2.28.0.windows.1

