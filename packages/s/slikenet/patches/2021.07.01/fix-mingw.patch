diff --git a/CMakeLists.txt b/CMakeLists.txt
index 007291d94..47e0a7067 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -28,6 +28,10 @@ set(SLikeNet_VERSION_PATCH "0")
 set(SLikeNet_VERSION ${SLikeNet_VERSION_MAJOR}.${SLikeNet_VERSION_MINOR}.${SLikeNet_VERSION_PATCH})
 set(SLikeNet_API_VERSION ${SLikeNet_VERSION_MAJOR}.${SLikeNet_VERSION_MINOR})
 
+if(MINGW)
+	add_compile_definitions(_RAKNET_SUPPORT_TwoWayAuthentication=0)
+endif()
+
 # explicitly enable @rpath in the install name for any shared library being built (for cmake >=2.8.12 and <3.0 - it's enabled by default for >= 3.0)
 # note that for cmake < 2.8.12 we do not use rpath but rather keep the RakNet 4.082 behavior
 if( CMAKE_VERSION VERSION_LESS 3.0 )
diff --git a/CmakeIncludes/CmakeMacros.txt b/CmakeIncludes/CmakeMacros.txt
index 325ae733e..3e51ffbae 100644
--- a/CmakeIncludes/CmakeMacros.txt
+++ b/CmakeIncludes/CmakeMacros.txt
@@ -78,7 +78,7 @@ ENDMACRO(ADDCPPDEF)
 
 MACRO(FIXCOMPILEOPTIONS)#Fix added compile options that may cause problems, also fix warnings
 
-	IF(NOT ${CMAKE_GENERATOR} STREQUAL "MSYS Makefiles")
+	IF(NOT ${CMAKE_GENERATOR} MATCHES "MSYS Makefiles" AND NOT MINGW)
 		IF(WIN32 AND NOT UNIX)
 			STRING(REGEX REPLACE "/Z[0-9a-zA-Z]+" ""  CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
 			STRING(REGEX REPLACE "/Z[0-9a-zA-Z]+" ""  CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
@@ -93,7 +93,7 @@ MACRO(FIXCOMPILEOPTIONS)#Fix added compile options that may cause problems, also
 
 	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -w")# -nowarn 4018 -nowarn 4305 -nowarn 4244")
 		ENDIF(WIN32 AND NOT UNIX)
-	ENDIF(NOT ${CMAKE_GENERATOR} STREQUAL "MSYS Makefiles")
+	ENDIF(NOT ${CMAKE_GENERATOR} MATCHES "MSYS Makefiles|MinGW Makefiles")
 ENDMACRO(FIXCOMPILEOPTIONS)
 
 MACRO(FIXLINKOPTIONS)#Fix added link options that may cause problems
diff --git a/Lib/DLL/CMakeLists.txt b/Lib/DLL/CMakeLists.txt
index 2d1e07881..855d337ad 100644
--- a/Lib/DLL/CMakeLists.txt
+++ b/Lib/DLL/CMakeLists.txt
@@ -42,7 +42,9 @@ add_definitions(-D_RETAIL)
 
 IF(WIN32 AND NOT UNIX)
 	add_definitions(-DWIN32 -D_RAKNET_DLL -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_SECURE_NO_DEPRECATE)
-	SET( CMAKE_CXX_FLAGS "/GS- /GR-" )
+	IF(MSVC)
+		SET( CMAKE_CXX_FLAGS "/GS- /GR-" )
+	ENDIF()
 ELSE(WIN32 AND NOT UNIX)
 	set_target_properties(SLikeNetDLL PROPERTIES
 		OUTPUT_NAME "slikenet"
diff --git a/Lib/LibStatic/CMakeLists.txt b/Lib/LibStatic/CMakeLists.txt
index 955a99dec..babc5445d 100644
--- a/Lib/LibStatic/CMakeLists.txt
+++ b/Lib/LibStatic/CMakeLists.txt
@@ -42,7 +42,9 @@ add_definitions(-D_RETAIL)
 
 IF(WIN32 AND NOT UNIX)
 	add_definitions(-DWIN32 -D_RAKNET_DLL -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_SECURE_NO_DEPRECATE)
-	SET( CMAKE_CXX_FLAGS "/GS- /GR-" )
+	IF(MSVC)
+		SET( CMAKE_CXX_FLAGS "/GS- /GR-" )
+	ENDIF()
 ELSE(WIN32 AND NOT UNIX)
 	set_target_properties(SLikeNetLibStatic PROPERTIES
 		OUTPUT_NAME "slikenet"
diff --git a/Source/include/slikenet/BitStream.h b/Source/include/slikenet/BitStream.h
index 489f9f84c..4155b5a95 100644
--- a/Source/include/slikenet/BitStream.h
+++ b/Source/include/slikenet/BitStream.h
@@ -1694,9 +1694,9 @@ namespace SLNet
 		if (qx < 0.0) qx=0.0;
 		if (qy < 0.0) qy=0.0;
 		if (qz < 0.0) qz=0.0;
-		qx = _copysign( (double) qx, (double) (m21 - m12) );
-		qy = _copysign( (double) qy, (double) (m02 - m20) );
-		qz = _copysign( (double) qz, (double) (m10 - m01) );
+		qx = std::copysign( (double) qx, (double) (m21 - m12) );
+		qy = std::copysign( (double) qy, (double) (m02 - m20) );
+		qz = std::copysign( (double) qz, (double) (m10 - m01) );
 
 		WriteNormQuat(qw,qx,qy,qz);
 	}
diff --git a/Source/include/slikenet/WindowsIncludes.h b/Source/include/slikenet/WindowsIncludes.h
index 83041c58d..87b297b8e 100644
--- a/Source/include/slikenet/WindowsIncludes.h
+++ b/Source/include/slikenet/WindowsIncludes.h
@@ -13,6 +13,10 @@
  *  license found in the license.txt file in the root directory of this source tree.
  */
 
+#pragma once
+#include <cstdio>
+#include <cstdint>
+
 #ifndef NOMINMAX
 	#define NOMINMAX
 #endif
@@ -37,4 +41,326 @@
 // winsock2.h(212) : error C2011: 'netent' : 'struct' type redefinition
 // winsock2.h(219) : error C2011: 'servent' : 'struct' type redefinition 
 
+#ifdef __MINGW32__
+
+#define NS_INADDRSZ 4
+#define NS_IN6ADDRSZ 16
+#define NS_INT16SZ 2
+
+// https://stackoverflow.com/questions/15370033/how-to-use-inet-pton-with-the-mingw-compiler
+// Author: Paul Vixie, 1996. Tested in MinGW/GCC:
+inline int inet_pton4(const char *src, char *dst)
+{
+    uint8_t tmp[NS_INADDRSZ], *tp;
+
+    int saw_digit = 0;
+    int octets = 0;
+    *(tp = tmp) = 0;
+
+    int ch;
+    while ((ch = *src++) != '\0')
+    {
+        if (ch >= '0' && ch <= '9')
+        {
+            uint32_t n = *tp * 10 + (ch - '0');
+
+            if (saw_digit && *tp == 0)
+                return 0;
+
+            if (n > 255)
+                return 0;
+
+            *tp = n;
+            if (!saw_digit)
+            {
+                if (++octets > 4)
+                    return 0;
+                saw_digit = 1;
+            }
+        }
+        else if (ch == '.' && saw_digit)
+        {
+            if (octets == 4)
+                return 0;
+            *++tp = 0;
+            saw_digit = 0;
+        }
+        else
+            return 0;
+    }
+    if (octets < 4)
+        return 0;
+
+    memcpy(dst, tmp, NS_INADDRSZ);
+
+    return 1;
+}
+
+inline int inet_pton6(const char *src, char *dst)
+{
+    static const char xdigits[] = "0123456789abcdef";
+    uint8_t tmp[NS_IN6ADDRSZ];
+
+    uint8_t *tp = (uint8_t*) memset(tmp, '\0', NS_IN6ADDRSZ);
+    uint8_t *endp = tp + NS_IN6ADDRSZ;
+    uint8_t *colonp = NULL;
+
+    /* Leading :: requires some special handling. */
+    if (*src == ':')
+    {
+        if (*++src != ':')
+            return 0;
+    }
+
+    const char *curtok = src;
+    int saw_xdigit = 0;
+    uint32_t val = 0;
+    int ch;
+    while ((ch = tolower(*src++)) != '\0')
+    {
+        const char *pch = strchr(xdigits, ch);
+        if (pch != NULL)
+        {
+            val <<= 4;
+            val |= (pch - xdigits);
+            if (val > 0xffff)
+                return 0;
+            saw_xdigit = 1;
+            continue;
+        }
+        if (ch == ':')
+        {
+            curtok = src;
+            if (!saw_xdigit)
+            {
+                if (colonp)
+                    return 0;
+                colonp = tp;
+                continue;
+            }
+            else if (*src == '\0')
+            {
+                return 0;
+            }
+            if (tp + NS_INT16SZ > endp)
+                return 0;
+            *tp++ = (uint8_t) (val >> 8) & 0xff;
+            *tp++ = (uint8_t) val & 0xff;
+            saw_xdigit = 0;
+            val = 0;
+            continue;
+        }
+        if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
+                inet_pton4(curtok, (char*) tp) > 0)
+        {
+            tp += NS_INADDRSZ;
+            saw_xdigit = 0;
+            break; /* '\0' was seen by inet_pton4(). */
+        }
+        return 0;
+    }
+    if (saw_xdigit)
+    {
+        if (tp + NS_INT16SZ > endp)
+            return 0;
+        *tp++ = (uint8_t) (val >> 8) & 0xff;
+        *tp++ = (uint8_t) val & 0xff;
+    }
+    if (colonp != NULL)
+    {
+        /*
+         * Since some memmove()'s erroneously fail to handle
+         * overlapping regions, we'll do the shift by hand.
+         */
+        const int n = tp - colonp;
+
+        if (tp == endp)
+            return 0;
+
+        for (int i = 1; i <= n; i++)
+        {
+            endp[-i] = colonp[n - i];
+            colonp[n - i] = 0;
+        }
+        tp = endp;
+    }
+    if (tp != endp)
+        return 0;
+
+    memcpy(dst, tmp, NS_IN6ADDRSZ);
+
+    return 1;
+}
+
+inline int inet_pton(int af, const char *src, void *dst)
+{
+    switch (af)
+    {
+    case AF_INET:
+        return inet_pton4(src, (char*)dst);
+    case AF_INET6:
+        return inet_pton6(src, (char*)dst);
+    default:
+        return -1;
+    }
+}
+
+// https://code.woboq.org/userspace/glibc/resolv/inet_ntop.c.html
+/*
+ * Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/* const char *
+ * inet_ntop4(src, dst, size)
+ *        format an IPv4 address
+ * return:
+ *        `dst' (as a const)
+ * notes:
+ *        (1) uses no statics
+ *        (2) takes a u_char* not an in_addr as input
+ * author:
+ *        Paul Vixie, 1996.
+ */
+inline static const char *
+inet_ntop4 (const u_char *src, char *dst, socklen_t size)
+{
+        static const char fmt[] = "%u.%u.%u.%u";
+        char tmp[sizeof "255.255.255.255"];
+		int res = sprintf(tmp, fmt, src[0], src[1], src[2], src[3]);
+        if (res >= size || res < 0) {
+                //__set_errno (ENOSPC);
+                return (NULL);
+        }
+        return strcpy(dst, tmp);
+}
+/* const char *
+ * inet_ntop6(src, dst, size)
+ *        convert IPv6 binary address into presentation (printable) format
+ * author:
+ *        Paul Vixie, 1996.
+ */
+inline static const char *
+inet_ntop6 (const u_char *src, char *dst, socklen_t size)
+{
+        /*
+         * Note that int32_t and int16_t need only be "at least" large enough
+         * to contain a value of the specified size.  On some systems, like
+         * Crays, there is no such thing as an integer variable with 16 bits.
+         * Keep this in mind if you think this function should have been coded
+         * to use pointer overlays.  All the world's not a VAX.
+         */
+        char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
+        struct { int base, len; } best, cur;
+        u_int words[NS_IN6ADDRSZ / NS_INT16SZ];
+        int i;
+        /*
+         * Preprocess:
+         *        Copy the input (bytewise) array into a wordwise array.
+         *        Find the longest run of 0x00's in src[] for :: shorthanding.
+         */
+        memset(words, '\0', sizeof words);
+        for (i = 0; i < NS_IN6ADDRSZ; i += 2)
+                words[i / 2] = (src[i] << 8) | src[i + 1];
+        best.base = -1;
+        cur.base = -1;
+        best.len = 0;
+        cur.len = 0;
+        for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+                if (words[i] == 0) {
+                        if (cur.base == -1)
+                                cur.base = i, cur.len = 1;
+                        else
+                                cur.len++;
+                } else {
+                        if (cur.base != -1) {
+                                if (best.base == -1 || cur.len > best.len)
+                                        best = cur;
+                                cur.base = -1;
+                        }
+                }
+        }
+        if (cur.base != -1) {
+                if (best.base == -1 || cur.len > best.len)
+                        best = cur;
+        }
+        if (best.base != -1 && best.len < 2)
+                best.base = -1;
+        /*
+         * Format the result.
+         */
+        tp = tmp;
+        for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+                /* Are we inside the best run of 0x00's? */
+                if (best.base != -1 && i >= best.base &&
+                    i < (best.base + best.len)) {
+                        if (i == best.base)
+                                *tp++ = ':';
+                        continue;
+                }
+                /* Are we following an initial run of 0x00s or any real hex? */
+                if (i != 0)
+                        *tp++ = ':';
+                /* Is this address an encapsulated IPv4? */
+                if (i == 6 && best.base == 0 &&
+                    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
+                        if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
+                                return (NULL);
+                        tp += strlen(tp);
+                        break;
+                }
+                tp += sprintf(tp, "%x", words[i]);
+        }
+        /* Was it a trailing run of 0x00's? */
+        if (best.base != -1 && (best.base + best.len) ==
+            (NS_IN6ADDRSZ / NS_INT16SZ))
+                *tp++ = ':';
+        *tp++ = '\0';
+        /*
+         * Check for overflow, copy, and we're done.
+         */
+        if ((socklen_t)(tp - tmp) > size) {
+                //__set_errno (ENOSPC);
+                return (NULL);
+        }
+        return strcpy(dst, tmp);
+}
+
+/* char *
+ * inet_ntop(af, src, dst, size)
+ *        convert a network format address to presentation format.
+ * return:
+ *        pointer to presentation format address (`dst'), or NULL (see errno).
+ * author:
+ *        Paul Vixie, 1996.
+ */
+inline const char *
+inet_ntop (int af, const void *src, char *dst, socklen_t size)
+{
+        switch (af) {
+        case AF_INET:
+                return (inet_ntop4((const u_char*)src, dst, size));
+        case AF_INET6:
+                return (inet_ntop6((const u_char*)src, dst, size));
+        default:
+                //__set_errno (EAFNOSUPPORT);
+                return (NULL);
+        }
+        /* NOTREACHED */
+}
+
+#endif
+
 #endif
diff --git a/Source/src/TelnetTransport.cpp b/Source/src/TelnetTransport.cpp
index 336a9b6ee..9bc59462c 100644
--- a/Source/src/TelnetTransport.cpp
+++ b/Source/src/TelnetTransport.cpp
@@ -93,7 +93,7 @@ void TelnetTransport::Send(  SystemAddress systemAddress, const char *data,... )
 	{
 		size_t length = strlen(text);
 		size_t availableChars = REMOTE_MAX_TEXT_INPUT-length-1;
-		strncat_s(text, sendSuffix, availableChars);
+		strncat_s(text, sizeof(text), sendSuffix, availableChars);
 	}
 
 	tcpInterface->Send(text, (unsigned int) strlen(text), systemAddress, false);
